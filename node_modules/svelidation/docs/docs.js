
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.head.appendChild(r) })(window.document);
function noop() { }
const identity = x => x;
function assign(tar, src) {
    // @ts-ignore
    for (const k in src)
        tar[k] = src[k];
    return tar;
}
function add_location(element, file, line, column, char) {
    element.__svelte_meta = {
        loc: { file, line, column, char }
    };
}
function run(fn) {
    return fn();
}
function blank_object() {
    return Object.create(null);
}
function run_all(fns) {
    fns.forEach(run);
}
function is_function(thing) {
    return typeof thing === 'function';
}
function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
}
function validate_store(store, name) {
    if (!store || typeof store.subscribe !== 'function') {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
    }
}
function subscribe(store, callback) {
    const unsub = store.subscribe(callback);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
    let value;
    subscribe(store, _ => value = _)();
    return value;
}
function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, fn) {
    if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, fn);
        return definition[0](slot_ctx);
    }
}
function get_slot_context(definition, ctx, fn) {
    return definition[1]
        ? assign({}, assign(ctx.$$scope.ctx, definition[1](fn ? fn(ctx) : {})))
        : ctx.$$scope.ctx;
}
function get_slot_changes(definition, ctx, changed, fn) {
    return definition[1]
        ? assign({}, assign(ctx.$$scope.changed || {}, definition[1](fn ? fn(changed) : {})))
        : ctx.$$scope.changed || {};
}
function set_store_value(store, ret, value = ret) {
    store.set(value);
    return ret;
}
const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);

const is_client = typeof window !== 'undefined';
let now = is_client
    ? () => window.performance.now()
    : () => Date.now();
let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

const tasks = new Set();
let running = false;
function run_tasks() {
    tasks.forEach(task => {
        if (!task[0](now())) {
            tasks.delete(task);
            task[1]();
        }
    });
    running = tasks.size > 0;
    if (running)
        raf(run_tasks);
}
function loop(fn) {
    let task;
    if (!running) {
        running = true;
        raf(run_tasks);
    }
    return {
        promise: new Promise(fulfil => {
            tasks.add(task = [fn, fulfil]);
        }),
        abort() {
            tasks.delete(task);
        }
    };
}

function append(target, node) {
    target.appendChild(node);
}
function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
}
function detach(node) {
    node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i])
            iterations[i].d(detaching);
    }
}
function element(name) {
    return document.createElement(name);
}
function text(data) {
    return document.createTextNode(data);
}
function space() {
    return text(' ');
}
function empty() {
    return text('');
}
function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
    return function (event) {
        event.preventDefault();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function stop_propagation(fn) {
    return function (event) {
        event.stopPropagation();
        // @ts-ignore
        return fn.call(this, event);
    };
}
function attr(node, attribute, value) {
    if (value == null)
        node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
        node.setAttribute(attribute, value);
}
function get_binding_group_value(group) {
    const value = [];
    for (let i = 0; i < group.length; i += 1) {
        if (group[i].checked)
            value.push(group[i].__value);
    }
    return value;
}
function to_number(value) {
    return value === '' ? undefined : +value;
}
function children(element) {
    return Array.from(element.childNodes);
}
function set_input_value(input, value) {
    if (value != null || input.value) {
        input.value = value;
    }
}
function set_style(node, key, value, important) {
    node.style.setProperty(key, value, important ? 'important' : '');
}
function select_option(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        if (option.__value === value) {
            option.selected = true;
            return;
        }
    }
}
function select_options(select, value) {
    for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];
        option.selected = ~value.indexOf(option.__value);
    }
}
function select_value(select) {
    const selected_option = select.querySelector(':checked') || select.options[0];
    return selected_option && selected_option.__value;
}
function select_multiple_value(select) {
    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);
}
function toggle_class(element, name, toggle) {
    element.classList[toggle ? 'add' : 'remove'](name);
}
function custom_event(type, detail) {
    const e = document.createEvent('CustomEvent');
    e.initCustomEvent(type, false, false, detail);
    return e;
}

let stylesheet;
let active = 0;
let current_rules = {};
// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
    const step = 16.666 / duration;
    let keyframes = '{\n';
    for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
    }
    const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
    const name = `__svelte_${hash(rule)}_${uid}`;
    if (!current_rules[name]) {
        if (!stylesheet) {
            const style = element('style');
            document.head.appendChild(style);
            stylesheet = style.sheet;
        }
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
    }
    const animation = node.style.animation || '';
    node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;
    active += 1;
    return name;
}
function delete_rule(node, name) {
    node.style.animation = (node.style.animation || '')
        .split(', ')
        .filter(name
        ? anim => anim.indexOf(name) < 0 // remove specific animation
        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
    )
        .join(', ');
    if (name && !--active)
        clear_rules();
}
function clear_rules() {
    raf(() => {
        if (active)
            return;
        let i = stylesheet.cssRules.length;
        while (i--)
            stylesheet.deleteRule(i);
        current_rules = {};
    });
}

let current_component;
function set_current_component(component) {
    current_component = component;
}
function get_current_component() {
    if (!current_component)
        throw new Error(`Function called outside component initialization`);
    return current_component;
}
function createEventDispatcher() {
    const component = get_current_component();
    return (type, detail) => {
        const callbacks = component.$$.callbacks[type];
        if (callbacks) {
            // TODO are there situations where events could be dispatched
            // in a server (non-DOM) environment?
            const event = custom_event(type, detail);
            callbacks.slice().forEach(fn => {
                fn.call(component, event);
            });
        }
    };
}
// TODO figure out if we still want to support
// shorthand events, or if we want to implement
// a real bubbling mechanism
function bubble(component, event) {
    const callbacks = component.$$.callbacks[event.type];
    if (callbacks) {
        callbacks.slice().forEach(fn => fn(event));
    }
}

const dirty_components = [];
const binding_callbacks = [];
const render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = Promise.resolve();
let update_scheduled = false;
function schedule_update() {
    if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
    }
}
function add_render_callback(fn) {
    render_callbacks.push(fn);
}
function add_flush_callback(fn) {
    flush_callbacks.push(fn);
}
function flush() {
    const seen_callbacks = new Set();
    do {
        // first, call beforeUpdate functions
        // and update components
        while (dirty_components.length) {
            const component = dirty_components.shift();
            set_current_component(component);
            update(component.$$);
        }
        while (binding_callbacks.length)
            binding_callbacks.pop()();
        // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...
        for (let i = 0; i < render_callbacks.length; i += 1) {
            const callback = render_callbacks[i];
            if (!seen_callbacks.has(callback)) {
                callback();
                // ...so guard against infinite loops
                seen_callbacks.add(callback);
            }
        }
        render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
        flush_callbacks.pop()();
    }
    update_scheduled = false;
}
function update($$) {
    if ($$.fragment !== null) {
        $$.update($$.dirty);
        run_all($$.before_update);
        $$.fragment && $$.fragment.p($$.dirty, $$.ctx);
        $$.dirty = null;
        $$.after_update.forEach(add_render_callback);
    }
}

let promise;
function wait() {
    if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
            promise = null;
        });
    }
    return promise;
}
function dispatch(node, direction, kind) {
    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
}
const outroing = new Set();
let outros;
function group_outros() {
    outros = {
        r: 0,
        c: [],
        p: outros // parent group
    };
}
function check_outros() {
    if (!outros.r) {
        run_all(outros.c);
    }
    outros = outros.p;
}
function transition_in(block, local) {
    if (block && block.i) {
        outroing.delete(block);
        block.i(local);
    }
}
function transition_out(block, local, detach, callback) {
    if (block && block.o) {
        if (outroing.has(block))
            return;
        outroing.add(block);
        outros.c.push(() => {
            outroing.delete(block);
            if (callback) {
                if (detach)
                    block.d(1);
                callback();
            }
        });
        block.o(local);
    }
}
const null_transition = { duration: 0 };
function create_bidirectional_transition(node, fn, params, intro) {
    let config = fn(node, params);
    let t = intro ? 0 : 1;
    let running_program = null;
    let pending_program = null;
    let animation_name = null;
    function clear_animation() {
        if (animation_name)
            delete_rule(node, animation_name);
    }
    function init(program, duration) {
        const d = program.b - t;
        duration *= Math.abs(d);
        return {
            a: t,
            b: program.b,
            d,
            duration,
            start: program.start,
            end: program.start + duration,
            group: program.group
        };
    }
    function go(b) {
        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
        const program = {
            start: now() + delay,
            b
        };
        if (!b) {
            // @ts-ignore todo: improve typings
            program.group = outros;
            outros.r += 1;
        }
        if (running_program) {
            pending_program = program;
        }
        else {
            // if this is an intro, and there's a delay, we need to do
            // an initial tick and/or apply CSS animation immediately
            if (css) {
                clear_animation();
                animation_name = create_rule(node, t, b, duration, delay, easing, css);
            }
            if (b)
                tick(0, 1);
            running_program = init(program, duration);
            add_render_callback(() => dispatch(node, b, 'start'));
            loop(now => {
                if (pending_program && now > pending_program.start) {
                    running_program = init(pending_program, duration);
                    pending_program = null;
                    dispatch(node, running_program.b, 'start');
                    if (css) {
                        clear_animation();
                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                    }
                }
                if (running_program) {
                    if (now >= running_program.end) {
                        tick(t = running_program.b, 1 - t);
                        dispatch(node, running_program.b, 'end');
                        if (!pending_program) {
                            // we're done
                            if (running_program.b) {
                                // intro — we can tidy up immediately
                                clear_animation();
                            }
                            else {
                                // outro — needs to be coordinated
                                if (!--running_program.group.r)
                                    run_all(running_program.group.c);
                            }
                        }
                        running_program = null;
                    }
                    else if (now >= running_program.start) {
                        const p = now - running_program.start;
                        t = running_program.a + running_program.d * easing(p / running_program.duration);
                        tick(t, 1 - t);
                    }
                }
                return !!(running_program || pending_program);
            });
        }
    }
    return {
        run(b) {
            if (is_function(config)) {
                wait().then(() => {
                    // @ts-ignore
                    config = config();
                    go(b);
                });
            }
            else {
                go(b);
            }
        },
        end() {
            clear_animation();
            running_program = pending_program = null;
        }
    };
}

const globals = (typeof window !== 'undefined' ? window : global);
function outro_and_destroy_block(block, lookup) {
    transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
    });
}
function update_keyed_each(old_blocks, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
    let o = old_blocks.length;
    let n = list.length;
    let i = o;
    const old_indexes = {};
    while (i--)
        old_indexes[old_blocks[i].key] = i;
    const new_blocks = [];
    const new_lookup = new Map();
    const deltas = new Map();
    i = n;
    while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);
        if (!block) {
            block = create_each_block(key, child_ctx);
            block.c();
        }
        else if (dynamic) {
            block.p(changed, child_ctx);
        }
        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes)
            deltas.set(key, Math.abs(i - old_indexes[key]));
    }
    const will_move = new Set();
    const did_move = new Set();
    function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
    }
    while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;
        if (new_block === old_block) {
            // do nothing
            next = new_block.first;
            o--;
            n--;
        }
        else if (!new_lookup.has(old_key)) {
            // remove old block
            destroy(old_block, lookup);
            o--;
        }
        else if (!lookup.has(new_key) || will_move.has(new_key)) {
            insert(new_block);
        }
        else if (did_move.has(old_key)) {
            o--;
        }
        else if (deltas.get(new_key) > deltas.get(old_key)) {
            did_move.add(new_key);
            insert(new_block);
        }
        else {
            will_move.add(old_key);
            o--;
        }
    }
    while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key))
            destroy(old_block, lookup);
    }
    while (n)
        insert(new_blocks[n - 1]);
    return new_blocks;
}

function bind(component, name, callback) {
    if (has_prop(component.$$.props, name)) {
        name = component.$$.props[name] || name;
        component.$$.bound[name] = callback;
        callback(component.$$.ctx[name]);
    }
}
function create_component(block) {
    block && block.c();
}
function mount_component(component, target, anchor) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    // onMount happens before the initial afterUpdate
    add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
            on_destroy.push(...new_on_destroy);
        }
        else {
            // Edge case - component was destroyed immediately,
            // most likely as a result of a binding initialising
            run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
    });
    after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching);
        // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)
        $$.on_destroy = $$.fragment = null;
        $$.ctx = {};
    }
}
function make_dirty(component, key) {
    if (!component.$$.dirty) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty = blank_object();
    }
    component.$$.dirty[key] = true;
}
function init(component, options, instance, create_fragment, not_equal, props) {
    const parent_component = current_component;
    set_current_component(component);
    const prop_values = options.props || {};
    const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : []),
        // everything else
        callbacks: blank_object(),
        dirty: null
    };
    let ready = false;
    $$.ctx = instance
        ? instance(component, prop_values, (key, ret, value = ret) => {
            if ($$.ctx && not_equal($$.ctx[key], $$.ctx[key] = value)) {
                if ($$.bound[key])
                    $$.bound[key](value);
                if (ready)
                    make_dirty(component, key);
            }
            return ret;
        })
        : prop_values;
    $$.update();
    ready = true;
    run_all($$.before_update);
    // `false` as a special case of no DOM component
    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
    if (options.target) {
        if (options.hydrate) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.l(children(options.target));
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            $$.fragment && $$.fragment.c();
        }
        if (options.intro)
            transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush();
    }
    set_current_component(parent_component);
}
class SvelteComponent {
    $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
    }
    $on(type, callback) {
        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
        callbacks.push(callback);
        return () => {
            const index = callbacks.indexOf(callback);
            if (index !== -1)
                callbacks.splice(index, 1);
        };
    }
    $set() {
        // overridden by instance, if it has props
    }
}

function dispatch_dev(type, detail) {
    document.dispatchEvent(custom_event(type, detail));
}
function append_dev(target, node) {
    dispatch_dev("SvelteDOMInsert", { target, node });
    append(target, node);
}
function insert_dev(target, node, anchor) {
    dispatch_dev("SvelteDOMInsert", { target, node, anchor });
    insert(target, node, anchor);
}
function detach_dev(node) {
    dispatch_dev("SvelteDOMRemove", { node });
    detach(node);
}
function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
    const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
    if (has_prevent_default)
        modifiers.push('preventDefault');
    if (has_stop_propagation)
        modifiers.push('stopPropagation');
    dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
    const dispose = listen(node, event, handler, options);
    return () => {
        dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
        dispose();
    };
}
function attr_dev(node, attribute, value) {
    attr(node, attribute, value);
    if (value == null)
        dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
    else
        dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
}
function prop_dev(node, property, value) {
    node[property] = value;
    dispatch_dev("SvelteDOMSetProperty", { node, property, value });
}
function set_data_dev(text, data) {
    data = '' + data;
    if (text.data === data)
        return;
    dispatch_dev("SvelteDOMSetData", { node: text, data });
    text.data = data;
}
class SvelteComponentDev extends SvelteComponent {
    constructor(options) {
        if (!options || (!options.target && !options.$$inline)) {
            throw new Error(`'target' is a required option`);
        }
        super();
    }
    $destroy() {
        super.$destroy();
        this.$destroy = () => {
            console.warn(`Component was already destroyed`); // eslint-disable-line no-console
        };
    }
}

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}
function quintOut(t) {
    return --t * t * t * t * t + 1;
}

function fade(node, { delay = 0, duration = 400, easing = identity }) {
    const o = +getComputedStyle(node).opacity;
    return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
    };
}
function slide(node, { delay = 0, duration = 400, easing = cubicOut }) {
    const style = getComputedStyle(node);
    const opacity = +style.opacity;
    const height = parseFloat(style.height);
    const padding_top = parseFloat(style.paddingTop);
    const padding_bottom = parseFloat(style.paddingBottom);
    const margin_top = parseFloat(style.marginTop);
    const margin_bottom = parseFloat(style.marginBottom);
    const border_top_width = parseFloat(style.borderTopWidth);
    const border_bottom_width = parseFloat(style.borderBottomWidth);
    return {
        delay,
        duration,
        easing,
        css: t => `overflow: hidden;` +
            `opacity: ${Math.min(t * 20, 1) * opacity};` +
            `height: ${t * height}px;` +
            `padding-top: ${t * padding_top}px;` +
            `padding-bottom: ${t * padding_bottom}px;` +
            `margin-top: ${t * margin_top}px;` +
            `margin-bottom: ${t * margin_bottom}px;` +
            `border-top-width: ${t * border_top_width}px;` +
            `border-bottom-width: ${t * border_bottom_width}px;`
    };
}

var ListenInputEventsEnum;
(function (ListenInputEventsEnum) {
    ListenInputEventsEnum[ListenInputEventsEnum["never"] = 0] = "never";
    ListenInputEventsEnum[ListenInputEventsEnum["always"] = 1] = "always";
    ListenInputEventsEnum[ListenInputEventsEnum["afterValidation"] = 2] = "afterValidation";
})(ListenInputEventsEnum || (ListenInputEventsEnum = {}));
var SvelidationPresence;
(function (SvelidationPresence) {
    SvelidationPresence["required"] = "required";
    SvelidationPresence["optional"] = "optional";
})(SvelidationPresence || (SvelidationPresence = {}));
//# sourceMappingURL=typing.js.map

const subscriber_queue = [];
/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 * @param {*=}value initial value
 * @param {StartStopNotifier=}start start and stop notifications for subscriptions
 */
function writable(value, start = noop) {
    let stop;
    const subscribers = [];
    function set(new_value) {
        if (safe_not_equal(value, new_value)) {
            value = new_value;
            if (stop) { // store is ready
                const run_queue = !subscriber_queue.length;
                for (let i = 0; i < subscribers.length; i += 1) {
                    const s = subscribers[i];
                    s[1]();
                    subscriber_queue.push(s, value);
                }
                if (run_queue) {
                    for (let i = 0; i < subscriber_queue.length; i += 2) {
                        subscriber_queue[i][0](subscriber_queue[i + 1]);
                    }
                    subscriber_queue.length = 0;
                }
            }
        }
    }
    function update(fn) {
        set(fn(value));
    }
    function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);
        if (subscribers.length === 1) {
            stop = start(set) || noop;
        }
        run(value);
        return () => {
            const index = subscribers.indexOf(subscriber);
            if (index !== -1) {
                subscribers.splice(index, 1);
            }
            if (subscribers.length === 0) {
                stop();
                stop = null;
            }
        };
    }
    return { set, update, subscribe };
}

var isFunction = (f) => {
    return typeof f === 'function';
};
//# sourceMappingURL=is-function.js.map

class FormElement {
    constructor(node, options) {
        this.node = node;
        this.options = options;
        this.currentPhase = null;
        this.onClear = () => {
            if (!this.preventEvents()) {
                this.options.onClear();
            }
        };
        this.onValidate = () => {
            if (!this.preventEvents()) {
                this.options.onValidate();
            }
        };
        const { change, blur } = this.options.validateOnEvents;
        const { focus } = this.options.clearErrorsOnEvents;
        if (change) {
            node.addEventListener('change', this.onValidate);
        }
        if (blur) {
            node.addEventListener('blur', this.onValidate);
        }
        if (focus) {
            node.addEventListener('focus', this.onClear);
        }
    }
    setPhase(phase) {
        this.currentPhase = phase;
    }
    preventEvents() {
        const { listenInputEvents: initialPhase } = this.options;
        if (initialPhase === ListenInputEventsEnum.never) {
            return true;
        }
        if (initialPhase === ListenInputEventsEnum.always) {
            return false;
        }
        return this.currentPhase < initialPhase;
    }
    destroy() {
        this.node.removeEventListener('change', this.onValidate);
        this.node.removeEventListener('blur', this.onValidate);
        this.node.removeEventListener('focus', this.onClear);
    }
}
//# sourceMappingURL=form-element.js.map

const prepareBaseParams = (entryParams, validationOptions) => {
    const { trim: entryTrim, required, optional } = entryParams;
    const { presence, trim: optionsTrim } = validationOptions;
    const output = { ...entryParams };
    if (presence === SvelidationPresence.required && required === undefined && optional === undefined) {
        output.required = true;
    }
    if (optionsTrim && entryTrim === undefined) {
        output.trim = true;
    }
    return output;
};
//# sourceMappingURL=prepare-base-params.js.map

const globals$1 = [];
let typeRules = {};
let types = {};
let rules = {};
const getSpies = (params) => {
    if (!params) {
        return globals$1;
    }
    try {
        const { type: typeName, ruleName } = params;
        if (typeName && ruleName) {
            return typeRules[typeName][ruleName] || [];
        }
        else if (typeName) {
            return types[typeName] || [];
        }
        else {
            return rules[ruleName] || [];
        }
    }
    catch (e) {
        return [];
    }
};
//# sourceMappingURL=spy.js.map

let enable = true;
const disableWarn = () => {
    enable = false;
};
var warn = (...args) => {
    enable && console.warn(...args);
};
//# sourceMappingURL=warn.js.map

let types$1 = {};
let rules$1 = {};
const ensureType = (typeName, typeRules) => {
    if (typeof typeRules !== 'object') {
        {
            warn('svelidation: rules should be an object', typeName);
        }
        return;
    }
    Object.keys(typeRules).reduce((obj, key) => {
        const rule = typeRules[key];
        try {
            if (typeof rule === 'string') {
                const [typeName, ruleName] = rule.split('.');
                const inheritedRule = getType(typeName)[ruleName];
                if (isFunction(inheritedRule)) {
                    obj[ruleName] = inheritedRule;
                }
            }
            else if (isFunction(rule)) {
                obj[key] = rule;
            }
        }
        catch (e) {
            delete obj[key];
        }
        return obj;
    }, typeRules);
    if (!types$1[typeName]) {
        if (!isFunction(typeRules.type)) {
            {
                warn('svelidation: type method is required for new types', typeName);
            }
            return;
        }
        types$1[typeName] = {};
    }
    Object.assign(types$1[typeName], typeRules);
};
const resetType = (typeName) => {
    if (!typeName) {
        types$1 = {};
        Object.keys(installType).forEach(key => installType[key]());
    }
    else {
        delete types$1[typeName];
        if (installType[typeName]) {
            installType[typeName]();
        }
    }
};
const resetRule = (ruleName) => {
    if (!ruleName) {
        rules$1 = {};
        Object.keys(installRule).forEach(key => installRule[key]());
    }
    else {
        delete rules$1[ruleName];
        if (installRule[ruleName]) {
            installRule[ruleName]();
        }
    }
};
const installType = {
    string: () => {
        ensureType('string', {
            type: (value) => (typeof value === 'string'),
            min: (value, { min }) => (value.length >= min),
            max: (value, { max }) => (value.length <= max),
            between: (value, { between }) => (value.length >= between[0] && value.length <= between[1])
        });
    },
    email: () => {
        ensureType('email', {
            type: (value) => (typeof value === 'string' && (value === '' || !!(String(value)).match(/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/)))
        });
    },
    number: () => {
        ensureType('number', {
            type: (value) => (typeof value === 'number' || (typeof value === 'string' && (value === '' || !isNaN(parseFloat(value))))),
            required: value => !isNaN(typeof value === 'number' ? value : parseFloat(value)),
            min: (value, { min }) => (parseFloat(value) >= min),
            max: (value, { max }) => (parseFloat(value) <= max),
            between: (value, { between }) => (value >= between[0] && value <= between[1])
        });
    },
    boolean: () => {
        ensureType('boolean', {
            type: (value) => typeof value === 'boolean',
            required: (value) => value,
        });
    },
    array: () => {
        ensureType('array', {
            type: (value) => Array.isArray(value),
            required: (value) => value.length > 0,
            min: (value, { min }) => value.length >= min,
            max: (value, { max }) => value.length <= max,
            equal: (value, { equal }) => {
                if (isFunction(equal)) {
                    return equal(value);
                }
                return value.sort().toString() === equal.sort().toString();
            },
            includes: (value, { includes }) => value.includes(includes)
        });
    },
};
const installRule = {
    equal: () => {
        ensureRule('equal', (value, { equal }) => {
            if (isFunction(equal)) {
                return equal(value);
            }
            return value === equal;
        });
    },
    match: () => {
        ensureRule('match', (value, { match }) => !!(String(value)).match(match));
    },
    required: () => {
        ensureRule('required', (value) => {
            if (value === undefined || value === null) {
                return false;
            }
            return !!String(value);
        });
    }
};
const ensureRule = (ruleName, rule) => {
    if (!isFunction(rule)) {
        {
            warn('svelidation: ensureRule has to have second function argument', ruleName);
        }
        return;
    }
    Object.assign(rules$1, {
        [ruleName]: rule
    });
};
const getType = (typeName) => types$1[typeName];
const getRule = (ruleName) => rules$1[ruleName];
resetType();
resetRule();
//# sourceMappingURL=types.js.map

const runRuleWithSpies = ({ value, params: initialParams, rule, ruleName, spies }) => {
    const errors = [];
    const { type } = initialParams;
    let nextValue = value;
    let nextParams = initialParams;
    let stop = false;
    let abort = false;
    for (let i = 0; i < spies.length; i++) {
        stop = true;
        const spyErrors = spies[i](nextValue, { type, ruleName, ...nextParams }, (value, params = {}) => {
            nextValue = value;
            nextParams = { ...initialParams, ...params };
            stop = false;
        }, () => {
            abort = true;
        });
        if (abort) {
            return { abort };
        }
        if (Array.isArray(spyErrors)) {
            errors.push(...spyErrors);
        }
        if (stop) {
            break;
        }
    }
    if (!stop && !rule(nextValue, nextParams)) {
        errors.push(ruleName);
    }
    return { errors, stop, nextValue, nextParams };
};
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const getScope = ({ type, optional, ...rules }) => {
    const typeRules = getType(type);
    if (!typeRules) {
        return {};
    }
    return [...Object.keys(rules), 'type'].reduce((obj, ruleName) => {
        const rule = typeRules[ruleName] || getRule(ruleName);
        if (rule) {
            obj[ruleName] = rule;
        }
        else {
            {
                warn('svelidation: rule is not defined', ruleName);
            }
        }
        return obj;
    }, {});
};
const skipValidation = (value, { optional, required = false }) => {
    const valueIsAbsent = [undefined, null, ''].indexOf(value) > -1 || (Array.isArray(value) && !value.length);
    const valueIsOptional = typeof optional === 'boolean' ? optional : !required;
    return valueIsAbsent && valueIsOptional;
};
const validate = (value, validateParams) => {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars,prefer-const
    let { trim = false, id, ...params } = validateParams;
    if (trim && typeof value === 'string') {
        value = value.trim();
    }
    const { required, optional, type } = params;
    const globalSpies = getSpies();
    const typeSpies = getSpies({ type });
    const scope = getScope(params);
    // no type - no party
    if (!isFunction(scope.type)) {
        {
            warn('svelidation: type method is absent for type', params.type);
        }
        return [];
    }
    // skip for empty and optional fields
    if (skipValidation(value, { required, optional })) {
        return [];
    }
    const result = [];
    // ensure type with first pick
    const ruleNames = Object.keys(scope).filter(key => (key !== 'type'));
    ruleNames.unshift('type');
    for (let i = 0; i < ruleNames.length; i++) {
        const typeRuleSpies = getSpies({ type, ruleName: ruleNames[i] });
        const ruleSpies = getSpies({ ruleName: ruleNames[i] });
        const spies = [];
        if (i === 0) {
            spies.push(...globalSpies);
            spies.push(...typeSpies);
        }
        spies.push(...typeRuleSpies);
        spies.push(...ruleSpies);
        const { stop, errors, abort, nextValue, nextParams } = runRuleWithSpies({
            value, params, spies,
            rule: scope[ruleNames[i]],
            ruleName: ruleNames[i]
        });
        // exit validation with no errors in case of abort call
        if (abort) {
            return;
        }
        // stop validation with current errors in case of stop call
        // or if there are errors on first (type) step
        if (stop || (i === 0 && errors.length)) {
            return errors;
        }
        result.push(...errors);
        value = nextValue;
        params = nextParams;
    }
    return result;
};
//# sourceMappingURL=validator.js.map

const setValidationPhase = (entries, phase) => {
    entries.forEach(({ formElements }) => {
        if (formElements) {
            formElements.forEach(formElement => formElement.setPhase(phase));
        }
    });
};
const createValidation = (opts) => {
    let phase = ListenInputEventsEnum.never;
    const entries = [];
    const options = Object.assign({
        listenInputEvents: ListenInputEventsEnum.afterValidation,
        presence: 'optional',
        trim: false,
        includeAllEntries: false,
        validateOnEvents: {
            input: false,
            change: true,
            blur: false
        },
        clearErrorsOnEvents: {
            focus: false,
            reset: true
        },
        useCustomErrorsStore: false,
        getValues: false,
        warningsEnabled: true
    }, opts);
    if (!options.warningsEnabled) {
        disableWarn();
    }
    if (typeof options.validateOnEvents !== 'object' || options.validateOnEvents === null) {
        options.validateOnEvents = {};
    }
    if (typeof options.clearErrorsOnEvents !== 'object' || options.clearErrorsOnEvents === null) {
        options.clearErrorsOnEvents = {};
    }
    const getValues = () => {
        if (isFunction(options.getValues)) {
            return options.getValues(entries.map(entry => {
                return {
                    params: entry.params,
                    value: get_store_value(entry.store.value)
                };
            }));
        }
        return entries.reduce((result, entry) => {
            if (entry.formElements || options.includeAllEntries) {
                const { id } = entry.params;
                result.set(id || entry.params, get_store_value(entry.store.value));
            }
            return result;
        }, new Map());
    };
    const buildErrorsStore = (errors, entryParams = null) => {
        return isFunction(options.useCustomErrorsStore)
            ? options.useCustomErrorsStore(errors, entryParams)
            : errors;
    };
    const createEntry = (createEntryParams) => {
        const { value = '', ...params } = createEntryParams;
        const store = {
            errors: writable(buildErrorsStore([])),
            value: writable(value)
        };
        const entry = { store, params };
        const useInput = (inputNode, useOptions) => {
            const formElementOptions = Object.assign({}, options, useOptions, {
                onClear: () => store.errors.set(buildErrorsStore([])),
                onValidate: () => validateValueStore(store.value)
            });
            if (!entry.formElements) {
                entry.formElements = [];
            }
            const newElement = new FormElement(inputNode, formElementOptions);
            newElement.setPhase(phase);
            entry.formElements.push(newElement);
            let preventFirstSubscriberEvent = true;
            const unsubscribe = formElementOptions.validateOnEvents.input && store.value.subscribe(() => {
                if (preventFirstSubscriberEvent) {
                    preventFirstSubscriberEvent = false;
                    return;
                }
                if (options.listenInputEvents === ListenInputEventsEnum.always
                    || (options.listenInputEvents !== ListenInputEventsEnum.never && phase >= options.listenInputEvents)) {
                    validateValueStore(store.value);
                }
            });
            return {
                destroy: () => {
                    if (isFunction(unsubscribe)) {
                        unsubscribe();
                    }
                    for (let i = 0; i < entry.formElements.length; i++) {
                        const formElement = entry.formElements[i];
                        if (formElement.node === inputNode) {
                            entry.formElements.splice(i, 1);
                            formElement.destroy();
                            break;
                        }
                    }
                    if (!entry.formElements.length) {
                        delete entry.formElements;
                    }
                }
            };
        };
        entries.push(entry);
        return [store.errors, store.value, useInput];
    };
    const createEntries = (data) => {
        if (Array.isArray(data)) {
            return data.map(createEntry);
        }
        else {
            return Object.keys(data).reduce((sum, currentKey) => {
                return Object.assign(sum, {
                    [currentKey]: createEntry(data[currentKey])
                });
            }, {});
        }
    };
    const createForm = (formNode, events = {}) => {
        const { onFail: fail, onSubmit: submit, onSuccess: success } = events;
        const onReset = () => clearErrors();
        const onSubmit = e => {
            const errors = validate$1();
            isFunction(submit) && submit(e, errors);
            if (errors.length) {
                isFunction(fail) && fail(errors);
            }
            else {
                isFunction(success) && success(getValues());
            }
        };
        formNode.addEventListener('submit', onSubmit);
        if (options.clearErrorsOnEvents.reset) {
            formNode.addEventListener('reset', onReset);
        }
        return {
            destroy: () => {
                formNode.removeEventListener('submit', onSubmit);
                formNode.removeEventListener('reset', onReset);
            }
        };
    };
    const validateValueStore = (value) => {
        const entry = entries.find(entry => (entry.store.value === value));
        if (entry) {
            const value = get_store_value(entry.store.value);
            const errors = validate(value, prepareBaseParams(entry.params, options));
            if (Array.isArray(errors)) {
                entry.store.errors.set(buildErrorsStore(errors, prepareBaseParams(entry.params, options)));
                return errors;
            }
        }
        return buildErrorsStore([]);
    };
    const validate$1 = (includeNoFormElements = false) => {
        const errors = entries.reduce((errors, entry) => {
            if (entry.formElements || includeNoFormElements || options.includeAllEntries) {
                const storeErrors = validateValueStore(entry.store.value);
                if (storeErrors.length) {
                    errors.push({ [entry.params.type]: buildErrorsStore(storeErrors, prepareBaseParams(entry.params, options)) });
                }
            }
            return errors;
        }, []);
        phase = ListenInputEventsEnum.afterValidation;
        setValidationPhase(entries, ListenInputEventsEnum.afterValidation);
        return errors;
    };
    const clearErrors = (includeNoFormElements = false) => {
        entries.forEach(entry => {
            if (entry.formElements || includeNoFormElements || options.includeAllEntries) {
                entry.store.errors.set(buildErrorsStore([]));
            }
        });
    };
    return {
        createEntry,
        createEntries,
        createForm,
        validateValueStore,
        validate: validate$1,
        clearErrors,
        getValues
    };
};
//# sourceMappingURL=lib.js.map

/* src/docs/ui/button.svelte generated by Svelte v3.15.0 */

const file = "src/docs/ui/button.svelte";

function add_css() {
	var style = element("style");
	style.id = "svelte-74gb8w-style";
	style.textContent = "button.svelte-74gb8w{background:#dcefff;border-radius:3px;border:1px solid #bbb;box-shadow:0 0 5px #bbb;color:inherit;cursor:pointer;height:40px;font-size:inherit;font-weight:bold;margin-right:5px;line-height:28px;outline:0;padding:5px 10px;text-transform:uppercase}button.svelte-74gb8w:only-child{margin-right:0}button.svelte-74gb8w:hover{background-color:#fff}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnV0dG9uLnN2ZWx0ZSIsInNvdXJjZXMiOlsiYnV0dG9uLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxyXG4gIGV4cG9ydCBsZXQgdHlwZSA9ICdidXR0b24nO1xyXG48L3NjcmlwdD5cclxuXHJcbjxidXR0b24ge3R5cGV9IG9uOmNsaWNrPlxyXG4gIDxzbG90PnZhbGlkYXRlPC9zbG90PlxyXG48L2J1dHRvbj5cclxuXHJcbjxzdHlsZT5cclxuICAucm93IHtcclxuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XHJcbiAgfVxyXG5cclxuICAucm93Omxhc3QtY2hpbGQge1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMDtcclxuICB9XHJcblxyXG4gIGxhYmVsIHtcclxuICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gIH1cclxuXHJcbiAgYnV0dG9uIHtcclxuICAgIGJhY2tncm91bmQ6ICNkY2VmZmY7XHJcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XHJcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjYmJiO1xyXG4gICAgYm94LXNoYWRvdzogMCAwIDVweCAjYmJiO1xyXG4gICAgY29sb3I6IGluaGVyaXQ7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICBoZWlnaHQ6IDQwcHg7XHJcbiAgICBmb250LXNpemU6IGluaGVyaXQ7XHJcbiAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgIG1hcmdpbi1yaWdodDogNXB4O1xyXG4gICAgbGluZS1oZWlnaHQ6IDI4cHg7XHJcbiAgICBvdXRsaW5lOiAwO1xyXG4gICAgcGFkZGluZzogNXB4IDEwcHg7XHJcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xyXG4gIH1cclxuXHJcbiAgYnV0dG9uOm9ubHktY2hpbGQge1xyXG4gICAgbWFyZ2luLXJpZ2h0OiAwO1xyXG4gIH1cclxuXHJcbiAgYnV0dG9uOmhvdmVyIHtcclxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XHJcbiAgfVxyXG5cclxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluTnlZeTlrYjJOekwzVnBMMkoxZEhSdmJpNXpkbVZzZEdVaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0RlFVTkZPMGxCUTBVc2JVSkJRVzFDTzBWQlEzSkNPenRGUVVWQk8wbEJRMFVzWjBKQlFXZENPMFZCUTJ4Q096dEZRVVZCTzBsQlEwVXNZMEZCWXp0RlFVTm9RanM3UlVGRlFUdEpRVU5GTEcxQ1FVRnBRenRKUVVOcVF5eHJRa0ZCYTBJN1NVRkRiRUlzYzBKQlFUWkNPMGxCUXpkQ0xIZENRVUVyUWp0SlFVTXZRaXhqUVVGak8wbEJRMlFzWlVGQlpUdEpRVU5tTEZsQlFWazdTVUZEV2l4clFrRkJhMEk3U1VGRGJFSXNhVUpCUVdsQ08wbEJRMnBDTEdsQ1FVRnBRanRKUVVOcVFpeHBRa0ZCYVVJN1NVRkRha0lzVlVGQlZUdEpRVU5XTEdsQ1FVRnBRanRKUVVOcVFpeDVRa0ZCZVVJN1JVRkRNMEk3TzBWQlJVRTdTVUZEUlN4bFFVRmxPMFZCUTJwQ096dEZRVVZCTzBsQlEwVXNjMEpCUVhOQ08wVkJRM2hDSWl3aVptbHNaU0k2SW5OeVl5OWtiMk56TDNWcEwySjFkSFJ2Ymk1emRtVnNkR1VpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY2NseHVJQ0F1Y205M0lIdGNjbHh1SUNBZ0lHMWhjbWRwYmkxaWIzUjBiMjA2SURFd2NIZzdYSEpjYmlBZ2ZWeHlYRzVjY2x4dUlDQXVjbTkzT214aGMzUXRZMmhwYkdRZ2UxeHlYRzRnSUNBZ2JXRnlaMmx1TFdKdmRIUnZiVG9nTUR0Y2NseHVJQ0I5WEhKY2JseHlYRzRnSUd4aFltVnNJSHRjY2x4dUlDQWdJR1JwYzNCc1lYazZJR0pzYjJOck8xeHlYRzRnSUgxY2NseHVYSEpjYmlBZ1luVjBkRzl1SUh0Y2NseHVJQ0FnSUdKaFkydG5jbTkxYm1RNklIWmhjaWd0TFcxaGFXNURiMnh2Y2t4cFoyaDBLVHRjY2x4dUlDQWdJR0p2Y21SbGNpMXlZV1JwZFhNNklETndlRHRjY2x4dUlDQWdJR0p2Y21SbGNqb2dNWEI0SUhOdmJHbGtJSFpoY2lndExXZHlaWGtwTzF4eVhHNGdJQ0FnWW05NExYTm9ZV1J2ZHpvZ01DQXdJRFZ3ZUNCMllYSW9MUzFuY21WNUtUdGNjbHh1SUNBZ0lHTnZiRzl5T2lCcGJtaGxjbWwwTzF4eVhHNGdJQ0FnWTNWeWMyOXlPaUJ3YjJsdWRHVnlPMXh5WEc0Z0lDQWdhR1ZwWjJoME9pQTBNSEI0TzF4eVhHNGdJQ0FnWm05dWRDMXphWHBsT2lCcGJtaGxjbWwwTzF4eVhHNGdJQ0FnWm05dWRDMTNaV2xuYUhRNklHSnZiR1E3WEhKY2JpQWdJQ0J0WVhKbmFXNHRjbWxuYUhRNklEVndlRHRjY2x4dUlDQWdJR3hwYm1VdGFHVnBaMmgwT2lBeU9IQjRPMXh5WEc0Z0lDQWdiM1YwYkdsdVpUb2dNRHRjY2x4dUlDQWdJSEJoWkdScGJtYzZJRFZ3ZUNBeE1IQjRPMXh5WEc0Z0lDQWdkR1Y0ZEMxMGNtRnVjMlp2Y20wNklIVndjR1Z5WTJGelpUdGNjbHh1SUNCOVhISmNibHh5WEc0Z0lHSjFkSFJ2YmpwdmJteDVMV05vYVd4a0lIdGNjbHh1SUNBZ0lHMWhjbWRwYmkxeWFXZG9kRG9nTUR0Y2NseHVJQ0I5WEhKY2JseHlYRzRnSUdKMWRIUnZianBvYjNabGNpQjdYSEpjYmlBZ0lDQmlZV05yWjNKdmRXNWtMV052Ykc5eU9pQWpabVptTzF4eVhHNGdJSDFjY2x4dUlsMTkgKi88L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBcUJFLE1BQU0sY0FBQyxDQUFDLEFBQ04sVUFBVSxDQUFFLE9BQU8sQ0FDbkIsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUN0QixVQUFVLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUN4QixLQUFLLENBQUUsT0FBTyxDQUNkLE1BQU0sQ0FBRSxPQUFPLENBQ2YsTUFBTSxDQUFFLElBQUksQ0FDWixTQUFTLENBQUUsT0FBTyxDQUNsQixXQUFXLENBQUUsSUFBSSxDQUNqQixZQUFZLENBQUUsR0FBRyxDQUNqQixXQUFXLENBQUUsSUFBSSxDQUNqQixPQUFPLENBQUUsQ0FBQyxDQUNWLE9BQU8sQ0FBRSxHQUFHLENBQUMsSUFBSSxDQUNqQixjQUFjLENBQUUsU0FBUyxBQUMzQixDQUFDLEFBRUQsb0JBQU0sV0FBVyxBQUFDLENBQUMsQUFDakIsWUFBWSxDQUFFLENBQUMsQUFDakIsQ0FBQyxBQUVELG9CQUFNLE1BQU0sQUFBQyxDQUFDLEFBQ1osZ0JBQWdCLENBQUUsSUFBSSxBQUN4QixDQUFDIn0= */";
	append_dev(document.head, style);
}

function create_fragment(ctx) {
	let button;
	let t;
	let current;
	let dispose;
	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	const block = {
		c: function create() {
			button = element("button");

			if (!default_slot) {
				t = text("validate");
			}

			if (default_slot) default_slot.c();
			attr_dev(button, "type", ctx.type);
			attr_dev(button, "class", "svelte-74gb8w");
			add_location(button, file, 4, 0, 54);
			dispose = listen_dev(button, "click", ctx.click_handler, false, false, false);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);

			if (!default_slot) {
				append_dev(button, t);
			}

			if (default_slot) {
				default_slot.m(button, null);
			}

			current = true;
		},
		p: function update(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_template, ctx, changed, null), get_slot_context(default_slot_template, ctx, null));
			}

			if (!current || changed.type) {
				attr_dev(button, "type", ctx.type);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (default_slot) default_slot.d(detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { type = "button" } = $$props;
	const writable_props = ["type"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Button> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	function click_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ("type" in $$props) $$invalidate("type", type = $$props.type);
		if ("$$scope" in $$props) $$invalidate("$$scope", $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return { type };
	};

	$$self.$inject_state = $$props => {
		if ("type" in $$props) $$invalidate("type", type = $$props.type);
	};

	return { type, click_handler, $$slots, $$scope };
}

class Button extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-74gb8w-style")) add_css();
		init(this, options, instance, create_fragment, safe_not_equal, { type: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button",
			options,
			id: create_fragment.name
		});
	}

	get type() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/docs/builder/components/toggle.svelte generated by Svelte v3.15.0 */

const file$1 = "src/docs/builder/components/toggle.svelte";

function add_css$1() {
	var style = element("style");
	style.id = "svelte-1wkghe5-style";
	style.textContent = ".toggle.svelte-1wkghe5{background:#fff;box-shadow:0 0 5px #bbb;border-radius:15px;cursor:pointer;display:inline-block;height:20px;overflow:hidden;position:relative;transition:.3s background-color ease-in-out;vertical-align:top;width:40px}.toggle.checked.svelte-1wkghe5{background:#004cb4}.toggle.svelte-1wkghe5::after{background:#bbb;border-radius:7px;content:'';height:14px;left:3px;position:absolute;top:3px;transition-property:transform, background-color;transition-duration:.3s;transition-timing-function:ease-in-out;width:14px}.toggle.checked.svelte-1wkghe5::after{background:#fff;transform:translateX(calc(100% + 6px))}input.svelte-1wkghe5{left:0;opacity:0;position:absolute;visibility:hidden;top:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLnN2ZWx0ZSIsInNvdXJjZXMiOlsidG9nZ2xlLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxyXG4gIGV4cG9ydCBsZXQgY2hlY2tlZCA9IGZhbHNlO1xyXG4gIGV4cG9ydCBsZXQgaWQgPSBmYWxzZTtcclxuPC9zY3JpcHQ+XHJcblxyXG48bGFiZWwgY2xhc3M9XCJ0b2dnbGVcIiBjbGFzczpjaGVja2VkIG9uOmNsaWNrfHN0b3BQcm9wYWdhdGlvbj5cclxuICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgYmluZDpjaGVja2VkIG9uOmNoYW5nZSB7aWR9IC8+XHJcbjwvbGFiZWw+XHJcblxyXG48c3R5bGU+XHJcbiAgLnRvZ2dsZSB7XHJcbiAgICBiYWNrZ3JvdW5kOiAjZmZmO1xyXG4gICAgYm94LXNoYWRvdzogMCAwIDVweCAjYmJiO1xyXG4gICAgYm9yZGVyLXJhZGl1czogMTVweDtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcclxuICAgIGhlaWdodDogMjBweDtcclxuICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICB0cmFuc2l0aW9uOiAuM3MgYmFja2dyb3VuZC1jb2xvciBlYXNlLWluLW91dDtcclxuICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XHJcbiAgICB3aWR0aDogNDBweDtcclxuICB9XHJcblxyXG4gIC50b2dnbGUuY2hlY2tlZCB7XHJcbiAgICBiYWNrZ3JvdW5kOiAjMDA0Y2I0O1xyXG4gIH1cclxuXHJcbiAgLnRvZ2dsZTo6YWZ0ZXIge1xyXG4gICAgYmFja2dyb3VuZDogI2JiYjtcclxuICAgIGJvcmRlci1yYWRpdXM6IDdweDtcclxuICAgIGNvbnRlbnQ6ICcnO1xyXG4gICAgaGVpZ2h0OiAxNHB4O1xyXG4gICAgbGVmdDogM3B4O1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgdG9wOiAzcHg7XHJcbiAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiB0cmFuc2Zvcm0sIGJhY2tncm91bmQtY29sb3I7XHJcbiAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAuM3M7XHJcbiAgICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbi1vdXQ7XHJcbiAgICB3aWR0aDogMTRweDtcclxuICB9XHJcblxyXG4gIC50b2dnbGUuY2hlY2tlZDo6YWZ0ZXIge1xyXG4gICAgYmFja2dyb3VuZDogI2ZmZjtcclxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWChjYWxjKDEwMCUgKyA2cHgpKTtcclxuICB9XHJcblxyXG4gIGlucHV0IHtcclxuICAgIGxlZnQ6IDA7XHJcbiAgICBvcGFjaXR5OiAwO1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xyXG4gICAgdG9wOiAwO1xyXG4gIH1cclxuXHJcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbk55WXk5a2IyTnpMMkoxYVd4a1pYSXZZMjl0Y0c5dVpXNTBjeTkwYjJkbmJHVXVjM1psYkhSbElsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1JVRkRSVHRKUVVORkxHZENRVUZuUWp0SlFVTm9RaXgzUWtGQkswSTdTVUZETDBJc2JVSkJRVzFDTzBsQlEyNUNMR1ZCUVdVN1NVRkRaaXh4UWtGQmNVSTdTVUZEY2tJc1dVRkJXVHRKUVVOYUxHZENRVUZuUWp0SlFVTm9RaXhyUWtGQmEwSTdTVUZEYkVJc05FTkJRVFJETzBsQlF6VkRMRzFDUVVGdFFqdEpRVU51UWl4WFFVRlhPMFZCUTJJN08wVkJSVUU3U1VGRFJTeHRRa0ZCTkVJN1JVRkRPVUk3TzBWQlJVRTdTVUZEUlN4blFrRkJkVUk3U1VGRGRrSXNhMEpCUVd0Q08wbEJRMnhDTEZkQlFWYzdTVUZEV0N4WlFVRlpPMGxCUTFvc1UwRkJVenRKUVVOVUxHdENRVUZyUWp0SlFVTnNRaXhSUVVGUk8wbEJRMUlzWjBSQlFXZEVPMGxCUTJoRUxIZENRVUYzUWp0SlFVTjRRaXgxUTBGQmRVTTdTVUZEZGtNc1YwRkJWenRGUVVOaU96dEZRVVZCTzBsQlEwVXNaMEpCUVdkQ08wbEJRMmhDTEhWRFFVRjFRenRGUVVONlF6czdSVUZGUVR0SlFVTkZMRTlCUVU4N1NVRkRVQ3hWUVVGVk8wbEJRMVlzYTBKQlFXdENPMGxCUTJ4Q0xHdENRVUZyUWp0SlFVTnNRaXhOUVVGTk8wVkJRMUlpTENKbWFXeGxJam9pYzNKakwyUnZZM012WW5WcGJHUmxjaTlqYjIxd2IyNWxiblJ6TDNSdloyZHNaUzV6ZG1Wc2RHVWlMQ0p6YjNWeVkyVnpRMjl1ZEdWdWRDSTZXeUpjY2x4dUlDQXVkRzluWjJ4bElIdGNjbHh1SUNBZ0lHSmhZMnRuY205MWJtUTZJQ05tWm1ZN1hISmNiaUFnSUNCaWIzZ3RjMmhoWkc5M09pQXdJREFnTlhCNElIWmhjaWd0TFdkeVpYa3BPMXh5WEc0Z0lDQWdZbTl5WkdWeUxYSmhaR2wxY3pvZ01UVndlRHRjY2x4dUlDQWdJR04xY25OdmNqb2djRzlwYm5SbGNqdGNjbHh1SUNBZ0lHUnBjM0JzWVhrNklHbHViR2x1WlMxaWJHOWphenRjY2x4dUlDQWdJR2hsYVdkb2REb2dNakJ3ZUR0Y2NseHVJQ0FnSUc5MlpYSm1iRzkzT2lCb2FXUmtaVzQ3WEhKY2JpQWdJQ0J3YjNOcGRHbHZiam9nY21Wc1lYUnBkbVU3WEhKY2JpQWdJQ0IwY21GdWMybDBhVzl1T2lBdU0zTWdZbUZqYTJkeWIzVnVaQzFqYjJ4dmNpQmxZWE5sTFdsdUxXOTFkRHRjY2x4dUlDQWdJSFpsY25ScFkyRnNMV0ZzYVdkdU9pQjBiM0E3WEhKY2JpQWdJQ0IzYVdSMGFEb2dOREJ3ZUR0Y2NseHVJQ0I5WEhKY2JseHlYRzRnSUM1MGIyZG5iR1V1WTJobFkydGxaQ0I3WEhKY2JpQWdJQ0JpWVdOclozSnZkVzVrT2lCMllYSW9MUzF0WVdsdVEyOXNiM0lwTzF4eVhHNGdJSDFjY2x4dVhISmNiaUFnTG5SdloyZHNaVG82WVdaMFpYSWdlMXh5WEc0Z0lDQWdZbUZqYTJkeWIzVnVaRG9nZG1GeUtDMHRaM0psZVNrN1hISmNiaUFnSUNCaWIzSmtaWEl0Y21Ga2FYVnpPaUEzY0hnN1hISmNiaUFnSUNCamIyNTBaVzUwT2lBbkp6dGNjbHh1SUNBZ0lHaGxhV2RvZERvZ01UUndlRHRjY2x4dUlDQWdJR3hsWm5RNklETndlRHRjY2x4dUlDQWdJSEJ2YzJsMGFXOXVPaUJoWW5OdmJIVjBaVHRjY2x4dUlDQWdJSFJ2Y0RvZ00zQjRPMXh5WEc0Z0lDQWdkSEpoYm5OcGRHbHZiaTF3Y205d1pYSjBlVG9nZEhKaGJuTm1iM0p0TENCaVlXTnJaM0p2ZFc1a0xXTnZiRzl5TzF4eVhHNGdJQ0FnZEhKaGJuTnBkR2x2Ymkxa2RYSmhkR2x2YmpvZ0xqTnpPMXh5WEc0Z0lDQWdkSEpoYm5OcGRHbHZiaTEwYVcxcGJtY3RablZ1WTNScGIyNDZJR1ZoYzJVdGFXNHRiM1YwTzF4eVhHNGdJQ0FnZDJsa2RHZzZJREUwY0hnN1hISmNiaUFnZlZ4eVhHNWNjbHh1SUNBdWRHOW5aMnhsTG1Ob1pXTnJaV1E2T21GbWRHVnlJSHRjY2x4dUlDQWdJR0poWTJ0bmNtOTFibVE2SUNObVptWTdYSEpjYmlBZ0lDQjBjbUZ1YzJadmNtMDZJSFJ5WVc1emJHRjBaVmdvWTJGc1l5Z3hNREFsSUNzZ05uQjRLU2s3WEhKY2JpQWdmVnh5WEc1Y2NseHVJQ0JwYm5CMWRDQjdYSEpjYmlBZ0lDQnNaV1owT2lBd08xeHlYRzRnSUNBZ2IzQmhZMmwwZVRvZ01EdGNjbHh1SUNBZ0lIQnZjMmwwYVc5dU9pQmhZbk52YkhWMFpUdGNjbHh1SUNBZ0lIWnBjMmxpYVd4cGRIazZJR2hwWkdSbGJqdGNjbHh1SUNBZ0lIUnZjRG9nTUR0Y2NseHVJQ0I5WEhKY2JpSmRmUT09ICovPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVVFLE9BQU8sZUFBQyxDQUFDLEFBQ1AsVUFBVSxDQUFFLElBQUksQ0FDaEIsVUFBVSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FDeEIsYUFBYSxDQUFFLElBQUksQ0FDbkIsTUFBTSxDQUFFLE9BQU8sQ0FDZixPQUFPLENBQUUsWUFBWSxDQUNyQixNQUFNLENBQUUsSUFBSSxDQUNaLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLFVBQVUsQ0FBRSxHQUFHLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUM1QyxjQUFjLENBQUUsR0FBRyxDQUNuQixLQUFLLENBQUUsSUFBSSxBQUNiLENBQUMsQUFFRCxPQUFPLFFBQVEsZUFBQyxDQUFDLEFBQ2YsVUFBVSxDQUFFLE9BQU8sQUFDckIsQ0FBQyxBQUVELHNCQUFPLE9BQU8sQUFBQyxDQUFDLEFBQ2QsVUFBVSxDQUFFLElBQUksQ0FDaEIsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsT0FBTyxDQUFFLEVBQUUsQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLElBQUksQ0FBRSxHQUFHLENBQ1QsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLEdBQUcsQ0FDUixtQkFBbUIsQ0FBRSxTQUFTLENBQUMsQ0FBQyxnQkFBZ0IsQ0FDaEQsbUJBQW1CLENBQUUsR0FBRyxDQUN4QiwwQkFBMEIsQ0FBRSxXQUFXLENBQ3ZDLEtBQUssQ0FBRSxJQUFJLEFBQ2IsQ0FBQyxBQUVELE9BQU8sdUJBQVEsT0FBTyxBQUFDLENBQUMsQUFDdEIsVUFBVSxDQUFFLElBQUksQ0FDaEIsU0FBUyxDQUFFLFdBQVcsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEFBQ3pDLENBQUMsQUFFRCxLQUFLLGVBQUMsQ0FBQyxBQUNMLElBQUksQ0FBRSxDQUFDLENBQ1AsT0FBTyxDQUFFLENBQUMsQ0FDVixRQUFRLENBQUUsUUFBUSxDQUNsQixVQUFVLENBQUUsTUFBTSxDQUNsQixHQUFHLENBQUUsQ0FBQyxBQUNSLENBQUMifQ== */";
	append_dev(document.head, style);
}

function create_fragment$1(ctx) {
	let label;
	let input;
	let dispose;

	const block = {
		c: function create() {
			label = element("label");
			input = element("input");
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "id", ctx.id);
			attr_dev(input, "class", "svelte-1wkghe5");
			add_location(input, file$1, 6, 2, 145);
			attr_dev(label, "class", "toggle svelte-1wkghe5");
			toggle_class(label, "checked", ctx.checked);
			add_location(label, file$1, 5, 0, 80);

			dispose = [
				listen_dev(input, "change", ctx.input_change_handler),
				listen_dev(input, "change", ctx.change_handler, false, false, false),
				listen_dev(label, "click", stop_propagation(ctx.click_handler), false, true, false)
			];
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, input);
			input.checked = ctx.checked;
		},
		p: function update(changed, ctx) {
			if (changed.id) {
				attr_dev(input, "id", ctx.id);
			}

			if (changed.checked) {
				input.checked = ctx.checked;
			}

			if (changed.checked) {
				toggle_class(label, "checked", ctx.checked);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { checked = false } = $$props;
	let { id = false } = $$props;
	const writable_props = ["checked", "id"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Toggle> was created with unknown prop '${key}'`);
	});

	function click_handler(event) {
		bubble($$self, event);
	}

	function change_handler(event) {
		bubble($$self, event);
	}

	function input_change_handler() {
		checked = this.checked;
		$$invalidate("checked", checked);
	}

	$$self.$set = $$props => {
		if ("checked" in $$props) $$invalidate("checked", checked = $$props.checked);
		if ("id" in $$props) $$invalidate("id", id = $$props.id);
	};

	$$self.$capture_state = () => {
		return { checked, id };
	};

	$$self.$inject_state = $$props => {
		if ("checked" in $$props) $$invalidate("checked", checked = $$props.checked);
		if ("id" in $$props) $$invalidate("id", id = $$props.id);
	};

	return {
		checked,
		id,
		click_handler,
		change_handler,
		input_change_handler
	};
}

class Toggle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1wkghe5-style")) add_css$1();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { checked: 0, id: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Toggle",
			options,
			id: create_fragment$1.name
		});
	}

	get checked() {
		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/docs/builder/components/new-field-rule.svelte generated by Svelte v3.15.0 */
const file$2 = "src/docs/builder/components/new-field-rule.svelte";

function add_css$2() {
	var style = element("style");
	style.id = "svelte-cjbcpu-style";
	style.textContent = ".rule.svelte-cjbcpu{background:#dcefff;cursor:pointer;display:flex;flex:1 0 calc(50% - 10px);margin:0 10px 10px 0;min-width:250px;padding:10px;width:calc(50% - 10px)}.rule.checked.svelte-cjbcpu{cursor:initial}.disabled.svelte-cjbcpu{filter:grayscale(100%);opacity:.5;pointer-events:none}.rule.svelte-cjbcpu span.svelte-cjbcpu{flex:1;margin-left:10px}.rule.svelte-cjbcpu input.svelte-cjbcpu{border:1px solid #bbb;border-radius:3px;font-size:14px;height:20px;line-height:18px;margin-left:10px;outline:0;padding:0 3px;text-align:right;width:100px}.rule.svelte-cjbcpu input.svelte-cjbcpu:disabled{cursor:pointer;opacity:.5}.rule.svelte-cjbcpu .double.svelte-cjbcpu{width:45px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmV3LWZpZWxkLXJ1bGUuc3ZlbHRlIiwic291cmNlcyI6WyJuZXctZmllbGQtcnVsZS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cclxuICBpbXBvcnQgVG9nZ2xlIGZyb20gJ2RvY3MvYnVpbGRlci9jb21wb25lbnRzL3RvZ2dsZS5zdmVsdGUnO1xyXG5cclxuICBleHBvcnQgbGV0IG1vZGVsO1xyXG4gIGV4cG9ydCBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcclxuICBleHBvcnQgbGV0IHR5cGUgPSAndGV4dCc7XHJcbiAgZXhwb3J0IGxldCB0ZXh0O1xyXG4gIGV4cG9ydCBsZXQgcGxhY2Vob2xkZXIgPSBmYWxzZTtcclxuXHJcbiAgaWYgKCFwbGFjZWhvbGRlcikge1xyXG4gICAgcGxhY2Vob2xkZXIgPSAnJztcclxuICB9XHJcblxyXG4gIGNvbnN0IG9uQ2xpY2sgPSAoKSA9PiB7XHJcbiAgICBpZiAoIW1vZGVsLmNoZWNrZWQpIHtcclxuICAgICAgbW9kZWwuY2hlY2tlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG48L3NjcmlwdD5cclxuXHJcblxyXG48ZGl2XHJcbiAgY2xhc3M9XCJydWxlXCJcclxuICBjbGFzczpjaGVja2VkPXttb2RlbC5jaGVja2VkfVxyXG4gIGNsYXNzOmRpc2FibGVkXHJcbiAgb246Y2xpY2s9e29uQ2xpY2t9XHJcbj5cclxuICA8VG9nZ2xlIGJpbmQ6Y2hlY2tlZD17bW9kZWwuY2hlY2tlZH0gLz5cclxuXHJcbiAgPHNwYW4+e3RleHR9PC9zcGFuPlxyXG5cclxuICB7I2lmIHR5cGVvZiBtb2RlbC52YWx1ZSAhPT0gJ3VuZGVmaW5lZCd9XHJcbiAgICB7I2lmIEFycmF5LmlzQXJyYXkobW9kZWwudmFsdWUpfVxyXG4gICAgICA8aW5wdXQge3BsYWNlaG9sZGVyfSB0eXBlPVwibnVtYmVyXCIgY2xhc3M9XCJkb3VibGVcIiBkaXNhYmxlZD17IW1vZGVsLmNoZWNrZWR9IGJpbmQ6dmFsdWU9e21vZGVsLnZhbHVlWzBdfSAvPlxyXG4gICAgICA8aW5wdXQge3BsYWNlaG9sZGVyfSB0eXBlPVwibnVtYmVyXCIgY2xhc3M9XCJkb3VibGVcIiBkaXNhYmxlZD17IW1vZGVsLmNoZWNrZWR9IGJpbmQ6dmFsdWU9e21vZGVsLnZhbHVlWzFdfSAvPlxyXG4gICAgezplbHNlIGlmIHR5cGUgPT09ICdudW1iZXInfVxyXG4gICAgICA8aW5wdXQge3BsYWNlaG9sZGVyfSB0eXBlPVwibnVtYmVyXCIgZGlzYWJsZWQ9eyFtb2RlbC5jaGVja2VkfSBiaW5kOnZhbHVlPXttb2RlbC52YWx1ZX0gLz5cclxuICAgIHs6ZWxzZX1cclxuICAgICAgPGlucHV0IHtwbGFjZWhvbGRlcn0gdHlwZT1cInRleHRcIiBkaXNhYmxlZD17IW1vZGVsLmNoZWNrZWR9IGJpbmQ6dmFsdWU9e21vZGVsLnZhbHVlfSAvPlxyXG4gICAgey9pZn1cclxuICB7L2lmfVxyXG48L2Rpdj5cclxuXHJcbjxzdHlsZT5cclxuICAucnVsZSB7XHJcbiAgICBiYWNrZ3JvdW5kOiAjZGNlZmZmO1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGZsZXg6IDEgMCBjYWxjKDUwJSAtIDEwcHgpO1xyXG4gICAgbWFyZ2luOiAwIDEwcHggMTBweCAwO1xyXG4gICAgbWluLXdpZHRoOiAyNTBweDtcclxuICAgIHBhZGRpbmc6IDEwcHg7XHJcbiAgICB3aWR0aDogY2FsYyg1MCUgLSAxMHB4KTtcclxuICB9XHJcblxyXG4gIC5ydWxlLmNoZWNrZWQge1xyXG4gICAgY3Vyc29yOiBpbml0aWFsO1xyXG4gIH1cclxuXHJcbiAgLmRpc2FibGVkIHtcclxuICAgIGZpbHRlcjogZ3JheXNjYWxlKDEwMCUpO1xyXG4gICAgb3BhY2l0eTogLjU7XHJcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxuICB9XHJcblxyXG4gIC5ydWxlIHNwYW4ge1xyXG4gICAgZmxleDogMTtcclxuICAgIG1hcmdpbi1sZWZ0OiAxMHB4O1xyXG4gIH1cclxuXHJcbiAgLnJ1bGUgaW5wdXQge1xyXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2JiYjtcclxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcclxuICAgIGZvbnQtc2l6ZTogMTRweDtcclxuICAgIGhlaWdodDogMjBweDtcclxuICAgIGxpbmUtaGVpZ2h0OiAxOHB4O1xyXG4gICAgbWFyZ2luLWxlZnQ6IDEwcHg7XHJcbiAgICBvdXRsaW5lOiAwO1xyXG4gICAgcGFkZGluZzogMCAzcHg7XHJcbiAgICB0ZXh0LWFsaWduOiByaWdodDtcclxuICAgIHdpZHRoOiAxMDBweDtcclxuICB9XHJcblxyXG4gIC5ydWxlIGlucHV0OmRpc2FibGVkIHtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIG9wYWNpdHk6IC41O1xyXG4gIH1cclxuXHJcbiAgLnJ1bGUgLmRvdWJsZSB7XHJcbiAgICB3aWR0aDogNDVweDtcclxuICB9XHJcblxyXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5OeVl5OWtiMk56TDJKMWFXeGtaWEl2WTI5dGNHOXVaVzUwY3k5dVpYY3RabWxsYkdRdGNuVnNaUzV6ZG1Wc2RHVWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEZRVU5GTzBsQlEwVXNiVUpCUVdsRE8wbEJRMnBETEdWQlFXVTdTVUZEWml4aFFVRmhPMGxCUTJJc01FSkJRVEJDTzBsQlF6RkNMSEZDUVVGeFFqdEpRVU55UWl4blFrRkJaMEk3U1VGRGFFSXNZVUZCWVR0SlFVTmlMSFZDUVVGMVFqdEZRVU42UWpzN1JVRkZRVHRKUVVORkxHVkJRV1U3UlVGRGFrSTdPMFZCUlVFN1NVRkRSU3gxUWtGQmRVSTdTVUZEZGtJc1YwRkJWenRKUVVOWUxHOUNRVUZ2UWp0RlFVTjBRanM3UlVGRlFUdEpRVU5GTEU5QlFVODdTVUZEVUN4cFFrRkJhVUk3UlVGRGJrSTdPMFZCUlVFN1NVRkRSU3h6UWtGQk5rSTdTVUZETjBJc2EwSkJRV3RDTzBsQlEyeENMR1ZCUVdVN1NVRkRaaXhaUVVGWk8wbEJRMW9zYVVKQlFXbENPMGxCUTJwQ0xHbENRVUZwUWp0SlFVTnFRaXhWUVVGVk8wbEJRMVlzWTBGQll6dEpRVU5rTEdsQ1FVRnBRanRKUVVOcVFpeFpRVUZaTzBWQlEyUTdPMFZCUlVFN1NVRkRSU3hsUVVGbE8wbEJRMllzVjBGQlZ6dEZRVU5pT3p0RlFVVkJPMGxCUTBVc1YwRkJWenRGUVVOaUlpd2labWxzWlNJNkluTnlZeTlrYjJOekwySjFhV3hrWlhJdlkyOXRjRzl1Wlc1MGN5OXVaWGN0Wm1sbGJHUXRjblZzWlM1emRtVnNkR1VpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY2NseHVJQ0F1Y25Wc1pTQjdYSEpjYmlBZ0lDQmlZV05yWjNKdmRXNWtPaUIyWVhJb0xTMXRZV2x1UTI5c2IzSk1hV2RvZENrN1hISmNiaUFnSUNCamRYSnpiM0k2SUhCdmFXNTBaWEk3WEhKY2JpQWdJQ0JrYVhOd2JHRjVPaUJtYkdWNE8xeHlYRzRnSUNBZ1pteGxlRG9nTVNBd0lHTmhiR01vTlRBbElDMGdNVEJ3ZUNrN1hISmNiaUFnSUNCdFlYSm5hVzQ2SURBZ01UQndlQ0F4TUhCNElEQTdYSEpjYmlBZ0lDQnRhVzR0ZDJsa2RHZzZJREkxTUhCNE8xeHlYRzRnSUNBZ2NHRmtaR2x1WnpvZ01UQndlRHRjY2x4dUlDQWdJSGRwWkhSb09pQmpZV3hqS0RVd0pTQXRJREV3Y0hncE8xeHlYRzRnSUgxY2NseHVYSEpjYmlBZ0xuSjFiR1V1WTJobFkydGxaQ0I3WEhKY2JpQWdJQ0JqZFhKemIzSTZJR2x1YVhScFlXdzdYSEpjYmlBZ2ZWeHlYRzVjY2x4dUlDQXVaR2x6WVdKc1pXUWdlMXh5WEc0Z0lDQWdabWxzZEdWeU9pQm5jbUY1YzJOaGJHVW9NVEF3SlNrN1hISmNiaUFnSUNCdmNHRmphWFI1T2lBdU5UdGNjbHh1SUNBZ0lIQnZhVzUwWlhJdFpYWmxiblJ6T2lCdWIyNWxPMXh5WEc0Z0lIMWNjbHh1WEhKY2JpQWdMbkoxYkdVZ2MzQmhiaUI3WEhKY2JpQWdJQ0JtYkdWNE9pQXhPMXh5WEc0Z0lDQWdiV0Z5WjJsdUxXeGxablE2SURFd2NIZzdYSEpjYmlBZ2ZWeHlYRzVjY2x4dUlDQXVjblZzWlNCcGJuQjFkQ0I3WEhKY2JpQWdJQ0JpYjNKa1pYSTZJREZ3ZUNCemIyeHBaQ0IyWVhJb0xTMW5jbVY1S1R0Y2NseHVJQ0FnSUdKdmNtUmxjaTF5WVdScGRYTTZJRE53ZUR0Y2NseHVJQ0FnSUdadmJuUXRjMmw2WlRvZ01UUndlRHRjY2x4dUlDQWdJR2hsYVdkb2REb2dNakJ3ZUR0Y2NseHVJQ0FnSUd4cGJtVXRhR1ZwWjJoME9pQXhPSEI0TzF4eVhHNGdJQ0FnYldGeVoybHVMV3hsWm5RNklERXdjSGc3WEhKY2JpQWdJQ0J2ZFhSc2FXNWxPaUF3TzF4eVhHNGdJQ0FnY0dGa1pHbHVaem9nTUNBemNIZzdYSEpjYmlBZ0lDQjBaWGgwTFdGc2FXZHVPaUJ5YVdkb2REdGNjbHh1SUNBZ0lIZHBaSFJvT2lBeE1EQndlRHRjY2x4dUlDQjlYSEpjYmx4eVhHNGdJQzV5ZFd4bElHbHVjSFYwT21ScGMyRmliR1ZrSUh0Y2NseHVJQ0FnSUdOMWNuTnZjam9nY0c5cGJuUmxjanRjY2x4dUlDQWdJRzl3WVdOcGRIazZJQzQxTzF4eVhHNGdJSDFjY2x4dVhISmNiaUFnTG5KMWJHVWdMbVJ2ZFdKc1pTQjdYSEpjYmlBZ0lDQjNhV1IwYURvZ05EVndlRHRjY2x4dUlDQjlYSEpjYmlKZGZRPT0gKi88L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBNENFLEtBQUssY0FBQyxDQUFDLEFBQ0wsVUFBVSxDQUFFLE9BQU8sQ0FDbkIsTUFBTSxDQUFFLE9BQU8sQ0FDZixPQUFPLENBQUUsSUFBSSxDQUNiLElBQUksQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FDMUIsTUFBTSxDQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FDckIsU0FBUyxDQUFFLEtBQUssQ0FDaEIsT0FBTyxDQUFFLElBQUksQ0FDYixLQUFLLENBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxBQUN6QixDQUFDLEFBRUQsS0FBSyxRQUFRLGNBQUMsQ0FBQyxBQUNiLE1BQU0sQ0FBRSxPQUFPLEFBQ2pCLENBQUMsQUFFRCxTQUFTLGNBQUMsQ0FBQyxBQUNULE1BQU0sQ0FBRSxVQUFVLElBQUksQ0FBQyxDQUN2QixPQUFPLENBQUUsRUFBRSxDQUNYLGNBQWMsQ0FBRSxJQUFJLEFBQ3RCLENBQUMsQUFFRCxtQkFBSyxDQUFDLElBQUksY0FBQyxDQUFDLEFBQ1YsSUFBSSxDQUFFLENBQUMsQ0FDUCxXQUFXLENBQUUsSUFBSSxBQUNuQixDQUFDLEFBRUQsbUJBQUssQ0FBQyxLQUFLLGNBQUMsQ0FBQyxBQUNYLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FDdEIsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsU0FBUyxDQUFFLElBQUksQ0FDZixNQUFNLENBQUUsSUFBSSxDQUNaLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLE9BQU8sQ0FBRSxDQUFDLENBQ1YsT0FBTyxDQUFFLENBQUMsQ0FBQyxHQUFHLENBQ2QsVUFBVSxDQUFFLEtBQUssQ0FDakIsS0FBSyxDQUFFLEtBQUssQUFDZCxDQUFDLEFBRUQsbUJBQUssQ0FBQyxtQkFBSyxTQUFTLEFBQUMsQ0FBQyxBQUNwQixNQUFNLENBQUUsT0FBTyxDQUNmLE9BQU8sQ0FBRSxFQUFFLEFBQ2IsQ0FBQyxBQUVELG1CQUFLLENBQUMsT0FBTyxjQUFDLENBQUMsQUFDYixLQUFLLENBQUUsSUFBSSxBQUNiLENBQUMifQ== */";
	append_dev(document.head, style);
}

// (32:2) {#if typeof model.value !== 'undefined'}
function create_if_block(ctx) {
	let show_if;
	let if_block_anchor;

	function select_block_type(changed, ctx) {
		if (show_if == null || changed.model) show_if = !!Array.isArray(ctx.model.value);
		if (show_if) return create_if_block_1;
		if (ctx.type === "number") return create_if_block_2;
		return create_else_block;
	}

	let current_block_type = select_block_type(null, ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(changed, ctx) {
			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block) {
				if_block.p(changed, ctx);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(32:2) {#if typeof model.value !== 'undefined'}",
		ctx
	});

	return block;
}

// (38:4) {:else}
function create_else_block(ctx) {
	let input;
	let input_disabled_value;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "placeholder", ctx.placeholder);
			attr_dev(input, "type", "text");
			input.disabled = input_disabled_value = !ctx.model.checked;
			attr_dev(input, "class", "svelte-cjbcpu");
			add_location(input, file$2, 38, 6, 1004);
			dispose = listen_dev(input, "input", ctx.input_input_handler_1);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, ctx.model.value);
		},
		p: function update(changed, ctx) {
			if (changed.placeholder) {
				attr_dev(input, "placeholder", ctx.placeholder);
			}

			if (changed.model && input_disabled_value !== (input_disabled_value = !ctx.model.checked)) {
				prop_dev(input, "disabled", input_disabled_value);
			}

			if (changed.model && input.value !== ctx.model.value) {
				set_input_value(input, ctx.model.value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(38:4) {:else}",
		ctx
	});

	return block;
}

// (36:32) 
function create_if_block_2(ctx) {
	let input;
	let input_disabled_value;
	let input_updating = false;
	let dispose;

	function input_input_handler() {
		input_updating = true;
		ctx.input_input_handler.call(input);
	}

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "placeholder", ctx.placeholder);
			attr_dev(input, "type", "number");
			input.disabled = input_disabled_value = !ctx.model.checked;
			attr_dev(input, "class", "svelte-cjbcpu");
			add_location(input, file$2, 36, 6, 895);
			dispose = listen_dev(input, "input", input_input_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, ctx.model.value);
		},
		p: function update(changed, ctx) {
			if (changed.placeholder) {
				attr_dev(input, "placeholder", ctx.placeholder);
			}

			if (changed.model && input_disabled_value !== (input_disabled_value = !ctx.model.checked)) {
				prop_dev(input, "disabled", input_disabled_value);
			}

			if (!input_updating && changed.model) {
				set_input_value(input, ctx.model.value);
			}

			input_updating = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(36:32) ",
		ctx
	});

	return block;
}

// (33:4) {#if Array.isArray(model.value)}
function create_if_block_1(ctx) {
	let input0;
	let input0_disabled_value;
	let input0_updating = false;
	let t;
	let input1;
	let input1_disabled_value;
	let input1_updating = false;
	let dispose;

	function input0_input_handler() {
		input0_updating = true;
		ctx.input0_input_handler.call(input0);
	}

	function input1_input_handler() {
		input1_updating = true;
		ctx.input1_input_handler.call(input1);
	}

	const block = {
		c: function create() {
			input0 = element("input");
			t = space();
			input1 = element("input");
			attr_dev(input0, "placeholder", ctx.placeholder);
			attr_dev(input0, "type", "number");
			attr_dev(input0, "class", "double svelte-cjbcpu");
			input0.disabled = input0_disabled_value = !ctx.model.checked;
			add_location(input0, file$2, 33, 6, 633);
			attr_dev(input1, "placeholder", ctx.placeholder);
			attr_dev(input1, "type", "number");
			attr_dev(input1, "class", "double svelte-cjbcpu");
			input1.disabled = input1_disabled_value = !ctx.model.checked;
			add_location(input1, file$2, 34, 6, 747);

			dispose = [
				listen_dev(input0, "input", input0_input_handler),
				listen_dev(input1, "input", input1_input_handler)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, input0, anchor);
			set_input_value(input0, ctx.model.value[0]);
			insert_dev(target, t, anchor);
			insert_dev(target, input1, anchor);
			set_input_value(input1, ctx.model.value[1]);
		},
		p: function update(changed, ctx) {
			if (changed.placeholder) {
				attr_dev(input0, "placeholder", ctx.placeholder);
			}

			if (changed.model && input0_disabled_value !== (input0_disabled_value = !ctx.model.checked)) {
				prop_dev(input0, "disabled", input0_disabled_value);
			}

			if (!input0_updating && changed.model) {
				set_input_value(input0, ctx.model.value[0]);
			}

			input0_updating = false;

			if (changed.placeholder) {
				attr_dev(input1, "placeholder", ctx.placeholder);
			}

			if (changed.model && input1_disabled_value !== (input1_disabled_value = !ctx.model.checked)) {
				prop_dev(input1, "disabled", input1_disabled_value);
			}

			if (!input1_updating && changed.model) {
				set_input_value(input1, ctx.model.value[1]);
			}

			input1_updating = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input0);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(input1);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(33:4) {#if Array.isArray(model.value)}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div;
	let updating_checked;
	let t0;
	let span;
	let t1;
	let t2;
	let current;
	let dispose;

	function toggle_checked_binding(value) {
		ctx.toggle_checked_binding.call(null, value);
	}

	let toggle_props = {};

	if (ctx.model.checked !== void 0) {
		toggle_props.checked = ctx.model.checked;
	}

	const toggle = new Toggle({ props: toggle_props, $$inline: true });
	binding_callbacks.push(() => bind(toggle, "checked", toggle_checked_binding));
	let if_block = typeof ctx.model.value !== "undefined" && create_if_block(ctx);

	const block = {
		c: function create() {
			div = element("div");
			create_component(toggle.$$.fragment);
			t0 = space();
			span = element("span");
			t1 = text(ctx.text);
			t2 = space();
			if (if_block) if_block.c();
			attr_dev(span, "class", "svelte-cjbcpu");
			add_location(span, file$2, 29, 2, 522);
			attr_dev(div, "class", "rule svelte-cjbcpu");
			toggle_class(div, "checked", ctx.model.checked);
			toggle_class(div, "disabled", ctx.disabled);
			add_location(div, file$2, 21, 0, 377);
			dispose = listen_dev(div, "click", ctx.onClick, false, false, false);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(toggle, div, null);
			append_dev(div, t0);
			append_dev(div, span);
			append_dev(span, t1);
			append_dev(div, t2);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p: function update(changed, ctx) {
			const toggle_changes = {};

			if (!updating_checked && changed.model) {
				updating_checked = true;
				toggle_changes.checked = ctx.model.checked;
				add_flush_callback(() => updating_checked = false);
			}

			toggle.$set(toggle_changes);
			if (!current || changed.text) set_data_dev(t1, ctx.text);

			if (typeof ctx.model.value !== "undefined") {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (changed.model) {
				toggle_class(div, "checked", ctx.model.checked);
			}

			if (changed.disabled) {
				toggle_class(div, "disabled", ctx.disabled);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(toggle.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(toggle);
			if (if_block) if_block.d();
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { model } = $$props;
	let { disabled = false } = $$props;
	let { type = "text" } = $$props;
	let { text } = $$props;
	let { placeholder = false } = $$props;

	if (!placeholder) {
		$$invalidate("placeholder", placeholder = "");
	}

	const onClick = () => {
		if (!model.checked) {
			$$invalidate("model", model.checked = true, model);
		}
	};

	const writable_props = ["model", "disabled", "type", "text", "placeholder"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<New_field_rule> was created with unknown prop '${key}'`);
	});

	function toggle_checked_binding(value) {
		model.checked = value;
		$$invalidate("model", model);
	}

	function input0_input_handler() {
		model.value[0] = to_number(this.value);
		$$invalidate("model", model);
	}

	function input1_input_handler() {
		model.value[1] = to_number(this.value);
		$$invalidate("model", model);
	}

	function input_input_handler() {
		model.value = to_number(this.value);
		$$invalidate("model", model);
	}

	function input_input_handler_1() {
		model.value = this.value;
		$$invalidate("model", model);
	}

	$$self.$set = $$props => {
		if ("model" in $$props) $$invalidate("model", model = $$props.model);
		if ("disabled" in $$props) $$invalidate("disabled", disabled = $$props.disabled);
		if ("type" in $$props) $$invalidate("type", type = $$props.type);
		if ("text" in $$props) $$invalidate("text", text = $$props.text);
		if ("placeholder" in $$props) $$invalidate("placeholder", placeholder = $$props.placeholder);
	};

	$$self.$capture_state = () => {
		return { model, disabled, type, text, placeholder };
	};

	$$self.$inject_state = $$props => {
		if ("model" in $$props) $$invalidate("model", model = $$props.model);
		if ("disabled" in $$props) $$invalidate("disabled", disabled = $$props.disabled);
		if ("type" in $$props) $$invalidate("type", type = $$props.type);
		if ("text" in $$props) $$invalidate("text", text = $$props.text);
		if ("placeholder" in $$props) $$invalidate("placeholder", placeholder = $$props.placeholder);
	};

	return {
		model,
		disabled,
		type,
		text,
		placeholder,
		onClick,
		toggle_checked_binding,
		input0_input_handler,
		input1_input_handler,
		input_input_handler,
		input_input_handler_1
	};
}

class New_field_rule extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-cjbcpu-style")) add_css$2();

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			model: 0,
			disabled: 0,
			type: 0,
			text: 0,
			placeholder: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "New_field_rule",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (ctx.model === undefined && !("model" in props)) {
			console.warn("<New_field_rule> was created without expected prop 'model'");
		}

		if (ctx.text === undefined && !("text" in props)) {
			console.warn("<New_field_rule> was created without expected prop 'text'");
		}
	}

	get model() {
		throw new Error("<New_field_rule>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set model(value) {
		throw new Error("<New_field_rule>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<New_field_rule>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<New_field_rule>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<New_field_rule>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<New_field_rule>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<New_field_rule>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<New_field_rule>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<New_field_rule>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<New_field_rule>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/docs/builder/components/new-field.svelte generated by Svelte v3.15.0 */
const file$3 = "src/docs/builder/components/new-field.svelte";

function add_css$3() {
	var style = element("style");
	style.id = "svelte-i1wrzb-style";
	style.textContent = ".type.svelte-i1wrzb{display:flex;margin-bottom:10px;overflow:hidden}.type.svelte-i1wrzb:only-child{margin-bottom:0}.type.svelte-i1wrzb select.svelte-i1wrzb{border:1px solid #bbb;border-radius:3px;font-size:16px;height:40px;outline:0;padding:0 3px}.type.svelte-i1wrzb .button.svelte-i1wrzb{flex:1;margin-left:10px}.type.svelte-i1wrzb select.svelte-i1wrzb:disabled{background:#fff;color:inherit}.type select:disabled+.button.svelte-i1wrzb{margin-right:0;transition-delay:.5s}.rules.svelte-i1wrzb{display:flex;flex-wrap:wrap;width:calc(100% + 10px)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmV3LWZpZWxkLnN2ZWx0ZSIsInNvdXJjZXMiOlsibmV3LWZpZWxkLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxyXG4gIGltcG9ydCBCdXR0b24gZnJvbSAnZG9jcy91aS9idXR0b24uc3ZlbHRlJztcclxuICBpbXBvcnQgUnVsZSBmcm9tICcuL25ldy1maWVsZC1ydWxlLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IHsgc2xpZGUgfSBmcm9tICdzdmVsdGUvdHJhbnNpdGlvbic7XHJcbiAgaW1wb3J0IHsgcXVpbnRPdXQgfSBmcm9tICdzdmVsdGUvZWFzaW5nJztcclxuICBpbXBvcnQgeyBjcmVhdGVFdmVudERpc3BhdGNoZXIgfSBmcm9tICdzdmVsdGUnO1xyXG5cclxuICBsZXQgaW5pdGlhbFN0YXRlID0gdHJ1ZTtcclxuICBsZXQgc2VsZWN0ZWRUeXBlID0gJyc7XHJcbiAgbGV0IHNlbGVjdGVkUnVsZXMgPSB7XHJcbiAgICBtaW46IHsgY2hlY2tlZDogZmFsc2UsIHZhbHVlOiAnJyB9LFxyXG4gICAgbWF4OiB7IGNoZWNrZWQ6IGZhbHNlLCB2YWx1ZTogJycgfSxcclxuICAgIGJldHdlZW46IHsgY2hlY2tlZDogZmFsc2UsIHZhbHVlOiBbJycsICcnXSB9LFxyXG4gICAgaW5jbHVkZXM6IHsgY2hlY2tlZDogZmFsc2UsIHZhbHVlOiAnJyB9LFxyXG4gICAgZXF1YWw6IHsgY2hlY2tlZDogZmFsc2UsIHZhbHVlOiAnJyB9LFxyXG4gICAgbWF0Y2g6IHsgY2hlY2tlZDogZmFsc2UsIHZhbHVlOiAnJyB9LFxyXG4gICAgcmVxdWlyZWQ6IHsgY2hlY2tlZDogZmFsc2UgfSxcclxuICAgIG9wdGlvbmFsOiB7IGNoZWNrZWQ6IGZhbHNlIH0sXHJcbiAgfTtcclxuXHJcbiAgY29uc3Qgb25DaGFuZ2VUeXBlID0gKCkgPT4ge1xyXG4gICAgc2VsZWN0ZWRUeXBlID0gJyc7XHJcbiAgICBzZWxlY3RlZFJ1bGVzID0gT2JqZWN0LmtleXMoc2VsZWN0ZWRSdWxlcykucmVkdWNlKChyZXN1bHQsIHJ1bGVOYW1lKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJ1bGUgPSBzZWxlY3RlZFJ1bGVzW3J1bGVOYW1lXTtcclxuXHJcbiAgICAgIHJlc3VsdFtydWxlTmFtZV0gPSB7XHJcbiAgICAgICAgY2hlY2tlZDogZmFsc2VcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmICgndmFsdWUnIGluIHJ1bGUpIHtcclxuICAgICAgICByZXN1bHRbcnVsZU5hbWVdLnZhbHVlID0gQXJyYXkuaXNBcnJheShydWxlLnZhbHVlKSA/IFsnJywgJyddIDogJyc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LCB7fSk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaXNEZWZpbmVkID0gKHYpID0+IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IHYubGVuZ3RoIDogdHlwZW9mIHYgIT09ICd1bmRlZmluZWQnO1xyXG4gIGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XHJcbiAgY29uc3Qgb25TYXZlID0gKCkgPT4ge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmtleXMoc2VsZWN0ZWRSdWxlcykucmVkdWNlKChyZXN1bHQsIHJ1bGVOYW1lKSA9PiB7XHJcbiAgICAgIGNvbnN0IHJ1bGUgPSBzZWxlY3RlZFJ1bGVzW3J1bGVOYW1lXTtcclxuXHJcbiAgICAgIGlmICghcnVsZS5jaGVja2VkKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoJ3ZhbHVlJyBpbiBydWxlKSkge1xyXG4gICAgICAgIHJlc3VsdFtydWxlTmFtZV0gPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH0gZWxzZSBpZiAocnVsZU5hbWUgPT09ICdlcXVhbCcgJiYgc2VsZWN0ZWRUeXBlID09PSAnYXJyYXknKSB7XHJcbiAgICAgICAgcmVzdWx0W3J1bGVOYW1lXSA9IHJ1bGUudmFsdWUuc3BsaXQoJywnKS5tYXAoZXZhbCk7XHJcbiAgICAgIH0gZWxzZSBpZiAocnVsZU5hbWUgPT09ICdlcXVhbCcgJiYgc2VsZWN0ZWRUeXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJlc3VsdFtydWxlTmFtZV0gPSBwYXJzZUZsb2F0KHJ1bGUudmFsdWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocnVsZS52YWx1ZSkgPyAoaXNEZWZpbmVkKHJ1bGUudmFsdWVbMF0pICYmIGlzRGVmaW5lZChydWxlLnZhbHVlWzFdKSkgOiBpc0RlZmluZWQocnVsZS52YWx1ZSkpIHtcclxuICAgICAgICByZXN1bHRbcnVsZU5hbWVdID0gcnVsZS52YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sIHt9KTtcclxuXHJcbiAgICBpZiAoIU9iamVjdC5rZXlzKHJlc3VsdCkubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICByZXN1bHQudHlwZSA9IHNlbGVjdGVkVHlwZTtcclxuICAgIHJlc3VsdC52YWx1ZSA9IHNlbGVjdGVkVHlwZSA9PT0gJ2Jvb2xlYW4nID8gZmFsc2UgOiAoc2VsZWN0ZWRUeXBlID09PSAnYXJyYXknID8gW10gOiAnJyk7XHJcbiAgICBkaXNwYXRjaCgnbmV3RmllbGQnLCByZXN1bHQpO1xyXG4gICAgb25DYW5jZWwoKTtcclxuICB9O1xyXG5cclxuICBjb25zdCBvbkNhbmNlbCA9ICgpID0+IHtcclxuICAgIGluaXRpYWxTdGF0ZSA9IHRydWU7XHJcbiAgICBvbkNoYW5nZVR5cGUoKTtcclxuICB9O1xyXG48L3NjcmlwdD5cclxuXHJcbnsjaWYgaW5pdGlhbFN0YXRlfVxyXG4gIDxzbG90IC8+XHJcbiAgPEJ1dHRvbiBvbjpjbGljaz17KCkgPT4gKGluaXRpYWxTdGF0ZSA9IGZhbHNlKX0+YWRkIGZpZWxkPC9CdXR0b24+XHJcbns6ZWxzZX1cclxuICA8ZGl2IGNsYXNzPVwidHlwZVwiPlxyXG4gICAgPHNlbGVjdCBiaW5kOnZhbHVlPXtzZWxlY3RlZFR5cGV9IGRpc2FibGVkPXtzZWxlY3RlZFR5cGV9PlxyXG4gICAgICA8b3B0aW9uIHZhbHVlPXsnJ30gZGlzYWJsZWQ+Rmlyc3QsIHNlbGVjdCB0eXBlPC9vcHRpb24+XHJcbiAgICAgIDxvcHRpb24gdmFsdWU9XCJzdHJpbmdcIj5zdHJpbmc8L29wdGlvbj5cclxuICAgICAgPG9wdGlvbiB2YWx1ZT1cImVtYWlsXCI+ZW1haWw8L29wdGlvbj5cclxuICAgICAgPG9wdGlvbiB2YWx1ZT1cIm51bWJlclwiPm51bWJlcjwvb3B0aW9uPlxyXG4gICAgICA8b3B0aW9uIHZhbHVlPVwiYm9vbGVhblwiPmJvb2xlYW48L29wdGlvbj5cclxuICAgICAgPG9wdGlvbiB2YWx1ZT1cImFycmF5XCI+YXJyYXk8L29wdGlvbj5cclxuICAgIDwvc2VsZWN0PlxyXG4gICAgeyNpZiBzZWxlY3RlZFR5cGV9XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJidXR0b25cIj5cclxuICAgICAgICA8QnV0dG9uIG9uOmNsaWNrPXtvbkNoYW5nZVR5cGV9PmNoYW5nZTwvQnV0dG9uPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIHsvaWZ9XHJcbiAgPC9kaXY+XHJcblxyXG4gIHsjaWYgc2VsZWN0ZWRUeXBlfVxyXG4gICAgPGRpdiBjbGFzcz1cInJ1bGVzXCIgdHJhbnNpdGlvbjpzbGlkZXxsb2NhbD17e2R1cmF0aW9uOiA1MDAsIGVhc2luZzogcXVpbnRPdXR9fT5cclxuICAgICAgPFJ1bGVcclxuICAgICAgICB0eXBlPVwibnVtYmVyXCJcclxuICAgICAgICBiaW5kOm1vZGVsPXtzZWxlY3RlZFJ1bGVzLm1pbn1cclxuICAgICAgICBkaXNhYmxlZD17IVsnc3RyaW5nJywgJ251bWJlcicsICdhcnJheSddLmluY2x1ZGVzKHNlbGVjdGVkVHlwZSl9XHJcbiAgICAgICAgdGV4dD1cIm1pblwiXHJcbiAgICAgIC8+XHJcbiAgICAgIDxSdWxlXHJcbiAgICAgICAgdHlwZT1cIm51bWJlclwiXHJcbiAgICAgICAgYmluZDptb2RlbD17c2VsZWN0ZWRSdWxlcy5tYXh9XHJcbiAgICAgICAgZGlzYWJsZWQ9eyFbJ3N0cmluZycsICdudW1iZXInLCAnYXJyYXknXS5pbmNsdWRlcyhzZWxlY3RlZFR5cGUpfVxyXG4gICAgICAgIHRleHQ9XCJtYXhcIlxyXG4gICAgICAvPlxyXG4gICAgICA8UnVsZVxyXG4gICAgICAgIHR5cGU9XCJudW1iZXJcIlxyXG4gICAgICAgIGJpbmQ6bW9kZWw9e3NlbGVjdGVkUnVsZXMuYmV0d2Vlbn1cclxuICAgICAgICBkaXNhYmxlZD17IVsnc3RyaW5nJywgJ251bWJlciddLmluY2x1ZGVzKHNlbGVjdGVkVHlwZSl9XHJcbiAgICAgICAgdGV4dD1cImJldHdlZW5cIlxyXG4gICAgICAvPlxyXG4gICAgICA8UnVsZVxyXG4gICAgICAgIGJpbmQ6bW9kZWw9e3NlbGVjdGVkUnVsZXMuaW5jbHVkZXN9XHJcbiAgICAgICAgZGlzYWJsZWQ9e3NlbGVjdGVkVHlwZSAhPT0gJ2FycmF5J31cclxuICAgICAgICB0ZXh0PVwiaW5jbHVkZXNcIlxyXG4gICAgICAvPlxyXG4gICAgICA8UnVsZVxyXG4gICAgICAgIGJpbmQ6bW9kZWw9e3NlbGVjdGVkUnVsZXMuZXF1YWx9XHJcbiAgICAgICAgZGlzYWJsZWQ9e3NlbGVjdGVkVHlwZSA9PT0gJ2Jvb2xlYW4nfVxyXG4gICAgICAgIHRleHQ9XCJlcXVhbFwiXHJcbiAgICAgICAgcGxhY2Vob2xkZXI9e3NlbGVjdGVkVHlwZSA9PT0gJ2FycmF5JyAmJiAnMSwyLDMnfVxyXG4gICAgICAvPlxyXG4gICAgICA8UnVsZVxyXG4gICAgICAgIGJpbmQ6bW9kZWw9e3NlbGVjdGVkUnVsZXMubWF0Y2h9XHJcbiAgICAgICAgZGlzYWJsZWQ9e3NlbGVjdGVkVHlwZSA9PT0gJ2Jvb2xlYW4nfVxyXG4gICAgICAgIHRleHQ9XCJtYXRjaFwiXHJcbiAgICAgICAgcGxhY2Vob2xkZXI9XCJbQS1aYS16XXsxLDR9Li4uXCJcclxuICAgICAgLz5cclxuICAgICAgPFJ1bGVcclxuICAgICAgICBiaW5kOm1vZGVsPXtzZWxlY3RlZFJ1bGVzLnJlcXVpcmVkfVxyXG4gICAgICAgIGRpc2FibGVkPXtzZWxlY3RlZFJ1bGVzLm9wdGlvbmFsLmNoZWNrZWR9XHJcbiAgICAgICAgdGV4dD1cInJlcXVpcmVkXCJcclxuICAgICAgLz5cclxuICAgICAgPFJ1bGVcclxuICAgICAgICBiaW5kOm1vZGVsPXtzZWxlY3RlZFJ1bGVzLm9wdGlvbmFsfVxyXG4gICAgICAgIGRpc2FibGVkPXtzZWxlY3RlZFJ1bGVzLnJlcXVpcmVkLmNoZWNrZWR9XHJcbiAgICAgICAgdGV4dD1cIm9wdGlvbmFsXCJcclxuICAgICAgLz5cclxuICAgIDwvZGl2PlxyXG4gIHsvaWZ9XHJcblxyXG4gIHsjaWYgc2VsZWN0ZWRUeXBlfVxyXG4gICAgPEJ1dHRvbiBvbjpjbGljaz17b25TYXZlfT5DcmVhdGU8L0J1dHRvbj5cclxuICAgIDxCdXR0b24gb246Y2xpY2s9e29uQ2FuY2VsfT5DYW5jZWw8L0J1dHRvbj5cclxuICB7L2lmfVxyXG57L2lmfVxyXG5cclxuPHN0eWxlPlxyXG4gIC50eXBlIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xyXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICB9XHJcblxyXG4gIC50eXBlOm9ubHktY2hpbGQge1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMDtcclxuICB9XHJcblxyXG4gIC50eXBlIHNlbGVjdCB7XHJcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjYmJiO1xyXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xyXG4gICAgZm9udC1zaXplOiAxNnB4O1xyXG4gICAgaGVpZ2h0OiA0MHB4O1xyXG4gICAgb3V0bGluZTogMDtcclxuICAgIHBhZGRpbmc6IDAgM3B4O1xyXG4gIH1cclxuXHJcbiAgLnR5cGUgLmJ1dHRvbiB7XHJcbiAgICBmbGV4OiAxO1xyXG4gICAgbWFyZ2luLWxlZnQ6IDEwcHg7XHJcbiAgfVxyXG5cclxuICAudHlwZSBzZWxlY3Q6ZGlzYWJsZWQge1xyXG4gICAgYmFja2dyb3VuZDogI2ZmZjtcclxuICAgIGNvbG9yOiBpbmhlcml0O1xyXG4gIH1cclxuXHJcbiAgLnR5cGUgc2VsZWN0OmRpc2FibGVkICsgLmJ1dHRvbiB7XHJcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XHJcbiAgICB0cmFuc2l0aW9uLWRlbGF5OiAuNXM7XHJcbiAgfVxyXG5cclxuICAucnVsZXMge1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGZsZXgtd3JhcDogd3JhcDtcclxuICAgIHdpZHRoOiBjYWxjKDEwMCUgKyAxMHB4KTtcclxuICB9XHJcblxyXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5OeVl5OWtiMk56TDJKMWFXeGtaWEl2WTI5dGNHOXVaVzUwY3k5dVpYY3RabWxsYkdRdWMzWmxiSFJsSWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UlVGRFJUdEpRVU5GTEdGQlFXRTdTVUZEWWl4dFFrRkJiVUk3U1VGRGJrSXNaMEpCUVdkQ08wVkJRMnhDT3p0RlFVVkJPMGxCUTBVc1owSkJRV2RDTzBWQlEyeENPenRGUVVWQk8wbEJRMFVzYzBKQlFUWkNPMGxCUXpkQ0xHdENRVUZyUWp0SlFVTnNRaXhsUVVGbE8wbEJRMllzV1VGQldUdEpRVU5hTEZWQlFWVTdTVUZEVml4alFVRmpPMFZCUTJoQ096dEZRVVZCTzBsQlEwVXNUMEZCVHp0SlFVTlFMR2xDUVVGcFFqdEZRVU51UWpzN1JVRkZRVHRKUVVORkxHZENRVUZuUWp0SlFVTm9RaXhqUVVGak8wVkJRMmhDT3p0RlFVVkJPMGxCUTBVc1pVRkJaVHRKUVVObUxIRkNRVUZ4UWp0RlFVTjJRanM3UlVGRlFUdEpRVU5GTEdGQlFXRTdTVUZEWWl4bFFVRmxPMGxCUTJZc2QwSkJRWGRDTzBWQlF6RkNJaXdpWm1sc1pTSTZJbk55WXk5a2IyTnpMMkoxYVd4a1pYSXZZMjl0Y0c5dVpXNTBjeTl1WlhjdFptbGxiR1F1YzNabGJIUmxJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWEhKY2JpQWdMblI1Y0dVZ2UxeHlYRzRnSUNBZ1pHbHpjR3hoZVRvZ1pteGxlRHRjY2x4dUlDQWdJRzFoY21kcGJpMWliM1IwYjIwNklERXdjSGc3WEhKY2JpQWdJQ0J2ZG1WeVpteHZkem9nYUdsa1pHVnVPMXh5WEc0Z0lIMWNjbHh1WEhKY2JpQWdMblI1Y0dVNmIyNXNlUzFqYUdsc1pDQjdYSEpjYmlBZ0lDQnRZWEpuYVc0dFltOTBkRzl0T2lBd08xeHlYRzRnSUgxY2NseHVYSEpjYmlBZ0xuUjVjR1VnYzJWc1pXTjBJSHRjY2x4dUlDQWdJR0p2Y21SbGNqb2dNWEI0SUhOdmJHbGtJSFpoY2lndExXZHlaWGtwTzF4eVhHNGdJQ0FnWW05eVpHVnlMWEpoWkdsMWN6b2dNM0I0TzF4eVhHNGdJQ0FnWm05dWRDMXphWHBsT2lBeE5uQjRPMXh5WEc0Z0lDQWdhR1ZwWjJoME9pQTBNSEI0TzF4eVhHNGdJQ0FnYjNWMGJHbHVaVG9nTUR0Y2NseHVJQ0FnSUhCaFpHUnBibWM2SURBZ00zQjRPMXh5WEc0Z0lIMWNjbHh1WEhKY2JpQWdMblI1Y0dVZ0xtSjFkSFJ2YmlCN1hISmNiaUFnSUNCbWJHVjRPaUF4TzF4eVhHNGdJQ0FnYldGeVoybHVMV3hsWm5RNklERXdjSGc3WEhKY2JpQWdmVnh5WEc1Y2NseHVJQ0F1ZEhsd1pTQnpaV3hsWTNRNlpHbHpZV0pzWldRZ2UxeHlYRzRnSUNBZ1ltRmphMmR5YjNWdVpEb2dJMlptWmp0Y2NseHVJQ0FnSUdOdmJHOXlPaUJwYm1obGNtbDBPMXh5WEc0Z0lIMWNjbHh1WEhKY2JpQWdMblI1Y0dVZ2MyVnNaV04wT21ScGMyRmliR1ZrSUNzZ0xtSjFkSFJ2YmlCN1hISmNiaUFnSUNCdFlYSm5hVzR0Y21sbmFIUTZJREE3WEhKY2JpQWdJQ0IwY21GdWMybDBhVzl1TFdSbGJHRjVPaUF1TlhNN1hISmNiaUFnZlZ4eVhHNWNjbHh1SUNBdWNuVnNaWE1nZTF4eVhHNGdJQ0FnWkdsemNHeGhlVG9nWm14bGVEdGNjbHh1SUNBZ0lHWnNaWGd0ZDNKaGNEb2dkM0poY0R0Y2NseHVJQ0FnSUhkcFpIUm9PaUJqWVd4aktERXdNQ1VnS3lBeE1IQjRLVHRjY2x4dUlDQjlYSEpjYmlKZGZRPT0gKi88L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBMEpFLEtBQUssY0FBQyxDQUFDLEFBQ0wsT0FBTyxDQUFFLElBQUksQ0FDYixhQUFhLENBQUUsSUFBSSxDQUNuQixRQUFRLENBQUUsTUFBTSxBQUNsQixDQUFDLEFBRUQsbUJBQUssV0FBVyxBQUFDLENBQUMsQUFDaEIsYUFBYSxDQUFFLENBQUMsQUFDbEIsQ0FBQyxBQUVELG1CQUFLLENBQUMsTUFBTSxjQUFDLENBQUMsQUFDWixNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQ3RCLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsTUFBTSxDQUFFLElBQUksQ0FDWixPQUFPLENBQUUsQ0FBQyxDQUNWLE9BQU8sQ0FBRSxDQUFDLENBQUMsR0FBRyxBQUNoQixDQUFDLEFBRUQsbUJBQUssQ0FBQyxPQUFPLGNBQUMsQ0FBQyxBQUNiLElBQUksQ0FBRSxDQUFDLENBQ1AsV0FBVyxDQUFFLElBQUksQUFDbkIsQ0FBQyxBQUVELG1CQUFLLENBQUMsb0JBQU0sU0FBUyxBQUFDLENBQUMsQUFDckIsVUFBVSxDQUFFLElBQUksQ0FDaEIsS0FBSyxDQUFFLE9BQU8sQUFDaEIsQ0FBQyxBQUVELEtBQUssQ0FBQyxNQUFNLFNBQVMsQ0FBRyxPQUFPLGNBQUMsQ0FBQyxBQUMvQixZQUFZLENBQUUsQ0FBQyxDQUNmLGdCQUFnQixDQUFFLEdBQUcsQUFDdkIsQ0FBQyxBQUVELE1BQU0sY0FBQyxDQUFDLEFBQ04sT0FBTyxDQUFFLElBQUksQ0FDYixTQUFTLENBQUUsSUFBSSxDQUNmLEtBQUssQ0FBRSxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEFBQzFCLENBQUMifQ== */";
	append_dev(document.head, style);
}

// (81:0) {:else}
function create_else_block$1(ctx) {
	let div;
	let select;
	let option0;
	let option0_value_value;
	let option1;
	let option2;
	let option3;
	let option4;
	let option5;
	let t6;
	let t7;
	let t8;
	let if_block2_anchor;
	let current;
	let dispose;
	let if_block0 = ctx.selectedType && create_if_block_3(ctx);
	let if_block1 = ctx.selectedType && create_if_block_2$1(ctx);
	let if_block2 = ctx.selectedType && create_if_block_1$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			select = element("select");
			option0 = element("option");
			option0.textContent = "First, select type";
			option1 = element("option");
			option1.textContent = "string";
			option2 = element("option");
			option2.textContent = "email";
			option3 = element("option");
			option3.textContent = "number";
			option4 = element("option");
			option4.textContent = "boolean";
			option5 = element("option");
			option5.textContent = "array";
			t6 = space();
			if (if_block0) if_block0.c();
			t7 = space();
			if (if_block1) if_block1.c();
			t8 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
			option0.__value = option0_value_value = "";
			option0.value = option0.__value;
			option0.disabled = true;
			add_location(option0, file$3, 83, 6, 2535);
			option1.__value = "string";
			option1.value = option1.__value;
			add_location(option1, file$3, 84, 6, 2598);
			option2.__value = "email";
			option2.value = option2.__value;
			add_location(option2, file$3, 85, 6, 2644);
			option3.__value = "number";
			option3.value = option3.__value;
			add_location(option3, file$3, 86, 6, 2688);
			option4.__value = "boolean";
			option4.value = option4.__value;
			add_location(option4, file$3, 87, 6, 2734);
			option5.__value = "array";
			option5.value = option5.__value;
			add_location(option5, file$3, 88, 6, 2782);
			select.disabled = ctx.selectedType;
			attr_dev(select, "class", "svelte-i1wrzb");
			if (ctx.selectedType === void 0) add_render_callback(() => ctx.select_change_handler.call(select));
			add_location(select, file$3, 82, 4, 2469);
			attr_dev(div, "class", "type svelte-i1wrzb");
			add_location(div, file$3, 81, 2, 2445);
			dispose = listen_dev(select, "change", ctx.select_change_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, select);
			append_dev(select, option0);
			append_dev(select, option1);
			append_dev(select, option2);
			append_dev(select, option3);
			append_dev(select, option4);
			append_dev(select, option5);
			select_option(select, ctx.selectedType);
			append_dev(div, t6);
			if (if_block0) if_block0.m(div, null);
			insert_dev(target, t7, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t8, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, if_block2_anchor, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (!current || changed.selectedType) {
				prop_dev(select, "disabled", ctx.selectedType);
			}

			if (changed.selectedType) {
				select_option(select, ctx.selectedType);
			}

			if (ctx.selectedType) {
				if (if_block0) {
					if_block0.p(changed, ctx);
					transition_in(if_block0, 1);
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, null);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (ctx.selectedType) {
				if (if_block1) {
					if_block1.p(changed, ctx);
					transition_in(if_block1, 1);
				} else {
					if_block1 = create_if_block_2$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t8.parentNode, t8);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (ctx.selectedType) {
				if (if_block2) {
					if_block2.p(changed, ctx);
					transition_in(if_block2, 1);
				} else {
					if_block2 = create_if_block_1$1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (detaching) detach_dev(t7);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t8);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(81:0) {:else}",
		ctx
	});

	return block;
}

// (78:0) {#if initialState}
function create_if_block$1(ctx) {
	let t;
	let current;
	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	const button = new Button({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", ctx.click_handler);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
			t = space();
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			insert_dev(target, t, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_template, ctx, changed, null), get_slot_context(default_slot_template, ctx, null));
			}

			const button_changes = {};

			if (changed.$$scope) {
				button_changes.$$scope = { changed, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
			if (detaching) detach_dev(t);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(78:0) {#if initialState}",
		ctx
	});

	return block;
}

// (91:4) {#if selectedType}
function create_if_block_3(ctx) {
	let div;
	let current;

	const button = new Button({
			props: {
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", ctx.onChangeType);

	const block = {
		c: function create() {
			div = element("div");
			create_component(button.$$.fragment);
			attr_dev(div, "class", "button svelte-i1wrzb");
			add_location(div, file$3, 91, 6, 2865);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p: function update(changed, ctx) {
			const button_changes = {};

			if (changed.$$scope) {
				button_changes.$$scope = { changed, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(91:4) {#if selectedType}",
		ctx
	});

	return block;
}

// (93:8) <Button on:click={onChangeType}>
function create_default_slot_3(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("change");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(93:8) <Button on:click={onChangeType}>",
		ctx
	});

	return block;
}

// (98:2) {#if selectedType}
function create_if_block_2$1(ctx) {
	let div;
	let updating_model;
	let t0;
	let updating_model_1;
	let t1;
	let updating_model_2;
	let t2;
	let updating_model_3;
	let t3;
	let updating_model_4;
	let t4;
	let updating_model_5;
	let t5;
	let updating_model_6;
	let t6;
	let updating_model_7;
	let div_transition;
	let current;

	function rule0_model_binding(value) {
		ctx.rule0_model_binding.call(null, value);
	}

	let rule0_props = {
		type: "number",
		disabled: !["string", "number", "array"].includes(ctx.selectedType),
		text: "min"
	};

	if (ctx.selectedRules.min !== void 0) {
		rule0_props.model = ctx.selectedRules.min;
	}

	const rule0 = new New_field_rule({ props: rule0_props, $$inline: true });
	binding_callbacks.push(() => bind(rule0, "model", rule0_model_binding));

	function rule1_model_binding(value_1) {
		ctx.rule1_model_binding.call(null, value_1);
	}

	let rule1_props = {
		type: "number",
		disabled: !["string", "number", "array"].includes(ctx.selectedType),
		text: "max"
	};

	if (ctx.selectedRules.max !== void 0) {
		rule1_props.model = ctx.selectedRules.max;
	}

	const rule1 = new New_field_rule({ props: rule1_props, $$inline: true });
	binding_callbacks.push(() => bind(rule1, "model", rule1_model_binding));

	function rule2_model_binding(value_2) {
		ctx.rule2_model_binding.call(null, value_2);
	}

	let rule2_props = {
		type: "number",
		disabled: !["string", "number"].includes(ctx.selectedType),
		text: "between"
	};

	if (ctx.selectedRules.between !== void 0) {
		rule2_props.model = ctx.selectedRules.between;
	}

	const rule2 = new New_field_rule({ props: rule2_props, $$inline: true });
	binding_callbacks.push(() => bind(rule2, "model", rule2_model_binding));

	function rule3_model_binding(value_3) {
		ctx.rule3_model_binding.call(null, value_3);
	}

	let rule3_props = {
		disabled: ctx.selectedType !== "array",
		text: "includes"
	};

	if (ctx.selectedRules.includes !== void 0) {
		rule3_props.model = ctx.selectedRules.includes;
	}

	const rule3 = new New_field_rule({ props: rule3_props, $$inline: true });
	binding_callbacks.push(() => bind(rule3, "model", rule3_model_binding));

	function rule4_model_binding(value_4) {
		ctx.rule4_model_binding.call(null, value_4);
	}

	let rule4_props = {
		disabled: ctx.selectedType === "boolean",
		text: "equal",
		placeholder: ctx.selectedType === "array" && "1,2,3"
	};

	if (ctx.selectedRules.equal !== void 0) {
		rule4_props.model = ctx.selectedRules.equal;
	}

	const rule4 = new New_field_rule({ props: rule4_props, $$inline: true });
	binding_callbacks.push(() => bind(rule4, "model", rule4_model_binding));

	function rule5_model_binding(value_5) {
		ctx.rule5_model_binding.call(null, value_5);
	}

	let rule5_props = {
		disabled: ctx.selectedType === "boolean",
		text: "match",
		placeholder: "[A-Za-z]" + (4) + "..."
	};

	if (ctx.selectedRules.match !== void 0) {
		rule5_props.model = ctx.selectedRules.match;
	}

	const rule5 = new New_field_rule({ props: rule5_props, $$inline: true });
	binding_callbacks.push(() => bind(rule5, "model", rule5_model_binding));

	function rule6_model_binding(value_6) {
		ctx.rule6_model_binding.call(null, value_6);
	}

	let rule6_props = {
		disabled: ctx.selectedRules.optional.checked,
		text: "required"
	};

	if (ctx.selectedRules.required !== void 0) {
		rule6_props.model = ctx.selectedRules.required;
	}

	const rule6 = new New_field_rule({ props: rule6_props, $$inline: true });
	binding_callbacks.push(() => bind(rule6, "model", rule6_model_binding));

	function rule7_model_binding(value_7) {
		ctx.rule7_model_binding.call(null, value_7);
	}

	let rule7_props = {
		disabled: ctx.selectedRules.required.checked,
		text: "optional"
	};

	if (ctx.selectedRules.optional !== void 0) {
		rule7_props.model = ctx.selectedRules.optional;
	}

	const rule7 = new New_field_rule({ props: rule7_props, $$inline: true });
	binding_callbacks.push(() => bind(rule7, "model", rule7_model_binding));

	const block = {
		c: function create() {
			div = element("div");
			create_component(rule0.$$.fragment);
			t0 = space();
			create_component(rule1.$$.fragment);
			t1 = space();
			create_component(rule2.$$.fragment);
			t2 = space();
			create_component(rule3.$$.fragment);
			t3 = space();
			create_component(rule4.$$.fragment);
			t4 = space();
			create_component(rule5.$$.fragment);
			t5 = space();
			create_component(rule6.$$.fragment);
			t6 = space();
			create_component(rule7.$$.fragment);
			attr_dev(div, "class", "rules svelte-i1wrzb");
			add_location(div, file$3, 98, 4, 3007);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(rule0, div, null);
			append_dev(div, t0);
			mount_component(rule1, div, null);
			append_dev(div, t1);
			mount_component(rule2, div, null);
			append_dev(div, t2);
			mount_component(rule3, div, null);
			append_dev(div, t3);
			mount_component(rule4, div, null);
			append_dev(div, t4);
			mount_component(rule5, div, null);
			append_dev(div, t5);
			mount_component(rule6, div, null);
			append_dev(div, t6);
			mount_component(rule7, div, null);
			current = true;
		},
		p: function update(changed, ctx) {
			const rule0_changes = {};
			if (changed.selectedType) rule0_changes.disabled = !["string", "number", "array"].includes(ctx.selectedType);

			if (!updating_model && changed.selectedRules) {
				updating_model = true;
				rule0_changes.model = ctx.selectedRules.min;
				add_flush_callback(() => updating_model = false);
			}

			rule0.$set(rule0_changes);
			const rule1_changes = {};
			if (changed.selectedType) rule1_changes.disabled = !["string", "number", "array"].includes(ctx.selectedType);

			if (!updating_model_1 && changed.selectedRules) {
				updating_model_1 = true;
				rule1_changes.model = ctx.selectedRules.max;
				add_flush_callback(() => updating_model_1 = false);
			}

			rule1.$set(rule1_changes);
			const rule2_changes = {};
			if (changed.selectedType) rule2_changes.disabled = !["string", "number"].includes(ctx.selectedType);

			if (!updating_model_2 && changed.selectedRules) {
				updating_model_2 = true;
				rule2_changes.model = ctx.selectedRules.between;
				add_flush_callback(() => updating_model_2 = false);
			}

			rule2.$set(rule2_changes);
			const rule3_changes = {};
			if (changed.selectedType) rule3_changes.disabled = ctx.selectedType !== "array";

			if (!updating_model_3 && changed.selectedRules) {
				updating_model_3 = true;
				rule3_changes.model = ctx.selectedRules.includes;
				add_flush_callback(() => updating_model_3 = false);
			}

			rule3.$set(rule3_changes);
			const rule4_changes = {};
			if (changed.selectedType) rule4_changes.disabled = ctx.selectedType === "boolean";
			if (changed.selectedType) rule4_changes.placeholder = ctx.selectedType === "array" && "1,2,3";

			if (!updating_model_4 && changed.selectedRules) {
				updating_model_4 = true;
				rule4_changes.model = ctx.selectedRules.equal;
				add_flush_callback(() => updating_model_4 = false);
			}

			rule4.$set(rule4_changes);
			const rule5_changes = {};
			if (changed.selectedType) rule5_changes.disabled = ctx.selectedType === "boolean";

			if (!updating_model_5 && changed.selectedRules) {
				updating_model_5 = true;
				rule5_changes.model = ctx.selectedRules.match;
				add_flush_callback(() => updating_model_5 = false);
			}

			rule5.$set(rule5_changes);
			const rule6_changes = {};
			if (changed.selectedRules) rule6_changes.disabled = ctx.selectedRules.optional.checked;

			if (!updating_model_6 && changed.selectedRules) {
				updating_model_6 = true;
				rule6_changes.model = ctx.selectedRules.required;
				add_flush_callback(() => updating_model_6 = false);
			}

			rule6.$set(rule6_changes);
			const rule7_changes = {};
			if (changed.selectedRules) rule7_changes.disabled = ctx.selectedRules.required.checked;

			if (!updating_model_7 && changed.selectedRules) {
				updating_model_7 = true;
				rule7_changes.model = ctx.selectedRules.optional;
				add_flush_callback(() => updating_model_7 = false);
			}

			rule7.$set(rule7_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(rule0.$$.fragment, local);
			transition_in(rule1.$$.fragment, local);
			transition_in(rule2.$$.fragment, local);
			transition_in(rule3.$$.fragment, local);
			transition_in(rule4.$$.fragment, local);
			transition_in(rule5.$$.fragment, local);
			transition_in(rule6.$$.fragment, local);
			transition_in(rule7.$$.fragment, local);

			if (local) {
				add_render_callback(() => {
					if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 500, easing: quintOut }, true);
					div_transition.run(1);
				});
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(rule0.$$.fragment, local);
			transition_out(rule1.$$.fragment, local);
			transition_out(rule2.$$.fragment, local);
			transition_out(rule3.$$.fragment, local);
			transition_out(rule4.$$.fragment, local);
			transition_out(rule5.$$.fragment, local);
			transition_out(rule6.$$.fragment, local);
			transition_out(rule7.$$.fragment, local);

			if (local) {
				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 500, easing: quintOut }, false);
				div_transition.run(0);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(rule0);
			destroy_component(rule1);
			destroy_component(rule2);
			destroy_component(rule3);
			destroy_component(rule4);
			destroy_component(rule5);
			destroy_component(rule6);
			destroy_component(rule7);
			if (detaching && div_transition) div_transition.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(98:2) {#if selectedType}",
		ctx
	});

	return block;
}

// (148:2) {#if selectedType}
function create_if_block_1$1(ctx) {
	let t;
	let current;

	const button0 = new Button({
			props: {
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", ctx.onSave);

	const button1 = new Button({
			props: {
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", ctx.onCancel);

	const block = {
		c: function create() {
			create_component(button0.$$.fragment);
			t = space();
			create_component(button1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(button0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const button0_changes = {};

			if (changed.$$scope) {
				button0_changes.$$scope = { changed, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (changed.$$scope) {
				button1_changes.$$scope = { changed, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(button1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(148:2) {#if selectedType}",
		ctx
	});

	return block;
}

// (149:4) <Button on:click={onSave}>
function create_default_slot_2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Create");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(149:4) <Button on:click={onSave}>",
		ctx
	});

	return block;
}

// (150:4) <Button on:click={onCancel}>
function create_default_slot_1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Cancel");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(150:4) <Button on:click={onCancel}>",
		ctx
	});

	return block;
}

// (80:2) <Button on:click={() => (initialState = false)}>
function create_default_slot(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("add field");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(80:2) <Button on:click={() => (initialState = false)}>",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$1, create_else_block$1];
	const if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.initialState) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let initialState = true;
	let selectedType = "";

	let selectedRules = {
		min: { checked: false, value: "" },
		max: { checked: false, value: "" },
		between: { checked: false, value: ["", ""] },
		includes: { checked: false, value: "" },
		equal: { checked: false, value: "" },
		match: { checked: false, value: "" },
		required: { checked: false },
		optional: { checked: false }
	};

	const onChangeType = () => {
		$$invalidate("selectedType", selectedType = "");

		$$invalidate("selectedRules", selectedRules = Object.keys(selectedRules).reduce(
			(result, ruleName) => {
				const rule = selectedRules[ruleName];
				result[ruleName] = { checked: false };

				if ("value" in rule) {
					result[ruleName].value = Array.isArray(rule.value) ? ["", ""] : "";
				}

				return result;
			},
			{}
		));
	};

	const isDefined = v => typeof v === "string"
	? v.length
	: typeof v !== "undefined";

	const dispatch = createEventDispatcher();

	const onSave = () => {
		const result = Object.keys(selectedRules).reduce(
			(result, ruleName) => {
				const rule = selectedRules[ruleName];

				if (!rule.checked) {
					return result;
				}

				if (!("value" in rule)) {
					result[ruleName] = true;
					return result;
				} else if (ruleName === "equal" && selectedType === "array") {
					result[ruleName] = rule.value.split(",").map(eval);
				} else if (ruleName === "equal" && selectedType === "number") {
					result[ruleName] = parseFloat(rule.value);
				} else if (Array.isArray(rule.value)
				? isDefined(rule.value[0]) && isDefined(rule.value[1])
				: isDefined(rule.value)) {
					result[ruleName] = rule.value;
				}

				return result;
			},
			{}
		);

		if (!Object.keys(result).length) {
			return;
		}

		result.type = selectedType;

		result.value = selectedType === "boolean"
		? false
		: selectedType === "array" ? [] : "";

		dispatch("newField", result);
		onCancel();
	};

	const onCancel = () => {
		$$invalidate("initialState", initialState = true);
		onChangeType();
	};

	let { $$slots = {}, $$scope } = $$props;
	const click_handler = () => $$invalidate("initialState", initialState = false);

	function select_change_handler() {
		selectedType = select_value(this);
		$$invalidate("selectedType", selectedType);
	}

	function rule0_model_binding(value) {
		selectedRules.min = value;
		$$invalidate("selectedRules", selectedRules);
	}

	function rule1_model_binding(value_1) {
		selectedRules.max = value_1;
		$$invalidate("selectedRules", selectedRules);
	}

	function rule2_model_binding(value_2) {
		selectedRules.between = value_2;
		$$invalidate("selectedRules", selectedRules);
	}

	function rule3_model_binding(value_3) {
		selectedRules.includes = value_3;
		$$invalidate("selectedRules", selectedRules);
	}

	function rule4_model_binding(value_4) {
		selectedRules.equal = value_4;
		$$invalidate("selectedRules", selectedRules);
	}

	function rule5_model_binding(value_5) {
		selectedRules.match = value_5;
		$$invalidate("selectedRules", selectedRules);
	}

	function rule6_model_binding(value_6) {
		selectedRules.required = value_6;
		$$invalidate("selectedRules", selectedRules);
	}

	function rule7_model_binding(value_7) {
		selectedRules.optional = value_7;
		$$invalidate("selectedRules", selectedRules);
	}

	$$self.$set = $$props => {
		if ("$$scope" in $$props) $$invalidate("$$scope", $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("initialState" in $$props) $$invalidate("initialState", initialState = $$props.initialState);
		if ("selectedType" in $$props) $$invalidate("selectedType", selectedType = $$props.selectedType);
		if ("selectedRules" in $$props) $$invalidate("selectedRules", selectedRules = $$props.selectedRules);
	};

	return {
		initialState,
		selectedType,
		selectedRules,
		onChangeType,
		onSave,
		onCancel,
		click_handler,
		select_change_handler,
		rule0_model_binding,
		rule1_model_binding,
		rule2_model_binding,
		rule3_model_binding,
		rule4_model_binding,
		rule5_model_binding,
		rule6_model_binding,
		rule7_model_binding,
		$$slots,
		$$scope
	};
}

class New_field extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-i1wrzb-style")) add_css$3();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "New_field",
			options,
			id: create_fragment$3.name
		});
	}
}

/* src/docs/ui/widget.svelte generated by Svelte v3.15.0 */

const file$4 = "src/docs/ui/widget.svelte";

function add_css$4() {
	var style = element("style");
	style.id = "svelte-se31xl-style";
	style.textContent = "div.svelte-se31xl{border:5px solid #dcefff;box-shadow:0 0 3px #000;border-radius:3px;margin-bottom:20px;overflow:hidden;padding:10px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2lkZ2V0LnN2ZWx0ZSIsInNvdXJjZXMiOlsid2lkZ2V0LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8ZGl2PlxyXG4gIDxzbG90IC8+XHJcbjwvZGl2PlxyXG5cclxuPHN0eWxlPlxyXG4gIGRpdiB7XHJcbiAgICBib3JkZXI6IDVweCBzb2xpZCAjZGNlZmZmO1xyXG4gICAgYm94LXNoYWRvdzogMCAwIDNweCAjMDAwO1xyXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMjBweDtcclxuICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICBwYWRkaW5nOiAxMHB4O1xyXG4gIH1cclxuXHJcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbk55WXk5a2IyTnpMM1ZwTDNkcFpHZGxkQzV6ZG1Wc2RHVWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqdEZRVU5GTzBsQlEwVXNlVUpCUVhWRE8wbEJRM1pETEhkQ1FVRjNRanRKUVVONFFpeHJRa0ZCYTBJN1NVRkRiRUlzYlVKQlFXMUNPMGxCUTI1Q0xHZENRVUZuUWp0SlFVTm9RaXhoUVVGaE8wVkJRMllpTENKbWFXeGxJam9pYzNKakwyUnZZM012ZFdrdmQybGtaMlYwTG5OMlpXeDBaU0lzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWx4eVhHNGdJR1JwZGlCN1hISmNiaUFnSUNCaWIzSmtaWEk2SURWd2VDQnpiMnhwWkNCMllYSW9MUzF0WVdsdVEyOXNiM0pNYVdkb2RDazdYSEpjYmlBZ0lDQmliM2d0YzJoaFpHOTNPaUF3SURBZ00zQjRJQ013TURBN1hISmNiaUFnSUNCaWIzSmtaWEl0Y21Ga2FYVnpPaUF6Y0hnN1hISmNiaUFnSUNCdFlYSm5hVzR0WW05MGRHOXRPaUF5TUhCNE8xeHlYRzRnSUNBZ2IzWmxjbVpzYjNjNklHaHBaR1JsYmp0Y2NseHVJQ0FnSUhCaFpHUnBibWM2SURFd2NIZzdYSEpjYmlBZ2ZWeHlYRzRpWFgwPSAqLzwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFLRSxHQUFHLGNBQUMsQ0FBQyxBQUNILE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FDekIsVUFBVSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FDeEIsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsYUFBYSxDQUFFLElBQUksQ0FDbkIsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsT0FBTyxDQUFFLElBQUksQUFDZixDQUFDIn0= */";
	append_dev(document.head, style);
}

function create_fragment$4(ctx) {
	let div;
	let current;
	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", "svelte-se31xl");
			add_location(div, file$4, 0, 0, 0);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_template, ctx, changed, null), get_slot_context(default_slot_template, ctx, null));
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ("$$scope" in $$props) $$invalidate("$$scope", $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		
	};

	return { $$slots, $$scope };
}

class Widget extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-se31xl-style")) add_css$4();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Widget",
			options,
			id: create_fragment$4.name
		});
	}
}

/* src/docs/ui/code.svelte generated by Svelte v3.15.0 */

const file$5 = "src/docs/ui/code.svelte";

function add_css$5() {
	var style = element("style");
	style.id = "svelte-e9n8z1-style";
	style.textContent = "pre.svelte-e9n8z1{background:#dcefff;border:1px solid #bbb;border-radius:3px;box-shadow:0 0 5px #bbb;cursor:text;font-weight:normal;font-family:monospace;margin-bottom:10px;overflow-x:auto;padding:5px 10px}.builderMode.svelte-e9n8z1{border:0;border-radius:0;box-shadow:none;margin-bottom:0;min-height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29kZS5zdmVsdGUiLCJzb3VyY2VzIjpbImNvZGUuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XHJcbiAgZXhwb3J0IGxldCBjb2RlID0gJyc7XHJcbiAgZXhwb3J0IGxldCBidWlsZGVyTW9kZSA9IGZhbHNlO1xyXG5cclxuICBjb25zdCBhZGRDb2RlID0gKG5vZGUpID0+IHtcclxuICAgIG5vZGUudGV4dENvbnRlbnQgPSBjb2RlO1xyXG4gIH07XHJcbjwvc2NyaXB0PlxyXG5cclxuPHByZSBjbGFzczpidWlsZGVyTW9kZT48Y29kZSB1c2U6YWRkQ29kZT48L2NvZGU+PC9wcmU+XHJcblxyXG48c3R5bGU+XHJcbiAgcHJlIHtcclxuICAgIGJhY2tncm91bmQ6ICNkY2VmZmY7XHJcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjYmJiO1xyXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xyXG4gICAgYm94LXNoYWRvdzogMCAwIDVweCAjYmJiO1xyXG4gICAgY3Vyc29yOiB0ZXh0O1xyXG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcclxuICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XHJcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xyXG4gICAgb3ZlcmZsb3cteDogYXV0bztcclxuICAgIHBhZGRpbmc6IDVweCAxMHB4O1xyXG4gIH1cclxuXHJcbiAgLmJ1aWxkZXJNb2RlIHtcclxuICAgIGJvcmRlcjogMDtcclxuICAgIGJvcmRlci1yYWRpdXM6IDA7XHJcbiAgICBib3gtc2hhZG93OiBub25lO1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMDtcclxuICAgIG1pbi1oZWlnaHQ6IDEwMCU7XHJcbiAgfVxyXG5cclxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluTnlZeTlrYjJOekwzVnBMMk52WkdVdWMzWmxiSFJsSWwwc0ltNWhiV1Z6SWpwYlhTd2liV0Z3Y0dsdVozTWlPaUk3UlVGRFJUdEpRVU5GTEcxQ1FVRnBRenRKUVVOcVF5eHpRa0ZCTmtJN1NVRkROMElzYTBKQlFXdENPMGxCUTJ4Q0xIZENRVUVyUWp0SlFVTXZRaXhaUVVGWk8wbEJRMW9zYlVKQlFXMUNPMGxCUTI1Q0xITkNRVUZ6UWp0SlFVTjBRaXh0UWtGQmJVSTdTVUZEYmtJc1owSkJRV2RDTzBsQlEyaENMR2xDUVVGcFFqdEZRVU51UWpzN1JVRkZRVHRKUVVORkxGTkJRVk03U1VGRFZDeG5Ra0ZCWjBJN1NVRkRhRUlzWjBKQlFXZENPMGxCUTJoQ0xHZENRVUZuUWp0SlFVTm9RaXhuUWtGQlowSTdSVUZEYkVJaUxDSm1hV3hsSWpvaWMzSmpMMlJ2WTNNdmRXa3ZZMjlrWlM1emRtVnNkR1VpTENKemIzVnlZMlZ6UTI5dWRHVnVkQ0k2V3lKY2NseHVJQ0J3Y21VZ2UxeHlYRzRnSUNBZ1ltRmphMmR5YjNWdVpEb2dkbUZ5S0MwdGJXRnBia052Ykc5eVRHbG5hSFFwTzF4eVhHNGdJQ0FnWW05eVpHVnlPaUF4Y0hnZ2MyOXNhV1FnZG1GeUtDMHRaM0psZVNrN1hISmNiaUFnSUNCaWIzSmtaWEl0Y21Ga2FYVnpPaUF6Y0hnN1hISmNiaUFnSUNCaWIzZ3RjMmhoWkc5M09pQXdJREFnTlhCNElIWmhjaWd0TFdkeVpYa3BPMXh5WEc0Z0lDQWdZM1Z5YzI5eU9pQjBaWGgwTzF4eVhHNGdJQ0FnWm05dWRDMTNaV2xuYUhRNklHNXZjbTFoYkR0Y2NseHVJQ0FnSUdadmJuUXRabUZ0YVd4NU9pQnRiMjV2YzNCaFkyVTdYSEpjYmlBZ0lDQnRZWEpuYVc0dFltOTBkRzl0T2lBeE1IQjRPMXh5WEc0Z0lDQWdiM1psY21ac2IzY3RlRG9nWVhWMGJ6dGNjbHh1SUNBZ0lIQmhaR1JwYm1jNklEVndlQ0F4TUhCNE8xeHlYRzRnSUgxY2NseHVYSEpjYmlBZ0xtSjFhV3hrWlhKTmIyUmxJSHRjY2x4dUlDQWdJR0p2Y21SbGNqb2dNRHRjY2x4dUlDQWdJR0p2Y21SbGNpMXlZV1JwZFhNNklEQTdYSEpjYmlBZ0lDQmliM2d0YzJoaFpHOTNPaUJ1YjI1bE8xeHlYRzRnSUNBZ2JXRnlaMmx1TFdKdmRIUnZiVG9nTUR0Y2NseHVJQ0FnSUcxcGJpMW9aV2xuYUhRNklERXdNQ1U3WEhKY2JpQWdmVnh5WEc0aVhYMD0gKi88L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBWUUsR0FBRyxjQUFDLENBQUMsQUFDSCxVQUFVLENBQUUsT0FBTyxDQUNuQixNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQ3RCLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLFVBQVUsQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQ3hCLE1BQU0sQ0FBRSxJQUFJLENBQ1osV0FBVyxDQUFFLE1BQU0sQ0FDbkIsV0FBVyxDQUFFLFNBQVMsQ0FDdEIsYUFBYSxDQUFFLElBQUksQ0FDbkIsVUFBVSxDQUFFLElBQUksQ0FDaEIsT0FBTyxDQUFFLEdBQUcsQ0FBQyxJQUFJLEFBQ25CLENBQUMsQUFFRCxZQUFZLGNBQUMsQ0FBQyxBQUNaLE1BQU0sQ0FBRSxDQUFDLENBQ1QsYUFBYSxDQUFFLENBQUMsQ0FDaEIsVUFBVSxDQUFFLElBQUksQ0FDaEIsYUFBYSxDQUFFLENBQUMsQ0FDaEIsVUFBVSxDQUFFLElBQUksQUFDbEIsQ0FBQyJ9 */";
	append_dev(document.head, style);
}

function create_fragment$5(ctx) {
	let pre;
	let code_1;
	let addCode_action;

	const block = {
		c: function create() {
			pre = element("pre");
			code_1 = element("code");
			add_location(code_1, file$5, 9, 23, 175);
			attr_dev(pre, "class", "svelte-e9n8z1");
			toggle_class(pre, "builderMode", ctx.builderMode);
			add_location(pre, file$5, 9, 0, 152);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, pre, anchor);
			append_dev(pre, code_1);
			addCode_action = ctx.addCode.call(null, code_1) || ({});
		},
		p: function update(changed, ctx) {
			if (changed.builderMode) {
				toggle_class(pre, "builderMode", ctx.builderMode);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(pre);
			if (addCode_action && is_function(addCode_action.destroy)) addCode_action.destroy();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { code = "" } = $$props;
	let { builderMode = false } = $$props;

	const addCode = node => {
		node.textContent = code;
	};

	const writable_props = ["code", "builderMode"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Code> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("code" in $$props) $$invalidate("code", code = $$props.code);
		if ("builderMode" in $$props) $$invalidate("builderMode", builderMode = $$props.builderMode);
	};

	$$self.$capture_state = () => {
		return { code, builderMode };
	};

	$$self.$inject_state = $$props => {
		if ("code" in $$props) $$invalidate("code", code = $$props.code);
		if ("builderMode" in $$props) $$invalidate("builderMode", builderMode = $$props.builderMode);
	};

	return { code, builderMode, addCode };
}

class Code extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-e9n8z1-style")) add_css$5();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { code: 0, builderMode: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Code",
			options,
			id: create_fragment$5.name
		});
	}

	get code() {
		throw new Error("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set code(value) {
		throw new Error("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get builderMode() {
		throw new Error("<Code>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set builderMode(value) {
		throw new Error("<Code>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/docs/ui/error.svelte generated by Svelte v3.15.0 */

const { Error: Error_1 } = globals;
const file$6 = "src/docs/ui/error.svelte";

function add_css$6() {
	var style = element("style");
	style.id = "svelte-1deodsm-style";
	style.textContent = "input[type=\"checkbox\"]~.error.svelte-1deodsm{margin-top:0}.error.svelte-1deodsm{background:#ec512a;border-radius:3px;color:#fff;cursor:pointer;margin-top:10px;margin-bottom:10px;overflow:hidden;padding:5px 50px 5px 5px;position:relative;transition:.5s color .3s ease-in-out}.error.svelte-1deodsm:hover{color:#f37f64}span.svelte-1deodsm{display:inline-block;position:relative;vertical-align:top}span.svelte-1deodsm::after{box-sizing:border-box;color:#fff;content:'remove';font-weight:bold;height:100%;font-size:1em;left:100%;opacity:0;padding:0 10px;position:absolute;text-align:center;transform:translateX(200%);transition-delay:.3s;transition-duration:.3s;transition-timing-function:ease-in-out;transition-property:opacity, transform;text-transform:uppercase;top:0}.error.svelte-1deodsm:hover span.svelte-1deodsm::after{opacity:1;transform:translateX(0)}.error.svelte-1deodsm:hover,.error.svelte-1deodsm:hover span.svelte-1deodsm::after{transition-delay:.3s}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3Iuc3ZlbHRlIiwic291cmNlcyI6WyJlcnJvci5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cclxuICBleHBvcnQgbGV0IGVycm9ycztcclxuICBleHBvcnQgbGV0IGVycm9yQ29kZTtcclxuICBleHBvcnQgbGV0IGVycm9yVGV4dCA9ICcnO1xyXG4gIGV4cG9ydCBsZXQgZnJvbUxvb3AgPSBmYWxzZTtcclxuXHJcbiAgaW1wb3J0IHsgc2xpZGUgfSBmcm9tICdzdmVsdGUvdHJhbnNpdGlvbic7XHJcblxyXG4gIGNvbnN0IHJlbW92ZUVycm9yID0gKCkgPT4ge1xyXG4gICAgZXJyb3JzLnVwZGF0ZSh2ID0+IHtcclxuICAgICAgcmV0dXJuIHYuZmlsdGVyKGUgPT4gKGUgIT09IGVycm9yQ29kZSkpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG48L3NjcmlwdD5cclxuXHJcbnsjaWYgJGVycm9ycy5pbmNsdWRlcyhlcnJvckNvZGUpfVxyXG4gIDxkaXYgY2xhc3M9XCJlcnJvclwiIHRyYW5zaXRpb246c2xpZGV8bG9jYWw9e3sgZGVsYXk6IDAsIGR1cmF0aW9uOiA0MDAgfX0gb246Y2xpY2s9e3JlbW92ZUVycm9yfT5cclxuICAgIDxzcGFuPlxyXG4gICAgICB7I2lmIGVycm9yQ29kZSA9PT0gJ3JlcXVpcmVkJyAmJiAhZXJyb3JUZXh0ICYmICFmcm9tTG9vcH1cclxuICAgICAgICBUaGlzIGZpZWxkIGlzIHJlcXVpcmVkXHJcbiAgICAgIHs6ZWxzZSBpZiBlcnJvclRleHR9XHJcbiAgICAgICAge2Vycm9yVGV4dH1cclxuICAgICAgezplbHNlfVxyXG4gICAgICAgIHtlcnJvckNvZGV9IHJ1bGUgdmFsaWRhdGlvbiBlcnJvclxyXG4gICAgICB7L2lmfVxyXG4gICAgPC9zcGFuPlxyXG4gIDwvZGl2PlxyXG57L2lmfVxyXG5cclxuPHN0eWxlPlxyXG4gIDpnbG9iYWwoaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdKSB+IC5lcnJvciB7XHJcbiAgICBtYXJnaW4tdG9wOiAwO1xyXG4gIH1cclxuXHJcbiAgLmVycm9yIHtcclxuICAgIGJhY2tncm91bmQ6ICNlYzUxMmE7XHJcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XHJcbiAgICBjb2xvcjogI2ZmZjtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIG1hcmdpbi10b3A6IDEwcHg7XHJcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xyXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICAgIHBhZGRpbmc6IDVweCA1MHB4IDVweCA1cHg7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICB0cmFuc2l0aW9uOiAuNXMgY29sb3IgLjNzIGVhc2UtaW4tb3V0O1xyXG4gIH1cclxuXHJcbiAgLmVycm9yOmhvdmVyIHtcclxuICAgIGNvbG9yOiAjZjM3ZjY0O1xyXG4gIH1cclxuXHJcbiAgc3BhbiB7XHJcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbiAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wO1xyXG4gIH1cclxuXHJcbiAgc3Bhbjo6YWZ0ZXIge1xyXG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcclxuICAgIGNvbG9yOiAjZmZmO1xyXG4gICAgY29udGVudDogJ3JlbW92ZSc7XHJcbiAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgIGhlaWdodDogMTAwJTtcclxuICAgIGZvbnQtc2l6ZTogMWVtO1xyXG4gICAgbGVmdDogMTAwJTtcclxuICAgIG9wYWNpdHk6IDA7XHJcbiAgICBwYWRkaW5nOiAwIDEwcHg7XHJcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMjAwJSk7XHJcbiAgICB0cmFuc2l0aW9uLWRlbGF5OiAuM3M7XHJcbiAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAuM3M7XHJcbiAgICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogZWFzZS1pbi1vdXQ7XHJcbiAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiBvcGFjaXR5LCB0cmFuc2Zvcm07XHJcbiAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xyXG4gICAgdG9wOiAwO1xyXG4gIH1cclxuXHJcbiAgLmVycm9yOmhvdmVyIHNwYW46OmFmdGVyIHtcclxuICAgIG9wYWNpdHk6IDE7XHJcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoMCk7XHJcbiAgfVxyXG5cclxuICAuZXJyb3I6aG92ZXIsXHJcbiAgLmVycm9yOmhvdmVyIHNwYW46OmFmdGVye1xyXG4gICAgdHJhbnNpdGlvbi1kZWxheTogLjNzO1xyXG4gIH1cclxuXHJcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbk55WXk5a2IyTnpMM1ZwTDJWeWNtOXlMbk4yWld4MFpTSmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wVkJRMFU3U1VGRFJTeGhRVUZoTzBWQlEyWTdPMFZCUlVFN1NVRkRSU3h0UWtGQk1rSTdTVUZETTBJc2EwSkJRV3RDTzBsQlEyeENMRmRCUVZjN1NVRkRXQ3hsUVVGbE8wbEJRMllzWjBKQlFXZENPMGxCUTJoQ0xHMUNRVUZ0UWp0SlFVTnVRaXhuUWtGQlowSTdTVUZEYUVJc2VVSkJRWGxDTzBsQlEzcENMR3RDUVVGclFqdEpRVU5zUWl4eFEwRkJjVU03UlVGRGRrTTdPMFZCUlVFN1NVRkRSU3hqUVVGak8wVkJRMmhDT3p0RlFVVkJPMGxCUTBVc2NVSkJRWEZDTzBsQlEzSkNMR3RDUVVGclFqdEpRVU5zUWl4dFFrRkJiVUk3UlVGRGNrSTdPMFZCUlVFN1NVRkRSU3h6UWtGQmMwSTdTVUZEZEVJc1YwRkJWenRKUVVOWUxHbENRVUZwUWp0SlFVTnFRaXhwUWtGQmFVSTdTVUZEYWtJc1dVRkJXVHRKUVVOYUxHTkJRV003U1VGRFpDeFZRVUZWTzBsQlExWXNWVUZCVlR0SlFVTldMR1ZCUVdVN1NVRkRaaXhyUWtGQmEwSTdTVUZEYkVJc2EwSkJRV3RDTzBsQlEyeENMREpDUVVFeVFqdEpRVU16UWl4eFFrRkJjVUk3U1VGRGNrSXNkMEpCUVhkQ08wbEJRM2hDTEhWRFFVRjFRenRKUVVOMlF5eDFRMEZCZFVNN1NVRkRka01zZVVKQlFYbENPMGxCUTNwQ0xFMUJRVTA3UlVGRFVqczdSVUZGUVR0SlFVTkZMRlZCUVZVN1NVRkRWaXgzUWtGQmQwSTdSVUZETVVJN08wVkJSVUU3TzBsQlJVVXNjVUpCUVhGQ08wVkJRM1pDSWl3aVptbHNaU0k2SW5OeVl5OWtiMk56TDNWcEwyVnljbTl5TG5OMlpXeDBaU0lzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWx4eVhHNGdJRHBuYkc5aVlXd29hVzV3ZFhSYmRIbHdaVDFjSW1Ob1pXTnJZbTk0WENKZEtTQitJQzVsY25KdmNpQjdYSEpjYmlBZ0lDQnRZWEpuYVc0dGRHOXdPaUF3TzF4eVhHNGdJSDFjY2x4dVhISmNiaUFnTG1WeWNtOXlJSHRjY2x4dUlDQWdJR0poWTJ0bmNtOTFibVE2SUhaaGNpZ3RMWEpsWkVOdmJHOXlLVHRjY2x4dUlDQWdJR0p2Y21SbGNpMXlZV1JwZFhNNklETndlRHRjY2x4dUlDQWdJR052Ykc5eU9pQWpabVptTzF4eVhHNGdJQ0FnWTNWeWMyOXlPaUJ3YjJsdWRHVnlPMXh5WEc0Z0lDQWdiV0Z5WjJsdUxYUnZjRG9nTVRCd2VEdGNjbHh1SUNBZ0lHMWhjbWRwYmkxaWIzUjBiMjA2SURFd2NIZzdYSEpjYmlBZ0lDQnZkbVZ5Wm14dmR6b2dhR2xrWkdWdU8xeHlYRzRnSUNBZ2NHRmtaR2x1WnpvZ05YQjRJRFV3Y0hnZ05YQjRJRFZ3ZUR0Y2NseHVJQ0FnSUhCdmMybDBhVzl1T2lCeVpXeGhkR2wyWlR0Y2NseHVJQ0FnSUhSeVlXNXphWFJwYjI0NklDNDFjeUJqYjJ4dmNpQXVNM01nWldGelpTMXBiaTF2ZFhRN1hISmNiaUFnZlZ4eVhHNWNjbHh1SUNBdVpYSnliM0k2YUc5MlpYSWdlMXh5WEc0Z0lDQWdZMjlzYjNJNklDTm1NemRtTmpRN1hISmNiaUFnZlZ4eVhHNWNjbHh1SUNCemNHRnVJSHRjY2x4dUlDQWdJR1JwYzNCc1lYazZJR2x1YkdsdVpTMWliRzlqYXp0Y2NseHVJQ0FnSUhCdmMybDBhVzl1T2lCeVpXeGhkR2wyWlR0Y2NseHVJQ0FnSUhabGNuUnBZMkZzTFdGc2FXZHVPaUIwYjNBN1hISmNiaUFnZlZ4eVhHNWNjbHh1SUNCemNHRnVPanBoWm5SbGNpQjdYSEpjYmlBZ0lDQmliM2d0YzJsNmFXNW5PaUJpYjNKa1pYSXRZbTk0TzF4eVhHNGdJQ0FnWTI5c2IzSTZJQ05tWm1ZN1hISmNiaUFnSUNCamIyNTBaVzUwT2lBbmNtVnRiM1psSnp0Y2NseHVJQ0FnSUdadmJuUXRkMlZwWjJoME9pQmliMnhrTzF4eVhHNGdJQ0FnYUdWcFoyaDBPaUF4TURBbE8xeHlYRzRnSUNBZ1ptOXVkQzF6YVhwbE9pQXhaVzA3WEhKY2JpQWdJQ0JzWldaME9pQXhNREFsTzF4eVhHNGdJQ0FnYjNCaFkybDBlVG9nTUR0Y2NseHVJQ0FnSUhCaFpHUnBibWM2SURBZ01UQndlRHRjY2x4dUlDQWdJSEJ2YzJsMGFXOXVPaUJoWW5OdmJIVjBaVHRjY2x4dUlDQWdJSFJsZUhRdFlXeHBaMjQ2SUdObGJuUmxjanRjY2x4dUlDQWdJSFJ5WVc1elptOXliVG9nZEhKaGJuTnNZWFJsV0NneU1EQWxLVHRjY2x4dUlDQWdJSFJ5WVc1emFYUnBiMjR0WkdWc1lYazZJQzR6Y3p0Y2NseHVJQ0FnSUhSeVlXNXphWFJwYjI0dFpIVnlZWFJwYjI0NklDNHpjenRjY2x4dUlDQWdJSFJ5WVc1emFYUnBiMjR0ZEdsdGFXNW5MV1oxYm1OMGFXOXVPaUJsWVhObExXbHVMVzkxZER0Y2NseHVJQ0FnSUhSeVlXNXphWFJwYjI0dGNISnZjR1Z5ZEhrNklHOXdZV05wZEhrc0lIUnlZVzV6Wm05eWJUdGNjbHh1SUNBZ0lIUmxlSFF0ZEhKaGJuTm1iM0p0T2lCMWNIQmxjbU5oYzJVN1hISmNiaUFnSUNCMGIzQTZJREE3WEhKY2JpQWdmVnh5WEc1Y2NseHVJQ0F1WlhKeWIzSTZhRzkyWlhJZ2MzQmhiam82WVdaMFpYSWdlMXh5WEc0Z0lDQWdiM0JoWTJsMGVUb2dNVHRjY2x4dUlDQWdJSFJ5WVc1elptOXliVG9nZEhKaGJuTnNZWFJsV0Nnd0tUdGNjbHh1SUNCOVhISmNibHh5WEc0Z0lDNWxjbkp2Y2pwb2IzWmxjaXhjY2x4dUlDQXVaWEp5YjNJNmFHOTJaWElnYzNCaGJqbzZZV1owWlhKN1hISmNiaUFnSUNCMGNtRnVjMmwwYVc5dUxXUmxiR0Y1T2lBdU0zTTdYSEpjYmlBZ2ZWeHlYRzRpWFgwPSAqLzwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE4QlUsc0JBQXNCLEFBQUMsQ0FBRyxNQUFNLGVBQUMsQ0FBQyxBQUN4QyxVQUFVLENBQUUsQ0FBQyxBQUNmLENBQUMsQUFFRCxNQUFNLGVBQUMsQ0FBQyxBQUNOLFVBQVUsQ0FBRSxPQUFPLENBQ25CLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLE9BQU8sQ0FDZixVQUFVLENBQUUsSUFBSSxDQUNoQixhQUFhLENBQUUsSUFBSSxDQUNuQixRQUFRLENBQUUsTUFBTSxDQUNoQixPQUFPLENBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUN6QixRQUFRLENBQUUsUUFBUSxDQUNsQixVQUFVLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsV0FBVyxBQUN2QyxDQUFDLEFBRUQscUJBQU0sTUFBTSxBQUFDLENBQUMsQUFDWixLQUFLLENBQUUsT0FBTyxBQUNoQixDQUFDLEFBRUQsSUFBSSxlQUFDLENBQUMsQUFDSixPQUFPLENBQUUsWUFBWSxDQUNyQixRQUFRLENBQUUsUUFBUSxDQUNsQixjQUFjLENBQUUsR0FBRyxBQUNyQixDQUFDLEFBRUQsbUJBQUksT0FBTyxBQUFDLENBQUMsQUFDWCxVQUFVLENBQUUsVUFBVSxDQUN0QixLQUFLLENBQUUsSUFBSSxDQUNYLE9BQU8sQ0FBRSxRQUFRLENBQ2pCLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLE1BQU0sQ0FBRSxJQUFJLENBQ1osU0FBUyxDQUFFLEdBQUcsQ0FDZCxJQUFJLENBQUUsSUFBSSxDQUNWLE9BQU8sQ0FBRSxDQUFDLENBQ1YsT0FBTyxDQUFFLENBQUMsQ0FBQyxJQUFJLENBQ2YsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsU0FBUyxDQUFFLFdBQVcsSUFBSSxDQUFDLENBQzNCLGdCQUFnQixDQUFFLEdBQUcsQ0FDckIsbUJBQW1CLENBQUUsR0FBRyxDQUN4QiwwQkFBMEIsQ0FBRSxXQUFXLENBQ3ZDLG1CQUFtQixDQUFFLE9BQU8sQ0FBQyxDQUFDLFNBQVMsQ0FDdkMsY0FBYyxDQUFFLFNBQVMsQ0FDekIsR0FBRyxDQUFFLENBQUMsQUFDUixDQUFDLEFBRUQscUJBQU0sTUFBTSxDQUFDLG1CQUFJLE9BQU8sQUFBQyxDQUFDLEFBQ3hCLE9BQU8sQ0FBRSxDQUFDLENBQ1YsU0FBUyxDQUFFLFdBQVcsQ0FBQyxDQUFDLEFBQzFCLENBQUMsQUFFRCxxQkFBTSxNQUFNLENBQ1oscUJBQU0sTUFBTSxDQUFDLG1CQUFJLE9BQU8sQ0FBQyxBQUN2QixnQkFBZ0IsQ0FBRSxHQUFHLEFBQ3ZCLENBQUMifQ== */";
	append_dev(document.head, style);
}

// (16:0) {#if $errors.includes(errorCode)}
function create_if_block$2(ctx) {
	let div;
	let span;
	let div_transition;
	let current;
	let dispose;

	function select_block_type(changed, ctx) {
		if (ctx.errorCode === "required" && !ctx.errorText && !ctx.fromLoop) return create_if_block_1$2;
		if (ctx.errorText) return create_if_block_2$2;
		return create_else_block$2;
	}

	let current_block_type = select_block_type(null, ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			if_block.c();
			attr_dev(span, "class", "svelte-1deodsm");
			add_location(span, file$6, 17, 4, 439);
			attr_dev(div, "class", "error svelte-1deodsm");
			add_location(div, file$6, 16, 2, 338);
			dispose = listen_dev(div, "click", ctx.removeError, false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			if_block.m(span, null);
			current = true;
		},
		p: function update(changed, ctx) {
			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block) {
				if_block.p(changed, ctx);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(span, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;

			if (local) {
				add_render_callback(() => {
					if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { delay: 0, duration: 400 }, true);
					div_transition.run(1);
				});
			}

			current = true;
		},
		o: function outro(local) {
			if (local) {
				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { delay: 0, duration: 400 }, false);
				div_transition.run(0);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_block.d();
			if (detaching && div_transition) div_transition.end();
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(16:0) {#if $errors.includes(errorCode)}",
		ctx
	});

	return block;
}

// (23:6) {:else}
function create_else_block$2(ctx) {
	let t0;
	let t1;

	const block = {
		c: function create() {
			t0 = text(ctx.errorCode);
			t1 = text(" rule validation error");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
		},
		p: function update(changed, ctx) {
			if (changed.errorCode) set_data_dev(t0, ctx.errorCode);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(23:6) {:else}",
		ctx
	});

	return block;
}

// (21:26) 
function create_if_block_2$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(ctx.errorText);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(changed, ctx) {
			if (changed.errorText) set_data_dev(t, ctx.errorText);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(21:26) ",
		ctx
	});

	return block;
}

// (19:6) {#if errorCode === 'required' && !errorText && !fromLoop}
function create_if_block_1$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("This field is required");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(19:6) {#if errorCode === 'required' && !errorText && !fromLoop}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let show_if = ctx.$errors.includes(ctx.errorCode);
	let if_block_anchor;
	let if_block = show_if && create_if_block$2(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},
		p: function update(changed, ctx) {
			if (changed.$errors || changed.errorCode) show_if = ctx.$errors.includes(ctx.errorCode);

			if (show_if) {
				if (if_block) {
					if_block.p(changed, ctx);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			transition_in(if_block);
		},
		o: function outro(local) {
			transition_out(if_block);
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let $errors,
		$$unsubscribe_errors = noop,
		$$subscribe_errors = () => ($$unsubscribe_errors(), $$unsubscribe_errors = subscribe(errors, $$value => $$invalidate("$errors", $errors = $$value)), errors);

	$$self.$$.on_destroy.push(() => $$unsubscribe_errors());
	let { errors } = $$props;
	validate_store(errors, "errors");
	$$subscribe_errors();
	let { errorCode } = $$props;
	let { errorText = "" } = $$props;
	let { fromLoop = false } = $$props;

	const removeError = () => {
		errors.update(v => {
			return v.filter(e => e !== errorCode);
		});
	};

	const writable_props = ["errors", "errorCode", "errorText", "fromLoop"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Error> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ("errors" in $$props) $$subscribe_errors($$invalidate("errors", errors = $$props.errors));
		if ("errorCode" in $$props) $$invalidate("errorCode", errorCode = $$props.errorCode);
		if ("errorText" in $$props) $$invalidate("errorText", errorText = $$props.errorText);
		if ("fromLoop" in $$props) $$invalidate("fromLoop", fromLoop = $$props.fromLoop);
	};

	$$self.$capture_state = () => {
		return {
			errors,
			errorCode,
			errorText,
			fromLoop,
			$errors
		};
	};

	$$self.$inject_state = $$props => {
		if ("errors" in $$props) $$subscribe_errors($$invalidate("errors", errors = $$props.errors));
		if ("errorCode" in $$props) $$invalidate("errorCode", errorCode = $$props.errorCode);
		if ("errorText" in $$props) $$invalidate("errorText", errorText = $$props.errorText);
		if ("fromLoop" in $$props) $$invalidate("fromLoop", fromLoop = $$props.fromLoop);
		if ("$errors" in $$props) errors.set($errors = $$props.$errors);
	};

	return {
		errors,
		errorCode,
		errorText,
		fromLoop,
		removeError,
		$errors
	};
}

class Error$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1deodsm-style")) add_css$6();

		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
			errors: 0,
			errorCode: 0,
			errorText: 0,
			fromLoop: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Error",
			options,
			id: create_fragment$6.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (ctx.errors === undefined && !("errors" in props)) {
			console.warn("<Error> was created without expected prop 'errors'");
		}

		if (ctx.errorCode === undefined && !("errorCode" in props)) {
			console.warn("<Error> was created without expected prop 'errorCode'");
		}
	}

	get errors() {
		throw new Error_1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errors(value) {
		throw new Error_1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errorCode() {
		throw new Error_1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorCode(value) {
		throw new Error_1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errorText() {
		throw new Error_1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorText(value) {
		throw new Error_1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fromLoop() {
		throw new Error_1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fromLoop(value) {
		throw new Error_1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const getWithFirstUpper = (s) => s[0].toUpperCase() + s.slice(1);
const getEntryHTML = (id, { type }) => {
    const typeClass = getWithFirstUpper(type);
    switch (true) {
        case type === 'boolean':
            return `<label><input bind:checked={$value${typeClass}${id}} use:input${typeClass}${id} type="checkbox" /> Are you agree?</label>`;
        case type === 'array':
            return `<label><input bind:group={$value${typeClass}${id}} use:input${typeClass}${id} type="checkbox" value="Lorem" /> Lorem</label>
<label><input bind:group={$value${typeClass}${id}} use:input${typeClass}${id} type="checkbox" value="ipsum" /> Ipsum</label>
<label><input bind:group={$value${typeClass}${id}} use:input${typeClass}${id} type="checkbox" value="dolor" /> Dolor?</label>`;
        case type === 'email':
            return `<input type="email" bind:value={$value${typeClass}${id}} use:input${typeClass}${id} />`;
        case type === 'number':
            return `<input type="number" bind:value={$value${typeClass}${id}} use:input${typeClass}${id} />`;
        default:
            return `<input type="text" bind:value={$value${typeClass}${id}} use:input${typeClass}${id} />`;
    }
};
const getEntryErrors = (id, { type }) => {
    const typeClass = getWithFirstUpper(type);
    return `{#each $errors${typeClass}${id} as errorCode}
  <p>{errorCode} rule validation error</p>
{/each}`;
};
const getEntryJS = (id, params) => {
    const { type, ...rest } = params;
    const typeClass = getWithFirstUpper(type);
    let paramsObject = `type: '${type}'`;
    Object.keys(rest).forEach(ruleKey => {
        const paramValue = ruleKey === 'match' ? `/${rest[ruleKey]}/` : (rest[ruleKey] === '' ? "''" : JSON.stringify(rest[ruleKey]));
        paramsObject += `,\n  ${ruleKey}: ${paramValue}`;
    });
    return `<script>
const [ errors${typeClass}${id}, value${typeClass}${id}, input${typeClass}${id} ] = createEntry({
  ${paramsObject}
});
</script>`;
};
const getFormCode = ({ validateOnEvents, clearErrorsOnEvents, listenInputEvents, presence, trim, includeAllEntries }) => {
    const options = [];
    if (listenInputEvents !== 0 && (!validateOnEvents.change || validateOnEvents.input || validateOnEvents.blur)) {
        let code = '';
        code += `validateOnEvents: { `;
        if (validateOnEvents.change)
            code += `change: true, `;
        if (validateOnEvents.input)
            code += `input: true, `;
        if (validateOnEvents.blur)
            code += `blur: true, `;
        code += `}`;
        options.push(code);
    }
    if (!clearErrorsOnEvents.reset || (listenInputEvents !== 0 && clearErrorsOnEvents.focus)) {
        let code = '';
        code += `clearErrorsOnEvents: { `;
        if (clearErrorsOnEvents.reset)
            code += `reset: true, `;
        if (clearErrorsOnEvents.focus && listenInputEvents !== 0)
            code += `focus: true, `;
        code += `}`;
        options.push(code);
    }
    if (listenInputEvents !== 2) {
        options.push(`listenInputEvents: ` + listenInputEvents);
    }
    if (presence === 'required') {
        options.push(`presence: 'required'`);
    }
    else if (presence === 'optional') {
        options.push(`presence: 'optional'`);
    }
    if (trim) {
        options.push(`trim: true`);
    }
    if (includeAllEntries) {
        options.push(`includeAllEntries: true`);
    }
    const js = [
        `<script>`,
        `  import createSvelidation from 'svelidation';`,
        `  const { createEntry, createForm } = createSvelidation(${options.length ? `{\n    ${options.join(',\n    ')}\n  }` : ''});`,
        `</script>`
    ].join('\n');
    const html = [
        `<form use:createForm novalidate on:submit|preventDefault>`,
        `  <!-- inputs -->`,
        `</form>`
    ].join('\n');
    return js + '\n\n' + html;
};
//# sourceMappingURL=get-code.js.map

/* src/docs/builder/components/field.svelte generated by Svelte v3.15.0 */

const { Error: Error_1$1 } = globals;

const file$7 = "src/docs/builder/components/field.svelte";

function add_css$7() {
	var style = element("style");
	style.id = "svelte-b7x6vc-style";
	style.textContent = ".field.svelte-b7x6vc{display:flex;position:relative}.html.svelte-b7x6vc{border-right:1px dashed #bbb;padding:10px;width:50%}.code.svelte-b7x6vc{width:50%}label.svelte-b7x6vc{cursor:pointer;display:block}label+label.svelte-b7x6vc{margin-top:5px}.buttons.svelte-b7x6vc{margin:-10px 0 10px -10px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmllbGQuc3ZlbHRlIiwic291cmNlcyI6WyJmaWVsZC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cclxuICBleHBvcnQgbGV0IGNyZWF0ZUVudHJ5O1xyXG4gIGV4cG9ydCBsZXQgdmFsaWRhdGVWYWx1ZVN0b3JlO1xyXG4gIGV4cG9ydCBsZXQgcGFyYW1zO1xyXG4gIGV4cG9ydCBsZXQgaWQ7XHJcblxyXG4gIGltcG9ydCBFcnJvciBmcm9tICdkb2NzL3VpL2Vycm9yLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IENvZGUgZnJvbSAnZG9jcy91aS9jb2RlLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IHsgZ2V0RW50cnlIVE1MLCBnZXRFbnRyeUpTLCBnZXRFbnRyeUVycm9ycyB9IGZyb20gJ2RvY3MvYnVpbGRlci9saWIvZ2V0LWNvZGUvZ2V0LWNvZGUnO1xyXG5cclxuICBjb25zdCB7IHR5cGUgfSA9IHBhcmFtcztcclxuICBjb25zdCBbIGVycm9ycywgdmFsdWUsIGlucHV0IF0gPSBjcmVhdGVFbnRyeShwYXJhbXMpO1xyXG4gIGNvbnN0IHZhbGlkYXRlUm93ID0gKCkgPT4ge1xyXG4gICAgdmFsaWRhdGVWYWx1ZVN0b3JlKHZhbHVlKTtcclxuICB9O1xyXG48L3NjcmlwdD5cclxuXHJcbjxkaXYgY2xhc3M9XCJmaWVsZFwiPlxyXG4gIDxkaXYgY2xhc3M9XCJodG1sXCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwiYnV0dG9uc1wiPlxyXG4gICAgICA8c2xvdCAvPlxyXG4gICAgICA8YnV0dG9uIG9uOmNsaWNrPXt2YWxpZGF0ZVJvd30gdHlwZT1cImJ1dHRvblwiPnZhbGlkYXRlIGZpZWxkPC9idXR0b24+XHJcbiAgICA8L2Rpdj5cclxuICAgIHsjaWYgdHlwZSA9PT0gJ2Jvb2xlYW4nfVxyXG4gICAgICA8bGFiZWw+PGlucHV0IGJpbmQ6Y2hlY2tlZD17JHZhbHVlfSB1c2U6aW5wdXQgY2xhc3M9XCJpbnB1dC1jaG9pY2VcIiB0eXBlPVwiY2hlY2tib3hcIiAvPiBBcmUgeW91IGFncmVlPzwvbGFiZWw+XHJcbiAgICB7OmVsc2UgaWYgdHlwZSA9PT0gJ2FycmF5J31cclxuICAgICAgPGxhYmVsPjxpbnB1dCBiaW5kOmdyb3VwPXskdmFsdWV9IHVzZTppbnB1dCBjbGFzcz1cImlucHV0LWNob2ljZVwiIHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPVwiTG9yZW1cIiAvPiBMb3JlbTwvbGFiZWw+XHJcbiAgICAgIDxsYWJlbD48aW5wdXQgYmluZDpncm91cD17JHZhbHVlfSB1c2U6aW5wdXQgY2xhc3M9XCJpbnB1dC1jaG9pY2VcIiB0eXBlPVwiY2hlY2tib3hcIiB2YWx1ZT1cImlwc3VtXCIgLz4gSXBzdW08L2xhYmVsPlxyXG4gICAgICA8bGFiZWw+PGlucHV0IGJpbmQ6Z3JvdXA9eyR2YWx1ZX0gdXNlOmlucHV0IGNsYXNzPVwiaW5wdXQtY2hvaWNlXCIgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9XCJkb2xvclwiIC8+IERvbG9yPzwvbGFiZWw+XHJcbiAgICB7OmVsc2V9XHJcbiAgICAgIHsjaWYgdHlwZSA9PT0gJ251bWJlcid9XHJcbiAgICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBiaW5kOnZhbHVlPXskdmFsdWV9IHVzZTppbnB1dCBjbGFzcz1cImlucHV0LXRleHRcIiAvPlxyXG4gICAgICB7OmVsc2UgaWYgdHlwZSA9PT0gJ2VtYWlsJ31cclxuICAgICAgICA8aW5wdXQgdHlwZT1cImVtYWlsXCIgYmluZDp2YWx1ZT17JHZhbHVlfSB1c2U6aW5wdXQgY2xhc3M9XCJpbnB1dC10ZXh0XCIgLz5cclxuICAgICAgezplbHNlfVxyXG4gICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGJpbmQ6dmFsdWU9eyR2YWx1ZX0gdXNlOmlucHV0IGNsYXNzPVwiaW5wdXQtdGV4dFwiIC8+XHJcbiAgICAgIHsvaWZ9XHJcbiAgICB7L2lmfVxyXG5cclxuICAgIHsjZWFjaCAkZXJyb3JzIGFzIGVycm9yQ29kZX1cclxuICAgICAgPEVycm9yIHtlcnJvcnN9IHtlcnJvckNvZGV9IGZyb21Mb29wIC8+XHJcbiAgICB7L2VhY2h9XHJcbiAgPC9kaXY+XHJcbiAgPGRpdiBjbGFzcz1cImNvZGVcIj5cclxuICAgIDxDb2RlIGNvZGU9e2dldEVudHJ5SlMoaWQsIHBhcmFtcykgKyAnXFxuXFxuJyArIGdldEVudHJ5SFRNTChpZCwgIHBhcmFtcykgKyAnXFxuJyArIGdldEVudHJ5RXJyb3JzKGlkLCBwYXJhbXMpfSBidWlsZGVyTW9kZSAvPlxyXG4gIDwvZGl2PlxyXG48L2Rpdj5cclxuXHJcbjxzdHlsZT5cclxuICAuZmllbGQge1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICB9XHJcblxyXG4gIC5odG1sIHtcclxuICAgIGJvcmRlci1yaWdodDogMXB4IGRhc2hlZCAjYmJiO1xyXG4gICAgcGFkZGluZzogMTBweDtcclxuICAgIHdpZHRoOiA1MCU7XHJcbiAgfVxyXG5cclxuICAuY29kZSB7XHJcbiAgICB3aWR0aDogNTAlO1xyXG4gIH1cclxuXHJcbiAgbGFiZWwge1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgZGlzcGxheTogYmxvY2s7XHJcbiAgfVxyXG5cclxuICBsYWJlbCArIGxhYmVsIHtcclxuICAgIG1hcmdpbi10b3A6IDVweDtcclxuICB9XHJcblxyXG4gIC5idXR0b25zIHtcclxuICAgIG1hcmdpbjogLTEwcHggMCAxMHB4IC0xMHB4O1xyXG4gIH1cclxuXHJcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbk55WXk5a2IyTnpMMkoxYVd4a1pYSXZZMjl0Y0c5dVpXNTBjeTltYVdWc1pDNXpkbVZzZEdVaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0RlFVTkZPMGxCUTBVc1lVRkJZVHRKUVVOaUxHdENRVUZyUWp0RlFVTndRanM3UlVGRlFUdEpRVU5GTERaQ1FVRnZRenRKUVVOd1F5eGhRVUZoTzBsQlEySXNWVUZCVlR0RlFVTmFPenRGUVVWQk8wbEJRMFVzVlVGQlZUdEZRVU5hT3p0RlFVVkJPMGxCUTBVc1pVRkJaVHRKUVVObUxHTkJRV003UlVGRGFFSTdPMFZCUlVFN1NVRkRSU3hsUVVGbE8wVkJRMnBDT3p0RlFVVkJPMGxCUTBVc01FSkJRVEJDTzBWQlF6VkNJaXdpWm1sc1pTSTZJbk55WXk5a2IyTnpMMkoxYVd4a1pYSXZZMjl0Y0c5dVpXNTBjeTltYVdWc1pDNXpkbVZzZEdVaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNjbHh1SUNBdVptbGxiR1FnZTF4eVhHNGdJQ0FnWkdsemNHeGhlVG9nWm14bGVEdGNjbHh1SUNBZ0lIQnZjMmwwYVc5dU9pQnlaV3hoZEdsMlpUdGNjbHh1SUNCOVhISmNibHh5WEc0Z0lDNW9kRzFzSUh0Y2NseHVJQ0FnSUdKdmNtUmxjaTF5YVdkb2REb2dNWEI0SUdSaGMyaGxaQ0IyWVhJb0xTMW5jbVY1S1R0Y2NseHVJQ0FnSUhCaFpHUnBibWM2SURFd2NIZzdYSEpjYmlBZ0lDQjNhV1IwYURvZ05UQWxPMXh5WEc0Z0lIMWNjbHh1WEhKY2JpQWdMbU52WkdVZ2UxeHlYRzRnSUNBZ2QybGtkR2c2SURVd0pUdGNjbHh1SUNCOVhISmNibHh5WEc0Z0lHeGhZbVZzSUh0Y2NseHVJQ0FnSUdOMWNuTnZjam9nY0c5cGJuUmxjanRjY2x4dUlDQWdJR1JwYzNCc1lYazZJR0pzYjJOck8xeHlYRzRnSUgxY2NseHVYSEpjYmlBZ2JHRmlaV3dnS3lCc1lXSmxiQ0I3WEhKY2JpQWdJQ0J0WVhKbmFXNHRkRzl3T2lBMWNIZzdYSEpjYmlBZ2ZWeHlYRzVjY2x4dUlDQXVZblYwZEc5dWN5QjdYSEpjYmlBZ0lDQnRZWEpuYVc0NklDMHhNSEI0SURBZ01UQndlQ0F0TVRCd2VEdGNjbHh1SUNCOVhISmNiaUpkZlE9PSAqLzwvc3R5bGU+XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFpREUsTUFBTSxjQUFDLENBQUMsQUFDTixPQUFPLENBQUUsSUFBSSxDQUNiLFFBQVEsQ0FBRSxRQUFRLEFBQ3BCLENBQUMsQUFFRCxLQUFLLGNBQUMsQ0FBQyxBQUNMLFlBQVksQ0FBRSxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FDN0IsT0FBTyxDQUFFLElBQUksQ0FDYixLQUFLLENBQUUsR0FBRyxBQUNaLENBQUMsQUFFRCxLQUFLLGNBQUMsQ0FBQyxBQUNMLEtBQUssQ0FBRSxHQUFHLEFBQ1osQ0FBQyxBQUVELEtBQUssY0FBQyxDQUFDLEFBQ0wsTUFBTSxDQUFFLE9BQU8sQ0FDZixPQUFPLENBQUUsS0FBSyxBQUNoQixDQUFDLEFBRUQsS0FBSyxDQUFHLEtBQUssY0FBQyxDQUFDLEFBQ2IsVUFBVSxDQUFFLEdBQUcsQUFDakIsQ0FBQyxBQUVELFFBQVEsY0FBQyxDQUFDLEFBQ1IsTUFBTSxDQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQUFDNUIsQ0FBQyJ9 */";
	append_dev(document.head, style);
}

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.errorCode = list[i];
	return child_ctx;
}

// (35:6) {:else}
function create_else_block$3(ctx) {
	let input_1;
	let input_action;
	let dispose;

	const block = {
		c: function create() {
			input_1 = element("input");
			attr_dev(input_1, "type", "text");
			attr_dev(input_1, "class", "input-text");
			add_location(input_1, file$7, 35, 8, 1444);
			dispose = listen_dev(input_1, "input", ctx.input_1_input_handler_2);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			set_input_value(input_1, ctx.$value);
			input_action = ctx.input.call(null, input_1) || ({});
		},
		p: function update(changed, ctx) {
			if (changed.$value && input_1.value !== ctx.$value) {
				set_input_value(input_1, ctx.$value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			if (input_action && is_function(input_action.destroy)) input_action.destroy();
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$3.name,
		type: "else",
		source: "(35:6) {:else}",
		ctx
	});

	return block;
}

// (33:33) 
function create_if_block_3$1(ctx) {
	let input_1;
	let input_action;
	let dispose;

	const block = {
		c: function create() {
			input_1 = element("input");
			attr_dev(input_1, "type", "email");
			attr_dev(input_1, "class", "input-text");
			add_location(input_1, file$7, 33, 8, 1348);
			dispose = listen_dev(input_1, "input", ctx.input_1_input_handler_1);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			set_input_value(input_1, ctx.$value);
			input_action = ctx.input.call(null, input_1) || ({});
		},
		p: function update(changed, ctx) {
			if (changed.$value && input_1.value !== ctx.$value) {
				set_input_value(input_1, ctx.$value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			if (input_action && is_function(input_action.destroy)) input_action.destroy();
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(33:33) ",
		ctx
	});

	return block;
}

// (31:6) {#if type === 'number'}
function create_if_block_2$3(ctx) {
	let input_1;
	let input_1_updating = false;
	let input_action;
	let dispose;

	function input_1_input_handler() {
		input_1_updating = true;
		ctx.input_1_input_handler.call(input_1);
	}

	const block = {
		c: function create() {
			input_1 = element("input");
			attr_dev(input_1, "type", "number");
			attr_dev(input_1, "class", "input-text");
			add_location(input_1, file$7, 31, 8, 1231);
			dispose = listen_dev(input_1, "input", input_1_input_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			set_input_value(input_1, ctx.$value);
			input_action = ctx.input.call(null, input_1) || ({});
		},
		p: function update(changed, ctx) {
			if (!input_1_updating && changed.$value) {
				set_input_value(input_1, ctx.$value);
			}

			input_1_updating = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			if (input_action && is_function(input_action.destroy)) input_action.destroy();
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$3.name,
		type: "if",
		source: "(31:6) {#if type === 'number'}",
		ctx
	});

	return block;
}

// (26:31) 
function create_if_block_1$3(ctx) {
	let label0;
	let input0;
	let input_action;
	let t0;
	let t1;
	let label1;
	let input1;
	let input_action_1;
	let t2;
	let t3;
	let label2;
	let input2;
	let input_action_2;
	let t4;
	let dispose;

	const block = {
		c: function create() {
			label0 = element("label");
			input0 = element("input");
			t0 = text(" Lorem");
			t1 = space();
			label1 = element("label");
			input1 = element("input");
			t2 = text(" Ipsum");
			t3 = space();
			label2 = element("label");
			input2 = element("input");
			t4 = text(" Dolor?");
			attr_dev(input0, "class", "input-choice");
			attr_dev(input0, "type", "checkbox");
			input0.__value = "Lorem";
			input0.value = input0.__value;
			ctx.$$binding_groups[0].push(input0);
			add_location(input0, file$7, 26, 13, 834);
			attr_dev(label0, "class", "svelte-b7x6vc");
			add_location(label0, file$7, 26, 6, 827);
			attr_dev(input1, "class", "input-choice");
			attr_dev(input1, "type", "checkbox");
			input1.__value = "ipsum";
			input1.value = input1.__value;
			ctx.$$binding_groups[0].push(input1);
			add_location(input1, file$7, 27, 13, 953);
			attr_dev(label1, "class", "svelte-b7x6vc");
			add_location(label1, file$7, 27, 6, 946);
			attr_dev(input2, "class", "input-choice");
			attr_dev(input2, "type", "checkbox");
			input2.__value = "dolor";
			input2.value = input2.__value;
			ctx.$$binding_groups[0].push(input2);
			add_location(input2, file$7, 28, 13, 1072);
			attr_dev(label2, "class", "svelte-b7x6vc");
			add_location(label2, file$7, 28, 6, 1065);

			dispose = [
				listen_dev(input0, "change", ctx.input0_change_handler),
				listen_dev(input1, "change", ctx.input1_change_handler),
				listen_dev(input2, "change", ctx.input2_change_handler)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, label0, anchor);
			append_dev(label0, input0);
			input0.checked = ~ctx.$value.indexOf(input0.__value);
			input_action = ctx.input.call(null, input0) || ({});
			append_dev(label0, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, label1, anchor);
			append_dev(label1, input1);
			input1.checked = ~ctx.$value.indexOf(input1.__value);
			input_action_1 = ctx.input.call(null, input1) || ({});
			append_dev(label1, t2);
			insert_dev(target, t3, anchor);
			insert_dev(target, label2, anchor);
			append_dev(label2, input2);
			input2.checked = ~ctx.$value.indexOf(input2.__value);
			input_action_2 = ctx.input.call(null, input2) || ({});
			append_dev(label2, t4);
		},
		p: function update(changed, ctx) {
			if (changed.$value) {
				input0.checked = ~ctx.$value.indexOf(input0.__value);
			}

			if (changed.$value) {
				input1.checked = ~ctx.$value.indexOf(input1.__value);
			}

			if (changed.$value) {
				input2.checked = ~ctx.$value.indexOf(input2.__value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label0);
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input0), 1);
			if (input_action && is_function(input_action.destroy)) input_action.destroy();
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(label1);
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input1), 1);
			if (input_action_1 && is_function(input_action_1.destroy)) input_action_1.destroy();
			if (detaching) detach_dev(t3);
			if (detaching) detach_dev(label2);
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input2), 1);
			if (input_action_2 && is_function(input_action_2.destroy)) input_action_2.destroy();
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(26:31) ",
		ctx
	});

	return block;
}

// (24:4) {#if type === 'boolean'}
function create_if_block$3(ctx) {
	let label;
	let input_1;
	let input_action;
	let t;
	let dispose;

	const block = {
		c: function create() {
			label = element("label");
			input_1 = element("input");
			t = text(" Are you agree?");
			attr_dev(input_1, "class", "input-choice");
			attr_dev(input_1, "type", "checkbox");
			add_location(input_1, file$7, 24, 13, 685);
			attr_dev(label, "class", "svelte-b7x6vc");
			add_location(label, file$7, 24, 6, 678);
			dispose = listen_dev(input_1, "change", ctx.input_1_change_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, input_1);
			input_1.checked = ctx.$value;
			input_action = ctx.input.call(null, input_1) || ({});
			append_dev(label, t);
		},
		p: function update(changed, ctx) {
			if (changed.$value) {
				input_1.checked = ctx.$value;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (input_action && is_function(input_action.destroy)) input_action.destroy();
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(24:4) {#if type === 'boolean'}",
		ctx
	});

	return block;
}

// (40:4) {#each $errors as errorCode}
function create_each_block(ctx) {
	let current;

	const error = new Error$1({
			props: {
				errors: ctx.errors,
				errorCode: ctx.errorCode,
				fromLoop: true
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(error.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(error, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const error_changes = {};
			if (changed.$errors) error_changes.errorCode = ctx.errorCode;
			error.$set(error_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(error, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(40:4) {#each $errors as errorCode}",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let div3;
	let div1;
	let div0;
	let t0;
	let button;
	let t2;
	let t3;
	let t4;
	let div2;
	let current;
	let dispose;
	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	function select_block_type(changed, ctx) {
		if (ctx.type === "boolean") return create_if_block$3;
		if (ctx.type === "array") return create_if_block_1$3;
		if (ctx.type === "number") return create_if_block_2$3;
		if (ctx.type === "email") return create_if_block_3$1;
		return create_else_block$3;
	}

	let current_block_type = select_block_type(null, ctx);
	let if_block = current_block_type(ctx);
	let each_value = ctx.$errors;
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const code = new Code({
			props: {
				code: getEntryJS(ctx.id, ctx.params) + "\n\n" + getEntryHTML(ctx.id, ctx.params) + "\n" + getEntryErrors(ctx.id, ctx.params),
				builderMode: true
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div3 = element("div");
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			t0 = space();
			button = element("button");
			button.textContent = "validate field";
			t2 = space();
			if_block.c();
			t3 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t4 = space();
			div2 = element("div");
			create_component(code.$$.fragment);
			attr_dev(button, "type", "button");
			add_location(button, file$7, 21, 6, 560);
			attr_dev(div0, "class", "buttons svelte-b7x6vc");
			add_location(div0, file$7, 19, 4, 515);
			attr_dev(div1, "class", "html svelte-b7x6vc");
			add_location(div1, file$7, 18, 2, 491);
			attr_dev(div2, "class", "code svelte-b7x6vc");
			add_location(div2, file$7, 43, 2, 1648);
			attr_dev(div3, "class", "field svelte-b7x6vc");
			add_location(div3, file$7, 17, 0, 468);
			dispose = listen_dev(button, "click", ctx.validateRow, false, false, false);
		},
		l: function claim(nodes) {
			throw new Error_1$1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div1);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			append_dev(div0, t0);
			append_dev(div0, button);
			append_dev(div1, t2);
			if_block.m(div1, null);
			append_dev(div1, t3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			append_dev(div3, t4);
			append_dev(div3, div2);
			mount_component(code, div2, null);
			current = true;
		},
		p: function update(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_template, ctx, changed, null), get_slot_context(default_slot_template, ctx, null));
			}

			if_block.p(changed, ctx);

			if (changed.errors || changed.$errors) {
				each_value = ctx.$errors;
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div1, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			const code_changes = {};
			if (changed.id || changed.params) code_changes.code = getEntryJS(ctx.id, ctx.params) + "\n\n" + getEntryHTML(ctx.id, ctx.params) + "\n" + getEntryErrors(ctx.id, ctx.params);
			code.$set(code_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(code.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(code.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
			if (default_slot) default_slot.d(detaching);
			if_block.d();
			destroy_each(each_blocks, detaching);
			destroy_component(code);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let $value;
	let $errors;
	let { createEntry } = $$props;
	let { validateValueStore } = $$props;
	let { params } = $$props;
	let { id } = $$props;
	const { type } = params;
	const [errors, value, input] = createEntry(params);
	validate_store(errors, "errors");
	component_subscribe($$self, errors, value => $$invalidate("$errors", $errors = value));
	validate_store(value, "value");
	component_subscribe($$self, value, value => $$invalidate("$value", $value = value));

	const validateRow = () => {
		validateValueStore(value);
	};

	const writable_props = ["createEntry", "validateValueStore", "params", "id"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Field> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	const $$binding_groups = [[]];

	function input_1_change_handler() {
		$value = this.checked;
		value.set($value);
	}

	function input0_change_handler() {
		$value = get_binding_group_value($$binding_groups[0]);
		value.set($value);
	}

	function input1_change_handler() {
		$value = get_binding_group_value($$binding_groups[0]);
		value.set($value);
	}

	function input2_change_handler() {
		$value = get_binding_group_value($$binding_groups[0]);
		value.set($value);
	}

	function input_1_input_handler() {
		$value = to_number(this.value);
		value.set($value);
	}

	function input_1_input_handler_1() {
		$value = this.value;
		value.set($value);
	}

	function input_1_input_handler_2() {
		$value = this.value;
		value.set($value);
	}

	$$self.$set = $$props => {
		if ("createEntry" in $$props) $$invalidate("createEntry", createEntry = $$props.createEntry);
		if ("validateValueStore" in $$props) $$invalidate("validateValueStore", validateValueStore = $$props.validateValueStore);
		if ("params" in $$props) $$invalidate("params", params = $$props.params);
		if ("id" in $$props) $$invalidate("id", id = $$props.id);
		if ("$$scope" in $$props) $$invalidate("$$scope", $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			createEntry,
			validateValueStore,
			params,
			id,
			$value,
			$errors
		};
	};

	$$self.$inject_state = $$props => {
		if ("createEntry" in $$props) $$invalidate("createEntry", createEntry = $$props.createEntry);
		if ("validateValueStore" in $$props) $$invalidate("validateValueStore", validateValueStore = $$props.validateValueStore);
		if ("params" in $$props) $$invalidate("params", params = $$props.params);
		if ("id" in $$props) $$invalidate("id", id = $$props.id);
		if ("$value" in $$props) value.set($value = $$props.$value);
		if ("$errors" in $$props) errors.set($errors = $$props.$errors);
	};

	return {
		createEntry,
		validateValueStore,
		params,
		id,
		type,
		errors,
		value,
		input,
		validateRow,
		$value,
		$errors,
		input_1_change_handler,
		input0_change_handler,
		input1_change_handler,
		input2_change_handler,
		input_1_input_handler,
		input_1_input_handler_1,
		input_1_input_handler_2,
		$$slots,
		$$scope,
		$$binding_groups
	};
}

class Field extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-b7x6vc-style")) add_css$7();

		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
			createEntry: 0,
			validateValueStore: 0,
			params: 0,
			id: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Field",
			options,
			id: create_fragment$7.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (ctx.createEntry === undefined && !("createEntry" in props)) {
			console.warn("<Field> was created without expected prop 'createEntry'");
		}

		if (ctx.validateValueStore === undefined && !("validateValueStore" in props)) {
			console.warn("<Field> was created without expected prop 'validateValueStore'");
		}

		if (ctx.params === undefined && !("params" in props)) {
			console.warn("<Field> was created without expected prop 'params'");
		}

		if (ctx.id === undefined && !("id" in props)) {
			console.warn("<Field> was created without expected prop 'id'");
		}
	}

	get createEntry() {
		throw new Error_1$1("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set createEntry(value) {
		throw new Error_1$1("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get validateValueStore() {
		throw new Error_1$1("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set validateValueStore(value) {
		throw new Error_1$1("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get params() {
		throw new Error_1$1("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set params(value) {
		throw new Error_1$1("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error_1$1("<Field>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error_1$1("<Field>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/docs/ui/reset.svelte generated by Svelte v3.15.0 */

// (7:0) {:else}
function create_else_block$4(ctx) {
	let current;
	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_template, ctx, changed, null), get_slot_context(default_slot_template, ctx, null));
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$4.name,
		type: "else",
		source: "(7:0) {:else}",
		ctx
	});

	return block;
}

// (5:0) {#if n%2}
function create_if_block$4(ctx) {
	let current;
	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_template, ctx, changed, null), get_slot_context(default_slot_template, ctx, null));
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(5:0) {#if n%2}",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$4, create_else_block$4];
	const if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.n % 2) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { n } = $$props;
	const writable_props = ["n"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Reset> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ("n" in $$props) $$invalidate("n", n = $$props.n);
		if ("$$scope" in $$props) $$invalidate("$$scope", $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return { n };
	};

	$$self.$inject_state = $$props => {
		if ("n" in $$props) $$invalidate("n", n = $$props.n);
	};

	return { n, $$slots, $$scope };
}

class Reset extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { n: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Reset",
			options,
			id: create_fragment$8.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (ctx.n === undefined && !("n" in props)) {
			console.warn("<Reset> was created without expected prop 'n'");
		}
	}

	get n() {
		throw new Error("<Reset>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set n(value) {
		throw new Error("<Reset>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/docs/builder/components/form-options-row.svelte generated by Svelte v3.15.0 */
const file$8 = "src/docs/builder/components/form-options-row.svelte";

function add_css$8() {
	var style = element("style");
	style.id = "svelte-17anesa-style";
	style.textContent = ".option.svelte-17anesa{background:#dcefff;cursor:pointer;display:flex;margin-bottom:10px;min-width:250px;padding:10px}.disabled.svelte-17anesa{cursor:initial;filter:grayscale(100%);opacity:.5;pointer-events:none}.option.svelte-17anesa label.svelte-17anesa{cursor:pointer;flex:1;margin-left:10px}.option.svelte-17anesa input.svelte-17anesa{border:1px solid #bbb;border-radius:3px;font-size:14px;height:20px;line-height:18px;margin-left:10px;outline:0;padding:0 3px;text-align:right;width:100px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybS1vcHRpb25zLXJvdy5zdmVsdGUiLCJzb3VyY2VzIjpbImZvcm0tb3B0aW9ucy1yb3cuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XHJcbiAgaW1wb3J0IFRvZ2dsZSBmcm9tICdkb2NzL2J1aWxkZXIvY29tcG9uZW50cy90b2dnbGUuc3ZlbHRlJztcclxuXHJcbiAgZXhwb3J0IGxldCBtb2RlbDtcclxuICBleHBvcnQgbGV0IGRpc2FibGVkID0gZmFsc2U7XHJcbiAgZXhwb3J0IGxldCB0ZXh0O1xyXG4gIGV4cG9ydCBsZXQgaWQ7XHJcbjwvc2NyaXB0PlxyXG5cclxuXHJcbjxkaXZcclxuICBjbGFzcz1cIm9wdGlvblwiXHJcbiAgY2xhc3M6Y2hlY2tlZD17bW9kZWx9XHJcbiAgY2xhc3M6ZGlzYWJsZWRcclxuPlxyXG4gIHsjaWYgdHlwZW9mIG1vZGVsID09PSAnYm9vbGVhbid9XHJcbiAgICA8VG9nZ2xlIGJpbmQ6Y2hlY2tlZD17bW9kZWx9IHtpZH0gLz5cclxuICB7L2lmfVxyXG5cclxuICA8bGFiZWwgZm9yPXtpZH0+e3RleHR9PC9sYWJlbD5cclxuXHJcbiAgeyNpZiB0eXBlb2YgbW9kZWwgIT09ICdib29sZWFuJ31cclxuICAgIDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgYmluZDp2YWx1ZT17bW9kZWx9IG1pbj1cIjBcIiBtYXg9XCIyXCIgLz5cclxuICB7L2lmfVxyXG48L2Rpdj5cclxuXHJcbjxzdHlsZT5cclxuICAub3B0aW9uIHtcclxuICAgIGJhY2tncm91bmQ6ICNkY2VmZmY7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMTBweDtcclxuICAgIG1pbi13aWR0aDogMjUwcHg7XHJcbiAgICBwYWRkaW5nOiAxMHB4O1xyXG4gIH1cclxuXHJcbiAgLmRpc2FibGVkIHtcclxuICAgIGN1cnNvcjogaW5pdGlhbDtcclxuICAgIGZpbHRlcjogZ3JheXNjYWxlKDEwMCUpO1xyXG4gICAgb3BhY2l0eTogLjU7XHJcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxuICB9XHJcblxyXG4gIC5vcHRpb24gbGFiZWwge1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgZmxleDogMTtcclxuICAgIG1hcmdpbi1sZWZ0OiAxMHB4O1xyXG4gIH1cclxuXHJcbiAgLm9wdGlvbiBpbnB1dCB7XHJcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjYmJiO1xyXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xyXG4gICAgZm9udC1zaXplOiAxNHB4O1xyXG4gICAgaGVpZ2h0OiAyMHB4O1xyXG4gICAgbGluZS1oZWlnaHQ6IDE4cHg7XHJcbiAgICBtYXJnaW4tbGVmdDogMTBweDtcclxuICAgIG91dGxpbmU6IDA7XHJcbiAgICBwYWRkaW5nOiAwIDNweDtcclxuICAgIHRleHQtYWxpZ246IHJpZ2h0O1xyXG4gICAgd2lkdGg6IDEwMHB4O1xyXG4gIH1cclxuXHJcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbk55WXk5a2IyTnpMMkoxYVd4a1pYSXZZMjl0Y0c5dVpXNTBjeTltYjNKdExXOXdkR2x2Ym5NdGNtOTNMbk4yWld4MFpTSmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wVkJRMFU3U1VGRFJTeHRRa0ZCYVVNN1NVRkRha01zWlVGQlpUdEpRVU5tTEdGQlFXRTdTVUZEWWl4dFFrRkJiVUk3U1VGRGJrSXNaMEpCUVdkQ08wbEJRMmhDTEdGQlFXRTdSVUZEWmpzN1JVRkZRVHRKUVVORkxHVkJRV1U3U1VGRFppeDFRa0ZCZFVJN1NVRkRka0lzVjBGQlZ6dEpRVU5ZTEc5Q1FVRnZRanRGUVVOMFFqczdSVUZGUVR0SlFVTkZMR1ZCUVdVN1NVRkRaaXhQUVVGUE8wbEJRMUFzYVVKQlFXbENPMFZCUTI1Q096dEZRVVZCTzBsQlEwVXNjMEpCUVRaQ08wbEJRemRDTEd0Q1FVRnJRanRKUVVOc1FpeGxRVUZsTzBsQlEyWXNXVUZCV1R0SlFVTmFMR2xDUVVGcFFqdEpRVU5xUWl4cFFrRkJhVUk3U1VGRGFrSXNWVUZCVlR0SlFVTldMR05CUVdNN1NVRkRaQ3hwUWtGQmFVSTdTVUZEYWtJc1dVRkJXVHRGUVVOa0lpd2labWxzWlNJNkluTnlZeTlrYjJOekwySjFhV3hrWlhJdlkyOXRjRzl1Wlc1MGN5OW1iM0p0TFc5d2RHbHZibk10Y205M0xuTjJaV3gwWlNJc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYklseHlYRzRnSUM1dmNIUnBiMjRnZTF4eVhHNGdJQ0FnWW1GamEyZHliM1Z1WkRvZ2RtRnlLQzB0YldGcGJrTnZiRzl5VEdsbmFIUXBPMXh5WEc0Z0lDQWdZM1Z5YzI5eU9pQndiMmx1ZEdWeU8xeHlYRzRnSUNBZ1pHbHpjR3hoZVRvZ1pteGxlRHRjY2x4dUlDQWdJRzFoY21kcGJpMWliM1IwYjIwNklERXdjSGc3WEhKY2JpQWdJQ0J0YVc0dGQybGtkR2c2SURJMU1IQjRPMXh5WEc0Z0lDQWdjR0ZrWkdsdVp6b2dNVEJ3ZUR0Y2NseHVJQ0I5WEhKY2JseHlYRzRnSUM1a2FYTmhZbXhsWkNCN1hISmNiaUFnSUNCamRYSnpiM0k2SUdsdWFYUnBZV3c3WEhKY2JpQWdJQ0JtYVd4MFpYSTZJR2R5WVhselkyRnNaU2d4TURBbEtUdGNjbHh1SUNBZ0lHOXdZV05wZEhrNklDNDFPMXh5WEc0Z0lDQWdjRzlwYm5SbGNpMWxkbVZ1ZEhNNklHNXZibVU3WEhKY2JpQWdmVnh5WEc1Y2NseHVJQ0F1YjNCMGFXOXVJR3hoWW1Wc0lIdGNjbHh1SUNBZ0lHTjFjbk52Y2pvZ2NHOXBiblJsY2p0Y2NseHVJQ0FnSUdac1pYZzZJREU3WEhKY2JpQWdJQ0J0WVhKbmFXNHRiR1ZtZERvZ01UQndlRHRjY2x4dUlDQjlYSEpjYmx4eVhHNGdJQzV2Y0hScGIyNGdhVzV3ZFhRZ2UxeHlYRzRnSUNBZ1ltOXlaR1Z5T2lBeGNIZ2djMjlzYVdRZ2RtRnlLQzB0WjNKbGVTazdYSEpjYmlBZ0lDQmliM0prWlhJdGNtRmthWFZ6T2lBemNIZzdYSEpjYmlBZ0lDQm1iMjUwTFhOcGVtVTZJREUwY0hnN1hISmNiaUFnSUNCb1pXbG5hSFE2SURJd2NIZzdYSEpjYmlBZ0lDQnNhVzVsTFdobGFXZG9kRG9nTVRod2VEdGNjbHh1SUNBZ0lHMWhjbWRwYmkxc1pXWjBPaUF4TUhCNE8xeHlYRzRnSUNBZ2IzVjBiR2x1WlRvZ01EdGNjbHh1SUNBZ0lIQmhaR1JwYm1jNklEQWdNM0I0TzF4eVhHNGdJQ0FnZEdWNGRDMWhiR2xuYmpvZ2NtbG5hSFE3WEhKY2JpQWdJQ0IzYVdSMGFEb2dNVEF3Y0hnN1hISmNiaUFnZlZ4eVhHNGlYWDA9ICovPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTJCRSxPQUFPLGVBQUMsQ0FBQyxBQUNQLFVBQVUsQ0FBRSxPQUFPLENBQ25CLE1BQU0sQ0FBRSxPQUFPLENBQ2YsT0FBTyxDQUFFLElBQUksQ0FDYixhQUFhLENBQUUsSUFBSSxDQUNuQixTQUFTLENBQUUsS0FBSyxDQUNoQixPQUFPLENBQUUsSUFBSSxBQUNmLENBQUMsQUFFRCxTQUFTLGVBQUMsQ0FBQyxBQUNULE1BQU0sQ0FBRSxPQUFPLENBQ2YsTUFBTSxDQUFFLFVBQVUsSUFBSSxDQUFDLENBQ3ZCLE9BQU8sQ0FBRSxFQUFFLENBQ1gsY0FBYyxDQUFFLElBQUksQUFDdEIsQ0FBQyxBQUVELHNCQUFPLENBQUMsS0FBSyxlQUFDLENBQUMsQUFDYixNQUFNLENBQUUsT0FBTyxDQUNmLElBQUksQ0FBRSxDQUFDLENBQ1AsV0FBVyxDQUFFLElBQUksQUFDbkIsQ0FBQyxBQUVELHNCQUFPLENBQUMsS0FBSyxlQUFDLENBQUMsQUFDYixNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQ3RCLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLFNBQVMsQ0FBRSxJQUFJLENBQ2YsTUFBTSxDQUFFLElBQUksQ0FDWixXQUFXLENBQUUsSUFBSSxDQUNqQixXQUFXLENBQUUsSUFBSSxDQUNqQixPQUFPLENBQUUsQ0FBQyxDQUNWLE9BQU8sQ0FBRSxDQUFDLENBQUMsR0FBRyxDQUNkLFVBQVUsQ0FBRSxLQUFLLENBQ2pCLEtBQUssQ0FBRSxLQUFLLEFBQ2QsQ0FBQyJ9 */";
	append_dev(document.head, style);
}

// (16:2) {#if typeof model === 'boolean'}
function create_if_block_1$4(ctx) {
	let updating_checked;
	let current;

	function toggle_checked_binding(value) {
		ctx.toggle_checked_binding.call(null, value);
	}

	let toggle_props = { id: ctx.id };

	if (ctx.model !== void 0) {
		toggle_props.checked = ctx.model;
	}

	const toggle = new Toggle({ props: toggle_props, $$inline: true });
	binding_callbacks.push(() => bind(toggle, "checked", toggle_checked_binding));

	const block = {
		c: function create() {
			create_component(toggle.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(toggle, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const toggle_changes = {};
			if (changed.id) toggle_changes.id = ctx.id;

			if (!updating_checked && changed.model) {
				updating_checked = true;
				toggle_changes.checked = ctx.model;
				add_flush_callback(() => updating_checked = false);
			}

			toggle.$set(toggle_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(toggle.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(toggle, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(16:2) {#if typeof model === 'boolean'}",
		ctx
	});

	return block;
}

// (22:2) {#if typeof model !== 'boolean'}
function create_if_block$5(ctx) {
	let input;
	let input_updating = false;
	let dispose;

	function input_input_handler() {
		input_updating = true;
		ctx.input_input_handler.call(input);
	}

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "type", "number");
			attr_dev(input, "min", "0");
			attr_dev(input, "max", "2");
			attr_dev(input, "class", "svelte-17anesa");
			add_location(input, file$8, 22, 4, 416);
			dispose = listen_dev(input, "input", input_input_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, ctx.model);
		},
		p: function update(changed, ctx) {
			if (!input_updating && changed.model) {
				set_input_value(input, ctx.model);
			}

			input_updating = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(22:2) {#if typeof model !== 'boolean'}",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let div;
	let t0;
	let label;
	let t1;
	let t2;
	let current;
	let if_block0 = typeof ctx.model === "boolean" && create_if_block_1$4(ctx);
	let if_block1 = typeof ctx.model !== "boolean" && create_if_block$5(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			label = element("label");
			t1 = text(ctx.text);
			t2 = space();
			if (if_block1) if_block1.c();
			attr_dev(label, "for", ctx.id);
			attr_dev(label, "class", "svelte-17anesa");
			add_location(label, file$8, 19, 2, 342);
			attr_dev(div, "class", "option svelte-17anesa");
			toggle_class(div, "checked", ctx.model);
			toggle_class(div, "disabled", ctx.disabled);
			add_location(div, file$8, 10, 0, 181);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			append_dev(div, label);
			append_dev(label, t1);
			append_dev(div, t2);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(changed, ctx) {
			if (typeof ctx.model === "boolean") {
				if (if_block0) {
					if_block0.p(changed, ctx);
					transition_in(if_block0, 1);
				} else {
					if_block0 = create_if_block_1$4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!current || changed.text) set_data_dev(t1, ctx.text);

			if (!current || changed.id) {
				attr_dev(label, "for", ctx.id);
			}

			if (typeof ctx.model !== "boolean") {
				if (if_block1) {
					if_block1.p(changed, ctx);
				} else {
					if_block1 = create_if_block$5(ctx);
					if_block1.c();
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (changed.model) {
				toggle_class(div, "checked", ctx.model);
			}

			if (changed.disabled) {
				toggle_class(div, "disabled", ctx.disabled);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let { model } = $$props;
	let { disabled = false } = $$props;
	let { text } = $$props;
	let { id } = $$props;
	const writable_props = ["model", "disabled", "text", "id"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Form_options_row> was created with unknown prop '${key}'`);
	});

	function toggle_checked_binding(value) {
		model = value;
		$$invalidate("model", model);
	}

	function input_input_handler() {
		model = to_number(this.value);
		$$invalidate("model", model);
	}

	$$self.$set = $$props => {
		if ("model" in $$props) $$invalidate("model", model = $$props.model);
		if ("disabled" in $$props) $$invalidate("disabled", disabled = $$props.disabled);
		if ("text" in $$props) $$invalidate("text", text = $$props.text);
		if ("id" in $$props) $$invalidate("id", id = $$props.id);
	};

	$$self.$capture_state = () => {
		return { model, disabled, text, id };
	};

	$$self.$inject_state = $$props => {
		if ("model" in $$props) $$invalidate("model", model = $$props.model);
		if ("disabled" in $$props) $$invalidate("disabled", disabled = $$props.disabled);
		if ("text" in $$props) $$invalidate("text", text = $$props.text);
		if ("id" in $$props) $$invalidate("id", id = $$props.id);
	};

	return {
		model,
		disabled,
		text,
		id,
		toggle_checked_binding,
		input_input_handler
	};
}

class Form_options_row extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-17anesa-style")) add_css$8();
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { model: 0, disabled: 0, text: 0, id: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Form_options_row",
			options,
			id: create_fragment$9.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (ctx.model === undefined && !("model" in props)) {
			console.warn("<Form_options_row> was created without expected prop 'model'");
		}

		if (ctx.text === undefined && !("text" in props)) {
			console.warn("<Form_options_row> was created without expected prop 'text'");
		}

		if (ctx.id === undefined && !("id" in props)) {
			console.warn("<Form_options_row> was created without expected prop 'id'");
		}
	}

	get model() {
		throw new Error("<Form_options_row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set model(value) {
		throw new Error("<Form_options_row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Form_options_row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Form_options_row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<Form_options_row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Form_options_row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Form_options_row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Form_options_row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/docs/builder/components/form-options.svelte generated by Svelte v3.15.0 */

const { Object: Object_1 } = globals;

// (82:0) <Button on:click={onSave}>
function create_default_slot_1$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Save");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(82:0) <Button on:click={onSave}>",
		ctx
	});

	return block;
}

// (83:0) <Button on:click={onCancel}>
function create_default_slot$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Cancel");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(83:0) <Button on:click={onCancel}>",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let updating_model;
	let t0;
	let updating_model_1;
	let t1;
	let updating_model_2;
	let t2;
	let updating_model_3;
	let t3;
	let updating_model_4;
	let t4;
	let updating_model_5;
	let t5;
	let updating_model_6;
	let t6;
	let updating_model_7;
	let t7;
	let updating_model_8;
	let t8;
	let updating_model_9;
	let t9;
	let t10;
	let current;

	function option0_model_binding(value) {
		ctx.option0_model_binding.call(null, value);
	}

	let option0_props = {
		id: "validateOnChange",
		disabled: ctx.formOptions.listenInputEvents === 0,
		text: "Validate on input value change"
	};

	if (ctx.formOptions.validateOnEvents.change !== void 0) {
		option0_props.model = ctx.formOptions.validateOnEvents.change;
	}

	const option0 = new Form_options_row({ props: option0_props, $$inline: true });
	binding_callbacks.push(() => bind(option0, "model", option0_model_binding));

	function option1_model_binding(value_1) {
		ctx.option1_model_binding.call(null, value_1);
	}

	let option1_props = {
		id: "validateOnInput",
		disabled: ctx.formOptions.listenInputEvents === 0,
		text: "Validate on input event"
	};

	if (ctx.formOptions.validateOnEvents.input !== void 0) {
		option1_props.model = ctx.formOptions.validateOnEvents.input;
	}

	const option1 = new Form_options_row({ props: option1_props, $$inline: true });
	binding_callbacks.push(() => bind(option1, "model", option1_model_binding));

	function option2_model_binding(value_2) {
		ctx.option2_model_binding.call(null, value_2);
	}

	let option2_props = {
		id: "validateOnBlur",
		disabled: ctx.formOptions.listenInputEvents === 0,
		text: "Validate on blur event"
	};

	if (ctx.formOptions.validateOnEvents.blur !== void 0) {
		option2_props.model = ctx.formOptions.validateOnEvents.blur;
	}

	const option2 = new Form_options_row({ props: option2_props, $$inline: true });
	binding_callbacks.push(() => bind(option2, "model", option2_model_binding));

	function option3_model_binding(value_3) {
		ctx.option3_model_binding.call(null, value_3);
	}

	let option3_props = {
		id: "clearErrorsOnReset",
		text: "Empty errors on reset form event"
	};

	if (ctx.formOptions.clearErrorsOnEvents.reset !== void 0) {
		option3_props.model = ctx.formOptions.clearErrorsOnEvents.reset;
	}

	const option3 = new Form_options_row({ props: option3_props, $$inline: true });
	binding_callbacks.push(() => bind(option3, "model", option3_model_binding));

	function option4_model_binding(value_4) {
		ctx.option4_model_binding.call(null, value_4);
	}

	let option4_props = {
		id: "clearErrorsOnFocus",
		disabled: ctx.formOptions.listenInputEvents === 0,
		text: "Empty entry errors on focus input event"
	};

	if (ctx.formOptions.clearErrorsOnEvents.focus !== void 0) {
		option4_props.model = ctx.formOptions.clearErrorsOnEvents.focus;
	}

	const option4 = new Form_options_row({ props: option4_props, $$inline: true });
	binding_callbacks.push(() => bind(option4, "model", option4_model_binding));

	function option5_model_binding(value_5) {
		ctx.option5_model_binding.call(null, value_5);
	}

	let option5_props = {
		id: "listenInputEvents",
		text: "Listen input events (0: never, 1: always: 2: after validation)"
	};

	if (ctx.formOptions.listenInputEvents !== void 0) {
		option5_props.model = ctx.formOptions.listenInputEvents;
	}

	const option5 = new Form_options_row({ props: option5_props, $$inline: true });
	binding_callbacks.push(() => bind(option5, "model", option5_model_binding));

	function option6_model_binding(value_6) {
		ctx.option6_model_binding.call(null, value_6);
	}

	let option6_props = {
		id: "presenceRequired",
		disabled: ctx.presence.optional,
		text: "All fields are required by default"
	};

	if (ctx.presence.required !== void 0) {
		option6_props.model = ctx.presence.required;
	}

	const option6 = new Form_options_row({ props: option6_props, $$inline: true });
	binding_callbacks.push(() => bind(option6, "model", option6_model_binding));

	function option7_model_binding(value_7) {
		ctx.option7_model_binding.call(null, value_7);
	}

	let option7_props = {
		id: "presenceOptional",
		disabled: ctx.presence.required,
		text: "All fields are optional by default"
	};

	if (ctx.presence.optional !== void 0) {
		option7_props.model = ctx.presence.optional;
	}

	const option7 = new Form_options_row({ props: option7_props, $$inline: true });
	binding_callbacks.push(() => bind(option7, "model", option7_model_binding));

	function option8_model_binding(value_8) {
		ctx.option8_model_binding.call(null, value_8);
	}

	let option8_props = {
		id: "trim",
		text: "Trim input value for validation purpose"
	};

	if (ctx.formOptions.trim !== void 0) {
		option8_props.model = ctx.formOptions.trim;
	}

	const option8 = new Form_options_row({ props: option8_props, $$inline: true });
	binding_callbacks.push(() => bind(option8, "model", option8_model_binding));

	function option9_model_binding(value_9) {
		ctx.option9_model_binding.call(null, value_9);
	}

	let option9_props = {
		id: "includeAllEntries",
		text: "Validate and reset all entries"
	};

	if (ctx.formOptions.includeAllEntries !== void 0) {
		option9_props.model = ctx.formOptions.includeAllEntries;
	}

	const option9 = new Form_options_row({ props: option9_props, $$inline: true });
	binding_callbacks.push(() => bind(option9, "model", option9_model_binding));

	const button0 = new Button({
			props: {
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", ctx.onSave);

	const button1 = new Button({
			props: {
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", ctx.onCancel);

	const block = {
		c: function create() {
			create_component(option0.$$.fragment);
			t0 = space();
			create_component(option1.$$.fragment);
			t1 = space();
			create_component(option2.$$.fragment);
			t2 = space();
			create_component(option3.$$.fragment);
			t3 = space();
			create_component(option4.$$.fragment);
			t4 = space();
			create_component(option5.$$.fragment);
			t5 = space();
			create_component(option6.$$.fragment);
			t6 = space();
			create_component(option7.$$.fragment);
			t7 = space();
			create_component(option8.$$.fragment);
			t8 = space();
			create_component(option9.$$.fragment);
			t9 = space();
			create_component(button0.$$.fragment);
			t10 = space();
			create_component(button1.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(option0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(option1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(option2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(option3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(option4, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(option5, target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(option6, target, anchor);
			insert_dev(target, t6, anchor);
			mount_component(option7, target, anchor);
			insert_dev(target, t7, anchor);
			mount_component(option8, target, anchor);
			insert_dev(target, t8, anchor);
			mount_component(option9, target, anchor);
			insert_dev(target, t9, anchor);
			mount_component(button0, target, anchor);
			insert_dev(target, t10, anchor);
			mount_component(button1, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const option0_changes = {};
			if (changed.formOptions) option0_changes.disabled = ctx.formOptions.listenInputEvents === 0;

			if (!updating_model && changed.formOptions) {
				updating_model = true;
				option0_changes.model = ctx.formOptions.validateOnEvents.change;
				add_flush_callback(() => updating_model = false);
			}

			option0.$set(option0_changes);
			const option1_changes = {};
			if (changed.formOptions) option1_changes.disabled = ctx.formOptions.listenInputEvents === 0;

			if (!updating_model_1 && changed.formOptions) {
				updating_model_1 = true;
				option1_changes.model = ctx.formOptions.validateOnEvents.input;
				add_flush_callback(() => updating_model_1 = false);
			}

			option1.$set(option1_changes);
			const option2_changes = {};
			if (changed.formOptions) option2_changes.disabled = ctx.formOptions.listenInputEvents === 0;

			if (!updating_model_2 && changed.formOptions) {
				updating_model_2 = true;
				option2_changes.model = ctx.formOptions.validateOnEvents.blur;
				add_flush_callback(() => updating_model_2 = false);
			}

			option2.$set(option2_changes);
			const option3_changes = {};

			if (!updating_model_3 && changed.formOptions) {
				updating_model_3 = true;
				option3_changes.model = ctx.formOptions.clearErrorsOnEvents.reset;
				add_flush_callback(() => updating_model_3 = false);
			}

			option3.$set(option3_changes);
			const option4_changes = {};
			if (changed.formOptions) option4_changes.disabled = ctx.formOptions.listenInputEvents === 0;

			if (!updating_model_4 && changed.formOptions) {
				updating_model_4 = true;
				option4_changes.model = ctx.formOptions.clearErrorsOnEvents.focus;
				add_flush_callback(() => updating_model_4 = false);
			}

			option4.$set(option4_changes);
			const option5_changes = {};

			if (!updating_model_5 && changed.formOptions) {
				updating_model_5 = true;
				option5_changes.model = ctx.formOptions.listenInputEvents;
				add_flush_callback(() => updating_model_5 = false);
			}

			option5.$set(option5_changes);
			const option6_changes = {};
			if (changed.presence) option6_changes.disabled = ctx.presence.optional;

			if (!updating_model_6 && changed.presence) {
				updating_model_6 = true;
				option6_changes.model = ctx.presence.required;
				add_flush_callback(() => updating_model_6 = false);
			}

			option6.$set(option6_changes);
			const option7_changes = {};
			if (changed.presence) option7_changes.disabled = ctx.presence.required;

			if (!updating_model_7 && changed.presence) {
				updating_model_7 = true;
				option7_changes.model = ctx.presence.optional;
				add_flush_callback(() => updating_model_7 = false);
			}

			option7.$set(option7_changes);
			const option8_changes = {};

			if (!updating_model_8 && changed.formOptions) {
				updating_model_8 = true;
				option8_changes.model = ctx.formOptions.trim;
				add_flush_callback(() => updating_model_8 = false);
			}

			option8.$set(option8_changes);
			const option9_changes = {};

			if (!updating_model_9 && changed.formOptions) {
				updating_model_9 = true;
				option9_changes.model = ctx.formOptions.includeAllEntries;
				add_flush_callback(() => updating_model_9 = false);
			}

			option9.$set(option9_changes);
			const button0_changes = {};

			if (changed.$$scope) {
				button0_changes.$$scope = { changed, ctx };
			}

			button0.$set(button0_changes);
			const button1_changes = {};

			if (changed.$$scope) {
				button1_changes.$$scope = { changed, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(option0.$$.fragment, local);
			transition_in(option1.$$.fragment, local);
			transition_in(option2.$$.fragment, local);
			transition_in(option3.$$.fragment, local);
			transition_in(option4.$$.fragment, local);
			transition_in(option5.$$.fragment, local);
			transition_in(option6.$$.fragment, local);
			transition_in(option7.$$.fragment, local);
			transition_in(option8.$$.fragment, local);
			transition_in(option9.$$.fragment, local);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(option0.$$.fragment, local);
			transition_out(option1.$$.fragment, local);
			transition_out(option2.$$.fragment, local);
			transition_out(option3.$$.fragment, local);
			transition_out(option4.$$.fragment, local);
			transition_out(option5.$$.fragment, local);
			transition_out(option6.$$.fragment, local);
			transition_out(option7.$$.fragment, local);
			transition_out(option8.$$.fragment, local);
			transition_out(option9.$$.fragment, local);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(option0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(option1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(option2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(option3, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(option4, detaching);
			if (detaching) detach_dev(t4);
			destroy_component(option5, detaching);
			if (detaching) detach_dev(t5);
			destroy_component(option6, detaching);
			if (detaching) detach_dev(t6);
			destroy_component(option7, detaching);
			if (detaching) detach_dev(t7);
			destroy_component(option8, detaching);
			if (detaching) detach_dev(t8);
			destroy_component(option9, detaching);
			if (detaching) detach_dev(t9);
			destroy_component(button0, detaching);
			if (detaching) detach_dev(t10);
			destroy_component(button1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let { formOptions } = $$props;

	const presence = {
		optional: formOptions.presence === "optional",
		required: formOptions.presence === "required"
	};

	const dispatch = createEventDispatcher();

	const onSave = () => {
		const listenInputEvents = parseFloat(formOptions.listenInputEvents);

		dispatch("save", Object.assign(formOptions, {
			listenInputEvents: isNaN(listenInputEvents)
			? 0
			: Math.min(2, Math.max(0, listenInputEvents)),
			presence: presence.optional
			? "optional"
			: presence.required ? "required" : null
		}));
	};

	const onCancel = () => {
		dispatch("cancel");
	};

	const writable_props = ["formOptions"];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Form_options> was created with unknown prop '${key}'`);
	});

	function option0_model_binding(value) {
		formOptions.validateOnEvents.change = value;
		$$invalidate("formOptions", formOptions);
	}

	function option1_model_binding(value_1) {
		formOptions.validateOnEvents.input = value_1;
		$$invalidate("formOptions", formOptions);
	}

	function option2_model_binding(value_2) {
		formOptions.validateOnEvents.blur = value_2;
		$$invalidate("formOptions", formOptions);
	}

	function option3_model_binding(value_3) {
		formOptions.clearErrorsOnEvents.reset = value_3;
		$$invalidate("formOptions", formOptions);
	}

	function option4_model_binding(value_4) {
		formOptions.clearErrorsOnEvents.focus = value_4;
		$$invalidate("formOptions", formOptions);
	}

	function option5_model_binding(value_5) {
		formOptions.listenInputEvents = value_5;
		$$invalidate("formOptions", formOptions);
	}

	function option6_model_binding(value_6) {
		presence.required = value_6;
		$$invalidate("presence", presence);
	}

	function option7_model_binding(value_7) {
		presence.optional = value_7;
		$$invalidate("presence", presence);
	}

	function option8_model_binding(value_8) {
		formOptions.trim = value_8;
		$$invalidate("formOptions", formOptions);
	}

	function option9_model_binding(value_9) {
		formOptions.includeAllEntries = value_9;
		$$invalidate("formOptions", formOptions);
	}

	$$self.$set = $$props => {
		if ("formOptions" in $$props) $$invalidate("formOptions", formOptions = $$props.formOptions);
	};

	$$self.$capture_state = () => {
		return { formOptions };
	};

	$$self.$inject_state = $$props => {
		if ("formOptions" in $$props) $$invalidate("formOptions", formOptions = $$props.formOptions);
	};

	return {
		formOptions,
		presence,
		onSave,
		onCancel,
		option0_model_binding,
		option1_model_binding,
		option2_model_binding,
		option3_model_binding,
		option4_model_binding,
		option5_model_binding,
		option6_model_binding,
		option7_model_binding,
		option8_model_binding,
		option9_model_binding
	};
}

class Form_options extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { formOptions: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Form_options",
			options,
			id: create_fragment$a.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (ctx.formOptions === undefined && !("formOptions" in props)) {
			console.warn("<Form_options> was created without expected prop 'formOptions'");
		}
	}

	get formOptions() {
		throw new Error("<Form_options>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set formOptions(value) {
		throw new Error("<Form_options>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/docs/builder/builder.svelte generated by Svelte v3.15.0 */
const file$9 = "src/docs/builder/builder.svelte";

function add_css$9() {
	var style = element("style");
	style.id = "svelte-1p4n34s-style";
	style.textContent = ".row.svelte-1p4n34s{border-bottom:1px solid #bbb;margin:0 -10px}.row.svelte-1p4n34s:first-child{padding:0 10px 10px}.row.svelte-1p4n34s:last-child{border:0;margin:0;padding-top:10px}.remove-row.svelte-1p4n34s button{background:none;border:0;cursor:pointer;color:#ec512a;font-size:12px;line-height:19px;padding:2px 5px;text-transform:uppercase}.remove-row.svelte-1p4n34s button:hover{background:#ec512a;color:#fff}.code.svelte-1p4n34s{margin-bottom:10px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVpbGRlci5zdmVsdGUiLCJzb3VyY2VzIjpbImJ1aWxkZXIuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XHJcbiAgaW1wb3J0IGNyZWF0ZVZhbGlkYXRpb24gZnJvbSAnbGliL2xpYic7XHJcbiAgaW1wb3J0IE5ld0ZpZWxkIGZyb20gJ2RvY3MvYnVpbGRlci9jb21wb25lbnRzL25ldy1maWVsZC5zdmVsdGUnO1xyXG4gIGltcG9ydCBXaWRnZXQgZnJvbSAnZG9jcy91aS93aWRnZXQuc3ZlbHRlJztcclxuICBpbXBvcnQgQnV0dG9uIGZyb20gJ2RvY3MvdWkvYnV0dG9uLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IENvZGUgZnJvbSAnZG9jcy91aS9jb2RlLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IEZpZWxkIGZyb20gJ2RvY3MvYnVpbGRlci9jb21wb25lbnRzL2ZpZWxkLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IFJlc2V0IGZyb20gJ2RvY3MvdWkvcmVzZXQuc3ZlbHRlJztcclxuICBpbXBvcnQgRm9ybU9wdGlvbnMgZnJvbSAnZG9jcy9idWlsZGVyL2NvbXBvbmVudHMvZm9ybS1vcHRpb25zLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IHsgZ2V0Rm9ybUNvZGUgfSBmcm9tICdkb2NzL2J1aWxkZXIvbGliL2dldC1jb2RlL2dldC1jb2RlJztcclxuXHJcbiAgbGV0IGlkID0gMDtcclxuICBsZXQgZmllbGRzID0gW3tcclxuICAgIGlkOiBpZCsrLFxyXG4gICAgcGFyYW1zOiB7XHJcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxyXG4gICAgICB2YWx1ZTogJycsXHJcbiAgICAgIG1pbjogMixcclxuICAgICAgcmVxdWlyZWQ6IHRydWVcclxuICAgIH1cclxuICB9XTtcclxuXHJcbiAgY29uc3Qgb25OZXdGaWVsZCA9ICh7IGRldGFpbDogcGFyYW1zIH0pID0+IHtcclxuICAgIGZpZWxkcyA9IFtcclxuICAgICAgLi4uZmllbGRzLFxyXG4gICAgICB7IGlkOiBpZCsrLCBwYXJhbXMgfVxyXG4gICAgXTtcclxuICB9O1xyXG5cclxuICBjb25zdCByZW1vdmVSb3cgPSAocm93SWQpID0+IHtcclxuICAgIGZpZWxkcyA9IGZpZWxkcy5maWx0ZXIoKHsgaWQgfSkgPT4gKGlkICE9PSByb3dJZCkpO1xyXG4gIH07XHJcblxyXG4gIGxldCBmb3JtT3B0aW9ucyA9IHtcclxuICAgIHZhbGlkYXRlT25FdmVudHM6IHsgY2hhbmdlOiB0cnVlLCBpbnB1dDogZmFsc2UsIGJsdXI6IGZhbHNlIH0sXHJcbiAgICBjbGVhckVycm9yc09uRXZlbnRzOiB7IHJlc2V0OiB0cnVlLCBmb2N1czogZmFsc2UgfSxcclxuICAgIGxpc3RlbklucHV0RXZlbnRzOiAyLFxyXG4gICAgcHJlc2VuY2U6ICdvcHRpb25hbCcsXHJcbiAgICB0cmltOiBmYWxzZSxcclxuICAgIGluY2x1ZGVBbGxFbnRyaWVzOiBmYWxzZVxyXG4gIH07XHJcbiAgbGV0IGZvcm1PcHRpb25zTW9kZSA9IGZhbHNlO1xyXG4gIGxldCBmb3JtQ29kZSA9IGdldEZvcm1Db2RlKGZvcm1PcHRpb25zKTtcclxuICBsZXQgZm9ybVJlc2V0ID0gMDtcclxuICBjb25zdCBvblNhdmUgPSAoeyBkZXRhaWwgfSkgPT4ge1xyXG4gICAgZm9ybU9wdGlvbnNNb2RlID0gZmFsc2U7XHJcbiAgICBmb3JtT3B0aW9ucyA9IGRldGFpbDtcclxuXHJcbiAgICBjb25zdCBuZXdDb2RlID0gZ2V0Rm9ybUNvZGUoZm9ybU9wdGlvbnMpO1xyXG4gICAgaWYgKG5ld0NvZGUgIT09IGZvcm1Db2RlKSB7XHJcbiAgICAgIGZvcm1Db2RlID0gbmV3Q29kZTtcclxuICAgICAgY29uc3QgdmFsaWRhdGlvbiA9IGNyZWF0ZVZhbGlkYXRpb24oeyAuLi5mb3JtT3B0aW9ucyB9KTtcclxuICAgICAgY3JlYXRlRW50cnkgPSB2YWxpZGF0aW9uLmNyZWF0ZUVudHJ5O1xyXG4gICAgICBjcmVhdGVGb3JtID0gdmFsaWRhdGlvbi5jcmVhdGVGb3JtO1xyXG4gICAgICB2YWxpZGF0ZVZhbHVlU3RvcmUgPSB2YWxpZGF0aW9uLnZhbGlkYXRlVmFsdWVTdG9yZTtcclxuICAgICAgZm9ybVJlc2V0Kys7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgbGV0IHsgY3JlYXRlRW50cnksIGNyZWF0ZUZvcm0sIHZhbGlkYXRlVmFsdWVTdG9yZSB9ID0gY3JlYXRlVmFsaWRhdGlvbihmb3JtT3B0aW9ucyk7XHJcbjwvc2NyaXB0PlxyXG5cclxuPFdpZGdldD5cclxuICA8UmVzZXQgbj17Zm9ybVJlc2V0fT5cclxuICAgIDxmb3JtIHVzZTpjcmVhdGVGb3JtIG5vdmFsaWRhdGUgb246c3VibWl0fHByZXZlbnREZWZhdWx0PlxyXG4gICAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG4gICAgICB7I2lmIGZvcm1PcHRpb25zTW9kZX1cclxuICAgICAgICA8Rm9ybU9wdGlvbnNcclxuICAgICAgICAgIHtmb3JtT3B0aW9uc31cclxuICAgICAgICAgIG9uOnNhdmU9e29uU2F2ZX1cclxuICAgICAgICAgIG9uOmNhbmNlbD17KCkgPT4gKGZvcm1PcHRpb25zTW9kZSA9IGZhbHNlKX1cclxuICAgICAgICAvPlxyXG4gICAgICB7OmVsc2V9XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNvZGVcIj5cclxuICAgICAgICAgIDxDb2RlIGNvZGU9e2Zvcm1Db2RlfSBidWlsZGVyTW9kZSAvPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxCdXR0b24gb246Y2xpY2s9eygpID0+IChmb3JtT3B0aW9uc01vZGUgPSB0cnVlKX0+ZWRpdCBmb3JtIG9wdGlvbnM8L0J1dHRvbj5cclxuICAgICAgey9pZn1cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIHsjZWFjaCBmaWVsZHMgYXMgeyBpZCwgcGFyYW1zIH0gKGlkKX1cclxuICAgICAgPGRpdiBjbGFzcz1cInJvdyBmaWVsZC1yb3cgcmVtb3ZlLXJvd1wiPlxyXG4gICAgICAgIDxGaWVsZCB7cGFyYW1zfSB7Y3JlYXRlRW50cnl9IHtpZH0ge3ZhbGlkYXRlVmFsdWVTdG9yZX0+XHJcbiAgICAgICAgICA8YnV0dG9uIG9uOmNsaWNrfHByZXZlbnREZWZhdWx0PXsoKSA9PiByZW1vdmVSb3coaWQpfT5yZW1vdmU8L2J1dHRvbj5cclxuICAgICAgICA8L0ZpZWxkPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIHsvZWFjaH1cclxuXHJcbiAgICA8ZGl2IGNsYXNzPVwicm93IHBhZGRpbmdcIj5cclxuICAgICAgPE5ld0ZpZWxkIG9uOm5ld0ZpZWxkPXtvbk5ld0ZpZWxkfT5cclxuICAgICAgICB7I2lmIGZpZWxkcy5sZW5ndGh9XHJcbiAgICAgICAgICA8QnV0dG9uIHR5cGU9XCJzdWJtaXRcIj5WYWxpZGF0ZSBhbGw8L0J1dHRvbj5cclxuICAgICAgICB7L2lmfVxyXG4gICAgICA8L05ld0ZpZWxkPlxyXG4gICAgPC9kaXY+XHJcbiAgPC9mb3JtPlxyXG4gIDwvUmVzZXQ+XHJcbjwvV2lkZ2V0PlxyXG5cclxuPHN0eWxlPlxyXG4gIC5yb3cge1xyXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNiYmI7XHJcbiAgICBtYXJnaW46IDAgLTEwcHg7XHJcbiAgfVxyXG5cclxuICAucm93OmZpcnN0LWNoaWxkIHtcclxuICAgIHBhZGRpbmc6IDAgMTBweCAxMHB4O1xyXG4gIH1cclxuXHJcbiAgLnJvdzpsYXN0LWNoaWxkIHtcclxuICAgIGJvcmRlcjogMDtcclxuICAgIG1hcmdpbjogMDtcclxuICAgIHBhZGRpbmctdG9wOiAxMHB4O1xyXG4gIH1cclxuXHJcbiAgLnJlbW92ZS1yb3cgOmdsb2JhbChidXR0b24pIHtcclxuICAgIGJhY2tncm91bmQ6IG5vbmU7XHJcbiAgICBib3JkZXI6IDA7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICBjb2xvcjogI2VjNTEyYTtcclxuICAgIGZvbnQtc2l6ZTogMTJweDtcclxuICAgIGxpbmUtaGVpZ2h0OiAxOXB4O1xyXG4gICAgcGFkZGluZzogMnB4IDVweDtcclxuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XHJcbiAgfVxyXG5cclxuICAucmVtb3ZlLXJvdyA6Z2xvYmFsKGJ1dHRvbjpob3Zlcikge1xyXG4gICAgYmFja2dyb3VuZDogI2VjNTEyYTtcclxuICAgIGNvbG9yOiAjZmZmO1xyXG4gIH1cclxuXHJcbiAgLmZvcm0tcGFyYW1zIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBmbGV4LXdyYXA6IHdyYXA7XHJcbiAgICB3aWR0aDogY2FsYygxMDAlICsgMTBweCk7XHJcbiAgfVxyXG5cclxuICAuY29kZSB7XHJcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xyXG4gIH1cclxuXHJcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbk55WXk5a2IyTnpMMkoxYVd4a1pYSXZZblZwYkdSbGNpNXpkbVZzZEdVaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWp0RlFVTkZPMGxCUTBVc05rSkJRVzlETzBsQlEzQkRMR1ZCUVdVN1JVRkRha0k3TzBWQlJVRTdTVUZEUlN4dlFrRkJiMEk3UlVGRGRFSTdPMFZCUlVFN1NVRkRSU3hUUVVGVE8wbEJRMVFzVTBGQlV6dEpRVU5VTEdsQ1FVRnBRanRGUVVOdVFqczdSVUZGUVR0SlFVTkZMR2RDUVVGblFqdEpRVU5vUWl4VFFVRlRPMGxCUTFRc1pVRkJaVHRKUVVObUxHTkJRWE5DTzBsQlEzUkNMR1ZCUVdVN1NVRkRaaXhwUWtGQmFVSTdTVUZEYWtJc1owSkJRV2RDTzBsQlEyaENMSGxDUVVGNVFqdEZRVU16UWpzN1JVRkZRVHRKUVVORkxHMUNRVUV5UWp0SlFVTXpRaXhYUVVGWE8wVkJRMkk3TzBWQlJVRTdTVUZEUlN4aFFVRmhPMGxCUTJJc1pVRkJaVHRKUVVObUxIZENRVUYzUWp0RlFVTXhRanM3UlVGRlFUdEpRVU5GTEcxQ1FVRnRRanRGUVVOeVFpSXNJbVpwYkdVaU9pSnpjbU12Wkc5amN5OWlkV2xzWkdWeUwySjFhV3hrWlhJdWMzWmxiSFJsSWl3aWMyOTFjbU5sYzBOdmJuUmxiblFpT2xzaVhISmNiaUFnTG5KdmR5QjdYSEpjYmlBZ0lDQmliM0prWlhJdFltOTBkRzl0T2lBeGNIZ2djMjlzYVdRZ2RtRnlLQzB0WjNKbGVTazdYSEpjYmlBZ0lDQnRZWEpuYVc0NklEQWdMVEV3Y0hnN1hISmNiaUFnZlZ4eVhHNWNjbHh1SUNBdWNtOTNPbVpwY25OMExXTm9hV3hrSUh0Y2NseHVJQ0FnSUhCaFpHUnBibWM2SURBZ01UQndlQ0F4TUhCNE8xeHlYRzRnSUgxY2NseHVYSEpjYmlBZ0xuSnZkenBzWVhOMExXTm9hV3hrSUh0Y2NseHVJQ0FnSUdKdmNtUmxjam9nTUR0Y2NseHVJQ0FnSUcxaGNtZHBiam9nTUR0Y2NseHVJQ0FnSUhCaFpHUnBibWN0ZEc5d09pQXhNSEI0TzF4eVhHNGdJSDFjY2x4dVhISmNiaUFnTG5KbGJXOTJaUzF5YjNjZ09tZHNiMkpoYkNoaWRYUjBiMjRwSUh0Y2NseHVJQ0FnSUdKaFkydG5jbTkxYm1RNklHNXZibVU3WEhKY2JpQWdJQ0JpYjNKa1pYSTZJREE3WEhKY2JpQWdJQ0JqZFhKemIzSTZJSEJ2YVc1MFpYSTdYSEpjYmlBZ0lDQmpiMnh2Y2pvZ2RtRnlLQzB0Y21Wa1EyOXNiM0lwTzF4eVhHNGdJQ0FnWm05dWRDMXphWHBsT2lBeE1uQjRPMXh5WEc0Z0lDQWdiR2x1WlMxb1pXbG5hSFE2SURFNWNIZzdYSEpjYmlBZ0lDQndZV1JrYVc1bk9pQXljSGdnTlhCNE8xeHlYRzRnSUNBZ2RHVjRkQzEwY21GdWMyWnZjbTA2SUhWd2NHVnlZMkZ6WlR0Y2NseHVJQ0I5WEhKY2JseHlYRzRnSUM1eVpXMXZkbVV0Y205M0lEcG5iRzlpWVd3b1luVjBkRzl1T21odmRtVnlLU0I3WEhKY2JpQWdJQ0JpWVdOclozSnZkVzVrT2lCMllYSW9MUzF5WldSRGIyeHZjaWs3WEhKY2JpQWdJQ0JqYjJ4dmNqb2dJMlptWmp0Y2NseHVJQ0I5WEhKY2JseHlYRzRnSUM1bWIzSnRMWEJoY21GdGN5QjdYSEpjYmlBZ0lDQmthWE53YkdGNU9pQm1iR1Y0TzF4eVhHNGdJQ0FnWm14bGVDMTNjbUZ3T2lCM2NtRndPMXh5WEc0Z0lDQWdkMmxrZEdnNklHTmhiR01vTVRBd0pTQXJJREV3Y0hncE8xeHlYRzRnSUgxY2NseHVYSEpjYmlBZ0xtTnZaR1VnZTF4eVhHNGdJQ0FnYldGeVoybHVMV0p2ZEhSdmJUb2dNVEJ3ZUR0Y2NseHVJQ0I5WEhKY2JpSmRmUT09ICovPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9HRSxJQUFJLGVBQUMsQ0FBQyxBQUNKLGFBQWEsQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FDN0IsTUFBTSxDQUFFLENBQUMsQ0FBQyxLQUFLLEFBQ2pCLENBQUMsQUFFRCxtQkFBSSxZQUFZLEFBQUMsQ0FBQyxBQUNoQixPQUFPLENBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLEFBQ3RCLENBQUMsQUFFRCxtQkFBSSxXQUFXLEFBQUMsQ0FBQyxBQUNmLE1BQU0sQ0FBRSxDQUFDLENBQ1QsTUFBTSxDQUFFLENBQUMsQ0FDVCxXQUFXLENBQUUsSUFBSSxBQUNuQixDQUFDLEFBRUQsMEJBQVcsQ0FBQyxBQUFRLE1BQU0sQUFBRSxDQUFDLEFBQzNCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLE1BQU0sQ0FBRSxDQUFDLENBQ1QsTUFBTSxDQUFFLE9BQU8sQ0FDZixLQUFLLENBQUUsT0FBTyxDQUNkLFNBQVMsQ0FBRSxJQUFJLENBQ2YsV0FBVyxDQUFFLElBQUksQ0FDakIsT0FBTyxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQ2hCLGNBQWMsQ0FBRSxTQUFTLEFBQzNCLENBQUMsQUFFRCwwQkFBVyxDQUFDLEFBQVEsWUFBWSxBQUFFLENBQUMsQUFDakMsVUFBVSxDQUFFLE9BQU8sQ0FDbkIsS0FBSyxDQUFFLElBQUksQUFDYixDQUFDLEFBUUQsS0FBSyxlQUFDLENBQUMsQUFDTCxhQUFhLENBQUUsSUFBSSxBQUNyQixDQUFDIn0= */";
	append_dev(document.head, style);
}

function get_each_context$1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.id = list[i].id;
	child_ctx.params = list[i].params;
	return child_ctx;
}

// (73:6) {:else}
function create_else_block$5(ctx) {
	let div;
	let t;
	let current;

	const code = new Code({
			props: { code: ctx.formCode, builderMode: true },
			$$inline: true
		});

	const button = new Button({
			props: {
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button.$on("click", ctx.click_handler);

	const block = {
		c: function create() {
			div = element("div");
			create_component(code.$$.fragment);
			t = space();
			create_component(button.$$.fragment);
			attr_dev(div, "class", "code svelte-1p4n34s");
			add_location(div, file$9, 73, 8, 2110);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(code, div, null);
			insert_dev(target, t, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const code_changes = {};
			if (changed.formCode) code_changes.code = ctx.formCode;
			code.$set(code_changes);
			const button_changes = {};

			if (changed.$$scope) {
				button_changes.$$scope = { changed, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(code.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(code);
			if (detaching) detach_dev(t);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$5.name,
		type: "else",
		source: "(73:6) {:else}",
		ctx
	});

	return block;
}

// (67:6) {#if formOptionsMode}
function create_if_block_1$5(ctx) {
	let current;

	const formoptions = new Form_options({
			props: { formOptions: ctx.formOptions },
			$$inline: true
		});

	formoptions.$on("save", ctx.onSave);
	formoptions.$on("cancel", ctx.cancel_handler);

	const block = {
		c: function create() {
			create_component(formoptions.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(formoptions, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const formoptions_changes = {};
			if (changed.formOptions) formoptions_changes.formOptions = ctx.formOptions;
			formoptions.$set(formoptions_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(formoptions.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(formoptions.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(formoptions, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(67:6) {#if formOptionsMode}",
		ctx
	});

	return block;
}

// (77:8) <Button on:click={() => (formOptionsMode = true)}>
function create_default_slot_5(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("edit form options");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(77:8) <Button on:click={() => (formOptionsMode = true)}>",
		ctx
	});

	return block;
}

// (83:8) <Field {params} {createEntry} {id} {validateValueStore}>
function create_default_slot_4(ctx) {
	let button;
	let dispose;

	function click_handler_1(...args) {
		return ctx.click_handler_1(ctx, ...args);
	}

	const block = {
		c: function create() {
			button = element("button");
			button.textContent = "remove";
			add_location(button, file$9, 83, 10, 2472);
			dispose = listen_dev(button, "click", prevent_default(click_handler_1), false, false, true);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
		},
		p: function update(changed, new_ctx) {
			ctx = new_ctx;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(83:8) <Field {params} {createEntry} {id} {validateValueStore}>",
		ctx
	});

	return block;
}

// (81:4) {#each fields as { id, params }
function create_each_block$1(key_1, ctx) {
	let div;
	let current;

	const field = new Field({
			props: {
				params: ctx.params,
				createEntry: ctx.createEntry,
				id: ctx.id,
				validateValueStore: ctx.validateValueStore,
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			div = element("div");
			create_component(field.$$.fragment);
			attr_dev(div, "class", "row field-row remove-row svelte-1p4n34s");
			add_location(div, file$9, 81, 6, 2356);
			this.first = div;
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(field, div, null);
			current = true;
		},
		p: function update(changed, ctx) {
			const field_changes = {};
			if (changed.fields) field_changes.params = ctx.params;
			if (changed.createEntry) field_changes.createEntry = ctx.createEntry;
			if (changed.fields) field_changes.id = ctx.id;
			if (changed.validateValueStore) field_changes.validateValueStore = ctx.validateValueStore;

			if (changed.$$scope || changed.fields) {
				field_changes.$$scope = { changed, ctx };
			}

			field.$set(field_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(field);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(81:4) {#each fields as { id, params }",
		ctx
	});

	return block;
}

// (91:8) {#if fields.length}
function create_if_block$6(ctx) {
	let current;

	const button = new Button({
			props: {
				type: "submit",
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(91:8) {#if fields.length}",
		ctx
	});

	return block;
}

// (92:10) <Button type="submit">
function create_default_slot_3$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Validate all");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$1.name,
		type: "slot",
		source: "(92:10) <Button type=\\\"submit\\\">",
		ctx
	});

	return block;
}

// (90:6) <NewField on:newField={onNewField}>
function create_default_slot_2$1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = ctx.fields.length && create_if_block$6(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (ctx.fields.length) {
				if (!if_block) {
					if_block = create_if_block$6(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					transition_in(if_block, 1);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(90:6) <NewField on:newField={onNewField}>",
		ctx
	});

	return block;
}

// (64:2) <Reset n={formReset}>
function create_default_slot_1$2(ctx) {
	let form;
	let div0;
	let current_block_type_index;
	let if_block;
	let t0;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t1;
	let div1;
	let createForm_action;
	let current;
	let dispose;
	const if_block_creators = [create_if_block_1$5, create_else_block$5];
	const if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.formOptionsMode) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let each_value = ctx.fields;
	const get_key = ctx => ctx.id;

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$1(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
	}

	const newfield = new New_field({
			props: {
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	newfield.$on("newField", ctx.onNewField);

	const block = {
		c: function create() {
			form = element("form");
			div0 = element("div");
			if_block.c();
			t0 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			div1 = element("div");
			create_component(newfield.$$.fragment);
			attr_dev(div0, "class", "row svelte-1p4n34s");
			add_location(div0, file$9, 65, 4, 1897);
			attr_dev(div1, "class", "row padding svelte-1p4n34s");
			add_location(div1, file$9, 88, 4, 2594);
			form.noValidate = true;
			add_location(form, file$9, 64, 4, 1834);
			dispose = listen_dev(form, "submit", prevent_default(ctx.submit_handler), false, false, true);
		},
		m: function mount(target, anchor) {
			insert_dev(target, form, anchor);
			append_dev(form, div0);
			if_blocks[current_block_type_index].m(div0, null);
			append_dev(form, t0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(form, null);
			}

			append_dev(form, t1);
			append_dev(form, div1);
			mount_component(newfield, div1, null);
			createForm_action = ctx.createForm.call(null, form) || ({});
			current = true;
		},
		p: function update(changed, ctx) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div0, null);
			}

			const each_value = ctx.fields;
			group_outros();
			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, form, outro_and_destroy_block, create_each_block$1, t1, get_each_context$1);
			check_outros();
			const newfield_changes = {};

			if (changed.$$scope || changed.fields) {
				newfield_changes.$$scope = { changed, ctx };
			}

			newfield.$set(newfield_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(newfield.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(newfield.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			if_blocks[current_block_type_index].d();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			destroy_component(newfield);
			if (createForm_action && is_function(createForm_action.destroy)) createForm_action.destroy();
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(64:2) <Reset n={formReset}>",
		ctx
	});

	return block;
}

// (63:0) <Widget>
function create_default_slot$2(ctx) {
	let current;

	const reset = new Reset({
			props: {
				n: ctx.formReset,
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(reset.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(reset, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const reset_changes = {};
			if (changed.formReset) reset_changes.n = ctx.formReset;

			if (changed.$$scope || changed.fields || changed.createEntry || changed.validateValueStore || changed.formOptionsMode || changed.formOptions || changed.formCode) {
				reset_changes.$$scope = { changed, ctx };
			}

			reset.$set(reset_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(reset.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(reset.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(reset, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(63:0) <Widget>",
		ctx
	});

	return block;
}

function create_fragment$b(ctx) {
	let current;

	const widget = new Widget({
			props: {
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(widget.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(widget, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const widget_changes = {};

			if (changed.$$scope || changed.formReset || changed.fields || changed.createEntry || changed.validateValueStore || changed.formOptionsMode || changed.formOptions || changed.formCode) {
				widget_changes.$$scope = { changed, ctx };
			}

			widget.$set(widget_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(widget.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(widget.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(widget, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	let id = 0;

	let fields = [
		{
			id: id++,
			params: {
				type: "string",
				value: "",
				min: 2,
				required: true
			}
		}
	];

	const onNewField = ({ detail: params }) => {
		$$invalidate("fields", fields = [...fields, { id: id++, params }]);
	};

	const removeRow = rowId => {
		$$invalidate("fields", fields = fields.filter(({ id }) => id !== rowId));
	};

	let formOptions = {
		validateOnEvents: { change: true, input: false, blur: false },
		clearErrorsOnEvents: { reset: true, focus: false },
		listenInputEvents: 2,
		presence: "optional",
		trim: false,
		includeAllEntries: false
	};

	let formOptionsMode = false;
	let formCode = getFormCode(formOptions);
	let formReset = 0;

	const onSave = ({ detail }) => {
		$$invalidate("formOptionsMode", formOptionsMode = false);
		$$invalidate("formOptions", formOptions = detail);
		const newCode = getFormCode(formOptions);

		if (newCode !== formCode) {
			$$invalidate("formCode", formCode = newCode);
			const validation = createValidation({ ...formOptions });
			$$invalidate("createEntry", createEntry = validation.createEntry);
			$$invalidate("createForm", createForm = validation.createForm);
			$$invalidate("validateValueStore", validateValueStore = validation.validateValueStore);
			$$invalidate("formReset", formReset++, formReset);
		}
	};

	let { createEntry, createForm, validateValueStore } = createValidation(formOptions);

	function submit_handler(event) {
		bubble($$self, event);
	}

	const cancel_handler = () => $$invalidate("formOptionsMode", formOptionsMode = false);
	const click_handler = () => $$invalidate("formOptionsMode", formOptionsMode = true);
	const click_handler_1 = ({ id }) => removeRow(id);

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("id" in $$props) id = $$props.id;
		if ("fields" in $$props) $$invalidate("fields", fields = $$props.fields);
		if ("formOptions" in $$props) $$invalidate("formOptions", formOptions = $$props.formOptions);
		if ("formOptionsMode" in $$props) $$invalidate("formOptionsMode", formOptionsMode = $$props.formOptionsMode);
		if ("formCode" in $$props) $$invalidate("formCode", formCode = $$props.formCode);
		if ("formReset" in $$props) $$invalidate("formReset", formReset = $$props.formReset);
		if ("createEntry" in $$props) $$invalidate("createEntry", createEntry = $$props.createEntry);
		if ("createForm" in $$props) $$invalidate("createForm", createForm = $$props.createForm);
		if ("validateValueStore" in $$props) $$invalidate("validateValueStore", validateValueStore = $$props.validateValueStore);
	};

	return {
		fields,
		onNewField,
		removeRow,
		formOptions,
		formOptionsMode,
		formCode,
		formReset,
		onSave,
		createEntry,
		createForm,
		validateValueStore,
		submit_handler,
		cancel_handler,
		click_handler,
		click_handler_1
	};
}

class Builder extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1p4n34s-style")) add_css$9();
		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Builder",
			options,
			id: create_fragment$b.name
		});
	}
}

/* src/docs/examples/components/row.svelte generated by Svelte v3.15.0 */

const file$a = "src/docs/examples/components/row.svelte";

function add_css$a() {
	var style = element("style");
	style.id = "svelte-13ta8dq-style";
	style.textContent = ".row.svelte-13ta8dq{margin-bottom:10px}.row.svelte-13ta8dq:last-child{margin-bottom:0}label.svelte-13ta8dq{display:block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm93LnN2ZWx0ZSIsInNvdXJjZXMiOlsicm93LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxyXG4gIGV4cG9ydCBsZXQgbGFiZWxUZXh0ID0gJyc7XHJcbjwvc2NyaXB0PlxyXG5cclxuPGRpdiBjbGFzcz1cInJvd1wiPlxyXG4gIDxsYWJlbD5cclxuICAgIDxzcGFuIGNsYXNzPVwibGFiZWxcIj57bGFiZWxUZXh0fTwvc3Bhbj5cclxuICAgIDxzbG90IC8+XHJcbiAgPC9sYWJlbD5cclxuPC9kaXY+XHJcblxyXG48c3R5bGU+XHJcbiAgLnJvdyB7XHJcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xyXG4gIH1cclxuXHJcbiAgLnJvdzpsYXN0LWNoaWxkIHtcclxuICAgIG1hcmdpbi1ib3R0b206IDA7XHJcbiAgfVxyXG5cclxuICBsYWJlbCB7XHJcbiAgICBkaXNwbGF5OiBibG9jaztcclxuICB9XHJcblxyXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5OeVl5OWtiMk56TDJWNFlXMXdiR1Z6TDJOdmJYQnZibVZ1ZEhNdmNtOTNMbk4yWld4MFpTSmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU8wVkJRMFU3U1VGRFJTeHRRa0ZCYlVJN1JVRkRja0k3TzBWQlJVRTdTVUZEUlN4blFrRkJaMEk3UlVGRGJFSTdPMFZCUlVFN1NVRkRSU3hqUVVGak8wVkJRMmhDSWl3aVptbHNaU0k2SW5OeVl5OWtiMk56TDJWNFlXMXdiR1Z6TDJOdmJYQnZibVZ1ZEhNdmNtOTNMbk4yWld4MFpTSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHh5WEc0Z0lDNXliM2NnZTF4eVhHNGdJQ0FnYldGeVoybHVMV0p2ZEhSdmJUb2dNVEJ3ZUR0Y2NseHVJQ0I5WEhKY2JseHlYRzRnSUM1eWIzYzZiR0Z6ZEMxamFHbHNaQ0I3WEhKY2JpQWdJQ0J0WVhKbmFXNHRZbTkwZEc5dE9pQXdPMXh5WEc0Z0lIMWNjbHh1WEhKY2JpQWdiR0ZpWld3Z2UxeHlYRzRnSUNBZ1pHbHpjR3hoZVRvZ1lteHZZMnM3WEhKY2JpQWdmVnh5WEc0aVhYMD0gKi88L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBWUUsSUFBSSxlQUFDLENBQUMsQUFDSixhQUFhLENBQUUsSUFBSSxBQUNyQixDQUFDLEFBRUQsbUJBQUksV0FBVyxBQUFDLENBQUMsQUFDZixhQUFhLENBQUUsQ0FBQyxBQUNsQixDQUFDLEFBRUQsS0FBSyxlQUFDLENBQUMsQUFDTCxPQUFPLENBQUUsS0FBSyxBQUNoQixDQUFDIn0= */";
	append_dev(document.head, style);
}

function create_fragment$c(ctx) {
	let div;
	let label;
	let span;
	let t0;
	let t1;
	let current;
	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	const block = {
		c: function create() {
			div = element("div");
			label = element("label");
			span = element("span");
			t0 = text(ctx.labelText);
			t1 = space();
			if (default_slot) default_slot.c();
			attr_dev(span, "class", "label");
			add_location(span, file$a, 6, 4, 87);
			attr_dev(label, "class", "svelte-13ta8dq");
			add_location(label, file$a, 5, 2, 74);
			attr_dev(div, "class", "row svelte-13ta8dq");
			add_location(div, file$a, 4, 0, 53);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, label);
			append_dev(label, span);
			append_dev(span, t0);
			append_dev(label, t1);

			if (default_slot) {
				default_slot.m(label, null);
			}

			current = true;
		},
		p: function update(changed, ctx) {
			if (!current || changed.labelText) set_data_dev(t0, ctx.labelText);

			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_template, ctx, changed, null), get_slot_context(default_slot_template, ctx, null));
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	let { labelText = "" } = $$props;
	const writable_props = ["labelText"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Row> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ("labelText" in $$props) $$invalidate("labelText", labelText = $$props.labelText);
		if ("$$scope" in $$props) $$invalidate("$$scope", $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return { labelText };
	};

	$$self.$inject_state = $$props => {
		if ("labelText" in $$props) $$invalidate("labelText", labelText = $$props.labelText);
	};

	return { labelText, $$slots, $$scope };
}

class Row extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-13ta8dq-style")) add_css$a();
		init(this, options, instance$c, create_fragment$c, safe_not_equal, { labelText: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Row",
			options,
			id: create_fragment$c.name
		});
	}

	get labelText() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set labelText(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/docs/examples/components/form.svelte generated by Svelte v3.15.0 */
const file$b = "src/docs/examples/components/form.svelte";

function add_css$b() {
	var style = element("style");
	style.id = "svelte-tbefmr-style";
	style.textContent = "h1.svelte-tbefmr{border-bottom:1px solid #004cb4;color:#fff;overflow:hidden;position:relative}h1.svelte-tbefmr span.svelte-tbefmr{background:#004cb4;color:#fff;display:inline-block;padding:0 5px;position:relative;vertical-align:top}.subtitle.svelte-tbefmr{background:#004cb4;bottom:0;font-size:12px;font-style:normal;line-height:16px;left:100%;padding:1px 5px 0;position:absolute;white-space:nowrap}.barge.svelte-tbefmr{background:#004cb4;font-style:normal;padding:0 5px;position:absolute;right:0;top:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybS5zdmVsdGUiLCJzb3VyY2VzIjpbImZvcm0uc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XHJcbiAgZXhwb3J0IGxldCBjcmVhdGVGb3JtO1xyXG4gIGV4cG9ydCBsZXQgY3JlYXRlRm9ybU9wdHMgPSB7fTtcclxuICBleHBvcnQgbGV0IHRpdGxlO1xyXG4gIGV4cG9ydCBsZXQgc3VidGl0bGUgPSAnJztcclxuICBleHBvcnQgbGV0IHR5cGUgPSBmYWxzZTtcclxuICBleHBvcnQgbGV0IHJ1bGUgPSBmYWxzZTtcclxuXHJcbiAgaW1wb3J0IFdpZGdldCBmcm9tICdkb2NzL3VpL3dpZGdldC5zdmVsdGUnO1xyXG48L3NjcmlwdD5cclxuXHJcbjxXaWRnZXQ+XHJcbiAgPGZvcm0gbm92YWxpZGF0ZSB1c2U6Y3JlYXRlRm9ybT17Y3JlYXRlRm9ybU9wdHN9IG9uOnN1Ym1pdHxwcmV2ZW50RGVmYXVsdD5cclxuICAgIDxoMT5cclxuICAgIDxzcGFuPlxyXG4gICAgICB7dGl0bGV9XHJcbiAgICAgIHsjaWYgc3VidGl0bGV9XHJcbiAgICAgICAgPGkgY2xhc3M9XCJzdWJ0aXRsZVwiPntzdWJ0aXRsZX08L2k+XHJcbiAgICAgIHsvaWZ9XHJcbiAgICA8L3NwYW4+XHJcblxyXG4gICAgICB7I2lmIHR5cGV9PGkgY2xhc3M9XCJiYXJnZVwiPnR5cGU8L2k+ey9pZn1cclxuICAgICAgeyNpZiBydWxlfTxpIGNsYXNzPVwiYmFyZ2VcIj5ydWxlPC9pPnsvaWZ9XHJcbiAgICA8L2gxPlxyXG4gICAgPHNsb3QgLz5cclxuICA8L2Zvcm0+XHJcbjwvV2lkZ2V0PlxyXG5cclxuPHN0eWxlPlxyXG4gIGgxIHtcclxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjMDA0Y2I0O1xyXG4gICAgY29sb3I6ICNmZmY7XHJcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gIH1cclxuXHJcbiAgaDEgc3BhbiB7XHJcbiAgICBiYWNrZ3JvdW5kOiAjMDA0Y2I0O1xyXG4gICAgY29sb3I6ICNmZmY7XHJcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICBwYWRkaW5nOiAwIDVweDtcclxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XHJcbiAgfVxyXG5cclxuICAuc3VidGl0bGUge1xyXG4gICAgYmFja2dyb3VuZDogIzAwNGNiNDtcclxuICAgIGJvdHRvbTogMDtcclxuICAgIGZvbnQtc2l6ZTogMTJweDtcclxuICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcclxuICAgIGxpbmUtaGVpZ2h0OiAxNnB4O1xyXG4gICAgbGVmdDogMTAwJTtcclxuICAgIHBhZGRpbmc6IDFweCA1cHggMDtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XHJcbiAgfVxyXG5cclxuICAuYmFyZ2Uge1xyXG4gICAgYmFja2dyb3VuZDogIzAwNGNiNDtcclxuICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcclxuICAgIHBhZGRpbmc6IDAgNXB4O1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgcmlnaHQ6IDA7XHJcbiAgICB0b3A6IDA7XHJcbiAgfVxyXG5cclxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluTnlZeTlrYjJOekwyVjRZVzF3YkdWekwyTnZiWEJ2Ym1WdWRITXZabTl5YlM1emRtVnNkR1VpWFN3aWJtRnRaWE1pT2x0ZExDSnRZWEJ3YVc1bmN5STZJanRGUVVORk8wbEJRMFVzWjBOQlFYbERPMGxCUTNwRExGZEJRVmM3U1VGRFdDeG5Ra0ZCWjBJN1NVRkRhRUlzYTBKQlFXdENPMFZCUTNCQ096dEZRVVZCTzBsQlEwVXNiVUpCUVRSQ08wbEJRelZDTEZkQlFWYzdTVUZEV0N4eFFrRkJjVUk3U1VGRGNrSXNZMEZCWXp0SlFVTmtMR3RDUVVGclFqdEpRVU5zUWl4dFFrRkJiVUk3UlVGRGNrSTdPMFZCUlVFN1NVRkRSU3h0UWtGQk5FSTdTVUZETlVJc1UwRkJVenRKUVVOVUxHVkJRV1U3U1VGRFppeHJRa0ZCYTBJN1NVRkRiRUlzYVVKQlFXbENPMGxCUTJwQ0xGVkJRVlU3U1VGRFZpeHJRa0ZCYTBJN1NVRkRiRUlzYTBKQlFXdENPMGxCUTJ4Q0xHMUNRVUZ0UWp0RlFVTnlRanM3UlVGRlFUdEpRVU5GTEcxQ1FVRTBRanRKUVVNMVFpeHJRa0ZCYTBJN1NVRkRiRUlzWTBGQll6dEpRVU5rTEd0Q1FVRnJRanRKUVVOc1FpeFJRVUZSTzBsQlExSXNUVUZCVFR0RlFVTlNJaXdpWm1sc1pTSTZJbk55WXk5a2IyTnpMMlY0WVcxd2JHVnpMMk52YlhCdmJtVnVkSE12Wm05eWJTNXpkbVZzZEdVaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SmNjbHh1SUNCb01TQjdYSEpjYmlBZ0lDQmliM0prWlhJdFltOTBkRzl0T2lBeGNIZ2djMjlzYVdRZ2RtRnlLQzB0YldGcGJrTnZiRzl5S1R0Y2NseHVJQ0FnSUdOdmJHOXlPaUFqWm1abU8xeHlYRzRnSUNBZ2IzWmxjbVpzYjNjNklHaHBaR1JsYmp0Y2NseHVJQ0FnSUhCdmMybDBhVzl1T2lCeVpXeGhkR2wyWlR0Y2NseHVJQ0I5WEhKY2JseHlYRzRnSUdneElITndZVzRnZTF4eVhHNGdJQ0FnWW1GamEyZHliM1Z1WkRvZ2RtRnlLQzB0YldGcGJrTnZiRzl5S1R0Y2NseHVJQ0FnSUdOdmJHOXlPaUFqWm1abU8xeHlYRzRnSUNBZ1pHbHpjR3hoZVRvZ2FXNXNhVzVsTFdKc2IyTnJPMXh5WEc0Z0lDQWdjR0ZrWkdsdVp6b2dNQ0ExY0hnN1hISmNiaUFnSUNCd2IzTnBkR2x2YmpvZ2NtVnNZWFJwZG1VN1hISmNiaUFnSUNCMlpYSjBhV05oYkMxaGJHbG5iam9nZEc5d08xeHlYRzRnSUgxY2NseHVYSEpjYmlBZ0xuTjFZblJwZEd4bElIdGNjbHh1SUNBZ0lHSmhZMnRuY205MWJtUTZJSFpoY2lndExXMWhhVzVEYjJ4dmNpazdYSEpjYmlBZ0lDQmliM1IwYjIwNklEQTdYSEpjYmlBZ0lDQm1iMjUwTFhOcGVtVTZJREV5Y0hnN1hISmNiaUFnSUNCbWIyNTBMWE4wZVd4bE9pQnViM0p0WVd3N1hISmNiaUFnSUNCc2FXNWxMV2hsYVdkb2REb2dNVFp3ZUR0Y2NseHVJQ0FnSUd4bFpuUTZJREV3TUNVN1hISmNiaUFnSUNCd1lXUmthVzVuT2lBeGNIZ2dOWEI0SURBN1hISmNiaUFnSUNCd2IzTnBkR2x2YmpvZ1lXSnpiMngxZEdVN1hISmNiaUFnSUNCM2FHbDBaUzF6Y0dGalpUb2dibTkzY21Gd08xeHlYRzRnSUgxY2NseHVYSEpjYmlBZ0xtSmhjbWRsSUh0Y2NseHVJQ0FnSUdKaFkydG5jbTkxYm1RNklIWmhjaWd0TFcxaGFXNURiMnh2Y2lrN1hISmNiaUFnSUNCbWIyNTBMWE4wZVd4bE9pQnViM0p0WVd3N1hISmNiaUFnSUNCd1lXUmthVzVuT2lBd0lEVndlRHRjY2x4dUlDQWdJSEJ2YzJsMGFXOXVPaUJoWW5OdmJIVjBaVHRjY2x4dUlDQWdJSEpwWjJoME9pQXdPMXh5WEc0Z0lDQWdkRzl3T2lBd08xeHlYRzRnSUgxY2NseHVJbDE5ICovPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTZCRSxFQUFFLGNBQUMsQ0FBQyxBQUNGLGFBQWEsQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FDaEMsS0FBSyxDQUFFLElBQUksQ0FDWCxRQUFRLENBQUUsTUFBTSxDQUNoQixRQUFRLENBQUUsUUFBUSxBQUNwQixDQUFDLEFBRUQsZ0JBQUUsQ0FBQyxJQUFJLGNBQUMsQ0FBQyxBQUNQLFVBQVUsQ0FBRSxPQUFPLENBQ25CLEtBQUssQ0FBRSxJQUFJLENBQ1gsT0FBTyxDQUFFLFlBQVksQ0FDckIsT0FBTyxDQUFFLENBQUMsQ0FBQyxHQUFHLENBQ2QsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsY0FBYyxDQUFFLEdBQUcsQUFDckIsQ0FBQyxBQUVELFNBQVMsY0FBQyxDQUFDLEFBQ1QsVUFBVSxDQUFFLE9BQU8sQ0FDbkIsTUFBTSxDQUFFLENBQUMsQ0FDVCxTQUFTLENBQUUsSUFBSSxDQUNmLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLElBQUksQ0FBRSxJQUFJLENBQ1YsT0FBTyxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUNsQixRQUFRLENBQUUsUUFBUSxDQUNsQixXQUFXLENBQUUsTUFBTSxBQUNyQixDQUFDLEFBRUQsTUFBTSxjQUFDLENBQUMsQUFDTixVQUFVLENBQUUsT0FBTyxDQUNuQixVQUFVLENBQUUsTUFBTSxDQUNsQixPQUFPLENBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FDZCxRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsQ0FBQyxDQUNSLEdBQUcsQ0FBRSxDQUFDLEFBQ1IsQ0FBQyJ9 */";
	append_dev(document.head, style);
}

// (17:6) {#if subtitle}
function create_if_block_2$4(ctx) {
	let i;
	let t;

	const block = {
		c: function create() {
			i = element("i");
			t = text(ctx.subtitle);
			attr_dev(i, "class", "subtitle svelte-tbefmr");
			add_location(i, file$b, 17, 8, 394);
		},
		m: function mount(target, anchor) {
			insert_dev(target, i, anchor);
			append_dev(i, t);
		},
		p: function update(changed, ctx) {
			if (changed.subtitle) set_data_dev(t, ctx.subtitle);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$4.name,
		type: "if",
		source: "(17:6) {#if subtitle}",
		ctx
	});

	return block;
}

// (22:6) {#if type}
function create_if_block_1$6(ctx) {
	let i;

	const block = {
		c: function create() {
			i = element("i");
			i.textContent = "type";
			attr_dev(i, "class", "barge svelte-tbefmr");
			add_location(i, file$b, 21, 16, 474);
		},
		m: function mount(target, anchor) {
			insert_dev(target, i, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$6.name,
		type: "if",
		source: "(22:6) {#if type}",
		ctx
	});

	return block;
}

// (23:6) {#if rule}
function create_if_block$7(ctx) {
	let i;

	const block = {
		c: function create() {
			i = element("i");
			i.textContent = "rule";
			attr_dev(i, "class", "barge svelte-tbefmr");
			add_location(i, file$b, 22, 16, 522);
		},
		m: function mount(target, anchor) {
			insert_dev(target, i, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(23:6) {#if rule}",
		ctx
	});

	return block;
}

// (12:0) <Widget>
function create_default_slot$3(ctx) {
	let form;
	let h1;
	let span;
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let createForm_action;
	let current;
	let dispose;
	let if_block0 = ctx.subtitle && create_if_block_2$4(ctx);
	let if_block1 = ctx.type && create_if_block_1$6(ctx);
	let if_block2 = ctx.rule && create_if_block$7(ctx);
	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	const block = {
		c: function create() {
			form = element("form");
			h1 = element("h1");
			span = element("span");
			t0 = text(ctx.title);
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (default_slot) default_slot.c();
			attr_dev(span, "class", "svelte-tbefmr");
			add_location(span, file$b, 14, 4, 341);
			attr_dev(h1, "class", "svelte-tbefmr");
			add_location(h1, file$b, 13, 4, 331);
			form.noValidate = true;
			add_location(form, file$b, 12, 2, 251);
			dispose = listen_dev(form, "submit", prevent_default(ctx.submit_handler), false, false, true);
		},
		m: function mount(target, anchor) {
			insert_dev(target, form, anchor);
			append_dev(form, h1);
			append_dev(h1, span);
			append_dev(span, t0);
			append_dev(span, t1);
			if (if_block0) if_block0.m(span, null);
			append_dev(h1, t2);
			if (if_block1) if_block1.m(h1, null);
			append_dev(h1, t3);
			if (if_block2) if_block2.m(h1, null);
			append_dev(form, t4);

			if (default_slot) {
				default_slot.m(form, null);
			}

			createForm_action = ctx.createForm.call(null, form, ctx.createFormOpts) || ({});
			current = true;
		},
		p: function update(changed, ctx) {
			if (!current || changed.title) set_data_dev(t0, ctx.title);

			if (ctx.subtitle) {
				if (if_block0) {
					if_block0.p(changed, ctx);
				} else {
					if_block0 = create_if_block_2$4(ctx);
					if_block0.c();
					if_block0.m(span, null);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (ctx.type) {
				if (!if_block1) {
					if_block1 = create_if_block_1$6(ctx);
					if_block1.c();
					if_block1.m(h1, t3);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (ctx.rule) {
				if (!if_block2) {
					if_block2 = create_if_block$7(ctx);
					if_block2.c();
					if_block2.m(h1, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_template, ctx, changed, null), get_slot_context(default_slot_template, ctx, null));
			}

			if (is_function(createForm_action.update) && changed.createFormOpts) createForm_action.update.call(null, ctx.createFormOpts);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (default_slot) default_slot.d(detaching);
			if (createForm_action && is_function(createForm_action.destroy)) createForm_action.destroy();
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(12:0) <Widget>",
		ctx
	});

	return block;
}

function create_fragment$d(ctx) {
	let current;

	const widget = new Widget({
			props: {
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(widget.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(widget, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const widget_changes = {};

			if (changed.$$scope || changed.createFormOpts || changed.rule || changed.type || changed.subtitle || changed.title) {
				widget_changes.$$scope = { changed, ctx };
			}

			widget.$set(widget_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(widget.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(widget.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(widget, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	let { createForm } = $$props;
	let { createFormOpts = {} } = $$props;
	let { title } = $$props;
	let { subtitle = "" } = $$props;
	let { type = false } = $$props;
	let { rule = false } = $$props;
	const writable_props = ["createForm", "createFormOpts", "title", "subtitle", "type", "rule"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Form> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	function submit_handler(event) {
		bubble($$self, event);
	}

	$$self.$set = $$props => {
		if ("createForm" in $$props) $$invalidate("createForm", createForm = $$props.createForm);
		if ("createFormOpts" in $$props) $$invalidate("createFormOpts", createFormOpts = $$props.createFormOpts);
		if ("title" in $$props) $$invalidate("title", title = $$props.title);
		if ("subtitle" in $$props) $$invalidate("subtitle", subtitle = $$props.subtitle);
		if ("type" in $$props) $$invalidate("type", type = $$props.type);
		if ("rule" in $$props) $$invalidate("rule", rule = $$props.rule);
		if ("$$scope" in $$props) $$invalidate("$$scope", $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return {
			createForm,
			createFormOpts,
			title,
			subtitle,
			type,
			rule
		};
	};

	$$self.$inject_state = $$props => {
		if ("createForm" in $$props) $$invalidate("createForm", createForm = $$props.createForm);
		if ("createFormOpts" in $$props) $$invalidate("createFormOpts", createFormOpts = $$props.createFormOpts);
		if ("title" in $$props) $$invalidate("title", title = $$props.title);
		if ("subtitle" in $$props) $$invalidate("subtitle", subtitle = $$props.subtitle);
		if ("type" in $$props) $$invalidate("type", type = $$props.type);
		if ("rule" in $$props) $$invalidate("rule", rule = $$props.rule);
	};

	return {
		createForm,
		createFormOpts,
		title,
		subtitle,
		type,
		rule,
		submit_handler,
		$$slots,
		$$scope
	};
}

class Form extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-tbefmr-style")) add_css$b();

		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
			createForm: 0,
			createFormOpts: 0,
			title: 0,
			subtitle: 0,
			type: 0,
			rule: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Form",
			options,
			id: create_fragment$d.name
		});

		const { ctx } = this.$$;
		const props = options.props || ({});

		if (ctx.createForm === undefined && !("createForm" in props)) {
			console.warn("<Form> was created without expected prop 'createForm'");
		}

		if (ctx.title === undefined && !("title" in props)) {
			console.warn("<Form> was created without expected prop 'title'");
		}
	}

	get createForm() {
		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set createForm(value) {
		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get createFormOpts() {
		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set createFormOpts(value) {
		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtitle() {
		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtitle(value) {
		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get rule() {
		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set rule(value) {
		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/docs/examples/string.svelte generated by Svelte v3.15.0 */

const { Error: Error_1$2 } = globals;
const file$c = "src/docs/examples/string.svelte";

// (32:2) <Row>
function create_default_slot_2$2(ctx) {
	let input;
	let inputMin_action;
	let t;
	let current;
	let dispose;

	const error = new Error$1({
			props: {
				errors: ctx.errorsMin,
				errorCode: "min",
				errorText: "Use at least 3 symbols"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input = element("input");
			t = space();
			create_component(error.$$.fragment);
			attr_dev(input, "class", "input-text");
			attr_dev(input, "placeholder", "type: 'string', min: 3");
			add_location(input, file$c, 32, 4, 1213);
			dispose = listen_dev(input, "input", ctx.input_input_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, ctx.$valueMin);
			inputMin_action = ctx.inputMin.call(null, input) || ({});
			insert_dev(target, t, anchor);
			mount_component(error, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$valueMin && input.value !== ctx.$valueMin) {
				set_input_value(input, ctx.$valueMin);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (inputMin_action && is_function(inputMin_action.destroy)) inputMin_action.destroy();
			if (detaching) detach_dev(t);
			destroy_component(error, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$2.name,
		type: "slot",
		source: "(32:2) <Row>",
		ctx
	});

	return block;
}

// (36:2) <Row>
function create_default_slot_1$3(ctx) {
	let input;
	let inputMax_action;
	let t0;
	let t1;
	let current;
	let dispose;

	const error0 = new Error$1({
			props: {
				errors: ctx.errorsMax,
				errorCode: "max",
				errorText: "Use 5 or less symbols"
			},
			$$inline: true
		});

	const error1 = new Error$1({
			props: {
				errors: ctx.errorsMax,
				errorCode: "required"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input = element("input");
			t0 = space();
			create_component(error0.$$.fragment);
			t1 = space();
			create_component(error1.$$.fragment);
			attr_dev(input, "class", "input-text");
			attr_dev(input, "placeholder", "type: 'string', max: 5, required: true");
			add_location(input, file$c, 36, 4, 1424);
			dispose = listen_dev(input, "input", ctx.input_input_handler_1);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, ctx.$valueMax);
			inputMax_action = ctx.inputMax.call(null, input) || ({});
			insert_dev(target, t0, anchor);
			mount_component(error0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(error1, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$valueMax && input.value !== ctx.$valueMax) {
				set_input_value(input, ctx.$valueMax);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error0.$$.fragment, local);
			transition_in(error1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error0.$$.fragment, local);
			transition_out(error1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (inputMax_action && is_function(inputMax_action.destroy)) inputMax_action.destroy();
			if (detaching) detach_dev(t0);
			destroy_component(error0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(error1, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$3.name,
		type: "slot",
		source: "(36:2) <Row>",
		ctx
	});

	return block;
}

// (19:0) <Form {createForm} title="string" subtitle="min, max, between" type>
function create_default_slot$4(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let current;

	const code0 = new Code({
			props: {
				code: `const [
  [ errorsMin, valueMin, inputMin ],
  [ errorsMax, valueMax, inputMax ]
] = createEntries([
  { type: 'string', min: 3 },
  { type: 'string', max: 5, required: true },
]);`
			},
			$$inline: true
		});

	const code1 = new Code({
			props: {
				code: `<input use:inputMin bind:value={$valueMin} />
{#if $errorsMin.includes('min')}Use at least 3 symbols{/if}
<input use:inputMax bind:value={$valueMax} />
{#if $errorsMax.includes('max')}Use 5 or less symbols{/if}
{#if $errorsMax.includes('required')}This field is required{/if}`
			},
			$$inline: true
		});

	const row0 = new Row({
			props: {
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const row1 = new Row({
			props: {
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const button = new Button({
			props: { type: "submit" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(code0.$$.fragment);
			t0 = space();
			create_component(code1.$$.fragment);
			t1 = space();
			create_component(row0.$$.fragment);
			t2 = space();
			create_component(row1.$$.fragment);
			t3 = space();
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(code0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(code1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(row0, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(row1, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const row0_changes = {};

			if (changed.$$scope || changed.$valueMin) {
				row0_changes.$$scope = { changed, ctx };
			}

			row0.$set(row0_changes);
			const row1_changes = {};

			if (changed.$$scope || changed.$valueMax) {
				row1_changes.$$scope = { changed, ctx };
			}

			row1.$set(row1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			transition_in(row0.$$.fragment, local);
			transition_in(row1.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			transition_out(row0.$$.fragment, local);
			transition_out(row1.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(code1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(row0, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(row1, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(19:0) <Form {createForm} title=\\\"string\\\" subtitle=\\\"min, max, between\\\" type>",
		ctx
	});

	return block;
}

function create_fragment$e(ctx) {
	let current;

	const form = new Form({
			props: {
				createForm: ctx.createForm,
				title: "string",
				subtitle: "min, max, between",
				type: true,
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(form.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$2("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const form_changes = {};

			if (changed.$$scope || changed.$valueMax || changed.$valueMin) {
				form_changes.$$scope = { changed, ctx };
			}

			form.$set(form_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	let $valueMin;
	let $valueMax;
	const { createEntries, createForm } = createValidation({ validateOnEvents: { input: true } });
	const [[errorsMin, valueMin, inputMin], [errorsMax, valueMax, inputMax]] = createEntries([{ type: "string", min: 3 }, { type: "string", max: 5, required: true }]);
	validate_store(valueMin, "valueMin");
	component_subscribe($$self, valueMin, value => $$invalidate("$valueMin", $valueMin = value));
	validate_store(valueMax, "valueMax");
	component_subscribe($$self, valueMax, value => $$invalidate("$valueMax", $valueMax = value));

	function input_input_handler() {
		$valueMin = this.value;
		valueMin.set($valueMin);
	}

	function input_input_handler_1() {
		$valueMax = this.value;
		valueMax.set($valueMax);
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("$valueMin" in $$props) valueMin.set($valueMin = $$props.$valueMin);
		if ("$valueMax" in $$props) valueMax.set($valueMax = $$props.$valueMax);
	};

	return {
		createForm,
		errorsMin,
		valueMin,
		inputMin,
		errorsMax,
		valueMax,
		inputMax,
		$valueMin,
		$valueMax,
		input_input_handler,
		input_input_handler_1
	};
}

class String$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "String",
			options,
			id: create_fragment$e.name
		});
	}
}

/* src/docs/examples/email.svelte generated by Svelte v3.15.0 */

const { Error: Error_1$3 } = globals;
const file$d = "src/docs/examples/email.svelte";

// (26:2) <Row labelText="Type your email">
function create_default_slot_1$4(ctx) {
	let input_1;
	let input_action;
	let t0;
	let t1;
	let current;
	let dispose;

	const error0 = new Error$1({
			props: {
				errors: ctx.errors,
				errorCode: "required"
			},
			$$inline: true
		});

	const error1 = new Error$1({
			props: {
				errors: ctx.errors,
				errorCode: "type",
				errorText: "Use valid email"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input_1 = element("input");
			t0 = space();
			create_component(error0.$$.fragment);
			t1 = space();
			create_component(error1.$$.fragment);
			attr_dev(input_1, "class", "input-text");
			attr_dev(input_1, "type", "email");
			attr_dev(input_1, "placeholder", "type: 'email', required: true");
			add_location(input_1, file$d, 26, 4, 932);
			dispose = listen_dev(input_1, "input", ctx.input_1_input_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			set_input_value(input_1, ctx.$value);
			input_action = ctx.input.call(null, input_1) || ({});
			insert_dev(target, t0, anchor);
			mount_component(error0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(error1, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$value && input_1.value !== ctx.$value) {
				set_input_value(input_1, ctx.$value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error0.$$.fragment, local);
			transition_in(error1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error0.$$.fragment, local);
			transition_out(error1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			if (input_action && is_function(input_action.destroy)) input_action.destroy();
			if (detaching) detach_dev(t0);
			destroy_component(error0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(error1, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$4.name,
		type: "slot",
		source: "(26:2) <Row labelText=\\\"Type your email\\\">",
		ctx
	});

	return block;
}

// (23:0) <Form {createForm} title="email" type>
function create_default_slot$5(ctx) {
	let t0;
	let t1;
	let t2;
	let current;

	const code0 = new Code({
			props: { code: ctx.htmlCode },
			$$inline: true
		});

	const code1 = new Code({
			props: { code: ctx.jsCode },
			$$inline: true
		});

	const row = new Row({
			props: {
				labelText: "Type your email",
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const button = new Button({
			props: { type: "submit" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(code0.$$.fragment);
			t0 = space();
			create_component(code1.$$.fragment);
			t1 = space();
			create_component(row.$$.fragment);
			t2 = space();
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(code0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(code1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(row, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const row_changes = {};

			if (changed.$$scope || changed.$value) {
				row_changes.$$scope = { changed, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			transition_in(row.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			transition_out(row.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(code1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(row, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$5.name,
		type: "slot",
		source: "(23:0) <Form {createForm} title=\\\"email\\\" type>",
		ctx
	});

	return block;
}

function create_fragment$f(ctx) {
	let current;

	const form = new Form({
			props: {
				createForm: ctx.createForm,
				title: "email",
				type: true,
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(form.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$3("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const form_changes = {};

			if (changed.$$scope || changed.$value) {
				form_changes.$$scope = { changed, ctx };
			}

			form.$set(form_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	let $value;
	const { createEntry, createForm } = createValidation({ validateOnEvents: { input: true } });
	const [errors, value, input] = createEntry({ type: "email", required: true });
	validate_store(value, "value");
	component_subscribe($$self, value, value => $$invalidate("$value", $value = value));

	const htmlCode = `const [ errors, value, input ] = createEntry({
  type: 'email', required: true
});`;

	const jsCode = `<input use:input bind:value={$value} />
{#if $errors.includes('type')}Use valid email{/if}
{#if $errors.includes('required')}This field is required{/if}`;

	function input_1_input_handler() {
		$value = this.value;
		value.set($value);
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("$value" in $$props) value.set($value = $$props.$value);
	};

	return {
		createForm,
		errors,
		value,
		input,
		htmlCode,
		jsCode,
		$value,
		input_1_input_handler
	};
}

class Email extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Email",
			options,
			id: create_fragment$f.name
		});
	}
}

/* src/docs/examples/number.svelte generated by Svelte v3.15.0 */

const { Error: Error_1$4 } = globals;
const file$e = "src/docs/examples/number.svelte";

// (37:2) <Row labelText="Type your age #1">
function create_default_slot_2$3(ctx) {
	let input;
	let input_updating = false;
	let inputMin_action;
	let t0;
	let t1;
	let current;
	let dispose;

	function input_input_handler() {
		input_updating = true;
		ctx.input_input_handler.call(input);
	}

	const error0 = new Error$1({
			props: {
				errors: ctx.errorsMin,
				errorCode: "required"
			},
			$$inline: true
		});

	const error1 = new Error$1({
			props: {
				errors: ctx.errorsMin,
				errorCode: "min",
				errorText: "For boomers only!"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input = element("input");
			t0 = space();
			create_component(error0.$$.fragment);
			t1 = space();
			create_component(error1.$$.fragment);
			attr_dev(input, "class", "input-text");
			attr_dev(input, "type", "number");
			attr_dev(input, "placeholder", "type: 'number', min: 18, required: true");
			add_location(input, file$e, 37, 4, 1422);
			dispose = listen_dev(input, "input", input_input_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, ctx.$valueMin);
			inputMin_action = ctx.inputMin.call(null, input) || ({});
			insert_dev(target, t0, anchor);
			mount_component(error0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(error1, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (!input_updating && changed.$valueMin) {
				set_input_value(input, ctx.$valueMin);
			}

			input_updating = false;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error0.$$.fragment, local);
			transition_in(error1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error0.$$.fragment, local);
			transition_out(error1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (inputMin_action && is_function(inputMin_action.destroy)) inputMin_action.destroy();
			if (detaching) detach_dev(t0);
			destroy_component(error0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(error1, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$3.name,
		type: "slot",
		source: "(37:2) <Row labelText=\\\"Type your age #1\\\">",
		ctx
	});

	return block;
}

// (42:2) <Row labelText="Type your age #2">
function create_default_slot_1$5(ctx) {
	let input;
	let input_updating = false;
	let inputMax_action;
	let t0;
	let t1;
	let current;
	let dispose;

	function input_input_handler_1() {
		input_updating = true;
		ctx.input_input_handler_1.call(input);
	}

	const error0 = new Error$1({
			props: {
				errors: ctx.errorsMax,
				errorCode: "required"
			},
			$$inline: true
		});

	const error1 = new Error$1({
			props: {
				errors: ctx.errorsMax,
				errorCode: "max",
				errorText: "Not for boomers!"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input = element("input");
			t0 = space();
			create_component(error0.$$.fragment);
			t1 = space();
			create_component(error1.$$.fragment);
			attr_dev(input, "class", "input-text");
			attr_dev(input, "type", "number");
			attr_dev(input, "placeholder", "type: 'number', max: 18, required: true");
			add_location(input, file$e, 42, 4, 1743);
			dispose = listen_dev(input, "input", input_input_handler_1);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, ctx.$valueMax);
			inputMax_action = ctx.inputMax.call(null, input) || ({});
			insert_dev(target, t0, anchor);
			mount_component(error0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(error1, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (!input_updating && changed.$valueMax) {
				set_input_value(input, ctx.$valueMax);
			}

			input_updating = false;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error0.$$.fragment, local);
			transition_in(error1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error0.$$.fragment, local);
			transition_out(error1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (inputMax_action && is_function(inputMax_action.destroy)) inputMax_action.destroy();
			if (detaching) detach_dev(t0);
			destroy_component(error0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(error1, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$5.name,
		type: "slot",
		source: "(42:2) <Row labelText=\\\"Type your age #2\\\">",
		ctx
	});

	return block;
}

// (34:0) <Form {createForm} title="number" subtitle="min, max, between" type>
function create_default_slot$6(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let current;

	const code0 = new Code({
			props: { code: ctx.jsCode },
			$$inline: true
		});

	const code1 = new Code({
			props: { code: ctx.htmlCode },
			$$inline: true
		});

	const row0 = new Row({
			props: {
				labelText: "Type your age #1",
				$$slots: { default: [create_default_slot_2$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const row1 = new Row({
			props: {
				labelText: "Type your age #2",
				$$slots: { default: [create_default_slot_1$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const button = new Button({
			props: { type: "submit" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(code0.$$.fragment);
			t0 = space();
			create_component(code1.$$.fragment);
			t1 = space();
			create_component(row0.$$.fragment);
			t2 = space();
			create_component(row1.$$.fragment);
			t3 = space();
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(code0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(code1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(row0, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(row1, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const row0_changes = {};

			if (changed.$$scope || changed.$valueMin) {
				row0_changes.$$scope = { changed, ctx };
			}

			row0.$set(row0_changes);
			const row1_changes = {};

			if (changed.$$scope || changed.$valueMax) {
				row1_changes.$$scope = { changed, ctx };
			}

			row1.$set(row1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			transition_in(row0.$$.fragment, local);
			transition_in(row1.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			transition_out(row0.$$.fragment, local);
			transition_out(row1.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(code1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(row0, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(row1, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$6.name,
		type: "slot",
		source: "(34:0) <Form {createForm} title=\\\"number\\\" subtitle=\\\"min, max, between\\\" type>",
		ctx
	});

	return block;
}

function create_fragment$g(ctx) {
	let current;

	const form = new Form({
			props: {
				createForm: ctx.createForm,
				title: "number",
				subtitle: "min, max, between",
				type: true,
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(form.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$4("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const form_changes = {};

			if (changed.$$scope || changed.$valueMax || changed.$valueMin) {
				form_changes.$$scope = { changed, ctx };
			}

			form.$set(form_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$g($$self, $$props, $$invalidate) {
	let $valueMin;
	let $valueMax;
	const { createEntries, createForm } = createValidation({ validateOnEvents: { input: true } });

	const [[errorsMin, valueMin, inputMin], [errorsMax, valueMax, inputMax]] = createEntries([
		{ type: "number", min: 18, required: true },
		{ type: "number", max: 18, required: true }
	]);

	validate_store(valueMin, "valueMin");
	component_subscribe($$self, valueMin, value => $$invalidate("$valueMin", $valueMin = value));
	validate_store(valueMax, "valueMax");
	component_subscribe($$self, valueMax, value => $$invalidate("$valueMax", $valueMax = value));

	const jsCode = `const [
  [ errorsMin, valueMin, inputMin ],
  [ errorsMax, valueMax, inputMax ],
] = createEntries([
  { type: 'number', min: 18, required: true },
  { type: 'number', max: 18, required: true }
]);`;

	const htmlCode = `<input use:inputMin bind:value={$valueMin} type="number" />
{#if $errorsMin.includes('required')}This field is required{/if}
{#if $errorsMin.includes('min')}For boomers only!{/if}
<input use:inputMax bind:value={$valueMax} type="number" />
{#if $errorsMax.includes('required')}This field is required{/if}
{#if $errorsMax.includes('max')}Not for boomers!{/if}`;

	function input_input_handler() {
		$valueMin = to_number(this.value);
		valueMin.set($valueMin);
	}

	function input_input_handler_1() {
		$valueMax = to_number(this.value);
		valueMax.set($valueMax);
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("$valueMin" in $$props) valueMin.set($valueMin = $$props.$valueMin);
		if ("$valueMax" in $$props) valueMax.set($valueMax = $$props.$valueMax);
	};

	return {
		createForm,
		errorsMin,
		valueMin,
		inputMin,
		errorsMax,
		valueMax,
		inputMax,
		jsCode,
		htmlCode,
		$valueMin,
		$valueMax,
		input_input_handler,
		input_input_handler_1
	};
}

class Number extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Number",
			options,
			id: create_fragment$g.name
		});
	}
}

/* src/docs/examples/boolean.svelte generated by Svelte v3.15.0 */

const { Error: Error_1$5 } = globals;
const file$f = "src/docs/examples/boolean.svelte";

// (25:0) <Form {createForm} title="boolean" type>
function create_default_slot$7(ctx) {
	let t0;
	let t1;
	let div;
	let label;
	let input_1;
	let input_action;
	let t2;
	let t3;
	let t4;
	let current;
	let dispose;

	const code0 = new Code({
			props: { code: ctx.jsCode },
			$$inline: true
		});

	const code1 = new Code({
			props: { code: ctx.htmlCode },
			$$inline: true
		});

	const error = new Error$1({
			props: {
				errors: ctx.errors,
				errorCode: "required",
				errorText: "Please check"
			},
			$$inline: true
		});

	const button = new Button({
			props: { type: "submit" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(code0.$$.fragment);
			t0 = space();
			create_component(code1.$$.fragment);
			t1 = space();
			div = element("div");
			label = element("label");
			input_1 = element("input");
			t2 = text(" Are you agree?");
			t3 = space();
			create_component(error.$$.fragment);
			t4 = space();
			create_component(button.$$.fragment);
			attr_dev(input_1, "class", "input-choice");
			attr_dev(input_1, "type", "checkbox");
			add_location(input_1, file$f, 28, 11, 874);
			add_location(label, file$f, 28, 4, 867);
			attr_dev(div, "class", "cells");
			add_location(div, file$f, 27, 2, 842);
			dispose = listen_dev(input_1, "change", ctx.input_1_change_handler);
		},
		m: function mount(target, anchor) {
			mount_component(code0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(code1, target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, label);
			append_dev(label, input_1);
			input_1.checked = ctx.$value;
			input_action = ctx.input.call(null, input_1) || ({});
			append_dev(label, t2);
			insert_dev(target, t3, anchor);
			mount_component(error, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$value) {
				input_1.checked = ctx.$value;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			transition_in(error.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			transition_out(error.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(code1, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);
			if (input_action && is_function(input_action.destroy)) input_action.destroy();
			if (detaching) detach_dev(t3);
			destroy_component(error, detaching);
			if (detaching) detach_dev(t4);
			destroy_component(button, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$7.name,
		type: "slot",
		source: "(25:0) <Form {createForm} title=\\\"boolean\\\" type>",
		ctx
	});

	return block;
}

function create_fragment$h(ctx) {
	let current;

	const form = new Form({
			props: {
				createForm: ctx.createForm,
				title: "boolean",
				type: true,
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(form.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$5("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const form_changes = {};

			if (changed.$$scope || changed.$value) {
				form_changes.$$scope = { changed, ctx };
			}

			form.$set(form_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$h($$self, $$props, $$invalidate) {
	let $value;
	const { createEntry, createForm } = createValidation({ validateOnEvents: { change: true } });

	const [errors, value, input] = createEntry({
		value: false,
		type: "boolean",
		required: true
	});

	validate_store(value, "value");
	component_subscribe($$self, value, value => $$invalidate("$value", $value = value));

	const jsCode = `const [ errors, value, input ] = createEntry({
  value: false,
  type: 'boolean',
  required: true
});`;

	const htmlCode = `<input use:input bind:checked={$value} type="checkbox" />
{#if $errors.includes('required')}Please check{/if}`;

	function input_1_change_handler() {
		$value = this.checked;
		value.set($value);
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("$value" in $$props) value.set($value = $$props.$value);
	};

	return {
		createForm,
		errors,
		value,
		input,
		jsCode,
		htmlCode,
		$value,
		input_1_change_handler
	};
}

class Boolean$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Boolean",
			options,
			id: create_fragment$h.name
		});
	}
}

/* src/docs/examples/array.svelte generated by Svelte v3.15.0 */

const { Error: Error_1$6 } = globals;
const file$g = "src/docs/examples/array.svelte";

// (51:0) <Form createForm={createForm1} title="array" subtitle="min, max, includes" type>
function create_default_slot_2$4(ctx) {
	let t0;
	let t1;
	let div;
	let label0;
	let input0;
	let input0_value_value;
	let input_action;
	let t2;
	let t3;
	let label1;
	let input1;
	let input1_value_value;
	let input_action_1;
	let t4;
	let t5;
	let label2;
	let input2;
	let input2_value_value;
	let input_action_2;
	let t6;
	let t7;
	let t8;
	let t9;
	let current;
	let dispose;
	const code0 = new Code({ props: { code: ctx.js1 }, $$inline: true });

	const code1 = new Code({
			props: { code: ctx.html1 },
			$$inline: true
		});

	const error0 = new Error$1({
			props: {
				errors: ctx.errors,
				errorCode: "required"
			},
			$$inline: true
		});

	const error1 = new Error$1({
			props: {
				errors: ctx.errors,
				errorCode: "min",
				errorText: "Pick at least 2, please"
			},
			$$inline: true
		});

	const button = new Button({
			props: { type: "submit" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(code0.$$.fragment);
			t0 = space();
			create_component(code1.$$.fragment);
			t1 = space();
			div = element("div");
			label0 = element("label");
			input0 = element("input");
			t2 = text(" First option");
			t3 = space();
			label1 = element("label");
			input1 = element("input");
			t4 = text(" Second option");
			t5 = space();
			label2 = element("label");
			input2 = element("input");
			t6 = text(" Third option");
			t7 = space();
			create_component(error0.$$.fragment);
			t8 = space();
			create_component(error1.$$.fragment);
			t9 = space();
			create_component(button.$$.fragment);
			input0.__value = input0_value_value = 1;
			input0.value = input0.__value;
			attr_dev(input0, "class", "input-choice");
			attr_dev(input0, "type", "checkbox");
			ctx.$$binding_groups[0].push(input0);
			add_location(input0, file$g, 54, 11, 1930);
			add_location(label0, file$g, 54, 4, 1923);
			input1.__value = input1_value_value = 2;
			input1.value = input1.__value;
			attr_dev(input1, "class", "input-choice");
			attr_dev(input1, "type", "checkbox");
			ctx.$$binding_groups[0].push(input1);
			add_location(input1, file$g, 55, 11, 2050);
			add_location(label1, file$g, 55, 4, 2043);
			input2.__value = input2_value_value = 3;
			input2.value = input2.__value;
			attr_dev(input2, "class", "input-choice");
			attr_dev(input2, "type", "checkbox");
			ctx.$$binding_groups[0].push(input2);
			add_location(input2, file$g, 56, 11, 2171);
			add_location(label2, file$g, 56, 4, 2164);
			attr_dev(div, "class", "cells");
			add_location(div, file$g, 53, 2, 1898);

			dispose = [
				listen_dev(input0, "change", ctx.input0_change_handler),
				listen_dev(input1, "change", ctx.input1_change_handler),
				listen_dev(input2, "change", ctx.input2_change_handler)
			];
		},
		m: function mount(target, anchor) {
			mount_component(code0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(code1, target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, label0);
			append_dev(label0, input0);
			input0.checked = ~ctx.$value.indexOf(input0.__value);
			input_action = ctx.input.call(null, input0) || ({});
			append_dev(label0, t2);
			append_dev(div, t3);
			append_dev(div, label1);
			append_dev(label1, input1);
			input1.checked = ~ctx.$value.indexOf(input1.__value);
			input_action_1 = ctx.input.call(null, input1) || ({});
			append_dev(label1, t4);
			append_dev(div, t5);
			append_dev(div, label2);
			append_dev(label2, input2);
			input2.checked = ~ctx.$value.indexOf(input2.__value);
			input_action_2 = ctx.input.call(null, input2) || ({});
			append_dev(label2, t6);
			insert_dev(target, t7, anchor);
			mount_component(error0, target, anchor);
			insert_dev(target, t8, anchor);
			mount_component(error1, target, anchor);
			insert_dev(target, t9, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$value) {
				input0.checked = ~ctx.$value.indexOf(input0.__value);
			}

			if (changed.$value) {
				input1.checked = ~ctx.$value.indexOf(input1.__value);
			}

			if (changed.$value) {
				input2.checked = ~ctx.$value.indexOf(input2.__value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			transition_in(error0.$$.fragment, local);
			transition_in(error1.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			transition_out(error0.$$.fragment, local);
			transition_out(error1.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(code1, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input0), 1);
			if (input_action && is_function(input_action.destroy)) input_action.destroy();
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input1), 1);
			if (input_action_1 && is_function(input_action_1.destroy)) input_action_1.destroy();
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input2), 1);
			if (input_action_2 && is_function(input_action_2.destroy)) input_action_2.destroy();
			if (detaching) detach_dev(t7);
			destroy_component(error0, detaching);
			if (detaching) detach_dev(t8);
			destroy_component(error1, detaching);
			if (detaching) detach_dev(t9);
			destroy_component(button, detaching);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$4.name,
		type: "slot",
		source: "(51:0) <Form createForm={createForm1} title=\\\"array\\\" subtitle=\\\"min, max, includes\\\" type>",
		ctx
	});

	return block;
}

// (67:2) <Row labelText="Pick few options">
function create_default_slot_1$6(ctx) {
	let select;
	let option0;
	let option0_value_value;
	let option1;
	let option1_value_value;
	let option2;
	let option2_value_value;
	let inputSelect_action;
	let t3;
	let current;
	let dispose;

	const error = new Error$1({
			props: {
				errors: ctx.errorsSelect,
				errorCode: "required",
				errorText: "Pick something please"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			select = element("select");
			option0 = element("option");
			option0.textContent = "First lorem ipsum";
			option1 = element("option");
			option1.textContent = "Second lorem ipsum";
			option2 = element("option");
			option2.textContent = "Third lorem ipsum";
			t3 = space();
			create_component(error.$$.fragment);
			option0.__value = option0_value_value = 1;
			option0.value = option0.__value;
			add_location(option0, file$g, 68, 6, 2685);
			option1.__value = option1_value_value = 2;
			option1.value = option1.__value;
			add_location(option1, file$g, 69, 6, 2737);
			option2.__value = option2_value_value = 3;
			option2.value = option2.__value;
			add_location(option2, file$g, 70, 6, 2790);
			select.multiple = true;
			if (ctx.$valueSelect === void 0) add_render_callback(() => ctx.select_change_handler.call(select));
			add_location(select, file$g, 67, 4, 2618);
			dispose = listen_dev(select, "change", ctx.select_change_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select, anchor);
			append_dev(select, option0);
			append_dev(select, option1);
			append_dev(select, option2);
			select_options(select, ctx.$valueSelect);
			inputSelect_action = ctx.inputSelect.call(null, select) || ({});
			insert_dev(target, t3, anchor);
			mount_component(error, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$valueSelect) {
				select_options(select, ctx.$valueSelect);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select);
			if (inputSelect_action && is_function(inputSelect_action.destroy)) inputSelect_action.destroy();
			if (detaching) detach_dev(t3);
			destroy_component(error, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$6.name,
		type: "slot",
		source: "(67:2) <Row labelText=\\\"Pick few options\\\">",
		ctx
	});

	return block;
}

// (64:0) <Form createForm={createForm2} title="array" subtitle="min, max, includes" type>
function create_default_slot$8(ctx) {
	let t0;
	let t1;
	let t2;
	let current;
	const code0 = new Code({ props: { code: ctx.js2 }, $$inline: true });

	const code1 = new Code({
			props: { code: ctx.html2 },
			$$inline: true
		});

	const row = new Row({
			props: {
				labelText: "Pick few options",
				$$slots: { default: [create_default_slot_1$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const button = new Button({
			props: { type: "submit" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(code0.$$.fragment);
			t0 = space();
			create_component(code1.$$.fragment);
			t1 = space();
			create_component(row.$$.fragment);
			t2 = space();
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(code0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(code1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(row, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const row_changes = {};

			if (changed.$$scope || changed.$valueSelect) {
				row_changes.$$scope = { changed, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			transition_in(row.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			transition_out(row.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(code1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(row, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$8.name,
		type: "slot",
		source: "(64:0) <Form createForm={createForm2} title=\\\"array\\\" subtitle=\\\"min, max, includes\\\" type>",
		ctx
	});

	return block;
}

function create_fragment$i(ctx) {
	let t;
	let current;

	const form0 = new Form({
			props: {
				createForm: ctx.createForm1,
				title: "array",
				subtitle: "min, max, includes",
				type: true,
				$$slots: { default: [create_default_slot_2$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const form1 = new Form({
			props: {
				createForm: ctx.createForm2,
				title: "array",
				subtitle: "min, max, includes",
				type: true,
				$$slots: { default: [create_default_slot$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(form0.$$.fragment);
			t = space();
			create_component(form1.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$6("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(form0, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(form1, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const form0_changes = {};

			if (changed.$$scope || changed.$value) {
				form0_changes.$$scope = { changed, ctx };
			}

			form0.$set(form0_changes);
			const form1_changes = {};

			if (changed.$$scope || changed.$valueSelect) {
				form1_changes.$$scope = { changed, ctx };
			}

			form1.$set(form1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form0.$$.fragment, local);
			transition_in(form1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form0.$$.fragment, local);
			transition_out(form1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form0, detaching);
			if (detaching) detach_dev(t);
			destroy_component(form1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$i($$self, $$props, $$invalidate) {
	let $value;
	let $valueSelect;
	const { createEntry: createEntry1, createForm: createForm1 } = createValidation({ validateOnEvents: { input: true } });
	const { createEntry: createEntry2, createForm: createForm2 } = createValidation({ validateOnEvents: { input: true } });

	const [errors, value, input] = createEntry1({
		type: "array",
		min: 2,
		required: true,
		value: []
	});

	validate_store(value, "value");
	component_subscribe($$self, value, value => $$invalidate("$value", $value = value));
	const [errorsSelect, valueSelect, inputSelect] = createEntry2({ type: "array", required: true, value: [] });
	validate_store(valueSelect, "valueSelect");
	component_subscribe($$self, valueSelect, value => $$invalidate("$valueSelect", $valueSelect = value));

	const js1 = `const [ errors, value, input ] = createEntry({
  type: 'array',
  min: 2,
  required: true,
  value: []
});`;

	const html1 = `<input use:input bind:group={$value} value={1} type="checkbox" /> First option
<input use:input bind:group={$value} value={2} type="checkbox" /> Second option
<input use:input bind:group={$value} value={3} type="checkbox" /> Third option
{#if $errors.includes('required')}Pick something please{/if}
{#if $errors.includes('min')}Pick at least 2, please{/if}`;

	const js2 = `const [ errors, value, input ] = createEntry({
  type: 'array',
  required: true,
  value: []
});`;

	const html2 = `<select multiple bind:value={$valueSelect} use:inputSelect>
  <option value={1}>First lorem ipsum</option>
  <option value={2}>Second lorem ipsum</option>
  <option value={3}>Third lorem ipsum</option>
</select>
{#if $errors.includes('required')}Pick something please{/if}`;

	const $$binding_groups = [[]];

	function input0_change_handler() {
		$value = get_binding_group_value($$binding_groups[0]);
		value.set($value);
	}

	function input1_change_handler() {
		$value = get_binding_group_value($$binding_groups[0]);
		value.set($value);
	}

	function input2_change_handler() {
		$value = get_binding_group_value($$binding_groups[0]);
		value.set($value);
	}

	function select_change_handler() {
		$valueSelect = select_multiple_value(this);
		valueSelect.set($valueSelect);
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("$value" in $$props) value.set($value = $$props.$value);
		if ("$valueSelect" in $$props) valueSelect.set($valueSelect = $$props.$valueSelect);
	};

	return {
		createForm1,
		createForm2,
		errors,
		value,
		input,
		errorsSelect,
		valueSelect,
		inputSelect,
		js1,
		html1,
		js2,
		html2,
		$value,
		$valueSelect,
		input0_change_handler,
		input1_change_handler,
		input2_change_handler,
		select_change_handler,
		$$binding_groups
	};
}

class Array$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Array",
			options,
			id: create_fragment$i.name
		});
	}
}

/* src/docs/examples/required.svelte generated by Svelte v3.15.0 */

const { Error: Error_1$7 } = globals;
const file$h = "src/docs/examples/required.svelte";

// (35:2) <Row labelText="Type your email (required)">
function create_default_slot_2$5(ctx) {
	let input_1;
	let inputRequired_action;
	let t0;
	let t1;
	let current;
	let dispose;

	const error0 = new Error$1({
			props: {
				errors: ctx.errorsRequired,
				errorCode: "type",
				errorText: "Use valid email"
			},
			$$inline: true
		});

	const error1 = new Error$1({
			props: {
				errors: ctx.errorsRequired,
				errorCode: "required"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input_1 = element("input");
			t0 = space();
			create_component(error0.$$.fragment);
			t1 = space();
			create_component(error1.$$.fragment);
			attr_dev(input_1, "class", "input-text");
			attr_dev(input_1, "type", "email");
			attr_dev(input_1, "placeholder", "type: 'email', required: true");
			add_location(input_1, file$h, 35, 4, 1277);
			dispose = listen_dev(input_1, "input", ctx.input_1_input_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			set_input_value(input_1, ctx.$valueRequired);
			inputRequired_action = ctx.inputRequired.call(null, input_1) || ({});
			insert_dev(target, t0, anchor);
			mount_component(error0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(error1, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$valueRequired && input_1.value !== ctx.$valueRequired) {
				set_input_value(input_1, ctx.$valueRequired);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error0.$$.fragment, local);
			transition_in(error1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error0.$$.fragment, local);
			transition_out(error1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			if (inputRequired_action && is_function(inputRequired_action.destroy)) inputRequired_action.destroy();
			if (detaching) detach_dev(t0);
			destroy_component(error0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(error1, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$5.name,
		type: "slot",
		source: "(35:2) <Row labelText=\\\"Type your email (required)\\\">",
		ctx
	});

	return block;
}

// (40:2) <Row labelText="Type your email (optional)">
function create_default_slot_1$7(ctx) {
	let input_1;
	let input_action;
	let t;
	let current;
	let dispose;

	const error = new Error$1({
			props: {
				errors: ctx.errors,
				errorCode: "type",
				errorText: "Use valid email"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input_1 = element("input");
			t = space();
			create_component(error.$$.fragment);
			attr_dev(input_1, "class", "input-text");
			attr_dev(input_1, "type", "email");
			attr_dev(input_1, "placeholder", "type: 'email'");
			add_location(input_1, file$h, 40, 4, 1616);
			dispose = listen_dev(input_1, "input", ctx.input_1_input_handler_1);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			set_input_value(input_1, ctx.$value);
			input_action = ctx.input.call(null, input_1) || ({});
			insert_dev(target, t, anchor);
			mount_component(error, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$value && input_1.value !== ctx.$value) {
				set_input_value(input_1, ctx.$value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			if (input_action && is_function(input_action.destroy)) input_action.destroy();
			if (detaching) detach_dev(t);
			destroy_component(error, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$7.name,
		type: "slot",
		source: "(40:2) <Row labelText=\\\"Type your email (optional)\\\">",
		ctx
	});

	return block;
}

// (32:0) <Form {createForm} title="required" rule>
function create_default_slot$9(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let current;

	const code0 = new Code({
			props: { code: ctx.jsCode },
			$$inline: true
		});

	const code1 = new Code({
			props: { code: ctx.htmlCode },
			$$inline: true
		});

	const row0 = new Row({
			props: {
				labelText: "Type your email (required)",
				$$slots: { default: [create_default_slot_2$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const row1 = new Row({
			props: {
				labelText: "Type your email (optional)",
				$$slots: { default: [create_default_slot_1$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const button = new Button({
			props: { type: "submit" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(code0.$$.fragment);
			t0 = space();
			create_component(code1.$$.fragment);
			t1 = space();
			create_component(row0.$$.fragment);
			t2 = space();
			create_component(row1.$$.fragment);
			t3 = space();
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(code0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(code1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(row0, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(row1, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const row0_changes = {};

			if (changed.$$scope || changed.$valueRequired) {
				row0_changes.$$scope = { changed, ctx };
			}

			row0.$set(row0_changes);
			const row1_changes = {};

			if (changed.$$scope || changed.$value) {
				row1_changes.$$scope = { changed, ctx };
			}

			row1.$set(row1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			transition_in(row0.$$.fragment, local);
			transition_in(row1.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			transition_out(row0.$$.fragment, local);
			transition_out(row1.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(code1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(row0, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(row1, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$9.name,
		type: "slot",
		source: "(32:0) <Form {createForm} title=\\\"required\\\" rule>",
		ctx
	});

	return block;
}

function create_fragment$j(ctx) {
	let current;

	const form = new Form({
			props: {
				createForm: ctx.createForm,
				title: "required",
				rule: true,
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(form.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$7("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const form_changes = {};

			if (changed.$$scope || changed.$value || changed.$valueRequired) {
				form_changes.$$scope = { changed, ctx };
			}

			form.$set(form_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$j($$self, $$props, $$invalidate) {
	let $valueRequired;
	let $value;
	const { createEntry, createForm } = createValidation({ validateOnEvents: { input: true } });
	const [errorsRequired, valueRequired, inputRequired] = createEntry({ type: "email", required: true });
	validate_store(valueRequired, "valueRequired");
	component_subscribe($$self, valueRequired, value => $$invalidate("$valueRequired", $valueRequired = value));
	const [errors, value, input] = createEntry({ type: "email" });
	validate_store(value, "value");
	component_subscribe($$self, value, value => $$invalidate("$value", $value = value));

	const jsCode = `const [ errorsRequired, valueRequired, inputRequired ] = createEntry({
  type: 'email', required: true
});
const [ errors, value, input ] = createEntry({
  type: 'email'
});`;

	const htmlCode = `<input use:inputRequired bind:value={$valueRequired} type="email" />
{#if $errors.includes('type')}Use valid email{/if}
{#if $errors.includes('required')}This field is required{/if}

<input use:input bind:value={$value} type="email" />
{#if $errors.includes('type')}Use valid email{/if}`;

	function input_1_input_handler() {
		$valueRequired = this.value;
		valueRequired.set($valueRequired);
	}

	function input_1_input_handler_1() {
		$value = this.value;
		value.set($value);
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("$valueRequired" in $$props) valueRequired.set($valueRequired = $$props.$valueRequired);
		if ("$value" in $$props) value.set($value = $$props.$value);
	};

	return {
		createForm,
		errorsRequired,
		valueRequired,
		inputRequired,
		errors,
		value,
		input,
		jsCode,
		htmlCode,
		$valueRequired,
		$value,
		input_1_input_handler,
		input_1_input_handler_1
	};
}

class Required extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Required",
			options,
			id: create_fragment$j.name
		});
	}
}

/* src/docs/examples/match.svelte generated by Svelte v3.15.0 */

const { Error: Error_1$8 } = globals;
const file$i = "src/docs/examples/match.svelte";

// (25:2) <Row labelText="Type something like AxxxxxxB">
function create_default_slot_1$8(ctx) {
	let input_1;
	let input_action;
	let t;
	let current;
	let dispose;

	const error = new Error$1({
			props: {
				errors: ctx.errors,
				errorCode: "match",
				errorText: "Should start from 'A' letter and ends with 'B' letter"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input_1 = element("input");
			t = space();
			create_component(error.$$.fragment);
			attr_dev(input_1, "class", "input-text");
			attr_dev(input_1, "type", "text");
			attr_dev(input_1, "placeholder", "type: 'string', match: /^A.*B$/");
			add_location(input_1, file$i, 25, 4, 925);
			dispose = listen_dev(input_1, "input", ctx.input_1_input_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			set_input_value(input_1, ctx.$value);
			input_action = ctx.input.call(null, input_1) || ({});
			insert_dev(target, t, anchor);
			mount_component(error, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$value && input_1.value !== ctx.$value) {
				set_input_value(input_1, ctx.$value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			if (input_action && is_function(input_action.destroy)) input_action.destroy();
			if (detaching) detach_dev(t);
			destroy_component(error, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$8.name,
		type: "slot",
		source: "(25:2) <Row labelText=\\\"Type something like AxxxxxxB\\\">",
		ctx
	});

	return block;
}

// (22:0) <Form {createForm} title="match" rule>
function create_default_slot$a(ctx) {
	let t0;
	let t1;
	let t2;
	let current;

	const code0 = new Code({
			props: { code: ctx.jsCode },
			$$inline: true
		});

	const code1 = new Code({
			props: { code: ctx.htmlCode },
			$$inline: true
		});

	const row = new Row({
			props: {
				labelText: "Type something like AxxxxxxB",
				$$slots: { default: [create_default_slot_1$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const button = new Button({
			props: { type: "submit" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(code0.$$.fragment);
			t0 = space();
			create_component(code1.$$.fragment);
			t1 = space();
			create_component(row.$$.fragment);
			t2 = space();
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(code0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(code1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(row, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const row_changes = {};

			if (changed.$$scope || changed.$value) {
				row_changes.$$scope = { changed, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			transition_in(row.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			transition_out(row.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(code1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(row, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$a.name,
		type: "slot",
		source: "(22:0) <Form {createForm} title=\\\"match\\\" rule>",
		ctx
	});

	return block;
}

function create_fragment$k(ctx) {
	let current;

	const form = new Form({
			props: {
				createForm: ctx.createForm,
				title: "match",
				rule: true,
				$$slots: { default: [create_default_slot$a] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(form.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$8("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const form_changes = {};

			if (changed.$$scope || changed.$value) {
				form_changes.$$scope = { changed, ctx };
			}

			form.$set(form_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$k($$self, $$props, $$invalidate) {
	let $value;
	const { createEntry, createForm } = createValidation({ validateOnEvents: { input: true } });
	const [errors, value, input] = createEntry({ type: "string", match: /^A.*B$/ });
	validate_store(value, "value");
	component_subscribe($$self, value, value => $$invalidate("$value", $value = value));

	const jsCode = `const [ errors, value, input ] = createEntry({
  type: 'string', match: /^A.*B$/
});`;

	const htmlCode = `<input use:input bind:value={$value} />
{#if $errors.includes('match')}Should start from 'A' letter and ends with 'B' letter{/if}`;

	function input_1_input_handler() {
		$value = this.value;
		value.set($value);
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("$value" in $$props) value.set($value = $$props.$value);
	};

	return {
		createForm,
		errors,
		value,
		input,
		jsCode,
		htmlCode,
		$value,
		input_1_input_handler
	};
}

class Match extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Match",
			options,
			id: create_fragment$k.name
		});
	}
}

/* src/docs/examples/equal.svelte generated by Svelte v3.15.0 */

const { Error: Error_1$9 } = globals;
const file$j = "src/docs/examples/equal.svelte";

// (26:2) <Row labelText="Type 'qwerty'">
function create_default_slot_1$9(ctx) {
	let input_1;
	let input_action;
	let t0;
	let t1;
	let current;
	let dispose;

	const error0 = new Error$1({
			props: {
				errors: ctx.errors,
				errorCode: "equal",
				errorText: "Should be equal to 'qwerty'"
			},
			$$inline: true
		});

	const error1 = new Error$1({
			props: {
				errors: ctx.errors,
				errorCode: "required"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input_1 = element("input");
			t0 = space();
			create_component(error0.$$.fragment);
			t1 = space();
			create_component(error1.$$.fragment);
			attr_dev(input_1, "class", "input-text");
			attr_dev(input_1, "type", "text");
			attr_dev(input_1, "placeholder", "type: 'string', equal: 'qwerty'");
			add_location(input_1, file$j, 26, 4, 979);
			dispose = listen_dev(input_1, "input", ctx.input_1_input_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			set_input_value(input_1, ctx.$value);
			input_action = ctx.input.call(null, input_1) || ({});
			insert_dev(target, t0, anchor);
			mount_component(error0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(error1, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$value && input_1.value !== ctx.$value) {
				set_input_value(input_1, ctx.$value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error0.$$.fragment, local);
			transition_in(error1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error0.$$.fragment, local);
			transition_out(error1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			if (input_action && is_function(input_action.destroy)) input_action.destroy();
			if (detaching) detach_dev(t0);
			destroy_component(error0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(error1, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$9.name,
		type: "slot",
		source: "(26:2) <Row labelText=\\\"Type 'qwerty'\\\">",
		ctx
	});

	return block;
}

// (23:0) <Form {createForm} title="equal" rule>
function create_default_slot$b(ctx) {
	let t0;
	let t1;
	let t2;
	let current;

	const code0 = new Code({
			props: { code: ctx.jsCode },
			$$inline: true
		});

	const code1 = new Code({
			props: { code: ctx.htmlCode },
			$$inline: true
		});

	const row = new Row({
			props: {
				labelText: "Type 'qwerty'",
				$$slots: { default: [create_default_slot_1$9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const button = new Button({
			props: { type: "submit" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(code0.$$.fragment);
			t0 = space();
			create_component(code1.$$.fragment);
			t1 = space();
			create_component(row.$$.fragment);
			t2 = space();
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(code0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(code1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(row, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const row_changes = {};

			if (changed.$$scope || changed.$value) {
				row_changes.$$scope = { changed, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			transition_in(row.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			transition_out(row.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(code1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(row, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$b.name,
		type: "slot",
		source: "(23:0) <Form {createForm} title=\\\"equal\\\" rule>",
		ctx
	});

	return block;
}

function create_fragment$l(ctx) {
	let current;

	const form = new Form({
			props: {
				createForm: ctx.createForm,
				title: "equal",
				rule: true,
				$$slots: { default: [create_default_slot$b] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(form.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$9("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const form_changes = {};

			if (changed.$$scope || changed.$value) {
				form_changes.$$scope = { changed, ctx };
			}

			form.$set(form_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$l($$self, $$props, $$invalidate) {
	let $value;
	const { createEntry, createForm } = createValidation({ validateOnEvents: { input: true } });

	const [errors, value, input] = createEntry({
		type: "string",
		equal: "qwerty",
		required: true
	});

	validate_store(value, "value");
	component_subscribe($$self, value, value => $$invalidate("$value", $value = value));

	const jsCode = `const [ errors, value, input ] = createEntry({
  type: 'string', equal: 'qwerty', required: true
});`;

	const htmlCode = `<input use:input bind:value={$value} />
{#if $errors.includes('equal')}Should be equal to 'qwerty'{/if}
{#if $errors.includes('required')}This field is required{/if}`;

	function input_1_input_handler() {
		$value = this.value;
		value.set($value);
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("$value" in $$props) value.set($value = $$props.$value);
	};

	return {
		createForm,
		errors,
		value,
		input,
		jsCode,
		htmlCode,
		$value,
		input_1_input_handler
	};
}

class Equal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$l, create_fragment$l, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Equal",
			options,
			id: create_fragment$l.name
		});
	}
}

function is_date(obj) {
    return Object.prototype.toString.call(obj) === '[object Date]';
}

function get_interpolator(a, b) {
    if (a === b || a !== a)
        return () => a;
    const type = typeof a;
    if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
        throw new Error('Cannot interpolate values of different type');
    }
    if (Array.isArray(a)) {
        const arr = b.map((bi, i) => {
            return get_interpolator(a[i], bi);
        });
        return t => arr.map(fn => fn(t));
    }
    if (type === 'object') {
        if (!a || !b)
            throw new Error('Object cannot be null');
        if (is_date(a) && is_date(b)) {
            a = a.getTime();
            b = b.getTime();
            const delta = b - a;
            return t => new Date(a + t * delta);
        }
        const keys = Object.keys(b);
        const interpolators = {};
        keys.forEach(key => {
            interpolators[key] = get_interpolator(a[key], b[key]);
        });
        return t => {
            const result = {};
            keys.forEach(key => {
                result[key] = interpolators[key](t);
            });
            return result;
        };
    }
    if (type === 'number') {
        const delta = b - a;
        return t => a + t * delta;
    }
    throw new Error(`Cannot interpolate ${type} values`);
}
function tweened(value, defaults = {}) {
    const store = writable(value);
    let task;
    let target_value = value;
    function set(new_value, opts) {
        if (value == null) {
            store.set(value = new_value);
            return Promise.resolve();
        }
        target_value = new_value;
        let previous_task = task;
        let started = false;
        let { delay = 0, duration = 400, easing = identity, interpolate = get_interpolator } = assign(assign({}, defaults), opts);
        const start = now() + delay;
        let fn;
        task = loop(now => {
            if (now < start)
                return true;
            if (!started) {
                fn = interpolate(value, new_value);
                if (typeof duration === 'function')
                    duration = duration(value, new_value);
                started = true;
            }
            if (previous_task) {
                previous_task.abort();
                previous_task = null;
            }
            const elapsed = now - start;
            if (elapsed > duration) {
                store.set(value = new_value);
                return false;
            }
            // @ts-ignore
            store.set(value = fn(easing(elapsed / duration)));
            return true;
        });
        return task.promise;
    }
    return {
        set,
        update: (fn, opts) => set(fn(target_value, value), opts),
        subscribe: store.subscribe
    };
}

/* src/docs/examples/array-sum-of-points.svelte generated by Svelte v3.15.0 */

const { Error: Error_1$a } = globals;
const file$k = "src/docs/examples/array-sum-of-points.svelte";

// (74:2) {#if $value.length}
function create_if_block$8(ctx) {
	let h1;
	let t0;
	let t1_value = ctx.$score.toFixed(0) + "";
	let t1;
	let t2;
	let h1_style_value;
	let if_block = ctx.$score === 100 && create_if_block_1$7(ctx);

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Your score: ");
			t1 = text(t1_value);
			t2 = text("/100 ");
			if (if_block) if_block.c();
			attr_dev(h1, "style", h1_style_value = `color: ${ctx.color}`);
			add_location(h1, file$k, 74, 4, 3947);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			append_dev(h1, t1);
			append_dev(h1, t2);
			if (if_block) if_block.m(h1, null);
		},
		p: function update(changed, ctx) {
			if (changed.$score && t1_value !== (t1_value = ctx.$score.toFixed(0) + "")) set_data_dev(t1, t1_value);

			if (ctx.$score === 100) {
				if (!if_block) {
					if_block = create_if_block_1$7(ctx);
					if_block.c();
					if_block.m(h1, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (changed.color && h1_style_value !== (h1_style_value = `color: ${ctx.color}`)) {
				attr_dev(h1, "style", h1_style_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$8.name,
		type: "if",
		source: "(74:2) {#if $value.length}",
		ctx
	});

	return block;
}

// (75:71) {#if $score === 100}
function create_if_block_1$7(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("You won!");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$7.name,
		type: "if",
		source: "(75:71) {#if $score === 100}",
		ctx
	});

	return block;
}

// (59:0) <Form {createForm} title="Pick as much sportsman as you can">
function create_default_slot$c(ctx) {
	let div;
	let label0;
	let input0;
	let input0_value_value;
	let input_action;
	let t0;
	let t1;
	let label1;
	let input1;
	let input1_value_value;
	let input_action_1;
	let t2;
	let t3;
	let label2;
	let input2;
	let input2_value_value;
	let input_action_2;
	let t4;
	let t5;
	let label3;
	let input3;
	let input3_value_value;
	let input_action_3;
	let t6;
	let t7;
	let label4;
	let input4;
	let input4_value_value;
	let input_action_4;
	let t8;
	let t9;
	let label5;
	let input5;
	let input5_value_value;
	let input_action_5;
	let t10;
	let t11;
	let label6;
	let input6;
	let input6_value_value;
	let input_action_6;
	let t12;
	let t13;
	let label7;
	let input7;
	let input7_value_value;
	let input_action_7;
	let t14;
	let t15;
	let label8;
	let input8;
	let input8_value_value;
	let input_action_8;
	let t16;
	let t17;
	let label9;
	let input9;
	let input9_value_value;
	let input_action_9;
	let t18;
	let t19;
	let t20;
	let t21;
	let t22;
	let current;
	let dispose;

	const error = new Error$1({
			props: {
				errors: ctx.errors,
				errorCode: "required",
				errorText: "Pick something please"
			},
			$$inline: true
		});

	let if_block = ctx.$value.length && create_if_block$8(ctx);

	const code0 = new Code({
			props: { code: ctx.jsCode },
			$$inline: true
		});

	const code1 = new Code({
			props: { code: ctx.htmlCode },
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			label0 = element("label");
			input0 = element("input");
			t0 = text(" Tom Brady");
			t1 = space();
			label1 = element("label");
			input1 = element("input");
			t2 = text(" Isaac Newton");
			t3 = space();
			label2 = element("label");
			input2 = element("input");
			t4 = text(" Pete Carrol");
			t5 = space();
			label3 = element("label");
			input3 = element("input");
			t6 = text(" Steve Jobs");
			t7 = space();
			label4 = element("label");
			input4 = element("input");
			t8 = text(" Paul Gascoigne");
			t9 = space();
			label5 = element("label");
			input5 = element("input");
			t10 = text(" Pele");
			t11 = space();
			label6 = element("label");
			input6 = element("input");
			t12 = text(" Albetro Contador");
			t13 = space();
			label7 = element("label");
			input7 = element("input");
			t14 = text(" David Gilmour");
			t15 = space();
			label8 = element("label");
			input8 = element("input");
			t16 = text(" Georges St-Pierre");
			t17 = space();
			label9 = element("label");
			input9 = element("input");
			t18 = text(" Rich Harris");
			t19 = space();
			create_component(error.$$.fragment);
			t20 = space();
			if (if_block) if_block.c();
			t21 = space();
			create_component(code0.$$.fragment);
			t22 = space();
			create_component(code1.$$.fragment);
			input0.disabled = ctx.disabled;
			input0.__value = input0_value_value = 9;
			input0.value = input0.__value;
			attr_dev(input0, "class", "input-choice");
			attr_dev(input0, "type", "checkbox");
			ctx.$$binding_groups[0].push(input0);
			add_location(input0, file$k, 60, 11, 2522);
			add_location(label0, file$k, 60, 4, 2515);
			input1.disabled = ctx.disabled;
			input1.__value = input1_value_value = -40;
			input1.value = input1.__value;
			attr_dev(input1, "class", "input-choice");
			attr_dev(input1, "type", "checkbox");
			ctx.$$binding_groups[0].push(input1);
			add_location(input1, file$k, 61, 11, 2650);
			add_location(label1, file$k, 61, 4, 2643);
			input2.disabled = ctx.disabled;
			input2.__value = input2_value_value = 30;
			input2.value = input2.__value;
			attr_dev(input2, "class", "input-choice");
			attr_dev(input2, "type", "checkbox");
			ctx.$$binding_groups[0].push(input2);
			add_location(input2, file$k, 62, 11, 2783);
			add_location(label2, file$k, 62, 4, 2776);
			input3.disabled = ctx.disabled;
			input3.__value = input3_value_value = -30;
			input3.value = input3.__value;
			attr_dev(input3, "class", "input-choice");
			attr_dev(input3, "type", "checkbox");
			ctx.$$binding_groups[0].push(input3);
			add_location(input3, file$k, 63, 11, 2914);
			add_location(label3, file$k, 63, 4, 2907);
			input4.disabled = ctx.disabled;
			input4.__value = input4_value_value = 14;
			input4.value = input4.__value;
			attr_dev(input4, "class", "input-choice");
			attr_dev(input4, "type", "checkbox");
			ctx.$$binding_groups[0].push(input4);
			add_location(input4, file$k, 64, 11, 3045);
			add_location(label4, file$k, 64, 4, 3038);
			input5.disabled = ctx.disabled;
			input5.__value = input5_value_value = 16;
			input5.value = input5.__value;
			attr_dev(input5, "class", "input-choice");
			attr_dev(input5, "type", "checkbox");
			ctx.$$binding_groups[0].push(input5);
			add_location(input5, file$k, 65, 11, 3179);
			add_location(label5, file$k, 65, 4, 3172);
			input6.disabled = ctx.disabled;
			input6.__value = input6_value_value = 20;
			input6.value = input6.__value;
			attr_dev(input6, "class", "input-choice");
			attr_dev(input6, "type", "checkbox");
			ctx.$$binding_groups[0].push(input6);
			add_location(input6, file$k, 66, 11, 3303);
			add_location(label6, file$k, 66, 4, 3296);
			input7.disabled = ctx.disabled;
			input7.__value = input7_value_value = -20;
			input7.value = input7.__value;
			attr_dev(input7, "class", "input-choice");
			attr_dev(input7, "type", "checkbox");
			ctx.$$binding_groups[0].push(input7);
			add_location(input7, file$k, 67, 11, 3439);
			add_location(label7, file$k, 67, 4, 3432);
			input8.disabled = ctx.disabled;
			input8.__value = input8_value_value = 11;
			input8.value = input8.__value;
			attr_dev(input8, "class", "input-choice");
			attr_dev(input8, "type", "checkbox");
			ctx.$$binding_groups[0].push(input8);
			add_location(input8, file$k, 68, 11, 3573);
			add_location(label8, file$k, 68, 4, 3566);
			input9.disabled = ctx.disabled;
			input9.__value = input9_value_value = -10;
			input9.value = input9.__value;
			attr_dev(input9, "class", "input-choice");
			attr_dev(input9, "type", "checkbox");
			ctx.$$binding_groups[0].push(input9);
			add_location(input9, file$k, 69, 11, 3710);
			add_location(label9, file$k, 69, 4, 3703);
			attr_dev(div, "class", "cells");
			add_location(div, file$k, 59, 2, 2490);

			dispose = [
				listen_dev(input0, "change", ctx.input0_change_handler),
				listen_dev(input1, "change", ctx.input1_change_handler),
				listen_dev(input2, "change", ctx.input2_change_handler),
				listen_dev(input3, "change", ctx.input3_change_handler),
				listen_dev(input4, "change", ctx.input4_change_handler),
				listen_dev(input5, "change", ctx.input5_change_handler),
				listen_dev(input6, "change", ctx.input6_change_handler),
				listen_dev(input7, "change", ctx.input7_change_handler),
				listen_dev(input8, "change", ctx.input8_change_handler),
				listen_dev(input9, "change", ctx.input9_change_handler)
			];
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, label0);
			append_dev(label0, input0);
			input0.checked = ~ctx.$value.indexOf(input0.__value);
			input_action = ctx.input.call(null, input0) || ({});
			append_dev(label0, t0);
			append_dev(div, t1);
			append_dev(div, label1);
			append_dev(label1, input1);
			input1.checked = ~ctx.$value.indexOf(input1.__value);
			input_action_1 = ctx.input.call(null, input1) || ({});
			append_dev(label1, t2);
			append_dev(div, t3);
			append_dev(div, label2);
			append_dev(label2, input2);
			input2.checked = ~ctx.$value.indexOf(input2.__value);
			input_action_2 = ctx.input.call(null, input2) || ({});
			append_dev(label2, t4);
			append_dev(div, t5);
			append_dev(div, label3);
			append_dev(label3, input3);
			input3.checked = ~ctx.$value.indexOf(input3.__value);
			input_action_3 = ctx.input.call(null, input3) || ({});
			append_dev(label3, t6);
			append_dev(div, t7);
			append_dev(div, label4);
			append_dev(label4, input4);
			input4.checked = ~ctx.$value.indexOf(input4.__value);
			input_action_4 = ctx.input.call(null, input4) || ({});
			append_dev(label4, t8);
			append_dev(div, t9);
			append_dev(div, label5);
			append_dev(label5, input5);
			input5.checked = ~ctx.$value.indexOf(input5.__value);
			input_action_5 = ctx.input.call(null, input5) || ({});
			append_dev(label5, t10);
			append_dev(div, t11);
			append_dev(div, label6);
			append_dev(label6, input6);
			input6.checked = ~ctx.$value.indexOf(input6.__value);
			input_action_6 = ctx.input.call(null, input6) || ({});
			append_dev(label6, t12);
			append_dev(div, t13);
			append_dev(div, label7);
			append_dev(label7, input7);
			input7.checked = ~ctx.$value.indexOf(input7.__value);
			input_action_7 = ctx.input.call(null, input7) || ({});
			append_dev(label7, t14);
			append_dev(div, t15);
			append_dev(div, label8);
			append_dev(label8, input8);
			input8.checked = ~ctx.$value.indexOf(input8.__value);
			input_action_8 = ctx.input.call(null, input8) || ({});
			append_dev(label8, t16);
			append_dev(div, t17);
			append_dev(div, label9);
			append_dev(label9, input9);
			input9.checked = ~ctx.$value.indexOf(input9.__value);
			input_action_9 = ctx.input.call(null, input9) || ({});
			append_dev(label9, t18);
			insert_dev(target, t19, anchor);
			mount_component(error, target, anchor);
			insert_dev(target, t20, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t21, anchor);
			mount_component(code0, target, anchor);
			insert_dev(target, t22, anchor);
			mount_component(code1, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (!current || changed.disabled) {
				prop_dev(input0, "disabled", ctx.disabled);
			}

			if (changed.$value) {
				input0.checked = ~ctx.$value.indexOf(input0.__value);
			}

			if (!current || changed.disabled) {
				prop_dev(input1, "disabled", ctx.disabled);
			}

			if (changed.$value) {
				input1.checked = ~ctx.$value.indexOf(input1.__value);
			}

			if (!current || changed.disabled) {
				prop_dev(input2, "disabled", ctx.disabled);
			}

			if (changed.$value) {
				input2.checked = ~ctx.$value.indexOf(input2.__value);
			}

			if (!current || changed.disabled) {
				prop_dev(input3, "disabled", ctx.disabled);
			}

			if (changed.$value) {
				input3.checked = ~ctx.$value.indexOf(input3.__value);
			}

			if (!current || changed.disabled) {
				prop_dev(input4, "disabled", ctx.disabled);
			}

			if (changed.$value) {
				input4.checked = ~ctx.$value.indexOf(input4.__value);
			}

			if (!current || changed.disabled) {
				prop_dev(input5, "disabled", ctx.disabled);
			}

			if (changed.$value) {
				input5.checked = ~ctx.$value.indexOf(input5.__value);
			}

			if (!current || changed.disabled) {
				prop_dev(input6, "disabled", ctx.disabled);
			}

			if (changed.$value) {
				input6.checked = ~ctx.$value.indexOf(input6.__value);
			}

			if (!current || changed.disabled) {
				prop_dev(input7, "disabled", ctx.disabled);
			}

			if (changed.$value) {
				input7.checked = ~ctx.$value.indexOf(input7.__value);
			}

			if (!current || changed.disabled) {
				prop_dev(input8, "disabled", ctx.disabled);
			}

			if (changed.$value) {
				input8.checked = ~ctx.$value.indexOf(input8.__value);
			}

			if (!current || changed.disabled) {
				prop_dev(input9, "disabled", ctx.disabled);
			}

			if (changed.$value) {
				input9.checked = ~ctx.$value.indexOf(input9.__value);
			}

			if (ctx.$value.length) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block$8(ctx);
					if_block.c();
					if_block.m(t21.parentNode, t21);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error.$$.fragment, local);
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error.$$.fragment, local);
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input0), 1);
			if (input_action && is_function(input_action.destroy)) input_action.destroy();
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input1), 1);
			if (input_action_1 && is_function(input_action_1.destroy)) input_action_1.destroy();
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input2), 1);
			if (input_action_2 && is_function(input_action_2.destroy)) input_action_2.destroy();
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input3), 1);
			if (input_action_3 && is_function(input_action_3.destroy)) input_action_3.destroy();
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input4), 1);
			if (input_action_4 && is_function(input_action_4.destroy)) input_action_4.destroy();
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input5), 1);
			if (input_action_5 && is_function(input_action_5.destroy)) input_action_5.destroy();
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input6), 1);
			if (input_action_6 && is_function(input_action_6.destroy)) input_action_6.destroy();
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input7), 1);
			if (input_action_7 && is_function(input_action_7.destroy)) input_action_7.destroy();
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input8), 1);
			if (input_action_8 && is_function(input_action_8.destroy)) input_action_8.destroy();
			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input9), 1);
			if (input_action_9 && is_function(input_action_9.destroy)) input_action_9.destroy();
			if (detaching) detach_dev(t19);
			destroy_component(error, detaching);
			if (detaching) detach_dev(t20);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(t21);
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t22);
			destroy_component(code1, detaching);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$c.name,
		type: "slot",
		source: "(59:0) <Form {createForm} title=\\\"Pick as much sportsman as you can\\\">",
		ctx
	});

	return block;
}

function create_fragment$m(ctx) {
	let current;

	const form = new Form({
			props: {
				createForm: ctx.createForm,
				title: "Pick as much sportsman as you can",
				$$slots: { default: [create_default_slot$c] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(form.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$a("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const form_changes = {};

			if (changed.$$scope || changed.$value || changed.color || changed.$score || changed.disabled) {
				form_changes.$$scope = { changed, ctx };
			}

			form.$set(form_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$m($$self, $$props, $$invalidate) {
	let $score;
	let $value;
	let score = tweened(0, { duration: 400, easing: cubicOut });
	validate_store(score, "score");
	component_subscribe($$self, score, value => $$invalidate("$score", $score = value));
	const { createEntry, createForm } = createValidation({ listenInputEvents: 1 });
	const [errors, value, input] = createEntry({ type: "array", value: [], required: true });
	validate_store(value, "value");
	component_subscribe($$self, value, value => $$invalidate("$value", $value = value));

	const jsCode = `let score = tweened(0, {
  duration: 400,
  easing: cubicOut
});

const { createEntry, createForm } = createValidation({ listenInputEvents: 1 });
const [ errors, value, input ] = createEntry({
  type: 'array',
  value: [],
  required: true
});

$: $score = $value.reduce((a, b) => (a + b), 0);
$: color = ($score < 0 ? 'red' : ($score < 50 ? 'inherit' : ($score < 100 ? '#768c7b' : '#32d75e')));
$: disabled = $score === 100;`;

	const htmlCode = `<h1>Pick as much sportsman as you can</h1>
<input {disabled} use:input bind:group={$value} type="checkbox" value={9} /> Tom Brady
<input {disabled} use:input bind:group={$value} type="checkbox" value={-40} /> Isaac Newton
<input {disabled} use:input bind:group={$value} type="checkbox" value={30} /> Pete Carrol
<input {disabled} use:input bind:group={$value} type="checkbox" value={-30} /> Steve Jobs
<input {disabled} use:input bind:group={$value} type="checkbox" value={14} /> Paul Gascoigne
<input {disabled} use:input bind:group={$value} type="checkbox" value={16} /> Pele
<input {disabled} use:input bind:group={$value} type="checkbox" value={20} /> Albetro Contador
<input {disabled} use:input bind:group={$value} type="checkbox" value={-20} /> David Gilmour
<input {disabled} use:input bind:group={$value} type="checkbox" value={11} /> Georges St-Pierre
<input {disabled} use:input bind:group={$value} type="checkbox" value={-10} /> Rich Harris

{#if $errors.includes('required')}Pick something please{/if}
{#if $value.length}
  <h1 style={\`color: \${color}\`}>Your score: {$score.toFixed(0)}/100 {#if $score === 100}You won!{/if}</h1>
{/if}`;

	const $$binding_groups = [[]];

	function input0_change_handler() {
		$value = get_binding_group_value($$binding_groups[0]);
		value.set($value);
	}

	function input1_change_handler() {
		$value = get_binding_group_value($$binding_groups[0]);
		value.set($value);
	}

	function input2_change_handler() {
		$value = get_binding_group_value($$binding_groups[0]);
		value.set($value);
	}

	function input3_change_handler() {
		$value = get_binding_group_value($$binding_groups[0]);
		value.set($value);
	}

	function input4_change_handler() {
		$value = get_binding_group_value($$binding_groups[0]);
		value.set($value);
	}

	function input5_change_handler() {
		$value = get_binding_group_value($$binding_groups[0]);
		value.set($value);
	}

	function input6_change_handler() {
		$value = get_binding_group_value($$binding_groups[0]);
		value.set($value);
	}

	function input7_change_handler() {
		$value = get_binding_group_value($$binding_groups[0]);
		value.set($value);
	}

	function input8_change_handler() {
		$value = get_binding_group_value($$binding_groups[0]);
		value.set($value);
	}

	function input9_change_handler() {
		$value = get_binding_group_value($$binding_groups[0]);
		value.set($value);
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("score" in $$props) $$invalidate("score", score = $$props.score);
		if ("$score" in $$props) score.set($score = $$props.$score);
		if ("$value" in $$props) value.set($value = $$props.$value);
		if ("color" in $$props) $$invalidate("color", color = $$props.color);
		if ("disabled" in $$props) $$invalidate("disabled", disabled = $$props.disabled);
	};

	let color;
	let disabled;

	$$self.$$.update = (changed = { $value: 1, $score: 1 }) => {
		if (changed.$value) {
			 set_store_value(score, $score = $value.reduce((a, b) => a + b, 0));
		}

		if (changed.$score) {
			 $$invalidate("color", color = $score < 0
			? "red"
			: $score < 50
				? "inherit"
				: $score < 100 ? "#768c7b" : "#32d75e");
		}

		if (changed.$score) {
			 $$invalidate("disabled", disabled = $score === 100);
		}
	};

	return {
		score,
		createForm,
		errors,
		value,
		input,
		jsCode,
		htmlCode,
		$score,
		$value,
		color,
		disabled,
		input0_change_handler,
		input1_change_handler,
		input2_change_handler,
		input3_change_handler,
		input4_change_handler,
		input5_change_handler,
		input6_change_handler,
		input7_change_handler,
		input8_change_handler,
		input9_change_handler,
		$$binding_groups
	};
}

class Array_sum_of_points extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$m, create_fragment$m, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Array_sum_of_points",
			options,
			id: create_fragment$m.name
		});
	}
}

/* src/docs/examples/field-confirm.svelte generated by Svelte v3.15.0 */

const { Error: Error_1$b } = globals;
const file$l = "src/docs/examples/field-confirm.svelte";

// (43:2) <Row>
function create_default_slot_2$6(ctx) {
	let t0;
	let input;
	let inputF1_action;
	let t1;
	let t2;
	let current;
	let dispose;

	const error0 = new Error$1({
			props: {
				errors: ctx.errorsF1,
				errorCode: "min",
				errorText: "At least 6 symbols"
			},
			$$inline: true
		});

	const error1 = new Error$1({
			props: {
				errors: ctx.errorsF1,
				errorCode: "match",
				errorText: "Use at one digit"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = text("Type your password\r\n    ");
			input = element("input");
			t1 = space();
			create_component(error0.$$.fragment);
			t2 = space();
			create_component(error1.$$.fragment);
			attr_dev(input, "class", "input-text");
			attr_dev(input, "type", "password");
			attr_dev(input, "placeholder", "type: 'string', min: 6, match: /d+/");
			add_location(input, file$l, 44, 4, 1565);
			dispose = listen_dev(input, "input", ctx.input_input_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, input, anchor);
			set_input_value(input, ctx.$valueF1);
			inputF1_action = ctx.inputF1.call(null, input) || ({});
			insert_dev(target, t1, anchor);
			mount_component(error0, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(error1, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$valueF1 && input.value !== ctx.$valueF1) {
				set_input_value(input, ctx.$valueF1);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error0.$$.fragment, local);
			transition_in(error1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error0.$$.fragment, local);
			transition_out(error1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(input);
			if (inputF1_action && is_function(inputF1_action.destroy)) inputF1_action.destroy();
			if (detaching) detach_dev(t1);
			destroy_component(error0, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(error1, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$6.name,
		type: "slot",
		source: "(43:2) <Row>",
		ctx
	});

	return block;
}

// (49:2) <Row>
function create_default_slot_1$a(ctx) {
	let t0;
	let input;
	let inputF2_action;
	let t1;
	let t2;
	let current;
	let dispose;

	const error0 = new Error$1({
			props: {
				errors: ctx.errorsF2,
				errorCode: "required"
			},
			$$inline: true
		});

	const error1 = new Error$1({
			props: {
				errors: ctx.errorsF2,
				errorCode: "equal",
				errorText: "Should be equal with second one"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = text("Confirm your password\r\n    ");
			input = element("input");
			t1 = space();
			create_component(error0.$$.fragment);
			t2 = space();
			create_component(error1.$$.fragment);
			attr_dev(input, "class", "input-text");
			attr_dev(input, "type", "password");
			attr_dev(input, "placeholder", "type: 'string', required: true, equal: function");
			add_location(input, file$l, 50, 4, 1905);
			dispose = listen_dev(input, "input", ctx.input_input_handler_1);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, input, anchor);
			set_input_value(input, ctx.$valueF2);
			inputF2_action = ctx.inputF2.call(null, input) || ({});
			insert_dev(target, t1, anchor);
			mount_component(error0, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(error1, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$valueF2 && input.value !== ctx.$valueF2) {
				set_input_value(input, ctx.$valueF2);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error0.$$.fragment, local);
			transition_in(error1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error0.$$.fragment, local);
			transition_out(error1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(input);
			if (inputF2_action && is_function(inputF2_action.destroy)) inputF2_action.destroy();
			if (detaching) detach_dev(t1);
			destroy_component(error0, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(error1, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$a.name,
		type: "slot",
		source: "(49:2) <Row>",
		ctx
	});

	return block;
}

// (40:0) <Form {createForm} title="Confirm password">
function create_default_slot$d(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let current;

	const code0 = new Code({
			props: { code: ctx.jsCode },
			$$inline: true
		});

	const code1 = new Code({
			props: { code: ctx.htmlCode },
			$$inline: true
		});

	const row0 = new Row({
			props: {
				$$slots: { default: [create_default_slot_2$6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const row1 = new Row({
			props: {
				$$slots: { default: [create_default_slot_1$a] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const button = new Button({
			props: { type: "submit" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(code0.$$.fragment);
			t0 = space();
			create_component(code1.$$.fragment);
			t1 = space();
			create_component(row0.$$.fragment);
			t2 = space();
			create_component(row1.$$.fragment);
			t3 = space();
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(code0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(code1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(row0, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(row1, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const row0_changes = {};

			if (changed.$$scope || changed.$valueF1) {
				row0_changes.$$scope = { changed, ctx };
			}

			row0.$set(row0_changes);
			const row1_changes = {};

			if (changed.$$scope || changed.$valueF2) {
				row1_changes.$$scope = { changed, ctx };
			}

			row1.$set(row1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			transition_in(row0.$$.fragment, local);
			transition_in(row1.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			transition_out(row0.$$.fragment, local);
			transition_out(row1.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(code1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(row0, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(row1, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$d.name,
		type: "slot",
		source: "(40:0) <Form {createForm} title=\\\"Confirm password\\\">",
		ctx
	});

	return block;
}

function create_fragment$n(ctx) {
	let current;

	const form = new Form({
			props: {
				createForm: ctx.createForm,
				title: "Confirm password",
				$$slots: { default: [create_default_slot$d] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(form.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$b("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const form_changes = {};

			if (changed.$$scope || changed.$valueF2 || changed.$valueF1) {
				form_changes.$$scope = { changed, ctx };
			}

			form.$set(form_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$n($$self, $$props, $$invalidate) {
	let $valueF1;
	let $valueF2;
	const { createEntry, createForm } = createValidation({ validateOnEvents: { input: true } });
	const [errorsF1, valueF1, inputF1] = createEntry({ type: "string", min: 6, match: /\d+/ });
	validate_store(valueF1, "valueF1");
	component_subscribe($$self, valueF1, value => $$invalidate("$valueF1", $valueF1 = value));

	const [errorsF2, valueF2, inputF2] = createEntry({
		type: "string",
		required: true,
		equal: value => {
			return value === $valueF1;
		}
	});

	validate_store(valueF2, "valueF2");
	component_subscribe($$self, valueF2, value => $$invalidate("$valueF2", $valueF2 = value));

	const jsCode = `const { createEntry, createForm } = createValidation({ validateOnEvents: { input: true } });
  const [ errorsF1, valueF1, inputF1 ] = createEntry({
    type: 'string', min: 6, match: /\d+/
  });

  const [ errorsF2, valueF2, inputF2 ] = createEntry({
    type: 'string', required: true, equal: (value) => {
    return value === $valueF1;
  }
});`;

	const htmlCode = `<input use:inputF1 bind:value={$valueF1} />
{#if $errorsF1.includes('min')}At least 6 symbols{/if}
{#if $errorsF1.includes('match')}TUse at one digit{/if}

<input use:inputF2 bind:value={$valueF2} />
{#if $errorsF2.includes('required')}This field is required{/if}
{#if $errorsF2.includes('equal')}Should be equal with second one{/if}`;

	function input_input_handler() {
		$valueF1 = this.value;
		valueF1.set($valueF1);
	}

	function input_input_handler_1() {
		$valueF2 = this.value;
		valueF2.set($valueF2);
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("$valueF1" in $$props) valueF1.set($valueF1 = $$props.$valueF1);
		if ("$valueF2" in $$props) valueF2.set($valueF2 = $$props.$valueF2);
	};

	return {
		createForm,
		errorsF1,
		valueF1,
		inputF1,
		errorsF2,
		valueF2,
		inputF2,
		jsCode,
		htmlCode,
		$valueF1,
		$valueF2,
		input_input_handler,
		input_input_handler_1
	};
}

class Field_confirm extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$n, create_fragment$n, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Field_confirm",
			options,
			id: create_fragment$n.name
		});
	}
}

/* src/docs/examples/dynamic-steps.svelte generated by Svelte v3.15.0 */

const { Error: Error_1$c } = globals;
const file$m = "src/docs/examples/dynamic-steps.svelte";

// (62:2) {:else}
function create_else_block$6(ctx) {
	let p;

	const block = {
		c: function create() {
			p = element("p");
			p.textContent = "SUCCESS";
			add_location(p, file$m, 62, 4, 2277);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$6.name,
		type: "else",
		source: "(62:2) {:else}",
		ctx
	});

	return block;
}

// (56:23) 
function create_if_block_1$8(ctx) {
	let t;
	let current;

	const row = new Row({
			props: {
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const button = new Button({
			props: {
				type: "submit",
				$$slots: { default: [create_default_slot_3$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(row.$$.fragment);
			t = space();
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(row, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const row_changes = {};

			if (changed.$$scope || changed.$step2Value) {
				row_changes.$$scope = { changed, ctx };
			}

			row.$set(row_changes);
			const button_changes = {};

			if (changed.$$scope) {
				button_changes.$$scope = { changed, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(row, detaching);
			if (detaching) detach_dev(t);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$8.name,
		type: "if",
		source: "(56:23) ",
		ctx
	});

	return block;
}

// (50:2) {#if step === 0}
function create_if_block$9(ctx) {
	let t;
	let current;

	const row = new Row({
			props: {
				$$slots: { default: [create_default_slot_2$7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const button = new Button({
			props: {
				type: "submit",
				$$slots: { default: [create_default_slot_1$b] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(row.$$.fragment);
			t = space();
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(row, target, anchor);
			insert_dev(target, t, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const row_changes = {};

			if (changed.$$scope || changed.$step1Value) {
				row_changes.$$scope = { changed, ctx };
			}

			row.$set(row_changes);
			const button_changes = {};

			if (changed.$$scope) {
				button_changes.$$scope = { changed, ctx };
			}

			button.$set(button_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(row, detaching);
			if (detaching) detach_dev(t);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$9.name,
		type: "if",
		source: "(50:2) {#if step === 0}",
		ctx
	});

	return block;
}

// (57:4) <Row>
function create_default_slot_4$1(ctx) {
	let input;
	let step2Input_action;
	let t;
	let current;
	let dispose;

	const error = new Error$1({
			props: {
				errors: ctx.step2Errors,
				errorCode: "required"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input = element("input");
			t = space();
			create_component(error.$$.fragment);
			attr_dev(input, "class", "input-text");
			attr_dev(input, "placeholder", "type: 'string', required: true");
			add_location(input, file$m, 57, 6, 2033);
			dispose = listen_dev(input, "input", ctx.input_input_handler_1);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, ctx.$step2Value);
			step2Input_action = ctx.step2Input.call(null, input) || ({});
			insert_dev(target, t, anchor);
			mount_component(error, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$step2Value && input.value !== ctx.$step2Value) {
				set_input_value(input, ctx.$step2Value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (step2Input_action && is_function(step2Input_action.destroy)) step2Input_action.destroy();
			if (detaching) detach_dev(t);
			destroy_component(error, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4$1.name,
		type: "slot",
		source: "(57:4) <Row>",
		ctx
	});

	return block;
}

// (61:4) <Button type="submit">
function create_default_slot_3$2(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Submit");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$2.name,
		type: "slot",
		source: "(61:4) <Button type=\\\"submit\\\">",
		ctx
	});

	return block;
}

// (51:4) <Row>
function create_default_slot_2$7(ctx) {
	let input;
	let step1Input_action;
	let t;
	let current;
	let dispose;

	const error = new Error$1({
			props: {
				errors: ctx.step1Errors,
				errorCode: "required"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input = element("input");
			t = space();
			create_component(error.$$.fragment);
			attr_dev(input, "class", "input-text");
			attr_dev(input, "placeholder", "type: 'string', required: true");
			add_location(input, file$m, 51, 6, 1759);
			dispose = listen_dev(input, "input", ctx.input_input_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, ctx.$step1Value);
			step1Input_action = ctx.step1Input.call(null, input) || ({});
			insert_dev(target, t, anchor);
			mount_component(error, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$step1Value && input.value !== ctx.$step1Value) {
				set_input_value(input, ctx.$step1Value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (step1Input_action && is_function(step1Input_action.destroy)) step1Input_action.destroy();
			if (detaching) detach_dev(t);
			destroy_component(error, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$7.name,
		type: "slot",
		source: "(51:4) <Row>",
		ctx
	});

	return block;
}

// (55:4) <Button type="submit">
function create_default_slot_1$b(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("Next step");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$b.name,
		type: "slot",
		source: "(55:4) <Button type=\\\"submit\\\">",
		ctx
	});

	return block;
}

// (23:0) <Form {createForm} createFormOpts={{ onSuccess }} title="Dynamic steps">
function create_default_slot$e(ctx) {
	let t0;
	let t1;
	let p;
	let t2;
	let t3_value = ctx.step + 1 + "";
	let t3;
	let t4;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const code0 = new Code({
			props: {
				code: `const { createEntries, createForm } = createValidation({ validateOnEvents: { input: true } });
const [
  [ step1Errors, step1Value, step1Input ],
  [ step2Errors, step2Value, step2Input ]
] = createEntries([
  { type: 'string', required: true },
  { type: 'string', required: true },
]);

let step = 0;
const onSuccess = () => step++;`
			},
			$$inline: true
		});

	const code1 = new Code({
			props: {
				code: `<form use:createForm={{ onSuccess }} on:submit|preventDefault>
  <p>current step is #{step+1}</p>
  {#if step === 0}
    <input use:step1Input bind:value={$step1Value} />
    {#if $step1Errors.includes('required')}This field is required{/if}
    <button type="submit">Next step</button>
  {:else if step === 1}
    <input use:step2Input bind:value={$step2Value} />
    {#if $step2Errors.includes('required')}This field is required{/if}
    <button type="submit">Submit</button>
  {:else}
    <p>SUCCESS</p>
  {/if}
</form>`
			},
			$$inline: true
		});

	const if_block_creators = [create_if_block$9, create_if_block_1$8, create_else_block$6];
	const if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.step === 0) return 0;
		if (ctx.step === 1) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			create_component(code0.$$.fragment);
			t0 = space();
			create_component(code1.$$.fragment);
			t1 = space();
			p = element("p");
			t2 = text("current step is #");
			t3 = text(t3_value);
			t4 = space();
			if_block.c();
			if_block_anchor = empty();
			add_location(p, file$m, 48, 2, 1688);
		},
		m: function mount(target, anchor) {
			mount_component(code0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(code1, target, anchor);
			insert_dev(target, t1, anchor);
			insert_dev(target, p, anchor);
			append_dev(p, t2);
			append_dev(p, t3);
			insert_dev(target, t4, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if ((!current || changed.step) && t3_value !== (t3_value = ctx.step + 1 + "")) set_data_dev(t3, t3_value);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(code1, detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(p);
			if (detaching) detach_dev(t4);
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$e.name,
		type: "slot",
		source: "(23:0) <Form {createForm} createFormOpts={{ onSuccess }} title=\\\"Dynamic steps\\\">",
		ctx
	});

	return block;
}

function create_fragment$o(ctx) {
	let current;

	const form = new Form({
			props: {
				createForm: ctx.createForm,
				createFormOpts: { onSuccess: ctx.onSuccess },
				title: "Dynamic steps",
				$$slots: { default: [create_default_slot$e] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(form.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$c("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const form_changes = {};

			if (changed.$$scope || changed.step || changed.$step1Value || changed.$step2Value) {
				form_changes.$$scope = { changed, ctx };
			}

			form.$set(form_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$o($$self, $$props, $$invalidate) {
	let $step1Value;
	let $step2Value;
	const { createEntries, createForm } = createValidation({ validateOnEvents: { input: true } });
	const [[step1Errors, step1Value, step1Input], [step2Errors, step2Value, step2Input]] = createEntries([{ type: "string", required: true }, { type: "string", required: true }]);
	validate_store(step1Value, "step1Value");
	component_subscribe($$self, step1Value, value => $$invalidate("$step1Value", $step1Value = value));
	validate_store(step2Value, "step2Value");
	component_subscribe($$self, step2Value, value => $$invalidate("$step2Value", $step2Value = value));
	let step = 0;
	const onSuccess = () => $$invalidate("step", step++, step);

	function input_input_handler() {
		$step1Value = this.value;
		step1Value.set($step1Value);
	}

	function input_input_handler_1() {
		$step2Value = this.value;
		step2Value.set($step2Value);
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("step" in $$props) $$invalidate("step", step = $$props.step);
		if ("$step1Value" in $$props) step1Value.set($step1Value = $$props.$step1Value);
		if ("$step2Value" in $$props) step2Value.set($step2Value = $$props.$step2Value);
	};

	return {
		createForm,
		step1Errors,
		step1Value,
		step1Input,
		step2Errors,
		step2Value,
		step2Input,
		step,
		onSuccess,
		$step1Value,
		$step2Value,
		input_input_handler,
		input_input_handler_1
	};
}

class Dynamic_steps extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Dynamic_steps",
			options,
			id: create_fragment$o.name
		});
	}
}

/* src/docs/examples/use-with-params.svelte generated by Svelte v3.15.0 */

const { Error: Error_1$d } = globals;
const file$n = "src/docs/examples/use-with-params.svelte";

// (31:2) <Row labelText="Validate on input">
function create_default_slot_2$8(ctx) {
	let input_1;
	let input_action;
	let t;
	let current;
	let dispose;

	const error = new Error$1({
			props: {
				errors: ctx.errors,
				errorCode: "min",
				errorText: "Use at least 3 symbols"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input_1 = element("input");
			t = space();
			create_component(error.$$.fragment);
			attr_dev(input_1, "class", "input-text");
			attr_dev(input_1, "placeholder", "type: 'string', min: 3, required: true");
			add_location(input_1, file$n, 31, 4, 1321);
			dispose = listen_dev(input_1, "input", ctx.input_1_input_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			set_input_value(input_1, ctx.$value);
			input_action = ctx.input.call(null, input_1) || ({});
			insert_dev(target, t, anchor);
			mount_component(error, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$value && input_1.value !== ctx.$value) {
				set_input_value(input_1, ctx.$value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			if (input_action && is_function(input_action.destroy)) input_action.destroy();
			if (detaching) detach_dev(t);
			destroy_component(error, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$8.name,
		type: "slot",
		source: "(31:2) <Row labelText=\\\"Validate on input\\\">",
		ctx
	});

	return block;
}

// (35:2) <Row labelText="Validate on blur">
function create_default_slot_1$c(ctx) {
	let input_1;
	let inputWithUseParams_action;
	let t;
	let current;
	let dispose;

	const error = new Error$1({
			props: {
				errors: ctx.errorsWithUseParams,
				errorCode: "min",
				errorText: "Use at least 3 symbols"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input_1 = element("input");
			t = space();
			create_component(error.$$.fragment);
			attr_dev(input_1, "class", "input-text");
			attr_dev(input_1, "placeholder", "type: 'string', min: 3, required: true");
			add_location(input_1, file$n, 35, 4, 1561);
			dispose = listen_dev(input_1, "input", ctx.input_1_input_handler_1);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			set_input_value(input_1, ctx.$valueWithUseParams);
			inputWithUseParams_action = ctx.inputWithUseParams.call(null, input_1, { validateOnEvents: { blur: true } }) || ({});
			insert_dev(target, t, anchor);
			mount_component(error, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$valueWithUseParams && input_1.value !== ctx.$valueWithUseParams) {
				set_input_value(input_1, ctx.$valueWithUseParams);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			if (inputWithUseParams_action && is_function(inputWithUseParams_action.destroy)) inputWithUseParams_action.destroy();
			if (detaching) detach_dev(t);
			destroy_component(error, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$c.name,
		type: "slot",
		source: "(35:2) <Row labelText=\\\"Validate on blur\\\">",
		ctx
	});

	return block;
}

// (19:0) <Form {createForm} title="'use' directive with params">
function create_default_slot$f(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let current;

	const code0 = new Code({
			props: {
				code: `const [
  [ errors, value, input ],
  [ errorsWithUseParams, valueWithUseParams, inputWithUseParams ]
] = createEntries([
  { type: 'string', min: 3, required: true },
  { type: 'string', min: 3, required: true },
]);`
			},
			$$inline: true
		});

	const code1 = new Code({
			props: {
				code: `<input use:input bind:value={$value} />
{#if $errors.includes('min')}Use at least 3 symbols{/if}
<input use:inputWithUseParams={{ validateOnEvents: { blur: true } }} bind:value={$valueWithUseParams} />
{#if $errorsWithUseParams.includes('min')}Use at least 3 symbols{/if}`
			},
			$$inline: true
		});

	const row0 = new Row({
			props: {
				labelText: "Validate on input",
				$$slots: { default: [create_default_slot_2$8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const row1 = new Row({
			props: {
				labelText: "Validate on blur",
				$$slots: { default: [create_default_slot_1$c] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const button = new Button({
			props: { type: "submit" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(code0.$$.fragment);
			t0 = space();
			create_component(code1.$$.fragment);
			t1 = space();
			create_component(row0.$$.fragment);
			t2 = space();
			create_component(row1.$$.fragment);
			t3 = space();
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(code0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(code1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(row0, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(row1, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const row0_changes = {};

			if (changed.$$scope || changed.$value) {
				row0_changes.$$scope = { changed, ctx };
			}

			row0.$set(row0_changes);
			const row1_changes = {};

			if (changed.$$scope || changed.$valueWithUseParams) {
				row1_changes.$$scope = { changed, ctx };
			}

			row1.$set(row1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			transition_in(row0.$$.fragment, local);
			transition_in(row1.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			transition_out(row0.$$.fragment, local);
			transition_out(row1.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(code1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(row0, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(row1, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$f.name,
		type: "slot",
		source: "(19:0) <Form {createForm} title=\\\"'use' directive with params\\\">",
		ctx
	});

	return block;
}

function create_fragment$p(ctx) {
	let current;

	const form = new Form({
			props: {
				createForm: ctx.createForm,
				title: "'use' directive with params",
				$$slots: { default: [create_default_slot$f] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(form.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$d("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const form_changes = {};

			if (changed.$$scope || changed.$valueWithUseParams || changed.$value) {
				form_changes.$$scope = { changed, ctx };
			}

			form.$set(form_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$p($$self, $$props, $$invalidate) {
	let $value;
	let $valueWithUseParams;

	const { createEntries, createForm } = createValidation({
		validateOnEvents: { input: true },
		listenInputEvents: 1
	});

	const [
		[errors, value, input],
		[errorsWithUseParams, valueWithUseParams, inputWithUseParams]
	] = createEntries([
		{ type: "string", min: 3, required: true },
		{ type: "string", min: 3, required: true }
	]);

	validate_store(value, "value");
	component_subscribe($$self, value, value => $$invalidate("$value", $value = value));
	validate_store(valueWithUseParams, "valueWithUseParams");
	component_subscribe($$self, valueWithUseParams, value => $$invalidate("$valueWithUseParams", $valueWithUseParams = value));

	function input_1_input_handler() {
		$value = this.value;
		value.set($value);
	}

	function input_1_input_handler_1() {
		$valueWithUseParams = this.value;
		valueWithUseParams.set($valueWithUseParams);
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("$value" in $$props) value.set($value = $$props.$value);
		if ("$valueWithUseParams" in $$props) valueWithUseParams.set($valueWithUseParams = $$props.$valueWithUseParams);
	};

	return {
		createForm,
		errors,
		value,
		input,
		errorsWithUseParams,
		valueWithUseParams,
		inputWithUseParams,
		$value,
		$valueWithUseParams,
		input_1_input_handler,
		input_1_input_handler_1
	};
}

class Use_with_params extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Use_with_params",
			options,
			id: create_fragment$p.name
		});
	}
}

/* src/docs/examples/without-inputs.svelte generated by Svelte v3.15.0 */

const { Error: Error_1$e } = globals;
const file$o = "src/docs/examples/without-inputs.svelte";

function add_css$c() {
	var style = element("style");
	style.id = "svelte-1u74her-style";
	style.textContent = "span.svelte-1u74her{display:inline-block;font-size:30px;line-height:30px;margin-top:4px;padding:0 10px;vertical-align:top}button{min-width:40px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2l0aG91dC1pbnB1dHMuc3ZlbHRlIiwic291cmNlcyI6WyJ3aXRob3V0LWlucHV0cy5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cclxuICBpbXBvcnQgY3JlYXRlVmFsaWRhdGlvbiBmcm9tICdsaWIvbGliJztcclxuICBpbXBvcnQgRXJyb3IgZnJvbSAnZG9jcy91aS9lcnJvci5zdmVsdGUnO1xyXG4gIGltcG9ydCBGb3JtIGZyb20gJ2RvY3MvZXhhbXBsZXMvY29tcG9uZW50cy9mb3JtLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IENvZGUgZnJvbSAnZG9jcy91aS9jb2RlLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IEJ1dHRvbiBmcm9tICdkb2NzL3VpL2J1dHRvbi5zdmVsdGUnO1xyXG5cclxuICBjb25zdCB7IGNyZWF0ZUVudHJ5LCBjcmVhdGVGb3JtLCB2YWxpZGF0ZVZhbHVlU3RvcmUgfSA9IGNyZWF0ZVZhbGlkYXRpb24oe1xyXG4gICAgaW5jbHVkZUFsbEVudHJpZXM6IHRydWVcclxuICB9KTtcclxuXHJcbiAgbGV0IFsgZXJyb3JzLCB2YWx1ZSBdID0gY3JlYXRlRW50cnkoe1xyXG4gICAgdHlwZTogJ251bWJlcicsXHJcbiAgICBtaW46IDMsXHJcbiAgICBtYXg6IDUsXHJcbiAgICB2YWx1ZTogM1xyXG4gIH0pO1xyXG48L3NjcmlwdD5cclxuXHJcbjxGb3JtIHtjcmVhdGVGb3JtfSB0aXRsZT1cIldpdGhvdXQgaW5wdXRzXCI+XHJcbiAgPENvZGUgY29kZT17YGNvbnN0IHsgY3JlYXRlRW50cnksIGNyZWF0ZUZvcm0sIHZhbGlkYXRlVmFsdWVTdG9yZSB9ID0gY3JlYXRlVmFsaWRhdGlvbih7XHJcbiAgaW5jbHVkZUFsbEVudHJpZXM6IHRydWVcclxufSk7XHJcblxyXG5sZXQgWyBlcnJvcnMsIHZhbHVlIF0gPSBjcmVhdGVFbnRyeSh7XHJcbiAgdHlwZTogJ251bWJlcicsXHJcbiAgbWluOiAzLFxyXG4gIG1heDogNSxcclxuICB2YWx1ZTogM1xyXG59KTtgfSAvPlxyXG4gIDxDb2RlIGNvZGU9e2A8YnV0dG9uIG9uOmNsaWNrPXsoKSA9PiAoJHZhbHVlLS0sIHZhbGlkYXRlVmFsdWVTdG9yZSh2YWx1ZSkpfT4tPC9idXR0b24+XHJcbjxzcGFuPnskdmFsdWV9PC9zcGFuPlxyXG48YnV0dG9uIG9uOmNsaWNrPXsoKSA9PiAoJHZhbHVlKyssIHZhbGlkYXRlVmFsdWVTdG9yZSh2YWx1ZSkpfT4rPC9idXR0b24+XHJcbnsjaWYgJGVycm9ycy5pbmNsdWRlcygnbWluJyl9MyBpcyBtaW57L2lmfVxyXG57I2lmICRlcnJvcnMuaW5jbHVkZXMoJ21heCcpfTUgaXMgbWF4ey9pZn1gfSAvPlxyXG4gIDxCdXR0b24gb246Y2xpY2s9eygpID0+ICgkdmFsdWUtLSwgdmFsaWRhdGVWYWx1ZVN0b3JlKHZhbHVlKSl9Pi08L0J1dHRvbj5cclxuICA8c3Bhbj57JHZhbHVlfTwvc3Bhbj5cclxuICA8QnV0dG9uIG9uOmNsaWNrPXsoKSA9PiAoJHZhbHVlKyssIHZhbGlkYXRlVmFsdWVTdG9yZSh2YWx1ZSkpfT4rPC9CdXR0b24+XHJcbiAgPEVycm9yIHtlcnJvcnN9IGVycm9yQ29kZT1cIm1pblwiIGVycm9yVGV4dD1cIjMgaXMgbWluXCIgLz5cclxuICA8RXJyb3Ige2Vycm9yc30gZXJyb3JDb2RlPVwibWF4XCIgZXJyb3JUZXh0PVwiNSBpcyBtYXhcIiAvPlxyXG48L0Zvcm0+XHJcblxyXG48c3R5bGU+XHJcbiAgc3BhbiB7XHJcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICBmb250LXNpemU6IDMwcHg7XHJcbiAgICBsaW5lLWhlaWdodDogMzBweDtcclxuICAgIG1hcmdpbi10b3A6IDRweDtcclxuICAgIHBhZGRpbmc6IDAgMTBweDtcclxuICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XHJcbiAgfVxyXG5cclxuICA6Z2xvYmFsKGJ1dHRvbikge1xyXG4gICAgbWluLXdpZHRoOiA0MHB4O1xyXG4gIH1cclxuXHJcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbk55WXk5a2IyTnpMMlY0WVcxd2JHVnpMM2RwZEdodmRYUXRhVzV3ZFhSekxuTjJaV3gwWlNKZExDSnVZVzFsY3lJNlcxMHNJbTFoY0hCcGJtZHpJam9pTzBWQlEwVTdTVUZEUlN4eFFrRkJjVUk3U1VGRGNrSXNaVUZCWlR0SlFVTm1MR2xDUVVGcFFqdEpRVU5xUWl4bFFVRmxPMGxCUTJZc1pVRkJaVHRKUVVObUxHMUNRVUZ0UWp0RlFVTnlRanM3UlVGRlFUdEpRVU5GTEdWQlFXVTdSVUZEYWtJaUxDSm1hV3hsSWpvaWMzSmpMMlJ2WTNNdlpYaGhiWEJzWlhNdmQybDBhRzkxZEMxcGJuQjFkSE11YzNabGJIUmxJaXdpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHNpWEhKY2JpQWdjM0JoYmlCN1hISmNiaUFnSUNCa2FYTndiR0Y1T2lCcGJteHBibVV0WW14dlkyczdYSEpjYmlBZ0lDQm1iMjUwTFhOcGVtVTZJRE13Y0hnN1hISmNiaUFnSUNCc2FXNWxMV2hsYVdkb2REb2dNekJ3ZUR0Y2NseHVJQ0FnSUcxaGNtZHBiaTEwYjNBNklEUndlRHRjY2x4dUlDQWdJSEJoWkdScGJtYzZJREFnTVRCd2VEdGNjbHh1SUNBZ0lIWmxjblJwWTJGc0xXRnNhV2R1T2lCMGIzQTdYSEpjYmlBZ2ZWeHlYRzVjY2x4dUlDQTZaMnh2WW1Gc0tHSjFkSFJ2YmlrZ2UxeHlYRzRnSUNBZ2JXbHVMWGRwWkhSb09pQTBNSEI0TzF4eVhHNGdJSDFjY2x4dUlsMTkgKi88L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBMkNFLElBQUksZUFBQyxDQUFDLEFBQ0osT0FBTyxDQUFFLFlBQVksQ0FDckIsU0FBUyxDQUFFLElBQUksQ0FDZixXQUFXLENBQUUsSUFBSSxDQUNqQixVQUFVLENBQUUsR0FBRyxDQUNmLE9BQU8sQ0FBRSxDQUFDLENBQUMsSUFBSSxDQUNmLGNBQWMsQ0FBRSxHQUFHLEFBQ3JCLENBQUMsQUFFTyxNQUFNLEFBQUUsQ0FBQyxBQUNmLFNBQVMsQ0FBRSxJQUFJLEFBQ2pCLENBQUMifQ== */";
	append_dev(document.head, style);
}

// (36:2) <Button on:click={() => ($value--, validateValueStore(value))}>
function create_default_slot_2$9(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("-");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$9.name,
		type: "slot",
		source: "(36:2) <Button on:click={() => ($value--, validateValueStore(value))}>",
		ctx
	});

	return block;
}

// (38:2) <Button on:click={() => ($value++, validateValueStore(value))}>
function create_default_slot_1$d(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text("+");
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$d.name,
		type: "slot",
		source: "(38:2) <Button on:click={() => ($value++, validateValueStore(value))}>",
		ctx
	});

	return block;
}

// (20:0) <Form {createForm} title="Without inputs">
function create_default_slot$g(ctx) {
	let t0;
	let t1;
	let t2;
	let span;
	let t3;
	let t4;
	let t5;
	let t6;
	let current;

	const code0 = new Code({
			props: {
				code: `const { createEntry, createForm, validateValueStore } = createValidation({
  includeAllEntries: true
});

let [ errors, value ] = createEntry({
  type: 'number',
  min: 3,
  max: 5,
  value: 3
});`
			},
			$$inline: true
		});

	const code1 = new Code({
			props: {
				code: `<button on:click={() => ($value--, validateValueStore(value))}>-</button>
<span>{$value}</span>
<button on:click={() => ($value++, validateValueStore(value))}>+</button>
{#if $errors.includes('min')}3 is min{/if}
{#if $errors.includes('max')}5 is max{/if}`
			},
			$$inline: true
		});

	const button0 = new Button({
			props: {
				$$slots: { default: [create_default_slot_2$9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button0.$on("click", ctx.click_handler);

	const button1 = new Button({
			props: {
				$$slots: { default: [create_default_slot_1$d] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	button1.$on("click", ctx.click_handler_1);

	const error0 = new Error$1({
			props: {
				errors: ctx.errors,
				errorCode: "min",
				errorText: "3 is min"
			},
			$$inline: true
		});

	const error1 = new Error$1({
			props: {
				errors: ctx.errors,
				errorCode: "max",
				errorText: "5 is max"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(code0.$$.fragment);
			t0 = space();
			create_component(code1.$$.fragment);
			t1 = space();
			create_component(button0.$$.fragment);
			t2 = space();
			span = element("span");
			t3 = text(ctx.$value);
			t4 = space();
			create_component(button1.$$.fragment);
			t5 = space();
			create_component(error0.$$.fragment);
			t6 = space();
			create_component(error1.$$.fragment);
			attr_dev(span, "class", "svelte-1u74her");
			add_location(span, file$o, 36, 2, 1119);
		},
		m: function mount(target, anchor) {
			mount_component(code0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(code1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(button0, target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, span, anchor);
			append_dev(span, t3);
			insert_dev(target, t4, anchor);
			mount_component(button1, target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(error0, target, anchor);
			insert_dev(target, t6, anchor);
			mount_component(error1, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const button0_changes = {};

			if (changed.$$scope) {
				button0_changes.$$scope = { changed, ctx };
			}

			button0.$set(button0_changes);
			if (!current || changed.$value) set_data_dev(t3, ctx.$value);
			const button1_changes = {};

			if (changed.$$scope) {
				button1_changes.$$scope = { changed, ctx };
			}

			button1.$set(button1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			transition_in(button0.$$.fragment, local);
			transition_in(button1.$$.fragment, local);
			transition_in(error0.$$.fragment, local);
			transition_in(error1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			transition_out(button0.$$.fragment, local);
			transition_out(button1.$$.fragment, local);
			transition_out(error0.$$.fragment, local);
			transition_out(error1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(code1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(button0, detaching);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(span);
			if (detaching) detach_dev(t4);
			destroy_component(button1, detaching);
			if (detaching) detach_dev(t5);
			destroy_component(error0, detaching);
			if (detaching) detach_dev(t6);
			destroy_component(error1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$g.name,
		type: "slot",
		source: "(20:0) <Form {createForm} title=\\\"Without inputs\\\">",
		ctx
	});

	return block;
}

function create_fragment$q(ctx) {
	let current;

	const form = new Form({
			props: {
				createForm: ctx.createForm,
				title: "Without inputs",
				$$slots: { default: [create_default_slot$g] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(form.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$e("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const form_changes = {};

			if (changed.$$scope || changed.$value) {
				form_changes.$$scope = { changed, ctx };
			}

			form.$set(form_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$q($$self, $$props, $$invalidate) {
	let $value;
	const { createEntry, createForm, validateValueStore } = createValidation({ includeAllEntries: true });
	let [errors, value] = createEntry({ type: "number", min: 3, max: 5, value: 3 });
	validate_store(value, "value");
	component_subscribe($$self, value, value => $$invalidate("$value", $value = value));
	const click_handler = () => (set_store_value(value, $value--, $value), validateValueStore(value));
	const click_handler_1 = () => (set_store_value(value, $value++, $value), validateValueStore(value));

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("errors" in $$props) $$invalidate("errors", errors = $$props.errors);
		if ("value" in $$props) $$invalidate("value", value = $$props.value);
		if ("$value" in $$props) value.set($value = $$props.$value);
	};

	return {
		createForm,
		validateValueStore,
		errors,
		value,
		$value,
		click_handler,
		click_handler_1
	};
}

class Without_inputs extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1u74her-style")) add_css$c();
		init(this, options, instance$q, create_fragment$q, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Without_inputs",
			options,
			id: create_fragment$q.name
		});
	}
}

/* src/docs/examples/custom-errors.svelte generated by Svelte v3.15.0 */

const { Object: Object_1$1 } = globals;
const file$p = "src/docs/examples/custom-errors.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = Object_1$1.create(ctx);
	child_ctx.errorCode = list[i];
	return child_ctx;
}

// (39:4) {#each Object.keys($errors) as errorCode}
function create_each_block$2(ctx) {
	let p;
	let t0;
	let t1_value = ctx.errorCode + "";
	let t1;
	let t2;
	let t3_value = ctx.$errors[ctx.errorCode] + "";
	let t3;

	const block = {
		c: function create() {
			p = element("p");
			t0 = text("Problem with ");
			t1 = text(t1_value);
			t2 = text(": ");
			t3 = text(t3_value);
			set_style(p, "color", "#f00");
			add_location(p, file$p, 39, 6, 1447);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			append_dev(p, t1);
			append_dev(p, t2);
			append_dev(p, t3);
		},
		p: function update(changed, ctx) {
			if (changed.$errors && t1_value !== (t1_value = ctx.errorCode + "")) set_data_dev(t1, t1_value);
			if (changed.$errors && t3_value !== (t3_value = ctx.$errors[ctx.errorCode] + "")) set_data_dev(t3, t3_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(39:4) {#each Object.keys($errors) as errorCode}",
		ctx
	});

	return block;
}

// (37:2) <Row>
function create_default_slot_1$e(ctx) {
	let input_1;
	let input_action;
	let t;
	let each_1_anchor;
	let dispose;
	let each_value = Object.keys(ctx.$errors);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			input_1 = element("input");
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
			attr_dev(input_1, "class", "input-text");
			attr_dev(input_1, "placeholder", "type: 'string', min: 5, required: true");
			add_location(input_1, file$p, 37, 4, 1281);
			dispose = listen_dev(input_1, "input", ctx.input_1_input_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			set_input_value(input_1, ctx.$value);
			input_action = ctx.input.call(null, input_1) || ({});
			insert_dev(target, t, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
		},
		p: function update(changed, ctx) {
			if (changed.$value && input_1.value !== ctx.$value) {
				set_input_value(input_1, ctx.$value);
			}

			if (changed.$errors || changed.Object) {
				each_value = Object.keys(ctx.$errors);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			if (input_action && is_function(input_action.destroy)) input_action.destroy();
			if (detaching) detach_dev(t);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$e.name,
		type: "slot",
		source: "(37:2) <Row>",
		ctx
	});

	return block;
}

// (21:0) <Form {createForm} title="Custom errors">
function create_default_slot$h(ctx) {
	let t0;
	let t1;
	let t2;
	let current;

	const code0 = new Code({
			props: {
				code: `const { createEntry, createForm } = createValidation({
  validateOnEvents: { input: true },
  useCustomErrorsStore: (errors, params) => {
    return errors.reduce((result, ruleName) => {
      result[ruleName] = params[ruleName];
      return result;
    }, {});
  }
});

const [ errors, value, input ] = createEntry({ type: 'string', min: 5, required: true });`
			},
			$$inline: true
		});

	const code1 = new Code({
			props: {
				code: `<input use:input bind:value={$value} />
{#each Object.keys($errors) as errorCode}
  Problem with {errorCode}: {$errors[errorCode]}
{/each}`
			},
			$$inline: true
		});

	const row = new Row({
			props: {
				$$slots: { default: [create_default_slot_1$e] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const button = new Button({
			props: { type: "submit" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(code0.$$.fragment);
			t0 = space();
			create_component(code1.$$.fragment);
			t1 = space();
			create_component(row.$$.fragment);
			t2 = space();
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(code0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(code1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(row, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const row_changes = {};

			if (changed.$$scope || changed.$errors || changed.$value) {
				row_changes.$$scope = { changed, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			transition_in(row.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			transition_out(row.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(code1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(row, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$h.name,
		type: "slot",
		source: "(21:0) <Form {createForm} title=\\\"Custom errors\\\">",
		ctx
	});

	return block;
}

function create_fragment$r(ctx) {
	let current;

	const form = new Form({
			props: {
				createForm: ctx.createForm,
				title: "Custom errors",
				$$slots: { default: [create_default_slot$h] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(form.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const form_changes = {};

			if (changed.$$scope || changed.$errors || changed.$value) {
				form_changes.$$scope = { changed, ctx };
			}

			form.$set(form_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$r($$self, $$props, $$invalidate) {
	let $value;
	let $errors;

	const { createEntry, createForm } = createValidation({
		validateOnEvents: { input: true },
		useCustomErrorsStore: (errors, params) => {
			return errors.reduce(
				(result, ruleName) => {
					result[ruleName] = params[ruleName];
					return result;
				},
				{}
			);
		}
	});

	const [errors, value, input] = createEntry({ type: "string", min: 5, required: true });
	validate_store(errors, "errors");
	component_subscribe($$self, errors, value => $$invalidate("$errors", $errors = value));
	validate_store(value, "value");
	component_subscribe($$self, value, value => $$invalidate("$value", $value = value));

	function input_1_input_handler() {
		$value = this.value;
		value.set($value);
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("$value" in $$props) value.set($value = $$props.$value);
		if ("$errors" in $$props) errors.set($errors = $$props.$errors);
	};

	return {
		createForm,
		errors,
		value,
		input,
		$value,
		$errors,
		input_1_input_handler
	};
}

class Custom_errors extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$r, create_fragment$r, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Custom_errors",
			options,
			id: create_fragment$r.name
		});
	}
}

/* src/docs/examples/get-values.svelte generated by Svelte v3.15.0 */

const { Error: Error_1$f } = globals;
const file$q = "src/docs/examples/get-values.svelte";

// (40:2) <Row>
function create_default_slot_3$3(ctx) {
	let input;
	let loginInput_action;
	let t0;
	let t1;
	let current;
	let dispose;

	const error0 = new Error$1({
			props: {
				errors: ctx.loginErrors,
				errorCode: "between",
				errorText: "Use at least 2 and not more than 10 symbols"
			},
			$$inline: true
		});

	const error1 = new Error$1({
			props: {
				errors: ctx.loginErrors,
				errorCode: "required"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input = element("input");
			t0 = space();
			create_component(error0.$$.fragment);
			t1 = space();
			create_component(error1.$$.fragment);
			attr_dev(input, "class", "input-text");
			attr_dev(input, "placeholder", "type: 'string', min: 3");
			add_location(input, file$q, 40, 4, 1747);
			dispose = listen_dev(input, "input", ctx.input_input_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, ctx.$loginValue);
			loginInput_action = ctx.loginInput.call(null, input) || ({});
			insert_dev(target, t0, anchor);
			mount_component(error0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(error1, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$loginValue && input.value !== ctx.$loginValue) {
				set_input_value(input, ctx.$loginValue);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error0.$$.fragment, local);
			transition_in(error1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error0.$$.fragment, local);
			transition_out(error1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (loginInput_action && is_function(loginInput_action.destroy)) loginInput_action.destroy();
			if (detaching) detach_dev(t0);
			destroy_component(error0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(error1, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$3.name,
		type: "slot",
		source: "(40:2) <Row>",
		ctx
	});

	return block;
}

// (45:2) <Row>
function create_default_slot_2$a(ctx) {
	let input;
	let passwordInput_action;
	let t;
	let current;
	let dispose;

	const error = new Error$1({
			props: {
				errors: ctx.passwordErrors,
				errorCode: "required"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input = element("input");
			t = space();
			create_component(error.$$.fragment);
			attr_dev(input, "class", "input-text");
			attr_dev(input, "type", "password");
			attr_dev(input, "placeholder", "type: 'string', max: 5, required: true");
			add_location(input, file$q, 45, 4, 2046);
			dispose = listen_dev(input, "input", ctx.input_input_handler_1);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, ctx.$passwordValue);
			passwordInput_action = ctx.passwordInput.call(null, input) || ({});
			insert_dev(target, t, anchor);
			mount_component(error, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$passwordValue && input.value !== ctx.$passwordValue) {
				set_input_value(input, ctx.$passwordValue);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (passwordInput_action && is_function(passwordInput_action.destroy)) passwordInput_action.destroy();
			if (detaching) detach_dev(t);
			destroy_component(error, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$a.name,
		type: "slot",
		source: "(45:2) <Row>",
		ctx
	});

	return block;
}

// (49:2) <Row>
function create_default_slot_1$f(ctx) {
	let pre;
	let t_value = JSON.stringify(ctx.result, null, "  ") + "";
	let t;

	const block = {
		c: function create() {
			pre = element("pre");
			t = text(t_value);
			add_location(pre, file$q, 49, 4, 2274);
		},
		m: function mount(target, anchor) {
			insert_dev(target, pre, anchor);
			append_dev(pre, t);
		},
		p: function update(changed, ctx) {
			if (changed.result && t_value !== (t_value = JSON.stringify(ctx.result, null, "  ") + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$f.name,
		type: "slot",
		source: "(49:2) <Row>",
		ctx
	});

	return block;
}

// (22:0) <Form {createForm} title="GET VALUES">
function create_default_slot$i(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let current;

	const code0 = new Code({
			props: {
				code: `const { createEntries, createForm, getValues } = createValidation({ validateOnEvents: { input: true } });
const [
  [ loginErrors, loginValue, loginInput ],
  [ passwordErrors, passwordValue, passwordInput ]
] = createEntries([
  { type: 'string', between: [2, 10], required: true, id: 'login' },
  { type: 'string', required: true, trim: false, id: 'password' },
]);

let result;
$: result = Object.fromEntries(getValues().entries()), $loginValue, $passwordValue;`
			},
			$$inline: true
		});

	const code1 = new Code({
			props: {
				code: `<input use:loginInput bind:value={$loginValue} />
{#if $errors.includes('between')}Use at least 2 and not more than 10 symbols{/if}
{#if $errors.includes('required')}Field is required{/if}
<input use:passwordInput bind:value={$passwordValue} type="password" />
{#if $errors.includes('required')}Field is required{/if}
{JSON.stringify(result, null, '  ')}`
			},
			$$inline: true
		});

	const row0 = new Row({
			props: {
				$$slots: { default: [create_default_slot_3$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const row1 = new Row({
			props: {
				$$slots: { default: [create_default_slot_2$a] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const row2 = new Row({
			props: {
				$$slots: { default: [create_default_slot_1$f] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const button = new Button({
			props: { type: "submit" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(code0.$$.fragment);
			t0 = space();
			create_component(code1.$$.fragment);
			t1 = space();
			create_component(row0.$$.fragment);
			t2 = space();
			create_component(row1.$$.fragment);
			t3 = space();
			create_component(row2.$$.fragment);
			t4 = space();
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(code0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(code1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(row0, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(row1, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(row2, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const row0_changes = {};

			if (changed.$$scope || changed.$loginValue) {
				row0_changes.$$scope = { changed, ctx };
			}

			row0.$set(row0_changes);
			const row1_changes = {};

			if (changed.$$scope || changed.$passwordValue) {
				row1_changes.$$scope = { changed, ctx };
			}

			row1.$set(row1_changes);
			const row2_changes = {};

			if (changed.$$scope || changed.result) {
				row2_changes.$$scope = { changed, ctx };
			}

			row2.$set(row2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			transition_in(row0.$$.fragment, local);
			transition_in(row1.$$.fragment, local);
			transition_in(row2.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			transition_out(row0.$$.fragment, local);
			transition_out(row1.$$.fragment, local);
			transition_out(row2.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(code1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(row0, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(row1, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(row2, detaching);
			if (detaching) detach_dev(t4);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$i.name,
		type: "slot",
		source: "(22:0) <Form {createForm} title=\\\"GET VALUES\\\">",
		ctx
	});

	return block;
}

function create_fragment$s(ctx) {
	let current;

	const form = new Form({
			props: {
				createForm: ctx.createForm,
				title: "GET VALUES",
				$$slots: { default: [create_default_slot$i] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(form.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$f("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const form_changes = {};

			if (changed.$$scope || changed.result || changed.$passwordValue || changed.$loginValue) {
				form_changes.$$scope = { changed, ctx };
			}

			form.$set(form_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$s($$self, $$props, $$invalidate) {
	let $loginValue;
	let $passwordValue;
	const { createEntries, createForm, getValues } = createValidation({ validateOnEvents: { input: true } });

	const [
		[loginErrors, loginValue, loginInput],
		[passwordErrors, passwordValue, passwordInput]
	] = createEntries([
		{
			type: "string",
			between: [2, 10],
			required: true,
			id: "login"
		},
		{
			type: "string",
			required: true,
			trim: false,
			id: "password"
		}
	]);

	validate_store(loginValue, "loginValue");
	component_subscribe($$self, loginValue, value => $$invalidate("$loginValue", $loginValue = value));
	validate_store(passwordValue, "passwordValue");
	component_subscribe($$self, passwordValue, value => $$invalidate("$passwordValue", $passwordValue = value));
	let result;

	function input_input_handler() {
		$loginValue = this.value;
		loginValue.set($loginValue);
	}

	function input_input_handler_1() {
		$passwordValue = this.value;
		passwordValue.set($passwordValue);
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("result" in $$props) $$invalidate("result", result = $$props.result);
		if ("$loginValue" in $$props) loginValue.set($loginValue = $$props.$loginValue);
		if ("$passwordValue" in $$props) passwordValue.set($passwordValue = $$props.$passwordValue);
	};

	$$self.$$.update = (changed = { $loginValue: 1, $passwordValue: 1 }) => {
		if (changed.$loginValue || changed.$passwordValue) {
			 ($$invalidate("result", result = Object.fromEntries(getValues().entries())), $passwordValue);
		}
	};

	return {
		createForm,
		loginErrors,
		loginValue,
		loginInput,
		passwordErrors,
		passwordValue,
		passwordInput,
		result,
		$loginValue,
		$passwordValue,
		input_input_handler,
		input_input_handler_1
	};
}

class Get_values extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Get_values",
			options,
			id: create_fragment$s.name
		});
	}
}

/* src/docs/examples/get-values-custom.svelte generated by Svelte v3.15.0 */

const { Error: Error_1$g } = globals;
const file$r = "src/docs/examples/get-values-custom.svelte";

// (58:2) <Row>
function create_default_slot_3$4(ctx) {
	let input;
	let loginInput_action;
	let t0;
	let t1;
	let current;
	let dispose;

	const error0 = new Error$1({
			props: {
				errors: ctx.loginErrors,
				errorCode: "between",
				errorText: "Use at least 2 and not more than 10 symbols"
			},
			$$inline: true
		});

	const error1 = new Error$1({
			props: {
				errors: ctx.loginErrors,
				errorCode: "required"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input = element("input");
			t0 = space();
			create_component(error0.$$.fragment);
			t1 = space();
			create_component(error1.$$.fragment);
			attr_dev(input, "class", "input-text");
			attr_dev(input, "placeholder", "type: 'string', min: 3");
			add_location(input, file$r, 58, 4, 2164);
			dispose = listen_dev(input, "input", ctx.input_input_handler);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, ctx.$loginValue);
			loginInput_action = ctx.loginInput.call(null, input) || ({});
			insert_dev(target, t0, anchor);
			mount_component(error0, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(error1, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$loginValue && input.value !== ctx.$loginValue) {
				set_input_value(input, ctx.$loginValue);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error0.$$.fragment, local);
			transition_in(error1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error0.$$.fragment, local);
			transition_out(error1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (loginInput_action && is_function(loginInput_action.destroy)) loginInput_action.destroy();
			if (detaching) detach_dev(t0);
			destroy_component(error0, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(error1, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3$4.name,
		type: "slot",
		source: "(58:2) <Row>",
		ctx
	});

	return block;
}

// (63:2) <Row>
function create_default_slot_2$b(ctx) {
	let input;
	let passwordInput_action;
	let t;
	let current;
	let dispose;

	const error = new Error$1({
			props: {
				errors: ctx.passwordErrors,
				errorCode: "required"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			input = element("input");
			t = space();
			create_component(error.$$.fragment);
			attr_dev(input, "class", "input-text");
			attr_dev(input, "type", "password");
			attr_dev(input, "placeholder", "type: 'string', max: 5, required: true");
			add_location(input, file$r, 63, 4, 2463);
			dispose = listen_dev(input, "input", ctx.input_input_handler_1);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, ctx.$passwordValue);
			passwordInput_action = ctx.passwordInput.call(null, input) || ({});
			insert_dev(target, t, anchor);
			mount_component(error, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (changed.$passwordValue && input.value !== ctx.$passwordValue) {
				set_input_value(input, ctx.$passwordValue);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			if (passwordInput_action && is_function(passwordInput_action.destroy)) passwordInput_action.destroy();
			if (detaching) detach_dev(t);
			destroy_component(error, detaching);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$b.name,
		type: "slot",
		source: "(63:2) <Row>",
		ctx
	});

	return block;
}

// (67:2) <Row>
function create_default_slot_1$g(ctx) {
	let pre;
	let t_value = JSON.stringify(ctx.result, null, "  ") + "";
	let t;

	const block = {
		c: function create() {
			pre = element("pre");
			t = text(t_value);
			add_location(pre, file$r, 67, 4, 2691);
		},
		m: function mount(target, anchor) {
			insert_dev(target, pre, anchor);
			append_dev(pre, t);
		},
		p: function update(changed, ctx) {
			if (changed.result && t_value !== (t_value = JSON.stringify(ctx.result, null, "  ") + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$g.name,
		type: "slot",
		source: "(67:2) <Row>",
		ctx
	});

	return block;
}

// (31:0) <Form {createForm} title="GET VALUES CUSTOM">
function create_default_slot$j(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let current;

	const code0 = new Code({
			props: {
				code: `const { createEntries, createForm, getValues } = createValidation({
  validateOnEvents: { input: true },
  getValues: entries => {
    return entries.reduce((result, { value, params }) => {
      result[params.MY_CUSTOM_KEY] = value;
      return result;
    }, {});
  },
  warningsEnabled: false
});
const [
  [ loginErrors, loginValue, loginInput ],
  [ passwordErrors, passwordValue, passwordInput ]
] = createEntries([
  { type: 'string', between: [2, 10], required: true, MY_CUSTOM_KEY: 'login' },
  { type: 'string', required: true, trim: false, MY_CUSTOM_KEY: 'password' },
]);

let result;
$: result = getValues(), $loginValue, $passwordValue;`
			},
			$$inline: true
		});

	const code1 = new Code({
			props: {
				code: `<input use:loginInput bind:value={$loginValue} />
{#if $errors.includes('between')}Use at least 2 and not more than 10 symbols{/if}
{#if $errors.includes('required')}Field is required{/if}
<input use:passwordInput bind:value={$passwordValue} type="password" />
{#if $errors.includes('required')}Field is required{/if}
{JSON.stringify(result, null, '  ')}`
			},
			$$inline: true
		});

	const row0 = new Row({
			props: {
				$$slots: { default: [create_default_slot_3$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const row1 = new Row({
			props: {
				$$slots: { default: [create_default_slot_2$b] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const row2 = new Row({
			props: {
				$$slots: { default: [create_default_slot_1$g] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const button = new Button({
			props: { type: "submit" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(code0.$$.fragment);
			t0 = space();
			create_component(code1.$$.fragment);
			t1 = space();
			create_component(row0.$$.fragment);
			t2 = space();
			create_component(row1.$$.fragment);
			t3 = space();
			create_component(row2.$$.fragment);
			t4 = space();
			create_component(button.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(code0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(code1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(row0, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(row1, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(row2, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(button, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const row0_changes = {};

			if (changed.$$scope || changed.$loginValue) {
				row0_changes.$$scope = { changed, ctx };
			}

			row0.$set(row0_changes);
			const row1_changes = {};

			if (changed.$$scope || changed.$passwordValue) {
				row1_changes.$$scope = { changed, ctx };
			}

			row1.$set(row1_changes);
			const row2_changes = {};

			if (changed.$$scope || changed.result) {
				row2_changes.$$scope = { changed, ctx };
			}

			row2.$set(row2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(code0.$$.fragment, local);
			transition_in(code1.$$.fragment, local);
			transition_in(row0.$$.fragment, local);
			transition_in(row1.$$.fragment, local);
			transition_in(row2.$$.fragment, local);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(code0.$$.fragment, local);
			transition_out(code1.$$.fragment, local);
			transition_out(row0.$$.fragment, local);
			transition_out(row1.$$.fragment, local);
			transition_out(row2.$$.fragment, local);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(code0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(code1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(row0, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(row1, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(row2, detaching);
			if (detaching) detach_dev(t4);
			destroy_component(button, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$j.name,
		type: "slot",
		source: "(31:0) <Form {createForm} title=\\\"GET VALUES CUSTOM\\\">",
		ctx
	});

	return block;
}

function create_fragment$t(ctx) {
	let current;

	const form = new Form({
			props: {
				createForm: ctx.createForm,
				title: "GET VALUES CUSTOM",
				$$slots: { default: [create_default_slot$j] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(form.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error_1$g("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(form, target, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			const form_changes = {};

			if (changed.$$scope || changed.result || changed.$passwordValue || changed.$loginValue) {
				form_changes.$$scope = { changed, ctx };
			}

			form.$set(form_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(form, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$t($$self, $$props, $$invalidate) {
	let $loginValue;
	let $passwordValue;

	const { createEntries, createForm, getValues } = createValidation({
		validateOnEvents: { input: true },
		getValues: entries => {
			return entries.reduce(
				(result, { value, params }) => {
					result[params.MY_CUSTOM_KEY] = value;
					return result;
				},
				{}
			);
		},
		warningsEnabled: false
	});

	const [
		[loginErrors, loginValue, loginInput],
		[passwordErrors, passwordValue, passwordInput]
	] = createEntries([
		{
			type: "string",
			between: [2, 10],
			required: true,
			MY_CUSTOM_KEY: "login"
		},
		{
			type: "string",
			required: true,
			trim: false,
			MY_CUSTOM_KEY: "password"
		}
	]);

	validate_store(loginValue, "loginValue");
	component_subscribe($$self, loginValue, value => $$invalidate("$loginValue", $loginValue = value));
	validate_store(passwordValue, "passwordValue");
	component_subscribe($$self, passwordValue, value => $$invalidate("$passwordValue", $passwordValue = value));
	let result;

	function input_input_handler() {
		$loginValue = this.value;
		loginValue.set($loginValue);
	}

	function input_input_handler_1() {
		$passwordValue = this.value;
		passwordValue.set($passwordValue);
	}

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("result" in $$props) $$invalidate("result", result = $$props.result);
		if ("$loginValue" in $$props) loginValue.set($loginValue = $$props.$loginValue);
		if ("$passwordValue" in $$props) passwordValue.set($passwordValue = $$props.$passwordValue);
	};

	$$self.$$.update = (changed = { $loginValue: 1, $passwordValue: 1 }) => {
		if (changed.$loginValue || changed.$passwordValue) {
			 ($$invalidate("result", result = getValues()), $passwordValue);
		}
	};

	return {
		createForm,
		loginErrors,
		loginValue,
		loginInput,
		passwordErrors,
		passwordValue,
		passwordInput,
		result,
		$loginValue,
		$passwordValue,
		input_input_handler,
		input_input_handler_1
	};
}

class Get_values_custom extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$t, create_fragment$t, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Get_values_custom",
			options,
			id: create_fragment$t.name
		});
	}
}

/* src/docs/docs.svelte generated by Svelte v3.15.0 */
const file$s = "src/docs/docs.svelte";

function add_css$d() {
	var style = element("style");
	style.id = "svelte-1edyv9o-style";
	style.textContent = "@import url('https://fonts.googleapis.com/css?family=Open+Sans&display=swap');.tabs{border-bottom:5px solid #dcefff;display:flex;margin-bottom:20px;position:relative}.tabs--bar{background:#004cb4;height:5px;left:0;position:absolute;top:100%;transition:.5s transform cubic-bezier(0.86, 0, 0.07, 1);width:50%}.tabs--button{background:none;border:0;cursor:pointer;flex:1;font-size:20px;line-height:20px;outline:none;padding:20px;text-transform:uppercase}.tabs--button:hover{color:#004cb4}.tabs--button:disabled{color:#004cb4}.logo{color:inherit;cursor:pointer;display:block;font-size:18px;line-height:22px;margin:10px auto 20px;max-width:260px;text-decoration:none;text-align:center}.logo img{display:block;max-width:100%}.logo:hover{color:#004cb4}.docs{padding-bottom:300px}h1{color:#004cb4;font-size:24px;line-height:28px;margin-bottom:.5em;overflow:hidden;text-transform:uppercase}.input-text,select{border:1px solid #333;border-radius:3px;font-size:14px;height:40px;line-height:18px;outline:0;padding:5px 10px;width:100%}select{height:auto;line-height:inherit;padding:5px}.input-text:focus,select:focus{border-color:#004cb4;box-shadow:0 0 3px #004cb4}.input-choice{display:inline-block;margin:4px 10px 0 0;vertical-align:top}.cells{display:flex;flex-wrap:wrap;align-content:flex-start;align-items:flex-start;margin-top:-10px;padding:10px;justify-content:center}.cells > *{background:#fff;border:1px solid #bbb;box-shadow:0 0 5px #bbb;border-radius:3px;cursor:pointer;margin:10px 5px 0;overflow:hidden;padding:5px;text-align:center;width:150px}.cells input{display:block;margin:0 auto 5px}code{outline:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9jcy5zdmVsdGUiLCJzb3VyY2VzIjpbImRvY3Muc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XHJcbiAgaW1wb3J0IHsgZmFkZSB9IGZyb20gJ3N2ZWx0ZS90cmFuc2l0aW9uJztcclxuICBpbXBvcnQgRWRpdG9yIGZyb20gJy4vYnVpbGRlci9idWlsZGVyLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IFN0cmluZyBmcm9tICcuL2V4YW1wbGVzL3N0cmluZy5zdmVsdGUnO1xyXG4gIGltcG9ydCBFbWFpbCBmcm9tICcuL2V4YW1wbGVzL2VtYWlsLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IE51bWJlciBmcm9tICcuL2V4YW1wbGVzL251bWJlci5zdmVsdGUnO1xyXG4gIGltcG9ydCBCb29sZWFuIGZyb20gJy4vZXhhbXBsZXMvYm9vbGVhbi5zdmVsdGUnO1xyXG4gIGltcG9ydCBBcnJheSBmcm9tICcuL2V4YW1wbGVzL2FycmF5LnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IFJlcXVpcmVkIGZyb20gJy4vZXhhbXBsZXMvcmVxdWlyZWQuc3ZlbHRlJztcclxuICBpbXBvcnQgTWF0Y2ggZnJvbSAnLi9leGFtcGxlcy9tYXRjaC5zdmVsdGUnO1xyXG4gIGltcG9ydCBFcXVhbCBmcm9tICcuL2V4YW1wbGVzL2VxdWFsLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IEFycmF5U3VtT2ZQb2ludHMgZnJvbSAnLi9leGFtcGxlcy9hcnJheS1zdW0tb2YtcG9pbnRzLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IEZpZWxkQ29uZmlybSBmcm9tICcuL2V4YW1wbGVzL2ZpZWxkLWNvbmZpcm0uc3ZlbHRlJztcclxuICBpbXBvcnQgRHluYW1pY1N0ZXBzIGZyb20gJy4vZXhhbXBsZXMvZHluYW1pYy1zdGVwcy5zdmVsdGUnO1xyXG4gIGltcG9ydCBVc2VXaXRoUGFyYW1zIGZyb20gJy4vZXhhbXBsZXMvdXNlLXdpdGgtcGFyYW1zLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IFdpdGhvdXRJbnB1dHMgZnJvbSAnLi9leGFtcGxlcy93aXRob3V0LWlucHV0cy5zdmVsdGUnO1xyXG4gIGltcG9ydCBDdXN0b21FcnJvcnMgZnJvbSAnLi9leGFtcGxlcy9jdXN0b20tZXJyb3JzLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IEdldFZhbHVlcyBmcm9tICcuL2V4YW1wbGVzL2dldC12YWx1ZXMuc3ZlbHRlJztcclxuICBpbXBvcnQgR2V0VmFsdWVzQ3VzdG9tIGZyb20gJy4vZXhhbXBsZXMvZ2V0LXZhbHVlcy1jdXN0b20uc3ZlbHRlJztcclxuXHJcbiAgbGV0IGJhcklkID0gMDtcclxuICBsZXQgcGFnZUlkID0gYmFySWQ7XHJcbiAgbGV0IHRyYW5zaXRpb25BY3RpdmUgPSBmYWxzZTtcclxuXHJcbiAgY29uc3Qgc3dpdGNoUGFnZXMgPSAobikgPT4ge1xyXG4gICAgaWYgKHRyYW5zaXRpb25BY3RpdmUpIHJldHVybjtcclxuICAgIHRyYW5zaXRpb25BY3RpdmUgPSB0cnVlO1xyXG4gICAgYmFySWQgPSBuO1xyXG4gIH07XHJcbjwvc2NyaXB0PlxyXG5cclxuPGEgaHJlZj1cIi8vZ2l0aHViLmNvbS95YXpvbm5pbGUvc3ZlbGlkYXRpb25cIiBjbGFzcz1cImxvZ29cIj5cclxuICA8aW1nIHNyYz1cIi4vbG9nby5zdmdcIiBhbHQ9XCJzdmVsaWRhdGlvblwiIC8+XHJcbiAgZ28gdG8gZ2l0aHViXHJcbjwvYT5cclxuXHJcbjxkaXYgY2xhc3M9XCJ0YWJzXCI+XHJcbiAgPGJ1dHRvbiBjbGFzcz1cInRhYnMtLWJ1dHRvblwiIG9uOmNsaWNrPXsoKSA9PiBzd2l0Y2hQYWdlcygwKX0gZGlzYWJsZWQ9e3BhZ2VJZCA9PT0gMH0+RXhhbXBsZXM8L2J1dHRvbj5cclxuICA8YnV0dG9uIGNsYXNzPVwidGFicy0tYnV0dG9uXCIgb246Y2xpY2s9eygpID0+IHN3aXRjaFBhZ2VzKDEpfSBkaXNhYmxlZD17cGFnZUlkID09PSAxfT5CdWlsZGVyPC9idXR0b24+XHJcbiAgPGkgY2xhc3M9XCJ0YWJzLS1iYXJcIiBzdHlsZT17YHRyYW5zZm9ybTogdHJhbnNsYXRlWCgkezEwMCAqIGJhcklkfSUpYH0+PC9pPlxyXG48L2Rpdj5cclxuXHJcbnsjaWYgIXRyYW5zaXRpb25BY3RpdmV9XHJcbiAgPGRpdlxyXG4gICAgY2xhc3M9XCJkb2NzXCJcclxuICAgIHRyYW5zaXRpb246ZmFkZT17eyBkZWxheTogMCwgZHVyYXRpb246IDI1MCB9fVxyXG4gICAgb246b3V0cm9lbmQ9eygpID0+IChwYWdlSWQgPSBiYXJJZCwgdHJhbnNpdGlvbkFjdGl2ZSA9IGZhbHNlKX1cclxuICA+XHJcbiAgICB7I2lmIHBhZ2VJZCA9PT0gMH1cclxuICAgICAgPFN0cmluZyAvPlxyXG4gICAgICA8RW1haWwgLz5cclxuICAgICAgPE51bWJlciAvPlxyXG4gICAgICA8Qm9vbGVhbiAvPlxyXG4gICAgICA8QXJyYXkgLz5cclxuICAgICAgPFJlcXVpcmVkIC8+XHJcbiAgICAgIDxNYXRjaCAvPlxyXG4gICAgICA8RXF1YWwgLz5cclxuICAgICAgPFVzZVdpdGhQYXJhbXMgLz5cclxuICAgICAgPFdpdGhvdXRJbnB1dHMgLz5cclxuICAgICAgPER5bmFtaWNTdGVwcyAvPlxyXG4gICAgICA8QXJyYXlTdW1PZlBvaW50cyAvPlxyXG4gICAgICA8RmllbGRDb25maXJtIC8+XHJcbiAgICAgIDxDdXN0b21FcnJvcnMgLz5cclxuICAgICAgPEdldFZhbHVlcyAvPlxyXG4gICAgICA8R2V0VmFsdWVzQ3VzdG9tIC8+XHJcbiAgICB7OmVsc2V9XHJcbiAgICAgIDxFZGl0b3IgLz5cclxuICAgIHsvaWZ9XHJcbiAgPC9kaXY+XHJcbnsvaWZ9XHJcblxyXG5cclxuPHN0eWxlIGdsb2JhbD5cclxuICBAaW1wb3J0IHVybCgnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PU9wZW4rU2FucyZkaXNwbGF5PXN3YXAnKTtcclxuXHJcbiAgOmdsb2JhbCgudGFicykge1xyXG4gICAgYm9yZGVyLWJvdHRvbTogNXB4IHNvbGlkICNkY2VmZmY7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMjBweDtcclxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICB9XHJcblxyXG4gIDpnbG9iYWwoLnRhYnMtLWJhcikge1xyXG4gICAgYmFja2dyb3VuZDogIzAwNGNiNDtcclxuICAgIGhlaWdodDogNXB4O1xyXG4gICAgbGVmdDogMDtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIHRvcDogMTAwJTtcclxuICAgIHRyYW5zaXRpb246IC41cyB0cmFuc2Zvcm0gY3ViaWMtYmV6aWVyKDAuODYsIDAsIDAuMDcsIDEpO1xyXG4gICAgd2lkdGg6IDUwJTtcclxuICB9XHJcblxyXG4gIDpnbG9iYWwoLnRhYnMtLWJ1dHRvbikge1xyXG4gICAgYmFja2dyb3VuZDogbm9uZTtcclxuICAgIGJvcmRlcjogMDtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIGZsZXg6IDE7XHJcbiAgICBmb250LXNpemU6IDIwcHg7XHJcbiAgICBsaW5lLWhlaWdodDogMjBweDtcclxuICAgIG91dGxpbmU6IG5vbmU7XHJcbiAgICBwYWRkaW5nOiAyMHB4O1xyXG4gICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcclxuICB9XHJcblxyXG4gIDpnbG9iYWwoLnRhYnMtLWJ1dHRvbjpob3Zlcikge1xyXG4gICAgY29sb3I6ICMwMDRjYjQ7XHJcbiAgfVxyXG5cclxuICA6Z2xvYmFsKC50YWJzLS1idXR0b246ZGlzYWJsZWQpIHtcclxuICAgIGNvbG9yOiAjMDA0Y2I0O1xyXG4gIH1cclxuXHJcbiAgOmdsb2JhbCgubG9nbykge1xyXG4gICAgY29sb3I6IGluaGVyaXQ7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICBkaXNwbGF5OiBibG9jaztcclxuICAgIGZvbnQtc2l6ZTogMThweDtcclxuICAgIGxpbmUtaGVpZ2h0OiAyMnB4O1xyXG4gICAgbWFyZ2luOiAxMHB4IGF1dG8gMjBweDtcclxuICAgIG1heC13aWR0aDogMjYwcHg7XHJcbiAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XHJcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgfVxyXG5cclxuICA6Z2xvYmFsKC5sb2dvIGltZykge1xyXG4gICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICBtYXgtd2lkdGg6IDEwMCU7XHJcbiAgfVxyXG5cclxuICA6Z2xvYmFsKC5sb2dvOmhvdmVyKSB7XHJcbiAgICBjb2xvcjogIzAwNGNiNDtcclxuICB9XHJcblxyXG4gIDpnbG9iYWwoLmRvY3MpIHtcclxuICAgIHBhZGRpbmctYm90dG9tOiAzMDBweDtcclxuICB9XHJcblxyXG4gIDpnbG9iYWwoaDEpIHtcclxuICAgIGNvbG9yOiAjMDA0Y2I0O1xyXG4gICAgZm9udC1zaXplOiAyNHB4O1xyXG4gICAgbGluZS1oZWlnaHQ6IDI4cHg7XHJcbiAgICBtYXJnaW4tYm90dG9tOiAuNWVtO1xyXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcclxuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XHJcbiAgfVxyXG5cclxuICA6Z2xvYmFsKC5pbnB1dC10ZXh0KSxcclxuICA6Z2xvYmFsKHNlbGVjdCkge1xyXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzMzMztcclxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcclxuICAgIGZvbnQtc2l6ZTogMTRweDtcclxuICAgIGhlaWdodDogNDBweDtcclxuICAgIGxpbmUtaGVpZ2h0OiAxOHB4O1xyXG4gICAgb3V0bGluZTogMDtcclxuICAgIHBhZGRpbmc6IDVweCAxMHB4O1xyXG4gICAgd2lkdGg6IDEwMCU7XHJcbiAgfVxyXG5cclxuICA6Z2xvYmFsKHNlbGVjdCkge1xyXG4gICAgaGVpZ2h0OiBhdXRvO1xyXG4gICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XHJcbiAgICBwYWRkaW5nOiA1cHg7XHJcbiAgfVxyXG5cclxuICA6Z2xvYmFsKC5pbnB1dC10ZXh0OmZvY3VzKSxcclxuICA6Z2xvYmFsKHNlbGVjdDpmb2N1cykge1xyXG4gICAgYm9yZGVyLWNvbG9yOiAjMDA0Y2I0O1xyXG4gICAgYm94LXNoYWRvdzogMCAwIDNweCAjMDA0Y2I0O1xyXG4gIH1cclxuXHJcbiAgOmdsb2JhbCguaW5wdXQtY2hvaWNlKSB7XHJcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcbiAgICBtYXJnaW46IDRweCAxMHB4IDAgMDtcclxuICAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XHJcbiAgfVxyXG5cclxuICA6Z2xvYmFsKC5jZWxscykge1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGZsZXgtd3JhcDogd3JhcDtcclxuICAgIGFsaWduLWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XHJcbiAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcclxuICAgIG1hcmdpbi10b3A6IC0xMHB4O1xyXG4gICAgcGFkZGluZzogMTBweDtcclxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG4gIH1cclxuXHJcbiAgOmdsb2JhbCguY2VsbHMgPiAqKSB7XHJcbiAgICBiYWNrZ3JvdW5kOiAjZmZmO1xyXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2JiYjtcclxuICAgIGJveC1zaGFkb3c6IDAgMCA1cHggI2JiYjtcclxuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIG1hcmdpbjogMTBweCA1cHggMDtcclxuICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICBwYWRkaW5nOiA1cHg7XHJcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICB3aWR0aDogMTUwcHg7XHJcbiAgfVxyXG5cclxuICA6Z2xvYmFsKC5jZWxscyBpbnB1dCkge1xyXG4gICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICBtYXJnaW46IDAgYXV0byA1cHg7XHJcbiAgfVxyXG5cclxuICA6Z2xvYmFsKGNvZGUpIHtcclxuICAgIG91dGxpbmU6IDA7XHJcbiAgfVxyXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW5OeVl5OWtiMk56TDNOeVl5OWtiMk56TDJSdlkzTXVjM1psYkhSbElsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lJN1JVRkRSU3cyUlVGQk5rVTdPMFZCUlRkRk8wbEJRMFVzWjBOQlFUaERPMGxCUXpsRExHRkJRV0U3U1VGRFlpeHRRa0ZCYlVJN1NVRkRia0lzYTBKQlFXdENPMFZCUTNCQ096dEZRVVZCTzBsQlEwVXNiVUpCUVRSQ08wbEJRelZDTEZkQlFWYzdTVUZEV0N4UFFVRlBPMGxCUTFBc2EwSkJRV3RDTzBsQlEyeENMRk5CUVZNN1NVRkRWQ3gzUkVGQmQwUTdTVUZEZUVRc1ZVRkJWVHRGUVVOYU96dEZRVVZCTzBsQlEwVXNaMEpCUVdkQ08wbEJRMmhDTEZOQlFWTTdTVUZEVkN4bFFVRmxPMGxCUTJZc1QwRkJUenRKUVVOUUxHVkJRV1U3U1VGRFppeHBRa0ZCYVVJN1NVRkRha0lzWVVGQllUdEpRVU5pTEdGQlFXRTdTVUZEWWl4NVFrRkJlVUk3UlVGRE0wSTdPMFZCUlVFN1NVRkRSU3hqUVVGMVFqdEZRVU42UWpzN1JVRkZRVHRKUVVORkxHTkJRWFZDTzBWQlEzcENPenRGUVVWQk8wbEJRMFVzWTBGQll6dEpRVU5rTEdWQlFXVTdTVUZEWml4alFVRmpPMGxCUTJRc1pVRkJaVHRKUVVObUxHbENRVUZwUWp0SlFVTnFRaXh6UWtGQmMwSTdTVUZEZEVJc1owSkJRV2RDTzBsQlEyaENMSEZDUVVGeFFqdEpRVU55UWl4clFrRkJhMEk3UlVGRGNFSTdPMFZCUlVFN1NVRkRSU3hqUVVGak8wbEJRMlFzWlVGQlpUdEZRVU5xUWpzN1JVRkZRVHRKUVVORkxHTkJRWFZDTzBWQlEzcENPenRGUVVWQk8wbEJRMFVzY1VKQlFYRkNPMFZCUTNaQ096dEZRVVZCTzBsQlEwVXNZMEZCZFVJN1NVRkRka0lzWlVGQlpUdEpRVU5tTEdsQ1FVRnBRanRKUVVOcVFpeHRRa0ZCYlVJN1NVRkRia0lzWjBKQlFXZENPMGxCUTJoQ0xIbENRVUY1UWp0RlFVTXpRanM3UlVGRlFUczdTVUZGUlN4elFrRkJjMEk3U1VGRGRFSXNhMEpCUVd0Q08wbEJRMnhDTEdWQlFXVTdTVUZEWml4WlFVRlpPMGxCUTFvc2FVSkJRV2xDTzBsQlEycENMRlZCUVZVN1NVRkRWaXhwUWtGQmFVSTdTVUZEYWtJc1YwRkJWenRGUVVOaU96dEZRVVZCTzBsQlEwVXNXVUZCV1R0SlFVTmFMRzlDUVVGdlFqdEpRVU53UWl4WlFVRlpPMFZCUTJRN08wVkJSVUU3TzBsQlJVVXNjVUpCUVRoQ08wbEJRemxDTERKQ1FVRnZRenRGUVVOMFF6czdSVUZGUVR0SlFVTkZMSEZDUVVGeFFqdEpRVU55UWl4dlFrRkJiMEk3U1VGRGNFSXNiVUpCUVcxQ08wVkJRM0pDT3p0RlFVVkJPMGxCUTBVc1lVRkJZVHRKUVVOaUxHVkJRV1U3U1VGRFppeDVRa0ZCZVVJN1NVRkRla0lzZFVKQlFYVkNPMGxCUTNaQ0xHbENRVUZwUWp0SlFVTnFRaXhoUVVGaE8wbEJRMklzZFVKQlFYVkNPMFZCUTNwQ096dEZRVVZCTzBsQlEwVXNaMEpCUVdkQ08wbEJRMmhDTEhOQ1FVRTJRanRKUVVNM1FpeDNRa0ZCSzBJN1NVRkRMMElzYTBKQlFXdENPMGxCUTJ4Q0xHVkJRV1U3U1VGRFppeHJRa0ZCYTBJN1NVRkRiRUlzWjBKQlFXZENPMGxCUTJoQ0xGbEJRVms3U1VGRFdpeHJRa0ZCYTBJN1NVRkRiRUlzV1VGQldUdEZRVU5rT3p0RlFVVkJPMGxCUTBVc1kwRkJZenRKUVVOa0xHdENRVUZyUWp0RlFVTndRanM3UlVGRlFUdEpRVU5GTEZWQlFWVTdSVUZEV2lJc0ltWnBiR1VpT2lKemNtTXZaRzlqY3k5a2IyTnpMbk4yWld4MFpTSXNJbk52ZFhKalpYTkRiMjUwWlc1MElqcGJJbHh5WEc0Z0lFQnBiWEJ2Y25RZ2RYSnNLQ2RvZEhSd2N6b3ZMMlp2Ym5SekxtZHZiMmRzWldGd2FYTXVZMjl0TDJOemN6OW1ZVzFwYkhrOVQzQmxiaXRUWVc1ekptUnBjM0JzWVhrOWMzZGhjQ2NwTzF4eVhHNWNjbHh1SUNBdWRHRmljeUI3WEhKY2JpQWdJQ0JpYjNKa1pYSXRZbTkwZEc5dE9pQTFjSGdnYzI5c2FXUWdkbUZ5S0MwdGJXRnBia052Ykc5eVRHbG5hSFFwTzF4eVhHNGdJQ0FnWkdsemNHeGhlVG9nWm14bGVEdGNjbHh1SUNBZ0lHMWhjbWRwYmkxaWIzUjBiMjA2SURJd2NIZzdYSEpjYmlBZ0lDQndiM05wZEdsdmJqb2djbVZzWVhScGRtVTdYSEpjYmlBZ2ZWeHlYRzVjY2x4dUlDQXVkR0ZpY3kwdFltRnlJSHRjY2x4dUlDQWdJR0poWTJ0bmNtOTFibVE2SUhaaGNpZ3RMVzFoYVc1RGIyeHZjaWs3WEhKY2JpQWdJQ0JvWldsbmFIUTZJRFZ3ZUR0Y2NseHVJQ0FnSUd4bFpuUTZJREE3WEhKY2JpQWdJQ0J3YjNOcGRHbHZiam9nWVdKemIyeDFkR1U3WEhKY2JpQWdJQ0IwYjNBNklERXdNQ1U3WEhKY2JpQWdJQ0IwY21GdWMybDBhVzl1T2lBdU5YTWdkSEpoYm5ObWIzSnRJR04xWW1sakxXSmxlbWxsY2lnd0xqZzJMQ0F3TENBd0xqQTNMQ0F4S1R0Y2NseHVJQ0FnSUhkcFpIUm9PaUExTUNVN1hISmNiaUFnZlZ4eVhHNWNjbHh1SUNBdWRHRmljeTB0WW5WMGRHOXVJSHRjY2x4dUlDQWdJR0poWTJ0bmNtOTFibVE2SUc1dmJtVTdYSEpjYmlBZ0lDQmliM0prWlhJNklEQTdYSEpjYmlBZ0lDQmpkWEp6YjNJNklIQnZhVzUwWlhJN1hISmNiaUFnSUNCbWJHVjRPaUF4TzF4eVhHNGdJQ0FnWm05dWRDMXphWHBsT2lBeU1IQjRPMXh5WEc0Z0lDQWdiR2x1WlMxb1pXbG5hSFE2SURJd2NIZzdYSEpjYmlBZ0lDQnZkWFJzYVc1bE9pQnViMjVsTzF4eVhHNGdJQ0FnY0dGa1pHbHVaem9nTWpCd2VEdGNjbHh1SUNBZ0lIUmxlSFF0ZEhKaGJuTm1iM0p0T2lCMWNIQmxjbU5oYzJVN1hISmNiaUFnZlZ4eVhHNWNjbHh1SUNBdWRHRmljeTB0WW5WMGRHOXVPbWh2ZG1WeUlIdGNjbHh1SUNBZ0lHTnZiRzl5T2lCMllYSW9MUzF0WVdsdVEyOXNiM0lwTzF4eVhHNGdJSDFjY2x4dVhISmNiaUFnTG5SaFluTXRMV0oxZEhSdmJqcGthWE5oWW14bFpDQjdYSEpjYmlBZ0lDQmpiMnh2Y2pvZ2RtRnlLQzB0YldGcGJrTnZiRzl5S1R0Y2NseHVJQ0I5WEhKY2JseHlYRzRnSUM1c2IyZHZJSHRjY2x4dUlDQWdJR052Ykc5eU9pQnBibWhsY21sME8xeHlYRzRnSUNBZ1kzVnljMjl5T2lCd2IybHVkR1Z5TzF4eVhHNGdJQ0FnWkdsemNHeGhlVG9nWW14dlkyczdYSEpjYmlBZ0lDQm1iMjUwTFhOcGVtVTZJREU0Y0hnN1hISmNiaUFnSUNCc2FXNWxMV2hsYVdkb2REb2dNakp3ZUR0Y2NseHVJQ0FnSUcxaGNtZHBiam9nTVRCd2VDQmhkWFJ2SURJd2NIZzdYSEpjYmlBZ0lDQnRZWGd0ZDJsa2RHZzZJREkyTUhCNE8xeHlYRzRnSUNBZ2RHVjRkQzFrWldOdmNtRjBhVzl1T2lCdWIyNWxPMXh5WEc0Z0lDQWdkR1Y0ZEMxaGJHbG5iam9nWTJWdWRHVnlPMXh5WEc0Z0lIMWNjbHh1WEhKY2JpQWdMbXh2WjI4Z2FXMW5JSHRjY2x4dUlDQWdJR1JwYzNCc1lYazZJR0pzYjJOck8xeHlYRzRnSUNBZ2JXRjRMWGRwWkhSb09pQXhNREFsTzF4eVhHNGdJSDFjY2x4dVhISmNiaUFnTG14dloyODZhRzkyWlhJZ2UxeHlYRzRnSUNBZ1kyOXNiM0k2SUhaaGNpZ3RMVzFoYVc1RGIyeHZjaWs3WEhKY2JpQWdmVnh5WEc1Y2NseHVJQ0F1Wkc5amN5QjdYSEpjYmlBZ0lDQndZV1JrYVc1bkxXSnZkSFJ2YlRvZ016QXdjSGc3WEhKY2JpQWdmVnh5WEc1Y2NseHVJQ0JvTVNCN1hISmNiaUFnSUNCamIyeHZjam9nZG1GeUtDMHRiV0ZwYmtOdmJHOXlLVHRjY2x4dUlDQWdJR1p2Ym5RdGMybDZaVG9nTWpSd2VEdGNjbHh1SUNBZ0lHeHBibVV0YUdWcFoyaDBPaUF5T0hCNE8xeHlYRzRnSUNBZ2JXRnlaMmx1TFdKdmRIUnZiVG9nTGpWbGJUdGNjbHh1SUNBZ0lHOTJaWEptYkc5M09pQm9hV1JrWlc0N1hISmNiaUFnSUNCMFpYaDBMWFJ5WVc1elptOXliVG9nZFhCd1pYSmpZWE5sTzF4eVhHNGdJSDFjY2x4dVhISmNiaUFnTG1sdWNIVjBMWFJsZUhRc1hISmNiaUFnYzJWc1pXTjBJSHRjY2x4dUlDQWdJR0p2Y21SbGNqb2dNWEI0SUhOdmJHbGtJQ016TXpNN1hISmNiaUFnSUNCaWIzSmtaWEl0Y21Ga2FYVnpPaUF6Y0hnN1hISmNiaUFnSUNCbWIyNTBMWE5wZW1VNklERTBjSGc3WEhKY2JpQWdJQ0JvWldsbmFIUTZJRFF3Y0hnN1hISmNiaUFnSUNCc2FXNWxMV2hsYVdkb2REb2dNVGh3ZUR0Y2NseHVJQ0FnSUc5MWRHeHBibVU2SURBN1hISmNiaUFnSUNCd1lXUmthVzVuT2lBMWNIZ2dNVEJ3ZUR0Y2NseHVJQ0FnSUhkcFpIUm9PaUF4TURBbE8xeHlYRzRnSUgxY2NseHVYSEpjYmlBZ2MyVnNaV04wSUh0Y2NseHVJQ0FnSUdobGFXZG9kRG9nWVhWMGJ6dGNjbHh1SUNBZ0lHeHBibVV0YUdWcFoyaDBPaUJwYm1obGNtbDBPMXh5WEc0Z0lDQWdjR0ZrWkdsdVp6b2dOWEI0TzF4eVhHNGdJSDFjY2x4dVhISmNiaUFnTG1sdWNIVjBMWFJsZUhRNlptOWpkWE1zWEhKY2JpQWdjMlZzWldOME9tWnZZM1Z6SUh0Y2NseHVJQ0FnSUdKdmNtUmxjaTFqYjJ4dmNqb2dkbUZ5S0MwdGJXRnBia052Ykc5eUtUdGNjbHh1SUNBZ0lHSnZlQzF6YUdGa2IzYzZJREFnTUNBemNIZ2dkbUZ5S0MwdGJXRnBia052Ykc5eUtUdGNjbHh1SUNCOVhISmNibHh5WEc0Z0lDNXBibkIxZEMxamFHOXBZMlVnZTF4eVhHNGdJQ0FnWkdsemNHeGhlVG9nYVc1c2FXNWxMV0pzYjJOck8xeHlYRzRnSUNBZ2JXRnlaMmx1T2lBMGNIZ2dNVEJ3ZUNBd0lEQTdYSEpjYmlBZ0lDQjJaWEowYVdOaGJDMWhiR2xuYmpvZ2RHOXdPMXh5WEc0Z0lIMWNjbHh1WEhKY2JpQWdMbU5sYkd4eklIdGNjbHh1SUNBZ0lHUnBjM0JzWVhrNklHWnNaWGc3WEhKY2JpQWdJQ0JtYkdWNExYZHlZWEE2SUhkeVlYQTdYSEpjYmlBZ0lDQmhiR2xuYmkxamIyNTBaVzUwT2lCbWJHVjRMWE4wWVhKME8xeHlYRzRnSUNBZ1lXeHBaMjR0YVhSbGJYTTZJR1pzWlhndGMzUmhjblE3WEhKY2JpQWdJQ0J0WVhKbmFXNHRkRzl3T2lBdE1UQndlRHRjY2x4dUlDQWdJSEJoWkdScGJtYzZJREV3Y0hnN1hISmNiaUFnSUNCcWRYTjBhV1o1TFdOdmJuUmxiblE2SUdObGJuUmxjanRjY2x4dUlDQjlYSEpjYmx4eVhHNGdJQzVqWld4c2N5QStJQ29nZTF4eVhHNGdJQ0FnWW1GamEyZHliM1Z1WkRvZ0kyWm1aanRjY2x4dUlDQWdJR0p2Y21SbGNqb2dNWEI0SUhOdmJHbGtJSFpoY2lndExXZHlaWGtwTzF4eVhHNGdJQ0FnWW05NExYTm9ZV1J2ZHpvZ01DQXdJRFZ3ZUNCMllYSW9MUzFuY21WNUtUdGNjbHh1SUNBZ0lHSnZjbVJsY2kxeVlXUnBkWE02SUROd2VEdGNjbHh1SUNBZ0lHTjFjbk52Y2pvZ2NHOXBiblJsY2p0Y2NseHVJQ0FnSUcxaGNtZHBiam9nTVRCd2VDQTFjSGdnTUR0Y2NseHVJQ0FnSUc5MlpYSm1iRzkzT2lCb2FXUmtaVzQ3WEhKY2JpQWdJQ0J3WVdSa2FXNW5PaUExY0hnN1hISmNiaUFnSUNCMFpYaDBMV0ZzYVdkdU9pQmpaVzUwWlhJN1hISmNiaUFnSUNCM2FXUjBhRG9nTVRVd2NIZzdYSEpjYmlBZ2ZWeHlYRzVjY2x4dUlDQXVZMlZzYkhNZ2FXNXdkWFFnZTF4eVhHNGdJQ0FnWkdsemNHeGhlVG9nWW14dlkyczdYSEpjYmlBZ0lDQnRZWEpuYVc0NklEQWdZWFYwYnlBMWNIZzdYSEpjYmlBZ2ZWeHlYRzVjY2x4dUlDQmpiMlJsSUh0Y2NseHVJQ0FnSUc5MWRHeHBibVU2SURBN1hISmNiaUFnZlZ4eVhHNGlYWDA9ICovPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlFRSxRQUFRLElBQUksZ0VBQWdFLENBQUMsQ0FBQyxBQUV0RSxLQUFLLEFBQUUsQ0FBQyxBQUNkLGFBQWEsQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FDaEMsT0FBTyxDQUFFLElBQUksQ0FDYixhQUFhLENBQUUsSUFBSSxDQUNuQixRQUFRLENBQUUsUUFBUSxBQUNwQixDQUFDLEFBRU8sVUFBVSxBQUFFLENBQUMsQUFDbkIsVUFBVSxDQUFFLE9BQU8sQ0FDbkIsTUFBTSxDQUFFLEdBQUcsQ0FDWCxJQUFJLENBQUUsQ0FBQyxDQUNQLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxJQUFJLENBQ1QsVUFBVSxDQUFFLEdBQUcsQ0FBQyxTQUFTLENBQUMsYUFBYSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDeEQsS0FBSyxDQUFFLEdBQUcsQUFDWixDQUFDLEFBRU8sYUFBYSxBQUFFLENBQUMsQUFDdEIsVUFBVSxDQUFFLElBQUksQ0FDaEIsTUFBTSxDQUFFLENBQUMsQ0FDVCxNQUFNLENBQUUsT0FBTyxDQUNmLElBQUksQ0FBRSxDQUFDLENBQ1AsU0FBUyxDQUFFLElBQUksQ0FDZixXQUFXLENBQUUsSUFBSSxDQUNqQixPQUFPLENBQUUsSUFBSSxDQUNiLE9BQU8sQ0FBRSxJQUFJLENBQ2IsY0FBYyxDQUFFLFNBQVMsQUFDM0IsQ0FBQyxBQUVPLG1CQUFtQixBQUFFLENBQUMsQUFDNUIsS0FBSyxDQUFFLE9BQU8sQUFDaEIsQ0FBQyxBQUVPLHNCQUFzQixBQUFFLENBQUMsQUFDL0IsS0FBSyxDQUFFLE9BQU8sQUFDaEIsQ0FBQyxBQUVPLEtBQUssQUFBRSxDQUFDLEFBQ2QsS0FBSyxDQUFFLE9BQU8sQ0FDZCxNQUFNLENBQUUsT0FBTyxDQUNmLE9BQU8sQ0FBRSxLQUFLLENBQ2QsU0FBUyxDQUFFLElBQUksQ0FDZixXQUFXLENBQUUsSUFBSSxDQUNqQixNQUFNLENBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQ3RCLFNBQVMsQ0FBRSxLQUFLLENBQ2hCLGVBQWUsQ0FBRSxJQUFJLENBQ3JCLFVBQVUsQ0FBRSxNQUFNLEFBQ3BCLENBQUMsQUFFTyxTQUFTLEFBQUUsQ0FBQyxBQUNsQixPQUFPLENBQUUsS0FBSyxDQUNkLFNBQVMsQ0FBRSxJQUFJLEFBQ2pCLENBQUMsQUFFTyxXQUFXLEFBQUUsQ0FBQyxBQUNwQixLQUFLLENBQUUsT0FBTyxBQUNoQixDQUFDLEFBRU8sS0FBSyxBQUFFLENBQUMsQUFDZCxjQUFjLENBQUUsS0FBSyxBQUN2QixDQUFDLEFBRU8sRUFBRSxBQUFFLENBQUMsQUFDWCxLQUFLLENBQUUsT0FBTyxDQUNkLFNBQVMsQ0FBRSxJQUFJLENBQ2YsV0FBVyxDQUFFLElBQUksQ0FDakIsYUFBYSxDQUFFLElBQUksQ0FDbkIsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsY0FBYyxDQUFFLFNBQVMsQUFDM0IsQ0FBQyxBQUVPLFdBQVcsQUFBQyxDQUNaLE1BQU0sQUFBRSxDQUFDLEFBQ2YsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUN0QixhQUFhLENBQUUsR0FBRyxDQUNsQixTQUFTLENBQUUsSUFBSSxDQUNmLE1BQU0sQ0FBRSxJQUFJLENBQ1osV0FBVyxDQUFFLElBQUksQ0FDakIsT0FBTyxDQUFFLENBQUMsQ0FDVixPQUFPLENBQUUsR0FBRyxDQUFDLElBQUksQ0FDakIsS0FBSyxDQUFFLElBQUksQUFDYixDQUFDLEFBRU8sTUFBTSxBQUFFLENBQUMsQUFDZixNQUFNLENBQUUsSUFBSSxDQUNaLFdBQVcsQ0FBRSxPQUFPLENBQ3BCLE9BQU8sQ0FBRSxHQUFHLEFBQ2QsQ0FBQyxBQUVPLGlCQUFpQixBQUFDLENBQ2xCLFlBQVksQUFBRSxDQUFDLEFBQ3JCLFlBQVksQ0FBRSxPQUFPLENBQ3JCLFVBQVUsQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEFBQzdCLENBQUMsQUFFTyxhQUFhLEFBQUUsQ0FBQyxBQUN0QixPQUFPLENBQUUsWUFBWSxDQUNyQixNQUFNLENBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNwQixjQUFjLENBQUUsR0FBRyxBQUNyQixDQUFDLEFBRU8sTUFBTSxBQUFFLENBQUMsQUFDZixPQUFPLENBQUUsSUFBSSxDQUNiLFNBQVMsQ0FBRSxJQUFJLENBQ2YsYUFBYSxDQUFFLFVBQVUsQ0FDekIsV0FBVyxDQUFFLFVBQVUsQ0FDdkIsVUFBVSxDQUFFLEtBQUssQ0FDakIsT0FBTyxDQUFFLElBQUksQ0FDYixlQUFlLENBQUUsTUFBTSxBQUN6QixDQUFDLEFBRU8sVUFBVSxBQUFFLENBQUMsQUFDbkIsVUFBVSxDQUFFLElBQUksQ0FDaEIsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUN0QixVQUFVLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUN4QixhQUFhLENBQUUsR0FBRyxDQUNsQixNQUFNLENBQUUsT0FBTyxDQUNmLE1BQU0sQ0FBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FDbEIsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsT0FBTyxDQUFFLEdBQUcsQ0FDWixVQUFVLENBQUUsTUFBTSxDQUNsQixLQUFLLENBQUUsS0FBSyxBQUNkLENBQUMsQUFFTyxZQUFZLEFBQUUsQ0FBQyxBQUNyQixPQUFPLENBQUUsS0FBSyxDQUNkLE1BQU0sQ0FBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQUFDcEIsQ0FBQyxBQUVPLElBQUksQUFBRSxDQUFDLEFBQ2IsT0FBTyxDQUFFLENBQUMsQUFDWixDQUFDIn0= */";
	append_dev(document.head, style);
}

// (43:0) {#if !transitionActive}
function create_if_block$a(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let div_transition;
	let current;
	let dispose;
	const if_block_creators = [create_if_block_1$9, create_else_block$7];
	const if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.pageId === 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			attr_dev(div, "class", "docs");
			add_location(div, file$s, 43, 2, 1709);
			dispose = listen_dev(div, "outroend", ctx.outroend_handler, false, false, false);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p: function update(changed, ctx) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);

			add_render_callback(() => {
				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { delay: 0, duration: 250 }, true);
				div_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { delay: 0, duration: 250 }, false);
			div_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
			if (detaching && div_transition) div_transition.end();
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$a.name,
		type: "if",
		source: "(43:0) {#if !transitionActive}",
		ctx
	});

	return block;
}

// (66:4) {:else}
function create_else_block$7(ctx) {
	let current;
	const editor = new Builder({ $$inline: true });

	const block = {
		c: function create() {
			create_component(editor.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(editor, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(editor.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(editor.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(editor, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$7.name,
		type: "else",
		source: "(66:4) {:else}",
		ctx
	});

	return block;
}

// (49:4) {#if pageId === 0}
function create_if_block_1$9(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let t9;
	let t10;
	let t11;
	let t12;
	let t13;
	let t14;
	let current;
	const string = new String$1({ $$inline: true });
	const email = new Email({ $$inline: true });
	const number = new Number({ $$inline: true });
	const boolean = new Boolean$1({ $$inline: true });
	const array = new Array$1({ $$inline: true });
	const required = new Required({ $$inline: true });
	const match = new Match({ $$inline: true });
	const equal = new Equal({ $$inline: true });
	const usewithparams = new Use_with_params({ $$inline: true });
	const withoutinputs = new Without_inputs({ $$inline: true });
	const dynamicsteps = new Dynamic_steps({ $$inline: true });
	const arraysumofpoints = new Array_sum_of_points({ $$inline: true });
	const fieldconfirm = new Field_confirm({ $$inline: true });
	const customerrors = new Custom_errors({ $$inline: true });
	const getvalues = new Get_values({ $$inline: true });
	const getvaluescustom = new Get_values_custom({ $$inline: true });

	const block = {
		c: function create() {
			create_component(string.$$.fragment);
			t0 = space();
			create_component(email.$$.fragment);
			t1 = space();
			create_component(number.$$.fragment);
			t2 = space();
			create_component(boolean.$$.fragment);
			t3 = space();
			create_component(array.$$.fragment);
			t4 = space();
			create_component(required.$$.fragment);
			t5 = space();
			create_component(match.$$.fragment);
			t6 = space();
			create_component(equal.$$.fragment);
			t7 = space();
			create_component(usewithparams.$$.fragment);
			t8 = space();
			create_component(withoutinputs.$$.fragment);
			t9 = space();
			create_component(dynamicsteps.$$.fragment);
			t10 = space();
			create_component(arraysumofpoints.$$.fragment);
			t11 = space();
			create_component(fieldconfirm.$$.fragment);
			t12 = space();
			create_component(customerrors.$$.fragment);
			t13 = space();
			create_component(getvalues.$$.fragment);
			t14 = space();
			create_component(getvaluescustom.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(string, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(email, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(number, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(boolean, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(array, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(required, target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(match, target, anchor);
			insert_dev(target, t6, anchor);
			mount_component(equal, target, anchor);
			insert_dev(target, t7, anchor);
			mount_component(usewithparams, target, anchor);
			insert_dev(target, t8, anchor);
			mount_component(withoutinputs, target, anchor);
			insert_dev(target, t9, anchor);
			mount_component(dynamicsteps, target, anchor);
			insert_dev(target, t10, anchor);
			mount_component(arraysumofpoints, target, anchor);
			insert_dev(target, t11, anchor);
			mount_component(fieldconfirm, target, anchor);
			insert_dev(target, t12, anchor);
			mount_component(customerrors, target, anchor);
			insert_dev(target, t13, anchor);
			mount_component(getvalues, target, anchor);
			insert_dev(target, t14, anchor);
			mount_component(getvaluescustom, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(string.$$.fragment, local);
			transition_in(email.$$.fragment, local);
			transition_in(number.$$.fragment, local);
			transition_in(boolean.$$.fragment, local);
			transition_in(array.$$.fragment, local);
			transition_in(required.$$.fragment, local);
			transition_in(match.$$.fragment, local);
			transition_in(equal.$$.fragment, local);
			transition_in(usewithparams.$$.fragment, local);
			transition_in(withoutinputs.$$.fragment, local);
			transition_in(dynamicsteps.$$.fragment, local);
			transition_in(arraysumofpoints.$$.fragment, local);
			transition_in(fieldconfirm.$$.fragment, local);
			transition_in(customerrors.$$.fragment, local);
			transition_in(getvalues.$$.fragment, local);
			transition_in(getvaluescustom.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(string.$$.fragment, local);
			transition_out(email.$$.fragment, local);
			transition_out(number.$$.fragment, local);
			transition_out(boolean.$$.fragment, local);
			transition_out(array.$$.fragment, local);
			transition_out(required.$$.fragment, local);
			transition_out(match.$$.fragment, local);
			transition_out(equal.$$.fragment, local);
			transition_out(usewithparams.$$.fragment, local);
			transition_out(withoutinputs.$$.fragment, local);
			transition_out(dynamicsteps.$$.fragment, local);
			transition_out(arraysumofpoints.$$.fragment, local);
			transition_out(fieldconfirm.$$.fragment, local);
			transition_out(customerrors.$$.fragment, local);
			transition_out(getvalues.$$.fragment, local);
			transition_out(getvaluescustom.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(string, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(email, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(number, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(boolean, detaching);
			if (detaching) detach_dev(t3);
			destroy_component(array, detaching);
			if (detaching) detach_dev(t4);
			destroy_component(required, detaching);
			if (detaching) detach_dev(t5);
			destroy_component(match, detaching);
			if (detaching) detach_dev(t6);
			destroy_component(equal, detaching);
			if (detaching) detach_dev(t7);
			destroy_component(usewithparams, detaching);
			if (detaching) detach_dev(t8);
			destroy_component(withoutinputs, detaching);
			if (detaching) detach_dev(t9);
			destroy_component(dynamicsteps, detaching);
			if (detaching) detach_dev(t10);
			destroy_component(arraysumofpoints, detaching);
			if (detaching) detach_dev(t11);
			destroy_component(fieldconfirm, detaching);
			if (detaching) detach_dev(t12);
			destroy_component(customerrors, detaching);
			if (detaching) detach_dev(t13);
			destroy_component(getvalues, detaching);
			if (detaching) detach_dev(t14);
			destroy_component(getvaluescustom, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$9.name,
		type: "if",
		source: "(49:4) {#if pageId === 0}",
		ctx
	});

	return block;
}

function create_fragment$u(ctx) {
	let a;
	let img;
	let img_src_value;
	let t0;
	let t1;
	let div;
	let button0;
	let t2;
	let button0_disabled_value;
	let t3;
	let button1;
	let t4;
	let button1_disabled_value;
	let t5;
	let i;
	let i_style_value;
	let t6;
	let if_block_anchor;
	let current;
	let dispose;
	let if_block = !ctx.transitionActive && create_if_block$a(ctx);

	const block = {
		c: function create() {
			a = element("a");
			img = element("img");
			t0 = text("\r\n  go to github");
			t1 = space();
			div = element("div");
			button0 = element("button");
			t2 = text("Examples");
			t3 = space();
			button1 = element("button");
			t4 = text("Builder");
			t5 = space();
			i = element("i");
			t6 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			if (img.src !== (img_src_value = "./logo.svg")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "svelidation");
			add_location(img, file$s, 32, 2, 1295);
			attr_dev(a, "href", "//github.com/yazonnile/svelidation");
			attr_dev(a, "class", "logo");
			add_location(a, file$s, 31, 0, 1233);
			attr_dev(button0, "class", "tabs--button");
			button0.disabled = button0_disabled_value = ctx.pageId === 0;
			add_location(button0, file$s, 37, 2, 1385);
			attr_dev(button1, "class", "tabs--button");
			button1.disabled = button1_disabled_value = ctx.pageId === 1;
			add_location(button1, file$s, 38, 2, 1491);
			attr_dev(i, "class", "tabs--bar");
			attr_dev(i, "style", i_style_value = `transform: translateX(${100 * ctx.barId}%)`);
			add_location(i, file$s, 39, 2, 1596);
			attr_dev(div, "class", "tabs");
			add_location(div, file$s, 36, 0, 1363);

			dispose = [
				listen_dev(button0, "click", ctx.click_handler, false, false, false),
				listen_dev(button1, "click", ctx.click_handler_1, false, false, false)
			];
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, img);
			append_dev(a, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, div, anchor);
			append_dev(div, button0);
			append_dev(button0, t2);
			append_dev(div, t3);
			append_dev(div, button1);
			append_dev(button1, t4);
			append_dev(div, t5);
			append_dev(div, i);
			insert_dev(target, t6, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(changed, ctx) {
			if (!current || changed.pageId && button0_disabled_value !== (button0_disabled_value = ctx.pageId === 0)) {
				prop_dev(button0, "disabled", button0_disabled_value);
			}

			if (!current || changed.pageId && button1_disabled_value !== (button1_disabled_value = ctx.pageId === 1)) {
				prop_dev(button1, "disabled", button1_disabled_value);
			}

			if (!current || changed.barId && i_style_value !== (i_style_value = `transform: translateX(${100 * ctx.barId}%)`)) {
				attr_dev(i, "style", i_style_value);
			}

			if (!ctx.transitionActive) {
				if (if_block) {
					if_block.p(changed, ctx);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block$a(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);
			if (detaching) detach_dev(t6);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$u.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$u($$self, $$props, $$invalidate) {
	let barId = 0;
	let pageId = barId;
	let transitionActive = false;

	const switchPages = n => {
		if (transitionActive) return;
		$$invalidate("transitionActive", transitionActive = true);
		$$invalidate("barId", barId = n);
	};

	const click_handler = () => switchPages(0);
	const click_handler_1 = () => switchPages(1);
	const outroend_handler = () => ($$invalidate("pageId", pageId = barId), $$invalidate("transitionActive", transitionActive = false));

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ("barId" in $$props) $$invalidate("barId", barId = $$props.barId);
		if ("pageId" in $$props) $$invalidate("pageId", pageId = $$props.pageId);
		if ("transitionActive" in $$props) $$invalidate("transitionActive", transitionActive = $$props.transitionActive);
	};

	return {
		barId,
		pageId,
		transitionActive,
		switchPages,
		click_handler,
		click_handler_1,
		outroend_handler
	};
}

class Docs extends SvelteComponentDev {
	constructor(options) {
		super(options);
		if (!document.getElementById("svelte-1edyv9o-style")) add_css$d();
		init(this, options, instance$u, create_fragment$u, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Docs",
			options,
			id: create_fragment$u.name
		});
	}
}

new Docs({ target: document.getElementById('app') });
//# sourceMappingURL=docs.js.map
//# sourceMappingURL=docs.js.map
