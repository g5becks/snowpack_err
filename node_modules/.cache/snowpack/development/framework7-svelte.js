import { SvelteComponentDev, init, safe_not_equal, dispatch_dev, create_slot, assign, compute_rest_props, validate_slots, exclude_internal_props, element, set_attributes, add_location, insert_dev, update_slot, get_spread_update, transition_in, transition_out, detach_dev, createEventDispatcher, onMount, onDestroy, binding_callbacks, attr_dev, space, append_dev, listen_dev, group_outros, check_outros, validate_each_argument, validate_each_keys, afterUpdate, tick, empty, create_component, mount_component, get_spread_object, destroy_component, update_keyed_each, outro_and_destroy_block, text, set_data_dev, prop_dev, noop, svg_element, run_all, select_options, select_option, toggle_class, setContext, getContext, HtmlTag, beforeUpdate } from './svelte/internal.js';

const Utils = {
  text(text) {
    if (typeof text === 'undefined' || text === null) return '';
    return text;
  },
  noUndefinedProps(obj) {
    const o = {};
    Object.keys(obj).forEach((key) => {
      if (typeof obj[key] !== 'undefined') o[key] = obj[key];
    });
    return o;
  },
  isTrueProp(val) {
    return val === true || val === '';
  },
  isStringProp(val) {
    return typeof val === 'string' && val !== '';
  },
  isObject(o) {
    return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
  },
  now() {
    return Date.now();
  },
  extend(...args) {
    let deep = true;
    let to;
    let from;
    if (typeof args[0] === 'boolean') {
      [deep, to] = args;
      args.splice(0, 2);
      from = args;
    } else {
      [to] = args;
      args.splice(0, 1);
      from = args;
    }
    for (let i = 0; i < from.length; i += 1) {
      const nextSource = args[i];
      if (nextSource !== undefined && nextSource !== null) {
        const keysArray = Object.keys(Object(nextSource));
        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
          const nextKey = keysArray[nextIndex];
          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) {
            if (!deep) {
              to[nextKey] = nextSource[nextKey];
            } else if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
              to[nextKey] = {};
              Utils.extend(to[nextKey], nextSource[nextKey]);
            } else {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
    }
    return to;
  },
  flattenArray(...args) {
    const arr = [];
    args.forEach((arg) => {
      if (Array.isArray(arg)) arr.push(...Utils.flattenArray(...arg));
      else arr.push(arg);
    });
    return arr;
  },
  classNames(...args) {
    const classes = [];
    args.forEach((arg) => {
      if (typeof arg === 'object' && arg.constructor === Object) {
        Object.keys(arg).forEach((key) => {
          if (arg[key]) classes.push(key);
        });
      } else if (arg) classes.push(arg);
    });
    const uniqueClasses = [];
    classes.forEach((c) => {
      if (uniqueClasses.indexOf(c) < 0) uniqueClasses.push(c);
    });
    return uniqueClasses.join(' ');
  },
  bindMethods(context, methods = []) {
    for (let i = 0; i < methods.length; i += 1) {
      if (context[methods[i]]) context[methods[i]] = context[methods[i]].bind(context);
    }
  },
};

const Mixins = {
  colorProps: {
    color: String,
    colorTheme: String,
    textColor: String,
    bgColor: String,
    borderColor: String,
    rippleColor: String,
    themeDark: Boolean,
  },
  colorClasses(props) {
    const {
      color,
      colorTheme,
      textColor,
      bgColor,
      borderColor,
      rippleColor,
      themeDark,
    } = props;

    return {
      'theme-dark': themeDark,
      [`color-${color}`]: color,
      [`color-theme-${colorTheme}`]: colorTheme,
      [`text-color-${textColor}`]: textColor,
      [`bg-color-${bgColor}`]: bgColor,
      [`border-color-${borderColor}`]: borderColor,
      [`ripple-color-${rippleColor}`]: rippleColor,
    };
  },
  linkIconProps: {
    icon: String,
    iconMaterial: String,
    iconF7: String,
    iconIos: String,
    iconMd: String,
    iconAurora: String,
    iconColor: String,
    iconSize: [String, Number],
  },
  linkRouterProps: {
    back: Boolean,
    external: Boolean,
    force: Boolean,
    animate: {
      type: Boolean,
      default: undefined,
    },
    ignoreCache: Boolean,
    reloadCurrent: Boolean,
    reloadAll: Boolean,
    reloadPrevious: Boolean,
    reloadDetail: {
      type: Boolean,
      default: undefined,
    },
    routeTabId: String,
    view: String,
    routeProps: Object,
    preventRouter: Boolean,
    transition: String,
  },
  linkRouterAttrs(props) {
    const {
      force,
      reloadCurrent,
      reloadPrevious,
      reloadAll,
      reloadDetail,
      animate,
      ignoreCache,
      routeTabId,
      view,
      transition,
    } = props;

    let dataAnimate;
    if ('animate' in props && typeof animate !== 'undefined') {
      dataAnimate = animate.toString();
    }

    let dataReloadDetail;
    if ('reloadDetail' in props && typeof reloadDetail !== 'undefined') {
      dataReloadDetail = reloadDetail.toString();
    }

    return {
      'data-force': force || undefined,
      'data-reload-current': reloadCurrent || undefined,
      'data-reload-all': reloadAll || undefined,
      'data-reload-previous': reloadPrevious || undefined,
      'data-reload-detail': dataReloadDetail,
      'data-animate': dataAnimate,
      'data-ignore-cache': ignoreCache || undefined,
      'data-route-tab-id': routeTabId || undefined,
      'data-view': Utils.isStringProp(view) ? view : undefined,
      'data-transition': Utils.isStringProp(transition) ? transition : undefined,
    };
  },
  linkRouterClasses(props) {
    const { back, linkBack, external, preventRouter } = props;

    return {
      back: back || linkBack,
      external,
      'prevent-router': preventRouter,
    };
  },
  linkActionsProps: {
    searchbarEnable: [Boolean, String],
    searchbarDisable: [Boolean, String],

    searchbarClear: [Boolean, String],
    searchbarToggle: [Boolean, String],

    // Panel
    panelOpen: [Boolean, String],
    panelClose: [Boolean, String],
    panelToggle: [Boolean, String],

    // Popup
    popupOpen: [Boolean, String],
    popupClose: [Boolean, String],

    // Actions
    actionsOpen: [Boolean, String],
    actionsClose: [Boolean, String],

    // Popover
    popoverOpen: [Boolean, String],
    popoverClose: [Boolean, String],

    // Login Screen
    loginScreenOpen: [Boolean, String],
    loginScreenClose: [Boolean, String],

    // Picker
    sheetOpen: [Boolean, String],
    sheetClose: [Boolean, String],

    // Sortable
    sortableEnable: [Boolean, String],
    sortableDisable: [Boolean, String],
    sortableToggle: [Boolean, String],

    // Card
    cardOpen: [Boolean, String],
    cardPreventOpen: [Boolean, String],
    cardClose: [Boolean, String],

    // Menu
    menuClose: {
      type: [Boolean, String],
      default: undefined,
    },
  },
  linkActionsAttrs(props) {
    const {
      searchbarEnable,
      searchbarDisable,
      searchbarClear,
      searchbarToggle,
      panelOpen,
      panelClose,
      panelToggle,
      popupOpen,
      popupClose,
      actionsOpen,
      actionsClose,
      popoverOpen,
      popoverClose,
      loginScreenOpen,
      loginScreenClose,
      sheetOpen,
      sheetClose,
      sortableEnable,
      sortableDisable,
      sortableToggle,
      cardOpen,
      cardClose,
    } = props;

    return {
      'data-searchbar': (Utils.isStringProp(searchbarEnable) && searchbarEnable)
                        || (Utils.isStringProp(searchbarDisable) && searchbarDisable)
                        || (Utils.isStringProp(searchbarClear) && searchbarClear)
                        || (Utils.isStringProp(searchbarToggle) && searchbarToggle) || undefined,
      'data-panel': (Utils.isStringProp(panelOpen) && panelOpen)
                    || (Utils.isStringProp(panelClose) && panelClose)
                    || (Utils.isStringProp(panelToggle) && panelToggle) || undefined,
      'data-popup': (Utils.isStringProp(popupOpen) && popupOpen)
                    || (Utils.isStringProp(popupClose) && popupClose) || undefined,
      'data-actions': (Utils.isStringProp(actionsOpen) && actionsOpen)
                    || (Utils.isStringProp(actionsClose) && actionsClose) || undefined,
      'data-popover': (Utils.isStringProp(popoverOpen) && popoverOpen)
                      || (Utils.isStringProp(popoverClose) && popoverClose) || undefined,
      'data-sheet': (Utils.isStringProp(sheetOpen) && sheetOpen)
                    || (Utils.isStringProp(sheetClose) && sheetClose) || undefined,
      'data-login-screen': (Utils.isStringProp(loginScreenOpen) && loginScreenOpen)
                           || (Utils.isStringProp(loginScreenClose) && loginScreenClose) || undefined,
      'data-sortable': (Utils.isStringProp(sortableEnable) && sortableEnable)
                       || (Utils.isStringProp(sortableDisable) && sortableDisable)
                       || (Utils.isStringProp(sortableToggle) && sortableToggle) || undefined,
      'data-card': (Utils.isStringProp(cardOpen) && cardOpen)
                    || (Utils.isStringProp(cardClose) && cardClose) || undefined,
    };
  },
  linkActionsClasses(props) {
    const {
      searchbarEnable,
      searchbarDisable,
      searchbarClear,
      searchbarToggle,
      panelOpen,
      panelClose,
      panelToggle,
      popupOpen,
      popupClose,
      actionsClose,
      actionsOpen,
      popoverOpen,
      popoverClose,
      loginScreenOpen,
      loginScreenClose,
      sheetOpen,
      sheetClose,
      sortableEnable,
      sortableDisable,
      sortableToggle,
      cardOpen,
      cardPreventOpen,
      cardClose,
      menuClose,
    } = props;

    return {
      'searchbar-enable': searchbarEnable || searchbarEnable === '',
      'searchbar-disable': searchbarDisable || searchbarDisable === '',
      'searchbar-clear': searchbarClear || searchbarClear === '',
      'searchbar-toggle': searchbarToggle || searchbarToggle === '',
      'panel-close': panelClose || panelClose === '',
      'panel-open': panelOpen || panelOpen === '',
      'panel-toggle': panelToggle || panelToggle === '',
      'popup-close': popupClose || popupClose === '',
      'popup-open': popupOpen || popupOpen === '',
      'actions-close': actionsClose || actionsClose === '',
      'actions-open': actionsOpen || actionsOpen === '',
      'popover-close': popoverClose || popoverClose === '',
      'popover-open': popoverOpen || popoverOpen === '',
      'sheet-close': sheetClose || sheetClose === '',
      'sheet-open': sheetOpen || sheetOpen === '',
      'login-screen-close': loginScreenClose || loginScreenClose === '',
      'login-screen-open': loginScreenOpen || loginScreenOpen === '',
      'sortable-enable': sortableEnable || sortableEnable === '',
      'sortable-disable': sortableDisable || sortableDisable === '',
      'sortable-toggle': sortableToggle || sortableToggle === '',
      'card-close': cardClose || cardClose === '',
      'card-open': cardOpen || cardOpen === '',
      'card-prevent-open': cardPreventOpen || cardPreventOpen === '',
      'menu-close': menuClose || menuClose === '',
    };
  },
};

function restProps(rest = {}) {
  const props = {};
  Object.keys(rest).forEach((key) => {
    if (key.indexOf('on') !== 0) {
      props[key] = rest[key];
    }
  });
  return props;
}

/* node_modules/framework7-svelte/components/accordion-content.svelte generated by Svelte v3.31.0 */
const file = "node_modules/framework7-svelte/components/accordion-content.svelte";

function create_fragment(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file, 16, 0, 327);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Accordion_content", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "accordion-item-content", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class Accordion_content extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Accordion_content",
			options,
			id: create_fragment.name
		});
	}

	get class() {
		throw new Error("<Accordion_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Accordion_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

// eslint-disable-next-line
let f7Instance;

const f7 = {
  instance: null,
  Framework7: null,
  events: null,
  init(rootEl, params = {}, routes) {
    const { events, Framework7 } = f7;
    const f7Params = Utils.extend({}, params, {
      root: rootEl,
    });
    if (routes && routes.length && !f7Params.routes) f7Params.routes = routes;

    const instance = new Framework7(f7Params);
    f7Instance = instance;
    if (instance.initialized) {
      f7.instance = instance;
      f7Instance = instance;
      events.emit('ready', f7.instance);
    } else {
      instance.on('init', () => {
        f7.instance = instance;
        f7Instance = instance;
        events.emit('ready', f7.instance);
      });
    }
  },
  ready(callback) {
    if (!callback) return;
    if (f7.instance) callback(f7.instance);
    else {
      f7.events.once('ready', callback);
    }
  },
  routers: {
    views: [],
    tabs: [],
    modals: null,
  },
};

/* node_modules/framework7-svelte/components/accordion-item.svelte generated by Svelte v3.31.0 */
const file$1 = "node_modules/framework7-svelte/components/accordion-item.svelte";

function create_fragment$1(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$1, 79, 0, 2482);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[7](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[7](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","opened"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Accordion_item", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { opened = undefined } = $$props;
	let el;

	function onBeforeOpen(accEl, prevent) {
		if (accEl !== el) return;
		dispatch("accordionBeforeOpen", [prevent]);
		if (typeof $$props.onAccordionBeforeOpen === "function") $$props.onAccordionBeforeOpen(prevent);
	}

	function onOpen(accEl) {
		if (accEl !== el) return;
		dispatch("accordionOpen");
		if (typeof $$props.onAccordionOpen === "function") $$props.onAccordionOpen();
	}

	function onOpened(accEl) {
		if (accEl !== el) return;
		dispatch("accordionOpened");
		if (typeof $$props.onAccordionOpened === "function") $$props.onAccordionOpened();
	}

	function onBeforeClose(accEl, prevent) {
		if (accEl !== el) return;
		dispatch("accordionBeforeClose", [prevent]);
		if (typeof $$props.onAccordionBeforeClose === "function") $$props.onAccordionBeforeClose(prevent);
	}

	function onClose(accEl) {
		if (accEl !== el) return;
		dispatch("accordionClose");
		if (typeof $$props.onAccordionClose === "function") $$props.onAccordionClose();
	}

	function onClosed(accEl) {
		if (accEl !== el) return;
		dispatch("accordionClosed");
		if (typeof $$props.onAccordionClosed === "function") $$props.onAccordionClosed();
	}

	onMount(() => {
		f7.ready(() => {
			f7.instance.on("accordionBeforeOpen", onBeforeOpen);
			f7.instance.on("accordionOpen", onOpen);
			f7.instance.on("accordionOpened", onOpened);
			f7.instance.on("accordionBeforeClose", onBeforeClose);
			f7.instance.on("accordionClose", onClose);
			f7.instance.on("accordionClosed", onClosed);
		});
	});

	onDestroy(() => {
		if (!f7.instance || !el) return;
		f7.instance.off("accordionBeforeOpen", onBeforeOpen);
		f7.instance.off("accordionOpen", onOpen);
		f7.instance.off("accordionOpened", onOpened);
		f7.instance.off("accordionBeforeClose", onBeforeClose);
		f7.instance.off("accordionClose", onClose);
		f7.instance.off("accordionClosed", onClosed);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("opened" in $$new_props) $$invalidate(4, opened = $$new_props.opened);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		opened,
		el,
		onBeforeOpen,
		onOpen,
		onOpened,
		onBeforeClose,
		onClose,
		onClosed,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("opened" in $$props) $$invalidate(4, opened = $$new_props.opened);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classes = Utils.classNames(className, "accordion-item", { "accordion-item-opened": opened }, Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [el, classes, $$restProps, className, opened, $$scope, slots, div_binding];
}

class Accordion_item extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { class: 3, opened: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Accordion_item",
			options,
			id: create_fragment$1.name
		});
	}

	get class() {
		throw new Error("<Accordion_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Accordion_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get opened() {
		throw new Error("<Accordion_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set opened(value) {
		throw new Error("<Accordion_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/accordion-toggle.svelte generated by Svelte v3.31.0 */
const file$2 = "node_modules/framework7-svelte/components/accordion-toggle.svelte";

function create_fragment$2(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$2, 16, 0, 326);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Accordion_toggle", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "accordion-item-toggle", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class Accordion_toggle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Accordion_toggle",
			options,
			id: create_fragment$2.name
		});
	}

	get class() {
		throw new Error("<Accordion_toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Accordion_toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/accordion.svelte generated by Svelte v3.31.0 */
const file$3 = "node_modules/framework7-svelte/components/accordion.svelte";

function create_fragment$3(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$3, 19, 0, 411);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","accordionOpposite"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Accordion", slots, ['default']);
	let { class: className = undefined } = $$props;
	let { accordionOpposite = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("accordionOpposite" in $$new_props) $$invalidate(3, accordionOpposite = $$new_props.accordionOpposite);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		accordionOpposite,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("accordionOpposite" in $$props) $$invalidate(3, accordionOpposite = $$new_props.accordionOpposite);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "accordion-list", accordionOpposite && "accordion-opposite", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, accordionOpposite, $$scope, slots];
}

class Accordion extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { class: 2, accordionOpposite: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Accordion",
			options,
			id: create_fragment$3.name
		});
	}

	get class() {
		throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accordionOpposite() {
		throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accordionOpposite(value) {
		throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function hasSlots (args, name) {
  return args && args[1] && args[1].$$slots && args[1].$$slots[name] && args[1].$$slots[name].length > 0;
}

/* node_modules/framework7-svelte/components/actions-button.svelte generated by Svelte v3.31.0 */
const file$4 = "node_modules/framework7-svelte/components/actions-button.svelte";
const get_media_slot_changes = dirty => ({});
const get_media_slot_context = ctx => ({});

// (49:2) {#if hasMediaSlots}
function create_if_block(ctx) {
	let div;
	let current;
	const media_slot_template = /*#slots*/ ctx[9].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[8], get_media_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "actions-button-media");
			add_location(div, file$4, 49, 4, 1073);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (media_slot) {
				if (media_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[8], dirty, get_media_slot_changes, get_media_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(49:2) {#if hasMediaSlots}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let div1;
	let t;
	let div0;
	let current;
	let mounted;
	let dispose;
	let if_block = /*hasMediaSlots*/ ctx[1] && create_if_block(ctx);
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	let div1_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[4])];
	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			if (if_block) if_block.c();
			t = space();
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div0, "class", "actions-button-text");
			add_location(div0, file$4, 53, 2, 1157);
			set_attributes(div1, div1_data);
			add_location(div1, file$4, 42, 0, 954);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			if (if_block) if_block.m(div1, null);
			append_dev(div1, t);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div1_binding*/ ctx[10](div1);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div1, "click", /*onClick*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*hasMediaSlots*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*hasMediaSlots*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			/*div1_binding*/ ctx[10](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","bold","close"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Actions_button", slots, ['media','default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { bold = false } = $$props;
	let { close = true } = $$props;
	let el;

	function onClick() {
		if (close && f7.instance) {
			const dom7 = f7.instance.$;
			f7.instance.actions.close(dom7(el).parents(".actions-modal"));
		}

		dispatch("click");
		if (typeof $$props.onClick === "function") $$props.onClick();
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ("bold" in $$new_props) $$invalidate(6, bold = $$new_props.bold);
		if ("close" in $$new_props) $$invalidate(7, close = $$new_props.close);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		Mixins,
		Utils,
		restProps,
		f7,
		hasSlots,
		dispatch,
		className,
		bold,
		close,
		el,
		onClick,
		hasMediaSlots,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(5, className = $$new_props.className);
		if ("bold" in $$props) $$invalidate(6, bold = $$new_props.bold);
		if ("close" in $$props) $$invalidate(7, close = $$new_props.close);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("hasMediaSlots" in $$props) $$invalidate(1, hasMediaSlots = $$new_props.hasMediaSlots);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	let hasMediaSlots;
	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(2, classes = Utils.classNames(
			className,
			{
				"actions-button": true,
				"actions-button-bold": bold
			},
			Mixins.colorClasses($$props)
		));
	};

	 $$invalidate(1, hasMediaSlots = hasSlots(arguments, "media"));
	$$props = exclude_internal_props($$props);

	return [
		el,
		hasMediaSlots,
		classes,
		onClick,
		$$restProps,
		className,
		bold,
		close,
		$$scope,
		slots,
		div1_binding
	];
}

class Actions_button extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { class: 5, bold: 6, close: 7 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Actions_button",
			options,
			id: create_fragment$4.name
		});
	}

	get class() {
		throw new Error("<Actions_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Actions_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bold() {
		throw new Error("<Actions_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bold(value) {
		throw new Error("<Actions_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get close() {
		throw new Error("<Actions_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set close(value) {
		throw new Error("<Actions_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/actions-group.svelte generated by Svelte v3.31.0 */
const file$5 = "node_modules/framework7-svelte/components/actions-group.svelte";

function create_fragment$5(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$5, 16, 0, 318);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Actions_group", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "actions-group", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class Actions_group extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Actions_group",
			options,
			id: create_fragment$5.name
		});
	}

	get class() {
		throw new Error("<Actions_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Actions_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/actions-label.svelte generated by Svelte v3.31.0 */
const file$6 = "node_modules/framework7-svelte/components/actions-label.svelte";

function create_fragment$6(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[2])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$6, 29, 0, 606);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*onClick*/ ctx[1], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","bold"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Actions_label", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { bold = false } = $$props;

	function onClick() {
		dispatch("click");
		if (typeof $$props.onClick === "function") $$props.onClick();
	}

	$$self.$$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("bold" in $$new_props) $$invalidate(4, bold = $$new_props.bold);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		Mixins,
		Utils,
		restProps,
		dispatch,
		className,
		bold,
		onClick,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("bold" in $$props) $$invalidate(4, bold = $$new_props.bold);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "actions-label", { "actions-button-bold": bold }, Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, onClick, $$restProps, className, bold, $$scope, slots];
}

class Actions_label extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, { class: 3, bold: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Actions_label",
			options,
			id: create_fragment$6.name
		});
	}

	get class() {
		throw new Error("<Actions_label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Actions_label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bold() {
		throw new Error("<Actions_label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bold(value) {
		throw new Error("<Actions_label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/actions.svelte generated by Svelte v3.31.0 */
const file$7 = "node_modules/framework7-svelte/components/actions.svelte";

function create_fragment$7(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);
	let div_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$7, 111, 0, 3207);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[19](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 131072) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[17], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[19](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","opened","grid","convertToPopover","forceToPopover","target","backdrop","backdropEl","closeByBackdropClick","closeByOutsideClick","closeOnEscape","instance","open","close"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Actions", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { opened = undefined } = $$props;
	let { grid = undefined } = $$props;
	let { convertToPopover = undefined } = $$props;
	let { forceToPopover = undefined } = $$props;
	let { target = undefined } = $$props;
	let { backdrop = undefined } = $$props;
	let { backdropEl = undefined } = $$props;
	let { closeByBackdropClick = undefined } = $$props;
	let { closeByOutsideClick = undefined } = $$props;
	let { closeOnEscape = undefined } = $$props;
	let el;
	let f7Actions;

	function instance() {
		return f7Actions;
	}

	function open(anim) {
		if (!f7Actions) return undefined;
		return f7Actions.open(anim);
	}

	function close(anim) {
		if (!f7Actions) return undefined;
		return f7Actions.close(anim);
	}

	function onOpen(instance) {
		dispatch("actionsOpen", [instance]);
		if (typeof $$props.onActionsOpen === "function") $$props.onActionsOpen(instance);
	}

	function onOpened(instance) {
		dispatch("actionsOpened", [instance]);
		if (typeof $$props.onActionsOpened === "function") $$props.onActionsOpened(instance);
	}

	function onClose(instance) {
		dispatch("actionsClose", [instance]);
		if (typeof $$props.onActionsClose === "function") $$props.onActionsClose(instance);
	}

	function onClosed(instance) {
		dispatch("actionsClosed", [instance]);
		if (typeof $$props.onActionsClosed === "function") $$props.onActionsClosed(instance);
	}

	let initialWatched = false;

	function watchOpened(openedPassed) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7Actions) return;
		if (openedPassed) f7Actions.open(); else f7Actions.close();
	}

	onMount(() => {
		const params = {
			el,
			on: {
				open: onOpen,
				opened: onOpened,
				close: onClose,
				closed: onClosed
			}
		};

		if (target) params.targetEl = target;
		if (typeof convertToPopover !== "undefined") params.convertToPopover = convertToPopover;
		if (typeof forceToPopover !== "undefined") params.forceToPopover = forceToPopover;
		if (typeof backdrop !== "undefined") params.backdrop = backdrop;
		if (typeof backdropEl !== "undefined") params.backdropEl = backdropEl;
		if (typeof closeByBackdropClick !== "undefined") params.closeByBackdropClick = closeByBackdropClick;
		if (typeof closeByOutsideClick !== "undefined") params.closeByOutsideClick = closeByOutsideClick;
		if (typeof closeOnEscape !== "undefined") params.closeOnEscape = closeOnEscape;

		f7.ready(() => {
			f7Actions = f7.instance.actions.create(params);

			if (opened) {
				f7Actions.open(false);
			}
		});
	});

	onDestroy(() => {
		if (f7Actions) f7Actions.destroy();
		f7Actions = undefined;
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(28, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("opened" in $$new_props) $$invalidate(4, opened = $$new_props.opened);
		if ("grid" in $$new_props) $$invalidate(5, grid = $$new_props.grid);
		if ("convertToPopover" in $$new_props) $$invalidate(6, convertToPopover = $$new_props.convertToPopover);
		if ("forceToPopover" in $$new_props) $$invalidate(7, forceToPopover = $$new_props.forceToPopover);
		if ("target" in $$new_props) $$invalidate(8, target = $$new_props.target);
		if ("backdrop" in $$new_props) $$invalidate(9, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$new_props) $$invalidate(10, backdropEl = $$new_props.backdropEl);
		if ("closeByBackdropClick" in $$new_props) $$invalidate(11, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ("closeByOutsideClick" in $$new_props) $$invalidate(12, closeByOutsideClick = $$new_props.closeByOutsideClick);
		if ("closeOnEscape" in $$new_props) $$invalidate(13, closeOnEscape = $$new_props.closeOnEscape);
		if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		opened,
		grid,
		convertToPopover,
		forceToPopover,
		target,
		backdrop,
		backdropEl,
		closeByBackdropClick,
		closeByOutsideClick,
		closeOnEscape,
		el,
		f7Actions,
		instance,
		open,
		close,
		onOpen,
		onOpened,
		onClose,
		onClosed,
		initialWatched,
		watchOpened,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(28, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("opened" in $$props) $$invalidate(4, opened = $$new_props.opened);
		if ("grid" in $$props) $$invalidate(5, grid = $$new_props.grid);
		if ("convertToPopover" in $$props) $$invalidate(6, convertToPopover = $$new_props.convertToPopover);
		if ("forceToPopover" in $$props) $$invalidate(7, forceToPopover = $$new_props.forceToPopover);
		if ("target" in $$props) $$invalidate(8, target = $$new_props.target);
		if ("backdrop" in $$props) $$invalidate(9, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$props) $$invalidate(10, backdropEl = $$new_props.backdropEl);
		if ("closeByBackdropClick" in $$props) $$invalidate(11, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ("closeByOutsideClick" in $$props) $$invalidate(12, closeByOutsideClick = $$new_props.closeByOutsideClick);
		if ("closeOnEscape" in $$props) $$invalidate(13, closeOnEscape = $$new_props.closeOnEscape);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("f7Actions" in $$props) f7Actions = $$new_props.f7Actions;
		if ("initialWatched" in $$props) initialWatched = $$new_props.initialWatched;
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classes = Utils.classNames(className, "actions-modal", { "actions-grid": grid }, Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*opened*/ 16) {
			 watchOpened(opened);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		classes,
		$$restProps,
		className,
		opened,
		grid,
		convertToPopover,
		forceToPopover,
		target,
		backdrop,
		backdropEl,
		closeByBackdropClick,
		closeByOutsideClick,
		closeOnEscape,
		instance,
		open,
		close,
		$$scope,
		slots,
		div_binding
	];
}

class Actions extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance_1, create_fragment$7, safe_not_equal, {
			class: 3,
			opened: 4,
			grid: 5,
			convertToPopover: 6,
			forceToPopover: 7,
			target: 8,
			backdrop: 9,
			backdropEl: 10,
			closeByBackdropClick: 11,
			closeByOutsideClick: 12,
			closeOnEscape: 13,
			instance: 14,
			open: 15,
			close: 16
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Actions",
			options,
			id: create_fragment$7.name
		});
	}

	get class() {
		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get opened() {
		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set opened(value) {
		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get grid() {
		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set grid(value) {
		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get convertToPopover() {
		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set convertToPopover(value) {
		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get forceToPopover() {
		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set forceToPopover(value) {
		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get target() {
		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set target(value) {
		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdrop() {
		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdrop(value) {
		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdropEl() {
		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdropEl(value) {
		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeByBackdropClick() {
		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeByBackdropClick(value) {
		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeByOutsideClick() {
		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeByOutsideClick(value) {
		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeOnEscape() {
		throw new Error("<Actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeOnEscape(value) {
		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[14];
	}

	set instance(value) {
		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		return this.$$.ctx[15];
	}

	set open(value) {
		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get close() {
		return this.$$.ctx[16];
	}

	set close(value) {
		throw new Error("<Actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/routable-modals.svelte generated by Svelte v3.31.0 */
const file$8 = "node_modules/framework7-svelte/components/routable-modals.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (33:2) {#each modals as modal (modal.id)}
function create_each_block(key_1, ctx) {
	let first;
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*modal*/ ctx[5].props];
	var switch_value = /*modal*/ ctx[5].component;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty & /*modals*/ 1)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*modal*/ ctx[5].props)])
			: {};

			if (switch_value !== (switch_value = /*modal*/ ctx[5].component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(33:2) {#each modals as modal (modal.id)}",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let div;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let each_value = /*modals*/ ctx[0];
	validate_each_argument(each_value);
	const get_key = ctx => /*modal*/ ctx[5].id;
	validate_each_keys(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "class", "framework7-modals");
			add_location(div, file$8, 31, 0, 614);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			/*div_binding*/ ctx[2](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*modals*/ 1) {
				const each_value = /*modals*/ ctx[0];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*div_binding*/ ctx[2](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Routable_modals", slots, []);
	let modals = [];
	let el;
	let routerData;

	onMount(() => {
		routerData = {
			el,
			modals,
			setModals(m) {
				tick().then(() => {
					$$invalidate(0, modals = m);
				});
			}
		};

		f7.routers.modals = routerData;
	});

	afterUpdate(() => {
		if (!routerData) return;
		f7.events.emit("modalsRouterDidUpdate", routerData);
	});

	onDestroy(() => {
		if (!routerData) return;
		f7.routers.modals = null;
		routerData = null;
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Routable_modals> was created with unknown prop '${key}'`);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		afterUpdate,
		tick,
		f7,
		modals,
		el,
		routerData
	});

	$$self.$inject_state = $$props => {
		if ("modals" in $$props) $$invalidate(0, modals = $$props.modals);
		if ("el" in $$props) $$invalidate(1, el = $$props.el);
		if ("routerData" in $$props) routerData = $$props.routerData;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [modals, el, div_binding];
}

class Routable_modals extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$8, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Routable_modals",
			options,
			id: create_fragment$8.name
		});
	}
}

/* node_modules/framework7-svelte/components/app.svelte generated by Svelte v3.31.0 */
const file$9 = "node_modules/framework7-svelte/components/app.svelte";

function create_fragment$9(ctx) {
	let div;
	let t;
	let routablemodals;
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
	routablemodals = new Routable_modals({ $$inline: true });

	let div_levels = [
		{ id: /*id*/ ctx[0] },
		{ class: /*classes*/ ctx[2] },
		restProps(/*$$restProps*/ ctx[3])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();
			create_component(routablemodals.$$.fragment);
			set_attributes(div, div_data);
			add_location(div, file$9, 34, 0, 804);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_dev(div, t);
			mount_component(routablemodals, div, null);
			/*div_binding*/ ctx[9](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*id*/ 1) && { id: /*id*/ ctx[0] },
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(routablemodals.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			transition_out(routablemodals.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			destroy_component(routablemodals);
			/*div_binding*/ ctx[9](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	const omit_props_names = ["id","params","routes","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("App", slots, ['default']);
	let { id = "framework7-root" } = $$props;
	let { params = {} } = $$props;
	let { routes = [] } = $$props;
	let { class: className = undefined } = $$props;
	let el;

	onMount(() => {
		const parentEl = el.parentNode;

		if (parentEl && parentEl !== document.body && parentEl.parentNode === document.body) {
			parentEl.style.height = "100%";
		}

		if (f7.instance) return;
		f7.init(el, params, routes);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ("params" in $$new_props) $$invalidate(4, params = $$new_props.params);
		if ("routes" in $$new_props) $$invalidate(5, routes = $$new_props.routes);
		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		f7,
		RoutableModals: Routable_modals,
		Mixins,
		Utils,
		restProps,
		id,
		params,
		routes,
		className,
		el,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
		if ("params" in $$props) $$invalidate(4, params = $$new_props.params);
		if ("routes" in $$props) $$invalidate(5, routes = $$new_props.routes);
		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
		if ("el" in $$props) $$invalidate(1, el = $$new_props.el);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(2, classes = Utils.classNames(className, "framework7-root", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);

	return [
		id,
		el,
		classes,
		$$restProps,
		params,
		routes,
		className,
		$$scope,
		slots,
		div_binding
	];
}

class App extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$9, safe_not_equal, { id: 0, params: 4, routes: 5, class: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "App",
			options,
			id: create_fragment$9.name
		});
	}

	get id() {
		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get params() {
		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set params(value) {
		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get routes() {
		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set routes(value) {
		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/appbar.svelte generated by Svelte v3.31.0 */
const file$a = "node_modules/framework7-svelte/components/appbar.svelte";
const get_after_inner_slot_changes = dirty => ({});
const get_after_inner_slot_context = ctx => ({});
const get_before_inner_slot_changes = dirty => ({});
const get_before_inner_slot_context = ctx => ({});

// (41:2) {:else}
function create_else_block(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(41:2) {:else}",
		ctx
	});

	return block;
}

// (37:2) {#if inner}
function create_if_block$1(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", /*innerClasses*/ ctx[2]);
			add_location(div, file$a, 37, 4, 767);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			if (!current || dirty & /*innerClasses*/ 4) {
				attr_dev(div, "class", /*innerClasses*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(37:2) {#if inner}",
		ctx
	});

	return block;
}

function create_fragment$a(ctx) {
	let div;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let current;
	const before_inner_slot_template = /*#slots*/ ctx[10]["before-inner"];
	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[9], get_before_inner_slot_context);
	const if_block_creators = [create_if_block$1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*inner*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const after_inner_slot_template = /*#slots*/ ctx[10]["after-inner"];
	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[9], get_after_inner_slot_context);
	let div_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[3])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (before_inner_slot) before_inner_slot.c();
			t0 = space();
			if_block.c();
			t1 = space();
			if (after_inner_slot) after_inner_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$a, 31, 0, 663);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (before_inner_slot) {
				before_inner_slot.m(div, null);
			}

			append_dev(div, t0);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t1);

			if (after_inner_slot) {
				after_inner_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (before_inner_slot) {
				if (before_inner_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(before_inner_slot, before_inner_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_before_inner_slot_changes, get_before_inner_slot_context);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, t1);
			}

			if (after_inner_slot) {
				if (after_inner_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(after_inner_slot, after_inner_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_after_inner_slot_changes, get_after_inner_slot_context);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_inner_slot, local);
			transition_in(if_block);
			transition_in(after_inner_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_inner_slot, local);
			transition_out(if_block);
			transition_out(after_inner_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (before_inner_slot) before_inner_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (after_inner_slot) after_inner_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","noShadow","noHairline","inner","innerClass","innerClassName"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Appbar", slots, ['before-inner','default','after-inner']);
	let { class: className = undefined } = $$props;
	let { noShadow = undefined } = $$props;
	let { noHairline = undefined } = $$props;
	let { inner = true } = $$props;
	let { innerClass = undefined } = $$props;
	let { innerClassName = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("noShadow" in $$new_props) $$invalidate(5, noShadow = $$new_props.noShadow);
		if ("noHairline" in $$new_props) $$invalidate(6, noHairline = $$new_props.noHairline);
		if ("inner" in $$new_props) $$invalidate(0, inner = $$new_props.inner);
		if ("innerClass" in $$new_props) $$invalidate(7, innerClass = $$new_props.innerClass);
		if ("innerClassName" in $$new_props) $$invalidate(8, innerClassName = $$new_props.innerClassName);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		noShadow,
		noHairline,
		inner,
		innerClass,
		innerClassName,
		classes,
		innerClasses
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("noShadow" in $$props) $$invalidate(5, noShadow = $$new_props.noShadow);
		if ("noHairline" in $$props) $$invalidate(6, noHairline = $$new_props.noHairline);
		if ("inner" in $$props) $$invalidate(0, inner = $$new_props.inner);
		if ("innerClass" in $$props) $$invalidate(7, innerClass = $$new_props.innerClass);
		if ("innerClassName" in $$props) $$invalidate(8, innerClassName = $$new_props.innerClassName);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
		if ("innerClasses" in $$props) $$invalidate(2, innerClasses = $$new_props.innerClasses);
	};

	let classes;
	let innerClasses;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classes = Utils.classNames(
			className,
			"appbar",
			{
				"no-shadow": noShadow,
				"no-hairline": noHairline
			},
			Mixins.colorClasses($$props)
		));

		if ($$self.$$.dirty & /*innerClass, innerClassName*/ 384) {
			 $$invalidate(2, innerClasses = Utils.classNames("appbar-inner", innerClass, innerClassName));
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		inner,
		classes,
		innerClasses,
		$$restProps,
		className,
		noShadow,
		noHairline,
		innerClass,
		innerClassName,
		$$scope,
		slots
	];
}

class Appbar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$9, create_fragment$a, safe_not_equal, {
			class: 4,
			noShadow: 5,
			noHairline: 6,
			inner: 0,
			innerClass: 7,
			innerClassName: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Appbar",
			options,
			id: create_fragment$a.name
		});
	}

	get class() {
		throw new Error("<Appbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Appbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noShadow() {
		throw new Error("<Appbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noShadow(value) {
		throw new Error("<Appbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairline() {
		throw new Error("<Appbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairline(value) {
		throw new Error("<Appbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inner() {
		throw new Error("<Appbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inner(value) {
		throw new Error("<Appbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get innerClass() {
		throw new Error("<Appbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set innerClass(value) {
		throw new Error("<Appbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get innerClassName() {
		throw new Error("<Appbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set innerClassName(value) {
		throw new Error("<Appbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/badge.svelte generated by Svelte v3.31.0 */
const file$b = "node_modules/framework7-svelte/components/badge.svelte";

function create_fragment$b(ctx) {
	let span;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let span_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			set_attributes(span, span_data);
			add_location(span, file$b, 64, 0, 1406);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","tooltip","tooltipTrigger"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Badge", slots, ['default']);
	let { class: className = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let el;
	let f7Tooltip;
	let tooltipText = tooltip;

	function watchTooltip(newText) {
		const oldText = tooltipText;
		if (oldText === newText) return;
		tooltipText = newText;

		if (!newText && f7Tooltip) {
			f7Tooltip.destroy();
			f7Tooltip = null;
			return;
		}

		if (newText && !f7Tooltip && f7.instance) {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: newText,
				trigger: tooltipTrigger
			});

			return;
		}

		if (!newText || !f7Tooltip) return;
		f7Tooltip.setText(newText);
	}

	onMount(() => {
		if (!tooltip) return;

		f7.ready(() => {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: tooltip,
				trigger: tooltipTrigger
			});
		});
	});

	onDestroy(() => {
		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
			f7Tooltip = null;
		}
	});

	$$self.$$set = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("tooltip" in $$new_props) $$invalidate(3, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$new_props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		className,
		tooltip,
		tooltipTrigger,
		el,
		f7Tooltip,
		tooltipText,
		watchTooltip,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("tooltip" in $$props) $$invalidate(3, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$props) $$invalidate(4, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("el" in $$props) el = $$new_props.el;
		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "badge", Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*tooltip*/ 8) {
			 watchTooltip(tooltip);
		}
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, tooltip, tooltipTrigger, $$scope, slots];
}

class Badge extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$b, safe_not_equal, { class: 2, tooltip: 3, tooltipTrigger: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Badge",
			options,
			id: create_fragment$b.name
		});
	}

	get class() {
		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltip() {
		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltip(value) {
		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltipTrigger() {
		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltipTrigger(value) {
		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/block-footer.svelte generated by Svelte v3.31.0 */
const file$c = "node_modules/framework7-svelte/components/block-footer.svelte";

function create_fragment$c(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$c, 15, 0, 316);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Block_footer", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Utils,
		restProps,
		Mixins,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "block-footer", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class Block_footer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$c, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Block_footer",
			options,
			id: create_fragment$c.name
		});
	}

	get class() {
		throw new Error("<Block_footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Block_footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/block-header.svelte generated by Svelte v3.31.0 */
const file$d = "node_modules/framework7-svelte/components/block-header.svelte";

function create_fragment$d(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$d, 15, 0, 316);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$c($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Block_header", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Utils,
		restProps,
		Mixins,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "block-header", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class Block_header extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$c, create_fragment$d, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Block_header",
			options,
			id: create_fragment$d.name
		});
	}

	get class() {
		throw new Error("<Block_header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Block_header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/block-title.svelte generated by Svelte v3.31.0 */
const file$e = "node_modules/framework7-svelte/components/block-title.svelte";

function create_fragment$e(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$e, 22, 0, 456);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$d($$self, $$props, $$invalidate) {
	const omit_props_names = ["large","medium","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Block_title", slots, ['default']);
	let { large = false } = $$props;
	let { medium = false } = $$props;
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("large" in $$new_props) $$invalidate(2, large = $$new_props.large);
		if ("medium" in $$new_props) $$invalidate(3, medium = $$new_props.medium);
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		large,
		medium,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
		if ("large" in $$props) $$invalidate(2, large = $$new_props.large);
		if ("medium" in $$props) $$invalidate(3, medium = $$new_props.medium);
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(
			className,
			"block-title",
			{
				"block-title-large": large,
				"block-title-medium": medium
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, large, medium, className, $$scope, slots];
}

class Block_title extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$d, create_fragment$e, safe_not_equal, { large: 2, medium: 3, class: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Block_title",
			options,
			id: create_fragment$e.name
		});
	}

	get large() {
		throw new Error("<Block_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set large(value) {
		throw new Error("<Block_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get medium() {
		throw new Error("<Block_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set medium(value) {
		throw new Error("<Block_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Block_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Block_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/block.svelte generated by Svelte v3.31.0 */
const file$f = "node_modules/framework7-svelte/components/block.svelte";

function create_fragment$f(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
	let div_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$f, 81, 0, 2150);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[22](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[20], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[22](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"inset","xsmallInset","smallInset","mediumInset","largeInset","xlargeInset","strong","tabs","tab","tabActive","accordionList","accordionOpposite","noHairlines","noHairlinesMd","noHairlinesIos","noHairlinesAurora","class"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Block", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { inset = false } = $$props;
	let { xsmallInset = false } = $$props;
	let { smallInset = false } = $$props;
	let { mediumInset = false } = $$props;
	let { largeInset = false } = $$props;
	let { xlargeInset = false } = $$props;
	let { strong = false } = $$props;
	let { tabs = false } = $$props;
	let { tab = false } = $$props;
	let { tabActive = false } = $$props;
	let { accordionList = false } = $$props;
	let { accordionOpposite = false } = $$props;
	let { noHairlines = false } = $$props;
	let { noHairlinesMd = false } = $$props;
	let { noHairlinesIos = false } = $$props;
	let { noHairlinesAurora = false } = $$props;
	let { class: className = undefined } = $$props;
	let el;

	function onTabShow(tabEl) {
		if (el !== tabEl) return;
		dispatch("tabShow");
		if (typeof $$props.onTabShow === "function") $$props.onTabShow(tabEl);
	}

	function onTabHide(tabEl) {
		if (el !== tabEl) return;
		dispatch("tabHide");
		if (typeof $$props.onTabHide === "function") $$props.onTabHide(tabEl);
	}

	onMount(() => {
		f7.ready(() => {
			f7.instance.on("tabShow", onTabShow);
			f7.instance.on("tabHide", onTabHide);
		});
	});

	onDestroy(() => {
		if (f7.instance) {
			f7.instance.off("tabShow", onTabShow);
			f7.instance.off("tabHide", onTabHide);
		}
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(26, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("inset" in $$new_props) $$invalidate(3, inset = $$new_props.inset);
		if ("xsmallInset" in $$new_props) $$invalidate(4, xsmallInset = $$new_props.xsmallInset);
		if ("smallInset" in $$new_props) $$invalidate(5, smallInset = $$new_props.smallInset);
		if ("mediumInset" in $$new_props) $$invalidate(6, mediumInset = $$new_props.mediumInset);
		if ("largeInset" in $$new_props) $$invalidate(7, largeInset = $$new_props.largeInset);
		if ("xlargeInset" in $$new_props) $$invalidate(8, xlargeInset = $$new_props.xlargeInset);
		if ("strong" in $$new_props) $$invalidate(9, strong = $$new_props.strong);
		if ("tabs" in $$new_props) $$invalidate(10, tabs = $$new_props.tabs);
		if ("tab" in $$new_props) $$invalidate(11, tab = $$new_props.tab);
		if ("tabActive" in $$new_props) $$invalidate(12, tabActive = $$new_props.tabActive);
		if ("accordionList" in $$new_props) $$invalidate(13, accordionList = $$new_props.accordionList);
		if ("accordionOpposite" in $$new_props) $$invalidate(14, accordionOpposite = $$new_props.accordionOpposite);
		if ("noHairlines" in $$new_props) $$invalidate(15, noHairlines = $$new_props.noHairlines);
		if ("noHairlinesMd" in $$new_props) $$invalidate(16, noHairlinesMd = $$new_props.noHairlinesMd);
		if ("noHairlinesIos" in $$new_props) $$invalidate(17, noHairlinesIos = $$new_props.noHairlinesIos);
		if ("noHairlinesAurora" in $$new_props) $$invalidate(18, noHairlinesAurora = $$new_props.noHairlinesAurora);
		if ("class" in $$new_props) $$invalidate(19, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		createEventDispatcher,
		f7,
		Mixins,
		Utils,
		restProps,
		dispatch,
		inset,
		xsmallInset,
		smallInset,
		mediumInset,
		largeInset,
		xlargeInset,
		strong,
		tabs,
		tab,
		tabActive,
		accordionList,
		accordionOpposite,
		noHairlines,
		noHairlinesMd,
		noHairlinesIos,
		noHairlinesAurora,
		className,
		el,
		onTabShow,
		onTabHide,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(26, $$props = assign(assign({}, $$props), $$new_props));
		if ("inset" in $$props) $$invalidate(3, inset = $$new_props.inset);
		if ("xsmallInset" in $$props) $$invalidate(4, xsmallInset = $$new_props.xsmallInset);
		if ("smallInset" in $$props) $$invalidate(5, smallInset = $$new_props.smallInset);
		if ("mediumInset" in $$props) $$invalidate(6, mediumInset = $$new_props.mediumInset);
		if ("largeInset" in $$props) $$invalidate(7, largeInset = $$new_props.largeInset);
		if ("xlargeInset" in $$props) $$invalidate(8, xlargeInset = $$new_props.xlargeInset);
		if ("strong" in $$props) $$invalidate(9, strong = $$new_props.strong);
		if ("tabs" in $$props) $$invalidate(10, tabs = $$new_props.tabs);
		if ("tab" in $$props) $$invalidate(11, tab = $$new_props.tab);
		if ("tabActive" in $$props) $$invalidate(12, tabActive = $$new_props.tabActive);
		if ("accordionList" in $$props) $$invalidate(13, accordionList = $$new_props.accordionList);
		if ("accordionOpposite" in $$props) $$invalidate(14, accordionOpposite = $$new_props.accordionOpposite);
		if ("noHairlines" in $$props) $$invalidate(15, noHairlines = $$new_props.noHairlines);
		if ("noHairlinesMd" in $$props) $$invalidate(16, noHairlinesMd = $$new_props.noHairlinesMd);
		if ("noHairlinesIos" in $$props) $$invalidate(17, noHairlinesIos = $$new_props.noHairlinesIos);
		if ("noHairlinesAurora" in $$props) $$invalidate(18, noHairlinesAurora = $$new_props.noHairlinesAurora);
		if ("className" in $$props) $$invalidate(19, className = $$new_props.className);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classes = Utils.classNames(
			className,
			"block",
			{
				inset,
				"xsmall-inset": xsmallInset,
				"small-inset": smallInset,
				"medium-inset": mediumInset,
				"large-inset": largeInset,
				"xlarge-inset": xlargeInset,
				"block-strong": strong,
				"accordion-list": accordionList,
				"accordion-opposite": accordionOpposite,
				tabs,
				tab,
				"tab-active": tabActive,
				"no-hairlines": noHairlines,
				"no-hairlines-md": noHairlinesMd,
				"no-hairlines-ios": noHairlinesIos,
				"no-hairlines-aurora": noHairlinesAurora
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		classes,
		$$restProps,
		inset,
		xsmallInset,
		smallInset,
		mediumInset,
		largeInset,
		xlargeInset,
		strong,
		tabs,
		tab,
		tabActive,
		accordionList,
		accordionOpposite,
		noHairlines,
		noHairlinesMd,
		noHairlinesIos,
		noHairlinesAurora,
		className,
		$$scope,
		slots,
		div_binding
	];
}

class Block extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$e, create_fragment$f, safe_not_equal, {
			inset: 3,
			xsmallInset: 4,
			smallInset: 5,
			mediumInset: 6,
			largeInset: 7,
			xlargeInset: 8,
			strong: 9,
			tabs: 10,
			tab: 11,
			tabActive: 12,
			accordionList: 13,
			accordionOpposite: 14,
			noHairlines: 15,
			noHairlinesMd: 16,
			noHairlinesIos: 17,
			noHairlinesAurora: 18,
			class: 19
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Block",
			options,
			id: create_fragment$f.name
		});
	}

	get inset() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inset(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xsmallInset() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xsmallInset(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smallInset() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smallInset(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mediumInset() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mediumInset(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get largeInset() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set largeInset(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xlargeInset() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xlargeInset(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get strong() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set strong(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabs() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabs(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tab() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tab(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabActive() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabActive(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accordionList() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accordionList(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accordionOpposite() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accordionOpposite(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlines() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlines(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesMd() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesMd(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesIos() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesIos(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesAurora() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesAurora(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* eslint no-underscore-dangle: "off" */

let routerComponentIdCounter = 0;

var componentsRouter = {
  proto: {
    pageComponentLoader(routerEl, component, componentUrl, options, resolve, reject) {
      const router = this;
      const el = routerEl;
      let viewRouter;
      f7.routers.views.forEach((data) => {
        if (data.el && data.el === routerEl) {
          viewRouter = data;
        }
      });

      if (!viewRouter) {
        reject();
        return;
      }

      const id = `${Utils.now()}_${(routerComponentIdCounter += 1)}`;
      const pageData = {
        component,
        id,
        props: Utils.extend(
          {
            f7route: options.route,
            $f7route: options.route,
            f7router: router,
            $f7router: router,
          },
          options.route.params,
          options.props || {},
        ),
      };
      if (viewRouter.component) {
        viewRouter.component.$f7router = router;
        viewRouter.component.$f7route = options.route;
      }

      let resolved;
      function onDidUpdate(componentRouterData) {
        if (componentRouterData !== viewRouter || resolved) return;
        f7.events.off('viewRouterDidUpdate', onDidUpdate);

        const pageEl = el.children[el.children.length - 1];
        pageData.el = pageEl;

        resolve(pageEl);
        resolved = true;
      }

      f7.events.on('viewRouterDidUpdate', onDidUpdate);

      viewRouter.pages.push(pageData);
      viewRouter.setPages(viewRouter.pages);
    },
    removePage($pageEl) {
      if (!$pageEl) return;
      const router = this;
      let f7Page;
      if ('length' in $pageEl && $pageEl[0]) f7Page = $pageEl[0].f7Page;
      else f7Page = $pageEl.f7Page;
      if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
        router.app.$($pageEl).remove();
        return;
      }
      let viewRouter;
      f7.routers.views.forEach((data) => {
        if (data.el && data.el === router.el) {
          viewRouter = data;
        }
      });

      let pageEl;
      if ('length' in $pageEl) {
        // Dom7
        if ($pageEl.length === 0) return;
        pageEl = $pageEl[0];
      } else {
        pageEl = $pageEl;
      }
      if (!pageEl) return;

      let pageComponentFound;
      viewRouter.pages.forEach((page, index) => {
        if (page.el === pageEl) {
          pageComponentFound = true;
          viewRouter.pages.splice(index, 1);
          viewRouter.setPages(viewRouter.pages);
        }
      });
      if (!pageComponentFound) {
        pageEl.parentNode.removeChild(pageEl);
      }
    },
    tabComponentLoader(tabEl, component, componentUrl, options, resolve, reject) {
      const router = this;
      if (!tabEl) reject();

      let tabRouter;
      f7.routers.tabs.forEach((tabData) => {
        if (tabData.el && tabData.el === tabEl) {
          tabRouter = tabData;
        }
      });
      if (!tabRouter) {
        reject();
        return;
      }

      const id = `${Utils.now()}_${(routerComponentIdCounter += 1)}`;
      const tabContent = {
        id,
        component,
        props: Utils.extend(
          {
            f7route: options.route,
            $f7route: options.route,
            f7router: router,
            $f7router: router,
          },
          options.route.params,
          options.props || {},
        ),
      };

      if (tabRouter.component) {
        tabRouter.component.$f7router = router;
        tabRouter.component.$f7route = options.route;
      }

      let resolved;
      function onDidUpdate(componentRouterData) {
        if (componentRouterData !== tabRouter || resolved) return;
        f7.events.off('tabRouterDidUpdate', onDidUpdate);

        const tabContentEl = tabEl.children[0];
        resolve(tabContentEl);

        resolved = true;
      }

      f7.events.on('tabRouterDidUpdate', onDidUpdate);

      tabRouter.setTabContent(tabContent);
    },
    removeTabContent(tabEl) {
      if (!tabEl) return;

      let tabRouter;
      f7.routers.tabs.forEach((tabData) => {
        if (tabData.el && tabData.el === tabEl) {
          tabRouter = tabData;
        }
      });
      const hasComponent = tabRouter && tabRouter.component;
      if (!tabRouter || !hasComponent) {
        tabEl.innerHTML = ''; // eslint-disable-line
        return;
      }
      tabRouter.setTabContent(null);
    },
    modalComponentLoader(rootEl, component, componentUrl, options, resolve, reject) {
      const router = this;
      const modalsRouter = f7.routers.modals;

      if (!modalsRouter) {
        reject();
        return;
      }

      const id = `${Utils.now()}_${(routerComponentIdCounter += 1)}`;
      const modalData = {
        component,
        id,
        props: Utils.extend(
          {
            f7route: options.route,
            $f7route: options.route,
            f7router: router,
            $f7router: router,
          },
          options.route.params,
          options.props || {},
        ),
      };
      if (modalsRouter.component) {
        modalsRouter.component.$f7router = router;
        modalsRouter.component.$f7route = options.route;
      }

      let resolved;
      function onDidUpdate() {
        if (resolved) return;
        f7.events.off('modalsRouterDidUpdate', onDidUpdate);

        const modalEl = modalsRouter.el.children[modalsRouter.el.children.length - 1];
        modalData.el = modalEl;

        resolve(modalEl);
        resolved = true;
      }

      f7.events.on('modalsRouterDidUpdate', onDidUpdate);

      modalsRouter.modals.push(modalData);
      modalsRouter.setModals(modalsRouter.modals);
    },
    removeModal(modalEl) {
      const modalsRouter = f7.routers.modals;
      if (!modalsRouter) return;

      let modalDataToRemove;
      modalsRouter.modals.forEach((modalData) => {
        if (modalData.el === modalEl) modalDataToRemove = modalData;
      });

      modalsRouter.modals.splice(modalsRouter.modals.indexOf(modalDataToRemove), 1);
      modalsRouter.setModals(modalsRouter.modals);
    },
  },
};

/* eslint no-underscore-dangle: "off" */
function f7ready(callback) {
  f7.ready(callback);
}
const f7Theme = {};
const Plugin = {
  name: 'phenomePlugin',
  installed: false,
  install(params = {}) {
    if (Plugin.installed) return;
    Plugin.installed = true;
    const Framework7 = this;
    f7.Framework7 = Framework7;
    f7.events = new Framework7.Events();
    // eslint-disable-next-line
    
    const { theme } = params;
    if (theme === 'md') f7Theme.md = true;
    if (theme === 'ios') f7Theme.ios = true;
    if (theme === 'aurora') f7Theme.aurora = true;
    if (!theme || theme === 'auto') {
      f7Theme.ios = !!Framework7.device.ios;
      f7Theme.aurora = Framework7.device.desktop && Framework7.device.electron;
      f7Theme.md = !f7Theme.ios && !f7Theme.aurora;
    }
    f7.ready(() => {
      f7Theme.ios = f7.instance.theme === 'ios';
      f7Theme.md = f7.instance.theme === 'md';
      f7Theme.aurora = f7.instance.theme === 'aurora';
    });
    
    // Extend F7 Router
    Framework7.Router.use(componentsRouter);
  },
};

/* node_modules/framework7-svelte/components/icon.svelte generated by Svelte v3.31.0 */
const file$g = "node_modules/framework7-svelte/components/icon.svelte";

function create_fragment$g(ctx) {
	let i;
	let t0_value = (/*iconText*/ ctx[2] || "") + "";
	let t0;
	let t1;
	let current;
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

	let i_levels = [
		{ style: /*iconStyle*/ ctx[3] },
		{ class: /*iconClasses*/ ctx[1] },
		restProps(/*$$restProps*/ ctx[4])
	];

	let i_data = {};

	for (let i = 0; i < i_levels.length; i += 1) {
		i_data = assign(i_data, i_levels[i]);
	}

	const block = {
		c: function create() {
			i = element("i");
			t0 = text(t0_value);
			t1 = space();
			if (default_slot) default_slot.c();
			set_attributes(i, i_data);
			add_location(i, file$g, 135, 0, 3344);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, i, anchor);
			append_dev(i, t0);
			append_dev(i, t1);

			if (default_slot) {
				default_slot.m(i, null);
			}

			/*i_binding*/ ctx[22](i);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*iconText*/ 4) && t0_value !== (t0_value = (/*iconText*/ ctx[2] || "") + "")) set_data_dev(t0, t0_value);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[20], dirty, null, null);
				}
			}

			set_attributes(i, i_data = get_spread_update(i_levels, [
				(!current || dirty & /*iconStyle*/ 8) && { style: /*iconStyle*/ ctx[3] },
				(!current || dirty & /*iconClasses*/ 2) && { class: /*iconClasses*/ ctx[1] },
				dirty & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(i);
			if (default_slot) default_slot.d(detaching);
			/*i_binding*/ ctx[22](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"style","class","material","f7","icon","ios","aurora","md","tooltip","tooltipTrigger","size"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Icon", slots, ['default']);
	let { style = undefined } = $$props;
	let { class: className = undefined } = $$props;
	let { material = undefined } = $$props;
	let { f7: f7$1 = undefined } = $$props;
	let { icon = undefined } = $$props;
	let { ios = undefined } = $$props;
	let { aurora = undefined } = $$props;
	let { md = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let { size = undefined } = $$props;

	// eslint-disable-next-line
	let _theme = f7.instance ? f7Theme : null;

	let el;
	let f7Tooltip;
	let classes = { icon: true };

	if (!f7.instance) {
		f7.ready(() => {
			$$invalidate(16, _theme = f7Theme);
		});
	}

	let themeIcon;

	function iconTextComputed(t) {
		let textComputed = material || f7$1;

		if (md && t && t.md && (md.indexOf("material:") >= 0 || md.indexOf("f7:") >= 0)) {
			textComputed = md.split(":")[1];
		} else if (ios && t && t.ios && (ios.indexOf("material:") >= 0 || ios.indexOf("f7:") >= 0)) {
			textComputed = ios.split(":")[1];
		} else if (aurora && t && t.aurora && (aurora.indexOf("material:") >= 0 || aurora.indexOf("f7:") >= 0)) {
			textComputed = aurora.split(":")[1];
		}

		return textComputed;
	}

	let tooltipText = tooltip;

	function watchTooltip(newText) {
		const oldText = tooltipText;
		if (oldText === newText) return;
		tooltipText = newText;

		if (!newText && f7Tooltip) {
			f7Tooltip.destroy();
			f7Tooltip = null;
			return;
		}

		if (newText && !f7Tooltip && f7.instance) {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: newText,
				trigger: tooltipTrigger
			});

			return;
		}

		if (!newText || !f7Tooltip) return;
		f7Tooltip.setText(newText);
	}

	onMount(() => {
		if (!tooltip) return;

		f7.ready(() => {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: tooltip,
				trigger: tooltipTrigger
			});
		});
	});

	onDestroy(() => {
		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
			f7Tooltip = null;
		}
	});

	function i_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(27, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("style" in $$new_props) $$invalidate(5, style = $$new_props.style);
		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ("material" in $$new_props) $$invalidate(7, material = $$new_props.material);
		if ("f7" in $$new_props) $$invalidate(8, f7$1 = $$new_props.f7);
		if ("icon" in $$new_props) $$invalidate(9, icon = $$new_props.icon);
		if ("ios" in $$new_props) $$invalidate(10, ios = $$new_props.ios);
		if ("aurora" in $$new_props) $$invalidate(11, aurora = $$new_props.aurora);
		if ("md" in $$new_props) $$invalidate(12, md = $$new_props.md);
		if ("tooltip" in $$new_props) $$invalidate(13, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$new_props) $$invalidate(14, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("size" in $$new_props) $$invalidate(15, size = $$new_props.size);
		if ("$$scope" in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		theme: f7Theme,
		F7: f7,
		style,
		className,
		material,
		f7: f7$1,
		icon,
		ios,
		aurora,
		md,
		tooltip,
		tooltipTrigger,
		size,
		_theme,
		el,
		f7Tooltip,
		classes,
		themeIcon,
		iconTextComputed,
		tooltipText,
		watchTooltip,
		iconClasses,
		iconText,
		iconSize,
		iconStyle
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(27, $$props = assign(assign({}, $$props), $$new_props));
		if ("style" in $$props) $$invalidate(5, style = $$new_props.style);
		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
		if ("material" in $$props) $$invalidate(7, material = $$new_props.material);
		if ("f7" in $$props) $$invalidate(8, f7$1 = $$new_props.f7);
		if ("icon" in $$props) $$invalidate(9, icon = $$new_props.icon);
		if ("ios" in $$props) $$invalidate(10, ios = $$new_props.ios);
		if ("aurora" in $$props) $$invalidate(11, aurora = $$new_props.aurora);
		if ("md" in $$props) $$invalidate(12, md = $$new_props.md);
		if ("tooltip" in $$props) $$invalidate(13, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$props) $$invalidate(14, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("size" in $$props) $$invalidate(15, size = $$new_props.size);
		if ("_theme" in $$props) $$invalidate(16, _theme = $$new_props._theme);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
		if ("classes" in $$props) $$invalidate(17, classes = $$new_props.classes);
		if ("themeIcon" in $$props) $$invalidate(18, themeIcon = $$new_props.themeIcon);
		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
		if ("iconClasses" in $$props) $$invalidate(1, iconClasses = $$new_props.iconClasses);
		if ("iconText" in $$props) $$invalidate(2, iconText = $$new_props.iconText);
		if ("iconSize" in $$props) $$invalidate(19, iconSize = $$new_props.iconSize);
		if ("iconStyle" in $$props) $$invalidate(3, iconStyle = $$new_props.iconStyle);
	};

	let iconClasses;
	let iconText;
	let iconSize;
	let iconStyle;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*_theme, ios, md, aurora*/ 72704) {
			 if (_theme) {
				if (_theme.ios) $$invalidate(18, themeIcon = ios);
				if (_theme.md) $$invalidate(18, themeIcon = md);
				if (_theme.aurora) $$invalidate(18, themeIcon = aurora);
			}
		}

		if ($$self.$$.dirty & /*themeIcon, material, f7, icon*/ 263040) {
			 if (themeIcon) {
				const parts = themeIcon.split(":");
				const prop = parts[0];
				const value = parts[1];

				if (prop === "material" || prop === "f7") {
					$$invalidate(17, classes["material-icons"] = prop === "material", classes);
					$$invalidate(17, classes["f7-icons"] = prop === "f7", classes);
				}

				if (prop === "icon") {
					$$invalidate(17, classes[value] = true, classes);
				}
			} else {
				$$invalidate(17, classes = {
					icon: true,
					"material-icons": material,
					"f7-icons": f7$1
				});

				if (icon) $$invalidate(17, classes[icon] = true, classes);
			}
		}

		 $$invalidate(1, iconClasses = Utils.classNames(className, classes, Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*_theme*/ 65536) {
			 $$invalidate(2, iconText = iconTextComputed(_theme));
		}

		if ($$self.$$.dirty & /*size*/ 32768) {
			 $$invalidate(19, iconSize = typeof size === "number" || parseFloat(size) === size * 1
			? `${size}px`
			: size);
		}

		if ($$self.$$.dirty & /*style, iconSize*/ 524320) {
			 $$invalidate(3, iconStyle = (style || "") + (iconSize
			? `;font-size: ${iconSize}; width: ${iconSize}; height: ${iconSize}`.replace(";;", "")
			: ""));
		}

		if ($$self.$$.dirty & /*tooltip*/ 8192) {
			 watchTooltip(tooltip);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		iconClasses,
		iconText,
		iconStyle,
		$$restProps,
		style,
		className,
		material,
		f7$1,
		icon,
		ios,
		aurora,
		md,
		tooltip,
		tooltipTrigger,
		size,
		_theme,
		classes,
		themeIcon,
		iconSize,
		$$scope,
		slots,
		i_binding
	];
}

class Icon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$f, create_fragment$g, safe_not_equal, {
			style: 5,
			class: 6,
			material: 7,
			f7: 8,
			icon: 9,
			ios: 10,
			aurora: 11,
			md: 12,
			tooltip: 13,
			tooltipTrigger: 14,
			size: 15
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Icon",
			options,
			id: create_fragment$g.name
		});
	}

	get style() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get material() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set material(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get f7() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set f7(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get icon() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set icon(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ios() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ios(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get aurora() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set aurora(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get md() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set md(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltip() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltip(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltipTrigger() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltipTrigger(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/button.svelte generated by Svelte v3.31.0 */
const file$h = "node_modules/framework7-svelte/components/button.svelte";

// (191:0) {:else}
function create_else_block$1(ctx) {
	let a;
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*hasIcon*/ ctx[5] && create_if_block_4(ctx);
	let if_block1 = typeof /*text*/ ctx[0] !== "undefined" && create_if_block_3(ctx);
	const default_slot_template = /*#slots*/ ctx[44].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);
	let a_levels = [{ class: /*classes*/ ctx[3] }, /*attrs*/ ctx[2]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			add_location(a, file$h, 191, 2, 5104);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			if (if_block0) if_block0.m(a, null);
			append_dev(a, t0);
			if (if_block1) if_block1.m(a, null);
			append_dev(a, t1);

			if (default_slot) {
				default_slot.m(a, null);
			}

			/*a_binding*/ ctx[46](a);
			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*hasIcon*/ ctx[5]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*hasIcon*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(a, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (typeof /*text*/ ctx[0] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					if_block1.m(a, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 4096) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[43], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty[0] & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				dirty[0] & /*attrs*/ 4 && /*attrs*/ ctx[2]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			/*a_binding*/ ctx[46](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(191:0) {:else}",
		ctx
	});

	return block;
}

// (167:0) {#if tagName === 'button'}
function create_if_block$2(ctx) {
	let button;
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*hasIcon*/ ctx[5] && create_if_block_2(ctx);
	let if_block1 = typeof /*text*/ ctx[0] !== "undefined" && create_if_block_1(ctx);
	const default_slot_template = /*#slots*/ ctx[44].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[43], null);
	let button_levels = [{ class: /*classes*/ ctx[3] }, /*attrs*/ ctx[2]];
	let button_data = {};

	for (let i = 0; i < button_levels.length; i += 1) {
		button_data = assign(button_data, button_levels[i]);
	}

	const block = {
		c: function create() {
			button = element("button");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			set_attributes(button, button_data);
			add_location(button, file$h, 167, 2, 4589);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			if (if_block0) if_block0.m(button, null);
			append_dev(button, t0);
			if (if_block1) if_block1.m(button, null);
			append_dev(button, t1);

			if (default_slot) {
				default_slot.m(button, null);
			}

			/*button_binding*/ ctx[45](button);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*onClick*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*hasIcon*/ ctx[5]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*hasIcon*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(button, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (typeof /*text*/ ctx[0] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					if_block1.m(button, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 4096) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[43], dirty, null, null);
				}
			}

			set_attributes(button, button_data = get_spread_update(button_levels, [
				(!current || dirty[0] & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				dirty[0] & /*attrs*/ 4 && /*attrs*/ ctx[2]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			/*button_binding*/ ctx[45](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(167:0) {#if tagName === 'button'}",
		ctx
	});

	return block;
}

// (198:4) {#if hasIcon}
function create_if_block_4(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				material: /*$$props*/ ctx[7].iconMaterial,
				f7: /*$$props*/ ctx[7].iconF7,
				icon: /*$$props*/ ctx[7].icon,
				md: /*$$props*/ ctx[7].iconMd,
				ios: /*$$props*/ ctx[7].iconIos,
				aurora: /*$$props*/ ctx[7].iconAurora,
				color: /*$$props*/ ctx[7].iconColor,
				size: /*$$props*/ ctx[7].iconSize
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty[0] & /*$$props*/ 128) icon_changes.material = /*$$props*/ ctx[7].iconMaterial;
			if (dirty[0] & /*$$props*/ 128) icon_changes.f7 = /*$$props*/ ctx[7].iconF7;
			if (dirty[0] & /*$$props*/ 128) icon_changes.icon = /*$$props*/ ctx[7].icon;
			if (dirty[0] & /*$$props*/ 128) icon_changes.md = /*$$props*/ ctx[7].iconMd;
			if (dirty[0] & /*$$props*/ 128) icon_changes.ios = /*$$props*/ ctx[7].iconIos;
			if (dirty[0] & /*$$props*/ 128) icon_changes.aurora = /*$$props*/ ctx[7].iconAurora;
			if (dirty[0] & /*$$props*/ 128) icon_changes.color = /*$$props*/ ctx[7].iconColor;
			if (dirty[0] & /*$$props*/ 128) icon_changes.size = /*$$props*/ ctx[7].iconSize;
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(198:4) {#if hasIcon}",
		ctx
	});

	return block;
}

// (210:4) {#if typeof text !== 'undefined'}
function create_if_block_3(ctx) {
	let span;
	let t_value = Utils.text(/*text*/ ctx[0]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file$h, 210, 6, 5537);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*text*/ 1 && t_value !== (t_value = Utils.text(/*text*/ ctx[0]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(210:4) {#if typeof text !== 'undefined'}",
		ctx
	});

	return block;
}

// (174:4) {#if hasIcon}
function create_if_block_2(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				material: /*$$props*/ ctx[7].iconMaterial,
				f7: /*$$props*/ ctx[7].iconF7,
				icon: /*$$props*/ ctx[7].icon,
				md: /*$$props*/ ctx[7].iconMd,
				ios: /*$$props*/ ctx[7].iconIos,
				aurora: /*$$props*/ ctx[7].iconAurora,
				color: /*$$props*/ ctx[7].iconColor,
				size: /*$$props*/ ctx[7].iconSize
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty[0] & /*$$props*/ 128) icon_changes.material = /*$$props*/ ctx[7].iconMaterial;
			if (dirty[0] & /*$$props*/ 128) icon_changes.f7 = /*$$props*/ ctx[7].iconF7;
			if (dirty[0] & /*$$props*/ 128) icon_changes.icon = /*$$props*/ ctx[7].icon;
			if (dirty[0] & /*$$props*/ 128) icon_changes.md = /*$$props*/ ctx[7].iconMd;
			if (dirty[0] & /*$$props*/ 128) icon_changes.ios = /*$$props*/ ctx[7].iconIos;
			if (dirty[0] & /*$$props*/ 128) icon_changes.aurora = /*$$props*/ ctx[7].iconAurora;
			if (dirty[0] & /*$$props*/ 128) icon_changes.color = /*$$props*/ ctx[7].iconColor;
			if (dirty[0] & /*$$props*/ 128) icon_changes.size = /*$$props*/ ctx[7].iconSize;
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(174:4) {#if hasIcon}",
		ctx
	});

	return block;
}

// (186:4) {#if typeof text !== 'undefined'}
function create_if_block_1(ctx) {
	let span;
	let t_value = Utils.text(/*text*/ ctx[0]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file$h, 186, 6, 5027);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*text*/ 1 && t_value !== (t_value = Utils.text(/*text*/ ctx[0]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(186:4) {#if typeof text !== 'undefined'}",
		ctx
	});

	return block;
}

function create_fragment$h(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$2, create_else_block$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tagName*/ ctx[4] === "button") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$g($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","text","tabLink","tabLinkActive","type","href","target","round","roundMd","roundIos","roundAurora","fill","fillMd","fillIos","fillAurora","large","largeMd","largeIos","largeAurora","small","smallMd","smallIos","smallAurora","raised","raisedMd","raisedIos","raisedAurora","outline","outlineMd","outlineIos","outlineAurora","active","disabled","tooltip","tooltipTrigger"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Button", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { text = undefined } = $$props;
	let { tabLink = undefined } = $$props;
	let { tabLinkActive = false } = $$props;
	let { type = undefined } = $$props;
	let { href = "#" } = $$props;
	let { target = undefined } = $$props;
	let { round = false } = $$props;
	let { roundMd = false } = $$props;
	let { roundIos = false } = $$props;
	let { roundAurora = false } = $$props;
	let { fill = false } = $$props;
	let { fillMd = false } = $$props;
	let { fillIos = false } = $$props;
	let { fillAurora = false } = $$props;
	let { large = false } = $$props;
	let { largeMd = false } = $$props;
	let { largeIos = false } = $$props;
	let { largeAurora = false } = $$props;
	let { small = false } = $$props;
	let { smallMd = false } = $$props;
	let { smallIos = false } = $$props;
	let { smallAurora = false } = $$props;
	let { raised = false } = $$props;
	let { raisedMd = false } = $$props;
	let { raisedIos = false } = $$props;
	let { raisedAurora = false } = $$props;
	let { outline = false } = $$props;
	let { outlineMd = false } = $$props;
	let { outlineIos = false } = $$props;
	let { outlineAurora = false } = $$props;
	let { active = false } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let el;
	let f7Tooltip;
	let tooltipText = tooltip;

	function watchTooltip(newText) {
		const oldText = tooltipText;
		if (oldText === newText) return;
		tooltipText = newText;

		if (!newText && f7Tooltip) {
			f7Tooltip.destroy();
			f7Tooltip = null;
			return;
		}

		if (newText && !f7Tooltip && f7.instance) {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: newText,
				trigger: tooltipTrigger
			});

			return;
		}

		if (!newText || !f7Tooltip) return;
		f7Tooltip.setText(newText);
	}

	function onClick() {
		dispatch("click");
		if (typeof $$props.onClick === "function") $$props.onClick();
	}

	onMount(() => {
		if ($$props.routeProps) {
			$$invalidate(1, el.f7RouteProps = $$props.routeProps, el);
		}

		if (!tooltip) return;

		f7.ready(() => {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: tooltip,
				trigger: tooltipTrigger
			});
		});
	});

	afterUpdate(() => {
		if ($$props.routeProps) {
			$$invalidate(1, el.f7RouteProps = $$props.routeProps, el);
		}
	});

	onDestroy(() => {
		if (el) delete el.f7RouteProps;

		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
			f7Tooltip = null;
		}
	});

	function button_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	function a_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(51, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ("text" in $$new_props) $$invalidate(0, text = $$new_props.text);
		if ("tabLink" in $$new_props) $$invalidate(9, tabLink = $$new_props.tabLink);
		if ("tabLinkActive" in $$new_props) $$invalidate(10, tabLinkActive = $$new_props.tabLinkActive);
		if ("type" in $$new_props) $$invalidate(11, type = $$new_props.type);
		if ("href" in $$new_props) $$invalidate(12, href = $$new_props.href);
		if ("target" in $$new_props) $$invalidate(13, target = $$new_props.target);
		if ("round" in $$new_props) $$invalidate(14, round = $$new_props.round);
		if ("roundMd" in $$new_props) $$invalidate(15, roundMd = $$new_props.roundMd);
		if ("roundIos" in $$new_props) $$invalidate(16, roundIos = $$new_props.roundIos);
		if ("roundAurora" in $$new_props) $$invalidate(17, roundAurora = $$new_props.roundAurora);
		if ("fill" in $$new_props) $$invalidate(18, fill = $$new_props.fill);
		if ("fillMd" in $$new_props) $$invalidate(19, fillMd = $$new_props.fillMd);
		if ("fillIos" in $$new_props) $$invalidate(20, fillIos = $$new_props.fillIos);
		if ("fillAurora" in $$new_props) $$invalidate(21, fillAurora = $$new_props.fillAurora);
		if ("large" in $$new_props) $$invalidate(22, large = $$new_props.large);
		if ("largeMd" in $$new_props) $$invalidate(23, largeMd = $$new_props.largeMd);
		if ("largeIos" in $$new_props) $$invalidate(24, largeIos = $$new_props.largeIos);
		if ("largeAurora" in $$new_props) $$invalidate(25, largeAurora = $$new_props.largeAurora);
		if ("small" in $$new_props) $$invalidate(26, small = $$new_props.small);
		if ("smallMd" in $$new_props) $$invalidate(27, smallMd = $$new_props.smallMd);
		if ("smallIos" in $$new_props) $$invalidate(28, smallIos = $$new_props.smallIos);
		if ("smallAurora" in $$new_props) $$invalidate(29, smallAurora = $$new_props.smallAurora);
		if ("raised" in $$new_props) $$invalidate(30, raised = $$new_props.raised);
		if ("raisedMd" in $$new_props) $$invalidate(31, raisedMd = $$new_props.raisedMd);
		if ("raisedIos" in $$new_props) $$invalidate(32, raisedIos = $$new_props.raisedIos);
		if ("raisedAurora" in $$new_props) $$invalidate(33, raisedAurora = $$new_props.raisedAurora);
		if ("outline" in $$new_props) $$invalidate(34, outline = $$new_props.outline);
		if ("outlineMd" in $$new_props) $$invalidate(35, outlineMd = $$new_props.outlineMd);
		if ("outlineIos" in $$new_props) $$invalidate(36, outlineIos = $$new_props.outlineIos);
		if ("outlineAurora" in $$new_props) $$invalidate(37, outlineAurora = $$new_props.outlineAurora);
		if ("active" in $$new_props) $$invalidate(38, active = $$new_props.active);
		if ("disabled" in $$new_props) $$invalidate(39, disabled = $$new_props.disabled);
		if ("tooltip" in $$new_props) $$invalidate(40, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$new_props) $$invalidate(41, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("$$scope" in $$new_props) $$invalidate(43, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		afterUpdate,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		Icon,
		dispatch,
		className,
		text,
		tabLink,
		tabLinkActive,
		type,
		href,
		target,
		round,
		roundMd,
		roundIos,
		roundAurora,
		fill,
		fillMd,
		fillIos,
		fillAurora,
		large,
		largeMd,
		largeIos,
		largeAurora,
		small,
		smallMd,
		smallIos,
		smallAurora,
		raised,
		raisedMd,
		raisedIos,
		raisedAurora,
		outline,
		outlineMd,
		outlineIos,
		outlineAurora,
		active,
		disabled,
		tooltip,
		tooltipTrigger,
		el,
		f7Tooltip,
		tooltipText,
		watchTooltip,
		onClick,
		hrefComputed,
		attrs,
		classes,
		tagName,
		hasIcon
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(8, className = $$new_props.className);
		if ("text" in $$props) $$invalidate(0, text = $$new_props.text);
		if ("tabLink" in $$props) $$invalidate(9, tabLink = $$new_props.tabLink);
		if ("tabLinkActive" in $$props) $$invalidate(10, tabLinkActive = $$new_props.tabLinkActive);
		if ("type" in $$props) $$invalidate(11, type = $$new_props.type);
		if ("href" in $$props) $$invalidate(12, href = $$new_props.href);
		if ("target" in $$props) $$invalidate(13, target = $$new_props.target);
		if ("round" in $$props) $$invalidate(14, round = $$new_props.round);
		if ("roundMd" in $$props) $$invalidate(15, roundMd = $$new_props.roundMd);
		if ("roundIos" in $$props) $$invalidate(16, roundIos = $$new_props.roundIos);
		if ("roundAurora" in $$props) $$invalidate(17, roundAurora = $$new_props.roundAurora);
		if ("fill" in $$props) $$invalidate(18, fill = $$new_props.fill);
		if ("fillMd" in $$props) $$invalidate(19, fillMd = $$new_props.fillMd);
		if ("fillIos" in $$props) $$invalidate(20, fillIos = $$new_props.fillIos);
		if ("fillAurora" in $$props) $$invalidate(21, fillAurora = $$new_props.fillAurora);
		if ("large" in $$props) $$invalidate(22, large = $$new_props.large);
		if ("largeMd" in $$props) $$invalidate(23, largeMd = $$new_props.largeMd);
		if ("largeIos" in $$props) $$invalidate(24, largeIos = $$new_props.largeIos);
		if ("largeAurora" in $$props) $$invalidate(25, largeAurora = $$new_props.largeAurora);
		if ("small" in $$props) $$invalidate(26, small = $$new_props.small);
		if ("smallMd" in $$props) $$invalidate(27, smallMd = $$new_props.smallMd);
		if ("smallIos" in $$props) $$invalidate(28, smallIos = $$new_props.smallIos);
		if ("smallAurora" in $$props) $$invalidate(29, smallAurora = $$new_props.smallAurora);
		if ("raised" in $$props) $$invalidate(30, raised = $$new_props.raised);
		if ("raisedMd" in $$props) $$invalidate(31, raisedMd = $$new_props.raisedMd);
		if ("raisedIos" in $$props) $$invalidate(32, raisedIos = $$new_props.raisedIos);
		if ("raisedAurora" in $$props) $$invalidate(33, raisedAurora = $$new_props.raisedAurora);
		if ("outline" in $$props) $$invalidate(34, outline = $$new_props.outline);
		if ("outlineMd" in $$props) $$invalidate(35, outlineMd = $$new_props.outlineMd);
		if ("outlineIos" in $$props) $$invalidate(36, outlineIos = $$new_props.outlineIos);
		if ("outlineAurora" in $$props) $$invalidate(37, outlineAurora = $$new_props.outlineAurora);
		if ("active" in $$props) $$invalidate(38, active = $$new_props.active);
		if ("disabled" in $$props) $$invalidate(39, disabled = $$new_props.disabled);
		if ("tooltip" in $$props) $$invalidate(40, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$props) $$invalidate(41, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("el" in $$props) $$invalidate(1, el = $$new_props.el);
		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
		if ("hrefComputed" in $$props) $$invalidate(42, hrefComputed = $$new_props.hrefComputed);
		if ("attrs" in $$props) $$invalidate(2, attrs = $$new_props.attrs);
		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
		if ("tagName" in $$props) $$invalidate(4, tagName = $$new_props.tagName);
		if ("hasIcon" in $$props) $$invalidate(5, hasIcon = $$new_props.hasIcon);
	};

	let hrefComputed;
	let attrs;
	let classes;
	let tagName;
	let hasIcon;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*href*/ 4096) {
			 $$invalidate(42, hrefComputed = href === true ? "#" : href || undefined);
		}

		 $$invalidate(2, attrs = Utils.extend(
			{
				href: hrefComputed,
				target,
				type,
				"data-tab": Utils.isStringProp(tabLink) && tabLink || undefined,
				...restProps($$restProps)
			},
			Mixins.linkRouterAttrs($$props),
			Mixins.linkActionsAttrs($$props)
		));

		 $$invalidate(3, classes = Utils.classNames(
			className,
			"button",
			{
				"tab-link": tabLink || tabLink === "",
				"tab-link-active": tabLinkActive,
				"button-round": round,
				"button-round-ios": roundIos,
				"button-round-aurora": roundAurora,
				"button-round-md": roundMd,
				"button-fill": fill,
				"button-fill-ios": fillIos,
				"button-fill-aurora": fillAurora,
				"button-fill-md": fillMd,
				"button-large": large,
				"button-large-ios": largeIos,
				"button-large-aurora": largeAurora,
				"button-large-md": largeMd,
				"button-small": small,
				"button-small-ios": smallIos,
				"button-small-aurora": smallAurora,
				"button-small-md": smallMd,
				"button-raised": raised,
				"button-raised-ios": raisedIos,
				"button-raised-aurora": raisedAurora,
				"button-raised-md": raisedMd,
				"button-active": active,
				"button-outline": outline,
				"button-outline-ios": outlineIos,
				"button-outline-aurora": outlineAurora,
				"button-outline-md": outlineMd,
				disabled
			},
			Mixins.colorClasses($$props),
			Mixins.linkRouterClasses($$props),
			Mixins.linkActionsClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*type*/ 2048) {
			 $$invalidate(4, tagName = type === "submit" || type === "reset" || type === "button"
			? "button"
			: "a");
		}

		 $$invalidate(5, hasIcon = $$props.icon || $$props.iconMaterial || $$props.iconF7 || $$props.iconMd || $$props.iconIos || $$props.iconAurora);

		if ($$self.$$.dirty[1] & /*tooltip*/ 512) {
			 watchTooltip(tooltip);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		text,
		el,
		attrs,
		classes,
		tagName,
		hasIcon,
		onClick,
		$$props,
		className,
		tabLink,
		tabLinkActive,
		type,
		href,
		target,
		round,
		roundMd,
		roundIos,
		roundAurora,
		fill,
		fillMd,
		fillIos,
		fillAurora,
		large,
		largeMd,
		largeIos,
		largeAurora,
		small,
		smallMd,
		smallIos,
		smallAurora,
		raised,
		raisedMd,
		raisedIos,
		raisedAurora,
		outline,
		outlineMd,
		outlineIos,
		outlineAurora,
		active,
		disabled,
		tooltip,
		tooltipTrigger,
		hrefComputed,
		$$scope,
		slots,
		button_binding,
		a_binding
	];
}

class Button extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$g,
			create_fragment$h,
			safe_not_equal,
			{
				class: 8,
				text: 0,
				tabLink: 9,
				tabLinkActive: 10,
				type: 11,
				href: 12,
				target: 13,
				round: 14,
				roundMd: 15,
				roundIos: 16,
				roundAurora: 17,
				fill: 18,
				fillMd: 19,
				fillIos: 20,
				fillAurora: 21,
				large: 22,
				largeMd: 23,
				largeIos: 24,
				largeAurora: 25,
				small: 26,
				smallMd: 27,
				smallIos: 28,
				smallAurora: 29,
				raised: 30,
				raisedMd: 31,
				raisedIos: 32,
				raisedAurora: 33,
				outline: 34,
				outlineMd: 35,
				outlineIos: 36,
				outlineAurora: 37,
				active: 38,
				disabled: 39,
				tooltip: 40,
				tooltipTrigger: 41
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Button",
			options,
			id: create_fragment$h.name
		});
	}

	get class() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabLink() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabLink(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabLinkActive() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabLinkActive(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get target() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set target(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get round() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set round(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get roundMd() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set roundMd(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get roundIos() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set roundIos(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get roundAurora() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set roundAurora(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fillMd() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fillMd(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fillIos() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fillIos(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fillAurora() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fillAurora(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get large() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set large(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get largeMd() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set largeMd(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get largeIos() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set largeIos(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get largeAurora() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set largeAurora(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get small() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set small(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smallMd() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smallMd(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smallIos() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smallIos(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smallAurora() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smallAurora(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raised() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raised(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raisedMd() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raisedMd(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raisedIos() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raisedIos(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raisedAurora() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raisedAurora(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outline() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outline(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outlineMd() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outlineMd(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outlineIos() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outlineIos(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outlineAurora() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outlineAurora(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltip() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltip(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltipTrigger() {
		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltipTrigger(value) {
		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/card-content.svelte generated by Svelte v3.31.0 */
const file$i = "node_modules/framework7-svelte/components/card-content.svelte";

function create_fragment$i(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$i, 21, 0, 399);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$h($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","padding"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Card_content", slots, ['default']);
	let { class: className = undefined } = $$props;
	let { padding = true } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("padding" in $$new_props) $$invalidate(3, padding = $$new_props.padding);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		padding,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("padding" in $$props) $$invalidate(3, padding = $$new_props.padding);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "card-content", { "card-content-padding": padding }, Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, padding, $$scope, slots];
}

class Card_content extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$h, create_fragment$i, safe_not_equal, { class: 2, padding: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Card_content",
			options,
			id: create_fragment$i.name
		});
	}

	get class() {
		throw new Error("<Card_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Card_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get padding() {
		throw new Error("<Card_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set padding(value) {
		throw new Error("<Card_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/card-footer.svelte generated by Svelte v3.31.0 */
const file$j = "node_modules/framework7-svelte/components/card-footer.svelte";

function create_fragment$j(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$j, 16, 0, 316);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$i($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Card_footer", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "card-footer", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class Card_footer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$i, create_fragment$j, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Card_footer",
			options,
			id: create_fragment$j.name
		});
	}

	get class() {
		throw new Error("<Card_footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Card_footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/card-header.svelte generated by Svelte v3.31.0 */
const file$k = "node_modules/framework7-svelte/components/card-header.svelte";

function create_fragment$k(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$k, 16, 0, 316);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$j($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Card_header", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "card-header", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class Card_header extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$j, create_fragment$k, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Card_header",
			options,
			id: create_fragment$k.name
		});
	}

	get class() {
		throw new Error("<Card_header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Card_header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/card.svelte generated by Svelte v3.31.0 */
const file$l = "node_modules/framework7-svelte/components/card.svelte";
const get_footer_slot_changes = dirty => ({});
const get_footer_slot_context = ctx => ({});
const get_content_slot_changes = dirty => ({});
const get_content_slot_context = ctx => ({});
const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});

// (148:2) {#if typeof title !== 'undefined' || hasHeaderSlots}
function create_if_block_2$1(ctx) {
	let cardheader;
	let current;

	cardheader = new Card_header({
			props: {
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cardheader.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(cardheader, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cardheader_changes = {};

			if (dirty[0] & /*$$scope, title*/ 268435457) {
				cardheader_changes.$$scope = { dirty, ctx };
			}

			cardheader.$set(cardheader_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cardheader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cardheader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cardheader, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(148:2) {#if typeof title !== 'undefined' || hasHeaderSlots}",
		ctx
	});

	return block;
}

// (149:4) <CardHeader>
function create_default_slot_2(ctx) {
	let t0_value = Utils.text(/*title*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[26].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[28], get_header_slot_context);

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);

			if (header_slot) {
				header_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = Utils.text(/*title*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[0] & /*$$scope*/ 268435456) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[28], dirty, get_header_slot_changes, get_header_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(149:4) <CardHeader>",
		ctx
	});

	return block;
}

// (154:2) {#if typeof content !== 'undefined' || hasContentSlots}
function create_if_block_1$1(ctx) {
	let cardcontent;
	let current;

	cardcontent = new Card_content({
			props: {
				padding: /*padding*/ ctx[12],
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cardcontent.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(cardcontent, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cardcontent_changes = {};
			if (dirty[0] & /*padding*/ 4096) cardcontent_changes.padding = /*padding*/ ctx[12];

			if (dirty[0] & /*$$scope, content*/ 268435458) {
				cardcontent_changes.$$scope = { dirty, ctx };
			}

			cardcontent.$set(cardcontent_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cardcontent.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cardcontent.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cardcontent, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(154:2) {#if typeof content !== 'undefined' || hasContentSlots}",
		ctx
	});

	return block;
}

// (155:4) <CardContent padding={padding}>
function create_default_slot_1(ctx) {
	let t0_value = Utils.text(/*content*/ ctx[1]) + "";
	let t0;
	let t1;
	let current;
	const content_slot_template = /*#slots*/ ctx[26].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[28], get_content_slot_context);

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = space();
			if (content_slot) content_slot.c();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);

			if (content_slot) {
				content_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*content*/ 2) && t0_value !== (t0_value = Utils.text(/*content*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

			if (content_slot) {
				if (content_slot.p && dirty[0] & /*$$scope*/ 268435456) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[28], dirty, get_content_slot_changes, get_content_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
			if (content_slot) content_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(155:4) <CardContent padding={padding}>",
		ctx
	});

	return block;
}

// (160:2) {#if typeof footer !== 'undefined' || hasFooterSlots}
function create_if_block$3(ctx) {
	let cardfooter;
	let current;

	cardfooter = new Card_footer({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(cardfooter.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(cardfooter, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const cardfooter_changes = {};

			if (dirty[0] & /*$$scope, footer*/ 268435460) {
				cardfooter_changes.$$scope = { dirty, ctx };
			}

			cardfooter.$set(cardfooter_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(cardfooter.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(cardfooter.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(cardfooter, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(160:2) {#if typeof footer !== 'undefined' || hasFooterSlots}",
		ctx
	});

	return block;
}

// (161:4) <CardFooter>
function create_default_slot(ctx) {
	let t0_value = Utils.text(/*footer*/ ctx[2]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[26].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[28], get_footer_slot_context);

	const block = {
		c: function create() {
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
		},
		m: function mount(target, anchor) {
			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);

			if (footer_slot) {
				footer_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 4) && t0_value !== (t0_value = Utils.text(/*footer*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[0] & /*$$scope*/ 268435456) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[28], dirty, get_footer_slot_changes, get_footer_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(161:4) <CardFooter>",
		ctx
	});

	return block;
}

function create_fragment$l(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let div_data_animate_value;
	let div_data_hide_navbar_on_open_value;
	let div_data_hide_toolbar_on_open_value;
	let div_data_hide_statusbar_on_open_value;
	let div_data_swipe_to_close_value;
	let div_data_close_by_backdrop_click_value;
	let div_data_backdrop_value;
	let current;
	let if_block0 = (typeof /*title*/ ctx[0] !== "undefined" || /*hasHeaderSlots*/ ctx[15]) && create_if_block_2$1(ctx);
	let if_block1 = (typeof /*content*/ ctx[1] !== "undefined" || /*hasContentSlots*/ ctx[16]) && create_if_block_1$1(ctx);
	let if_block2 = (typeof /*footer*/ ctx[2] !== "undefined" || /*hasFooterSlots*/ ctx[17]) && create_if_block$3(ctx);
	const default_slot_template = /*#slots*/ ctx[26].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[28], null);

	let div_levels = [
		{ class: /*classes*/ ctx[14] },
		{
			"data-animate": div_data_animate_value = typeof /*animate*/ ctx[3] === "undefined"
			? /*animate*/ ctx[3]
			: /*animate*/ ctx[3].toString()
		},
		{
			"data-hide-navbar-on-open": div_data_hide_navbar_on_open_value = typeof /*hideNavbarOnOpen*/ ctx[4] === "undefined"
			? /*hideNavbarOnOpen*/ ctx[4]
			: /*hideNavbarOnOpen*/ ctx[4].toString()
		},
		{
			"data-hide-toolbar-on-open": div_data_hide_toolbar_on_open_value = typeof /*hideToolbarOnOpen*/ ctx[5] === "undefined"
			? /*hideToolbarOnOpen*/ ctx[5]
			: /*hideToolbarOnOpen*/ ctx[5].toString()
		},
		{
			"data-hide-statusbar-on-open": div_data_hide_statusbar_on_open_value = typeof /*hideStatusbarOnOpen*/ ctx[6] === "undefined"
			? /*hideStatusbarOnOpen*/ ctx[6]
			: /*hideStatusbarOnOpen*/ ctx[6].toString()
		},
		{
			"data-scrollable-el": /*scrollableEl*/ ctx[7]
		},
		{
			"data-swipe-to-close": div_data_swipe_to_close_value = typeof /*swipeToClose*/ ctx[8] === "undefined"
			? /*swipeToClose*/ ctx[8]
			: /*swipeToClose*/ ctx[8].toString()
		},
		{
			"data-close-by-backdrop-click": div_data_close_by_backdrop_click_value = typeof /*closeByBackdropClick*/ ctx[9] === "undefined"
			? /*closeByBackdropClick*/ ctx[9]
			: /*closeByBackdropClick*/ ctx[9].toString()
		},
		{
			"data-backdrop": div_data_backdrop_value = typeof /*backdrop*/ ctx[10] === "undefined"
			? /*backdrop*/ ctx[10]
			: /*backdrop*/ ctx[10].toString()
		},
		{
			"data-backdrop-el": /*backdropEl*/ ctx[11]
		},
		restProps(/*$$restProps*/ ctx[18])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$l, 133, 0, 3864);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t1);
			if (if_block2) if_block2.m(div, null);
			append_dev(div, t2);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[27](div);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*title*/ ctx[0] !== "undefined" || /*hasHeaderSlots*/ ctx[15]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*title, hasHeaderSlots*/ 32769) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (typeof /*content*/ ctx[1] !== "undefined" || /*hasContentSlots*/ ctx[16]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*content, hasContentSlots*/ 65538) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (typeof /*footer*/ ctx[2] !== "undefined" || /*hasFooterSlots*/ ctx[17]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*footer, hasFooterSlots*/ 131076) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block$3(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, t2);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 268435456) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[28], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 16384) && { class: /*classes*/ ctx[14] },
				(!current || dirty[0] & /*animate*/ 8 && div_data_animate_value !== (div_data_animate_value = typeof /*animate*/ ctx[3] === "undefined"
				? /*animate*/ ctx[3]
				: /*animate*/ ctx[3].toString())) && { "data-animate": div_data_animate_value },
				(!current || dirty[0] & /*hideNavbarOnOpen*/ 16 && div_data_hide_navbar_on_open_value !== (div_data_hide_navbar_on_open_value = typeof /*hideNavbarOnOpen*/ ctx[4] === "undefined"
				? /*hideNavbarOnOpen*/ ctx[4]
				: /*hideNavbarOnOpen*/ ctx[4].toString())) && {
					"data-hide-navbar-on-open": div_data_hide_navbar_on_open_value
				},
				(!current || dirty[0] & /*hideToolbarOnOpen*/ 32 && div_data_hide_toolbar_on_open_value !== (div_data_hide_toolbar_on_open_value = typeof /*hideToolbarOnOpen*/ ctx[5] === "undefined"
				? /*hideToolbarOnOpen*/ ctx[5]
				: /*hideToolbarOnOpen*/ ctx[5].toString())) && {
					"data-hide-toolbar-on-open": div_data_hide_toolbar_on_open_value
				},
				(!current || dirty[0] & /*hideStatusbarOnOpen*/ 64 && div_data_hide_statusbar_on_open_value !== (div_data_hide_statusbar_on_open_value = typeof /*hideStatusbarOnOpen*/ ctx[6] === "undefined"
				? /*hideStatusbarOnOpen*/ ctx[6]
				: /*hideStatusbarOnOpen*/ ctx[6].toString())) && {
					"data-hide-statusbar-on-open": div_data_hide_statusbar_on_open_value
				},
				(!current || dirty[0] & /*scrollableEl*/ 128) && {
					"data-scrollable-el": /*scrollableEl*/ ctx[7]
				},
				(!current || dirty[0] & /*swipeToClose*/ 256 && div_data_swipe_to_close_value !== (div_data_swipe_to_close_value = typeof /*swipeToClose*/ ctx[8] === "undefined"
				? /*swipeToClose*/ ctx[8]
				: /*swipeToClose*/ ctx[8].toString())) && {
					"data-swipe-to-close": div_data_swipe_to_close_value
				},
				(!current || dirty[0] & /*closeByBackdropClick*/ 512 && div_data_close_by_backdrop_click_value !== (div_data_close_by_backdrop_click_value = typeof /*closeByBackdropClick*/ ctx[9] === "undefined"
				? /*closeByBackdropClick*/ ctx[9]
				: /*closeByBackdropClick*/ ctx[9].toString())) && {
					"data-close-by-backdrop-click": div_data_close_by_backdrop_click_value
				},
				(!current || dirty[0] & /*backdrop*/ 1024 && div_data_backdrop_value !== (div_data_backdrop_value = typeof /*backdrop*/ ctx[10] === "undefined"
				? /*backdrop*/ ctx[10]
				: /*backdrop*/ ctx[10].toString())) && { "data-backdrop": div_data_backdrop_value },
				(!current || dirty[0] & /*backdropEl*/ 2048) && {
					"data-backdrop-el": /*backdropEl*/ ctx[11]
				},
				dirty[0] & /*$$restProps*/ 262144 && restProps(/*$$restProps*/ ctx[18])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[27](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$k($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","title","content","footer","outline","expandable","expandableAnimateWidth","expandableOpened","animate","hideNavbarOnOpen","hideToolbarOnOpen","hideStatusbarOnOpen","scrollableEl","swipeToClose","closeByBackdropClick","backdrop","backdropEl","noShadow","noBorder","padding"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Card", slots, ['header','content','footer','default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { title = undefined } = $$props;
	let { content = undefined } = $$props;
	let { footer = undefined } = $$props;
	let { outline = false } = $$props;
	let { expandable = false } = $$props;
	let { expandableAnimateWidth = false } = $$props;
	let { expandableOpened = false } = $$props;
	let { animate = undefined } = $$props;
	let { hideNavbarOnOpen = undefined } = $$props;
	let { hideToolbarOnOpen = undefined } = $$props;
	let { hideStatusbarOnOpen = undefined } = $$props;
	let { scrollableEl = undefined } = $$props;
	let { swipeToClose = undefined } = $$props;
	let { closeByBackdropClick = undefined } = $$props;
	let { backdrop = undefined } = $$props;
	let { backdropEl = undefined } = $$props;
	let { noShadow = false } = $$props;
	let { noBorder = false } = $$props;
	let { padding = true } = $$props;
	let el;

	/* eslint-enable no-undef */
	function open() {
		f7.instance.card.open(el);
	}

	function close() {
		f7.instance.card.close(el);
	}

	let initialWatched = false;

	function watchOpened(openedPassed) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (openedPassed) {
			open();
		} else {
			close();
		}
	}

	function onBeforeOpen(cardEl, prevent) {
		if (cardEl !== el) return;
		dispatch("cardBeforeOpen", [el, prevent]);
		if (typeof $$props.onCardBeforeOpen === "function") $$props.onCardBeforeOpen(el, prevent);
	}

	function onOpen(cardEl) {
		if (cardEl !== el) return;
		dispatch("cardOpen", [el]);
		if (typeof $$props.onCardOpen === "function") $$props.onCardOpen(el);
	}

	function onOpened(cardEl, pageEl) {
		if (cardEl !== el) return;
		dispatch("cardOpened", [el, pageEl]);
		if (typeof $$props.onCardOpened === "function") $$props.onCardOpened(el, pageEl);
	}

	function onClose(cardEl) {
		if (cardEl !== el) return;
		dispatch("cardClose", [el]);
		if (typeof $$props.onCardClose === "function") $$props.onCardClose(el);
	}

	function onClosed(cardEl, pageEl) {
		if (cardEl !== el) return;
		dispatch("cardClosed", [el, pageEl]);
		if (typeof $$props.onCardClosed === "function") $$props.onCardClosed(el, pageEl);
	}

	onMount(() => {
		if (!expandable) return;

		f7.ready(() => {
			f7.instance.on("cardBeforeOpen", onBeforeOpen);
			f7.instance.on("cardOpen", onOpen);
			f7.instance.on("cardOpened", onOpened);
			f7.instance.on("cardClose", onClose);
			f7.instance.on("cardClosed", onClosed);

			if (expandable && expandableOpened && el) {
				f7.instance.card.open(el, false);
			}
		});
	});

	onDestroy(() => {
		if (!expandable) return;
		if (!f7.instance || !el) return;
		f7.instance.off("cardBeforeOpen", onBeforeOpen);
		f7.instance.off("cardOpen", onOpen);
		f7.instance.off("cardOpened", onOpened);
		f7.instance.off("cardClose", onClose);
		f7.instance.off("cardClosed", onClosed);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(13, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(39, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(19, className = $$new_props.class);
		if ("title" in $$new_props) $$invalidate(0, title = $$new_props.title);
		if ("content" in $$new_props) $$invalidate(1, content = $$new_props.content);
		if ("footer" in $$new_props) $$invalidate(2, footer = $$new_props.footer);
		if ("outline" in $$new_props) $$invalidate(20, outline = $$new_props.outline);
		if ("expandable" in $$new_props) $$invalidate(21, expandable = $$new_props.expandable);
		if ("expandableAnimateWidth" in $$new_props) $$invalidate(22, expandableAnimateWidth = $$new_props.expandableAnimateWidth);
		if ("expandableOpened" in $$new_props) $$invalidate(23, expandableOpened = $$new_props.expandableOpened);
		if ("animate" in $$new_props) $$invalidate(3, animate = $$new_props.animate);
		if ("hideNavbarOnOpen" in $$new_props) $$invalidate(4, hideNavbarOnOpen = $$new_props.hideNavbarOnOpen);
		if ("hideToolbarOnOpen" in $$new_props) $$invalidate(5, hideToolbarOnOpen = $$new_props.hideToolbarOnOpen);
		if ("hideStatusbarOnOpen" in $$new_props) $$invalidate(6, hideStatusbarOnOpen = $$new_props.hideStatusbarOnOpen);
		if ("scrollableEl" in $$new_props) $$invalidate(7, scrollableEl = $$new_props.scrollableEl);
		if ("swipeToClose" in $$new_props) $$invalidate(8, swipeToClose = $$new_props.swipeToClose);
		if ("closeByBackdropClick" in $$new_props) $$invalidate(9, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ("backdrop" in $$new_props) $$invalidate(10, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$new_props) $$invalidate(11, backdropEl = $$new_props.backdropEl);
		if ("noShadow" in $$new_props) $$invalidate(24, noShadow = $$new_props.noShadow);
		if ("noBorder" in $$new_props) $$invalidate(25, noBorder = $$new_props.noBorder);
		if ("padding" in $$new_props) $$invalidate(12, padding = $$new_props.padding);
		if ("$$scope" in $$new_props) $$invalidate(28, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		hasSlots,
		CardHeader: Card_header,
		CardContent: Card_content,
		CardFooter: Card_footer,
		dispatch,
		className,
		title,
		content,
		footer,
		outline,
		expandable,
		expandableAnimateWidth,
		expandableOpened,
		animate,
		hideNavbarOnOpen,
		hideToolbarOnOpen,
		hideStatusbarOnOpen,
		scrollableEl,
		swipeToClose,
		closeByBackdropClick,
		backdrop,
		backdropEl,
		noShadow,
		noBorder,
		padding,
		el,
		open,
		close,
		initialWatched,
		watchOpened,
		onBeforeOpen,
		onOpen,
		onOpened,
		onClose,
		onClosed,
		classes,
		hasHeaderSlots,
		hasContentSlots,
		hasFooterSlots
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(39, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(19, className = $$new_props.className);
		if ("title" in $$props) $$invalidate(0, title = $$new_props.title);
		if ("content" in $$props) $$invalidate(1, content = $$new_props.content);
		if ("footer" in $$props) $$invalidate(2, footer = $$new_props.footer);
		if ("outline" in $$props) $$invalidate(20, outline = $$new_props.outline);
		if ("expandable" in $$props) $$invalidate(21, expandable = $$new_props.expandable);
		if ("expandableAnimateWidth" in $$props) $$invalidate(22, expandableAnimateWidth = $$new_props.expandableAnimateWidth);
		if ("expandableOpened" in $$props) $$invalidate(23, expandableOpened = $$new_props.expandableOpened);
		if ("animate" in $$props) $$invalidate(3, animate = $$new_props.animate);
		if ("hideNavbarOnOpen" in $$props) $$invalidate(4, hideNavbarOnOpen = $$new_props.hideNavbarOnOpen);
		if ("hideToolbarOnOpen" in $$props) $$invalidate(5, hideToolbarOnOpen = $$new_props.hideToolbarOnOpen);
		if ("hideStatusbarOnOpen" in $$props) $$invalidate(6, hideStatusbarOnOpen = $$new_props.hideStatusbarOnOpen);
		if ("scrollableEl" in $$props) $$invalidate(7, scrollableEl = $$new_props.scrollableEl);
		if ("swipeToClose" in $$props) $$invalidate(8, swipeToClose = $$new_props.swipeToClose);
		if ("closeByBackdropClick" in $$props) $$invalidate(9, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ("backdrop" in $$props) $$invalidate(10, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$props) $$invalidate(11, backdropEl = $$new_props.backdropEl);
		if ("noShadow" in $$props) $$invalidate(24, noShadow = $$new_props.noShadow);
		if ("noBorder" in $$props) $$invalidate(25, noBorder = $$new_props.noBorder);
		if ("padding" in $$props) $$invalidate(12, padding = $$new_props.padding);
		if ("el" in $$props) $$invalidate(13, el = $$new_props.el);
		if ("initialWatched" in $$props) initialWatched = $$new_props.initialWatched;
		if ("classes" in $$props) $$invalidate(14, classes = $$new_props.classes);
		if ("hasHeaderSlots" in $$props) $$invalidate(15, hasHeaderSlots = $$new_props.hasHeaderSlots);
		if ("hasContentSlots" in $$props) $$invalidate(16, hasContentSlots = $$new_props.hasContentSlots);
		if ("hasFooterSlots" in $$props) $$invalidate(17, hasFooterSlots = $$new_props.hasFooterSlots);
	};

	let classes;
	let hasHeaderSlots;
	let hasContentSlots;
	let hasFooterSlots;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(14, classes = Utils.classNames(
			className,
			"card",
			{
				"card-outline": outline,
				"card-expandable": expandable,
				"card-expandable-animate-width": expandableAnimateWidth,
				"no-shadow": noShadow,
				"no-border": noBorder
			},
			Mixins.colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*expandableOpened*/ 8388608) {
			 watchOpened(expandableOpened);
		}
	};

	 $$invalidate(15, hasHeaderSlots = hasSlots(arguments, "header"));
	 $$invalidate(16, hasContentSlots = hasSlots(arguments, "content"));
	 $$invalidate(17, hasFooterSlots = hasSlots(arguments, "footer"));
	$$props = exclude_internal_props($$props);

	return [
		title,
		content,
		footer,
		animate,
		hideNavbarOnOpen,
		hideToolbarOnOpen,
		hideStatusbarOnOpen,
		scrollableEl,
		swipeToClose,
		closeByBackdropClick,
		backdrop,
		backdropEl,
		padding,
		el,
		classes,
		hasHeaderSlots,
		hasContentSlots,
		hasFooterSlots,
		$$restProps,
		className,
		outline,
		expandable,
		expandableAnimateWidth,
		expandableOpened,
		noShadow,
		noBorder,
		slots,
		div_binding,
		$$scope
	];
}

class Card extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$k,
			create_fragment$l,
			safe_not_equal,
			{
				class: 19,
				title: 0,
				content: 1,
				footer: 2,
				outline: 20,
				expandable: 21,
				expandableAnimateWidth: 22,
				expandableOpened: 23,
				animate: 3,
				hideNavbarOnOpen: 4,
				hideToolbarOnOpen: 5,
				hideStatusbarOnOpen: 6,
				scrollableEl: 7,
				swipeToClose: 8,
				closeByBackdropClick: 9,
				backdrop: 10,
				backdropEl: 11,
				noShadow: 24,
				noBorder: 25,
				padding: 12
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Card",
			options,
			id: create_fragment$l.name
		});
	}

	get class() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get content() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set content(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get footer() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set footer(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outline() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outline(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expandable() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expandable(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expandableAnimateWidth() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expandableAnimateWidth(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expandableOpened() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expandableOpened(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get animate() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set animate(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideNavbarOnOpen() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideNavbarOnOpen(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideToolbarOnOpen() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideToolbarOnOpen(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideStatusbarOnOpen() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideStatusbarOnOpen(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrollableEl() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scrollableEl(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeToClose() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeToClose(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeByBackdropClick() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeByBackdropClick(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdrop() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdrop(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdropEl() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdropEl(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noShadow() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noShadow(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noBorder() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noBorder(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get padding() {
		throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set padding(value) {
		throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/checkbox.svelte generated by Svelte v3.31.0 */
const file$m = "node_modules/framework7-svelte/components/checkbox.svelte";

function create_fragment$m(ctx) {
	let label;
	let input;
	let input_value_value;
	let t0;
	let i;
	let t1;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	let label_levels = [{ class: /*classes*/ ctx[6] }, restProps(/*$$restProps*/ ctx[8])];
	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	const block = {
		c: function create() {
			label = element("label");
			input = element("input");
			t0 = space();
			i = element("i");
			t1 = space();
			if (default_slot) default_slot.c();
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "name", /*name*/ ctx[1]);

			input.value = input_value_value = typeof /*value*/ ctx[2] === "undefined"
			? ""
			: /*value*/ ctx[2];

			input.disabled = /*disabled*/ ctx[3];
			input.readOnly = /*readonly*/ ctx[4];
			input.checked = /*checked*/ ctx[0];
			add_location(input, file$m, 49, 2, 1086);
			attr_dev(i, "class", "icon-checkbox");
			add_location(i, file$m, 59, 2, 1309);
			set_attributes(label, label_data);
			add_location(label, file$m, 48, 0, 1031);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, input);
			/*input_binding*/ ctx[13](input);
			append_dev(label, t0);
			append_dev(label, i);
			append_dev(label, t1);

			if (default_slot) {
				default_slot.m(label, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(input, "change", /*onChange*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*name*/ 2) {
				attr_dev(input, "name", /*name*/ ctx[1]);
			}

			if (!current || dirty & /*value*/ 4 && input_value_value !== (input_value_value = typeof /*value*/ ctx[2] === "undefined"
			? ""
			: /*value*/ ctx[2])) {
				prop_dev(input, "value", input_value_value);
			}

			if (!current || dirty & /*disabled*/ 8) {
				prop_dev(input, "disabled", /*disabled*/ ctx[3]);
			}

			if (!current || dirty & /*readonly*/ 16) {
				prop_dev(input, "readOnly", /*readonly*/ ctx[4]);
			}

			if (!current || dirty & /*checked*/ 1) {
				prop_dev(input, "checked", /*checked*/ ctx[0]);
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				(!current || dirty & /*classes*/ 64) && { class: /*classes*/ ctx[6] },
				dirty & /*$$restProps*/ 256 && restProps(/*$$restProps*/ ctx[8])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			/*input_binding*/ ctx[13](null);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$l($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","checked","indeterminate","name","value","disabled","readonly"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Checkbox", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { checked = undefined } = $$props;
	let { indeterminate = undefined } = $$props;
	let { name = undefined } = $$props;
	let { value = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let inputEl;

	function onChange(event) {
		dispatch("change", [event]);
		if (typeof $$props.onChange === "function") $$props.onChange(event);
	}

	onMount(() => {
		if (indeterminate && inputEl) {
			$$invalidate(5, inputEl.indeterminate = true, inputEl);
		}
	});

	afterUpdate(() => {
		if (inputEl) {
			$$invalidate(5, inputEl.indeterminate = indeterminate, inputEl);
		}
	});

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(5, inputEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(9, className = $$new_props.class);
		if ("checked" in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ("indeterminate" in $$new_props) $$invalidate(10, indeterminate = $$new_props.indeterminate);
		if ("name" in $$new_props) $$invalidate(1, name = $$new_props.name);
		if ("value" in $$new_props) $$invalidate(2, value = $$new_props.value);
		if ("disabled" in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
		if ("readonly" in $$new_props) $$invalidate(4, readonly = $$new_props.readonly);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		afterUpdate,
		Mixins,
		Utils,
		restProps,
		dispatch,
		className,
		checked,
		indeterminate,
		name,
		value,
		disabled,
		readonly,
		inputEl,
		onChange,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(9, className = $$new_props.className);
		if ("checked" in $$props) $$invalidate(0, checked = $$new_props.checked);
		if ("indeterminate" in $$props) $$invalidate(10, indeterminate = $$new_props.indeterminate);
		if ("name" in $$props) $$invalidate(1, name = $$new_props.name);
		if ("value" in $$props) $$invalidate(2, value = $$new_props.value);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$new_props.disabled);
		if ("readonly" in $$props) $$invalidate(4, readonly = $$new_props.readonly);
		if ("inputEl" in $$props) $$invalidate(5, inputEl = $$new_props.inputEl);
		if ("classes" in $$props) $$invalidate(6, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(6, classes = Utils.classNames(className, { checkbox: true, disabled }, Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);

	return [
		checked,
		name,
		value,
		disabled,
		readonly,
		inputEl,
		classes,
		onChange,
		$$restProps,
		className,
		indeterminate,
		$$scope,
		slots,
		input_binding
	];
}

class Checkbox extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$l, create_fragment$m, safe_not_equal, {
			class: 9,
			checked: 0,
			indeterminate: 10,
			name: 1,
			value: 2,
			disabled: 3,
			readonly: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Checkbox",
			options,
			id: create_fragment$m.name
		});
	}

	get class() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get indeterminate() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set indeterminate(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Checkbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Checkbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/chip.svelte generated by Svelte v3.31.0 */
const file$n = "node_modules/framework7-svelte/components/chip.svelte";
const get_text_slot_changes = dirty => ({});
const get_text_slot_context = ctx => ({});
const get_media_slot_changes$1 = dirty => ({});
const get_media_slot_context$1 = ctx => ({});

// (108:2) {#if media || hasMediaSlots || hasIcon}
function create_if_block_2$2(ctx) {
	let div;
	let t0;
	let t1_value = Utils.text(/*media*/ ctx[0]) + "";
	let t1;
	let t2;
	let current;
	let if_block = /*hasIcon*/ ctx[9] && create_if_block_3$1(ctx);
	const media_slot_template = /*#slots*/ ctx[21].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[20], get_media_slot_context$1);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", /*mediaClasses*/ ctx[5]);
			add_location(div, file$n, 108, 4, 2832);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasIcon*/ ctx[9]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*hasIcon*/ 512) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_3$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if ((!current || dirty & /*media*/ 1) && t1_value !== (t1_value = Utils.text(/*media*/ ctx[0]) + "")) set_data_dev(t1, t1_value);

			if (media_slot) {
				if (media_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_media_slot_changes$1, get_media_slot_context$1);
				}
			}

			if (!current || dirty & /*mediaClasses*/ 32) {
				attr_dev(div, "class", /*mediaClasses*/ ctx[5]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(108:2) {#if media || hasMediaSlots || hasIcon}",
		ctx
	});

	return block;
}

// (110:6) {#if hasIcon}
function create_if_block_3$1(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				material: /*$$props*/ ctx[12].iconMaterial,
				f7: /*$$props*/ ctx[12].iconF7,
				icon: /*$$props*/ ctx[12].icon,
				md: /*$$props*/ ctx[12].iconMd,
				ios: /*$$props*/ ctx[12].iconIos,
				aurora: /*$$props*/ ctx[12].iconAurora,
				color: /*$$props*/ ctx[12].iconColor,
				size: /*$$props*/ ctx[12].iconSize
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*$$props*/ 4096) icon_changes.material = /*$$props*/ ctx[12].iconMaterial;
			if (dirty & /*$$props*/ 4096) icon_changes.f7 = /*$$props*/ ctx[12].iconF7;
			if (dirty & /*$$props*/ 4096) icon_changes.icon = /*$$props*/ ctx[12].icon;
			if (dirty & /*$$props*/ 4096) icon_changes.md = /*$$props*/ ctx[12].iconMd;
			if (dirty & /*$$props*/ 4096) icon_changes.ios = /*$$props*/ ctx[12].iconIos;
			if (dirty & /*$$props*/ 4096) icon_changes.aurora = /*$$props*/ ctx[12].iconAurora;
			if (dirty & /*$$props*/ 4096) icon_changes.color = /*$$props*/ ctx[12].iconColor;
			if (dirty & /*$$props*/ 4096) icon_changes.size = /*$$props*/ ctx[12].iconSize;
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(110:6) {#if hasIcon}",
		ctx
	});

	return block;
}

// (126:2) {#if text || hasTextSlots || hasDefaultSlots}
function create_if_block_1$2(ctx) {
	let div;
	let t0_value = Utils.text(/*text*/ ctx[1]) + "";
	let t0;
	let t1;
	let t2;
	let current;
	const text_slot_template = /*#slots*/ ctx[21].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[20], get_text_slot_context);
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			t2 = space();
			if (default_slot) default_slot.c();
			attr_dev(div, "class", "chip-label");
			add_location(div, file$n, 126, 4, 3313);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			append_dev(div, t2);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*text*/ 2) && t0_value !== (t0_value = Utils.text(/*text*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_text_slot_changes, get_text_slot_context);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[20], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (text_slot) text_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(126:2) {#if text || hasTextSlots || hasDefaultSlots}",
		ctx
	});

	return block;
}

// (133:2) {#if deleteable}
function create_if_block$4(ctx) {
	let a;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			a = element("a");
			attr_dev(a, "class", "chip-delete");
			add_location(a, file$n, 133, 4, 3447);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onDeleteClick*/ ctx[11], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(133:2) {#if deleteable}",
		ctx
	});

	return block;
}

function create_fragment$n(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	let if_block0 = (/*media*/ ctx[0] || /*hasMediaSlots*/ ctx[6] || /*hasIcon*/ ctx[9]) && create_if_block_2$2(ctx);
	let if_block1 = (/*text*/ ctx[1] || /*hasTextSlots*/ ctx[7] || /*hasDefaultSlots*/ ctx[8]) && create_if_block_1$2(ctx);
	let if_block2 = /*deleteable*/ ctx[2] && create_if_block$4(ctx);
	let div_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[13])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			set_attributes(div, div_data);
			add_location(div, file$n, 106, 0, 2702);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t1);
			if (if_block2) if_block2.m(div, null);
			/*div_binding*/ ctx[22](div);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*onClick*/ ctx[10], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*media*/ ctx[0] || /*hasMediaSlots*/ ctx[6] || /*hasIcon*/ ctx[9]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*media, hasMediaSlots, hasIcon*/ 577) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*text*/ ctx[1] || /*hasTextSlots*/ ctx[7] || /*hasDefaultSlots*/ ctx[8]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*text, hasTextSlots, hasDefaultSlots*/ 386) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*deleteable*/ ctx[2]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$4(ctx);
					if_block2.c();
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*$$restProps*/ 8192 && restProps(/*$$restProps*/ ctx[13])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			/*div_binding*/ ctx[22](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$m($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","media","text","deleteable","mediaBgColor","mediaTextColor","outline","tooltip","tooltipTrigger"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Chip", slots, ['media','text','default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { media = undefined } = $$props;
	let { text = undefined } = $$props;
	let { deleteable = undefined } = $$props;
	let { mediaBgColor = undefined } = $$props;
	let { mediaTextColor = undefined } = $$props;
	let { outline = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let el;
	let f7Tooltip;
	let tooltipText = tooltip;

	function watchTooltip(newText) {
		const oldText = tooltipText;
		if (oldText === newText) return;
		tooltipText = newText;

		if (!newText && f7Tooltip) {
			f7Tooltip.destroy();
			f7Tooltip = null;
			return;
		}

		if (newText && !f7Tooltip && f7.instance) {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: newText,
				trigger: tooltipTrigger
			});

			return;
		}

		if (!newText || !f7Tooltip) return;
		f7Tooltip.setText(newText);
	}

	onMount(() => {
		if (!tooltip) return;

		f7.ready(() => {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: tooltip,
				trigger: tooltipTrigger
			});
		});
	});

	onDestroy(() => {
		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
			f7Tooltip = null;
		}
	});

	function onClick(e) {
		dispatch("click", [e]);
		if (typeof $$props.onClick === "function") $$props.onClick(e);
	}

	function onDeleteClick(e) {
		dispatch("delete", [e]);
		if (typeof $$props.onDelete === "function") $$props.onDelete(e);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(14, className = $$new_props.class);
		if ("media" in $$new_props) $$invalidate(0, media = $$new_props.media);
		if ("text" in $$new_props) $$invalidate(1, text = $$new_props.text);
		if ("deleteable" in $$new_props) $$invalidate(2, deleteable = $$new_props.deleteable);
		if ("mediaBgColor" in $$new_props) $$invalidate(15, mediaBgColor = $$new_props.mediaBgColor);
		if ("mediaTextColor" in $$new_props) $$invalidate(16, mediaTextColor = $$new_props.mediaTextColor);
		if ("outline" in $$new_props) $$invalidate(17, outline = $$new_props.outline);
		if ("tooltip" in $$new_props) $$invalidate(18, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$new_props) $$invalidate(19, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("$$scope" in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		hasSlots,
		f7,
		Icon,
		dispatch,
		className,
		media,
		text,
		deleteable,
		mediaBgColor,
		mediaTextColor,
		outline,
		tooltip,
		tooltipTrigger,
		el,
		f7Tooltip,
		tooltipText,
		watchTooltip,
		onClick,
		onDeleteClick,
		classes,
		mediaClasses,
		hasMediaSlots,
		hasTextSlots,
		hasDefaultSlots,
		hasIcon
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(14, className = $$new_props.className);
		if ("media" in $$props) $$invalidate(0, media = $$new_props.media);
		if ("text" in $$props) $$invalidate(1, text = $$new_props.text);
		if ("deleteable" in $$props) $$invalidate(2, deleteable = $$new_props.deleteable);
		if ("mediaBgColor" in $$props) $$invalidate(15, mediaBgColor = $$new_props.mediaBgColor);
		if ("mediaTextColor" in $$props) $$invalidate(16, mediaTextColor = $$new_props.mediaTextColor);
		if ("outline" in $$props) $$invalidate(17, outline = $$new_props.outline);
		if ("tooltip" in $$props) $$invalidate(18, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$props) $$invalidate(19, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("el" in $$props) $$invalidate(3, el = $$new_props.el);
		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
		if ("mediaClasses" in $$props) $$invalidate(5, mediaClasses = $$new_props.mediaClasses);
		if ("hasMediaSlots" in $$props) $$invalidate(6, hasMediaSlots = $$new_props.hasMediaSlots);
		if ("hasTextSlots" in $$props) $$invalidate(7, hasTextSlots = $$new_props.hasTextSlots);
		if ("hasDefaultSlots" in $$props) $$invalidate(8, hasDefaultSlots = $$new_props.hasDefaultSlots);
		if ("hasIcon" in $$props) $$invalidate(9, hasIcon = $$new_props.hasIcon);
	};

	let classes;
	let mediaClasses;
	let hasMediaSlots;
	let hasTextSlots;
	let hasDefaultSlots;
	let hasIcon;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(4, classes = Utils.classNames(className, "chip", { "chip-outline": outline }, Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*mediaTextColor, mediaBgColor*/ 98304) {
			 $$invalidate(5, mediaClasses = Utils.classNames("chip-media", mediaTextColor && `text-color-${mediaTextColor}`, mediaBgColor && `bg-color-${mediaBgColor}`));
		}

		 $$invalidate(9, hasIcon = $$props.icon || $$props.iconMaterial || $$props.iconF7 || $$props.iconMd || $$props.iconIos || $$props.iconAurora);

		if ($$self.$$.dirty & /*tooltip*/ 262144) {
			 watchTooltip(tooltip);
		}
	};

	 $$invalidate(6, hasMediaSlots = hasSlots(arguments, "media"));

	// eslint-disable-next-line
	 $$invalidate(7, hasTextSlots = hasSlots(arguments, "text"));

	// eslint-disable-next-line
	 $$invalidate(8, hasDefaultSlots = hasSlots(arguments, "default"));

	$$props = exclude_internal_props($$props);

	return [
		media,
		text,
		deleteable,
		el,
		classes,
		mediaClasses,
		hasMediaSlots,
		hasTextSlots,
		hasDefaultSlots,
		hasIcon,
		onClick,
		onDeleteClick,
		$$props,
		$$restProps,
		className,
		mediaBgColor,
		mediaTextColor,
		outline,
		tooltip,
		tooltipTrigger,
		$$scope,
		slots,
		div_binding
	];
}

class Chip extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$m, create_fragment$n, safe_not_equal, {
			class: 14,
			media: 0,
			text: 1,
			deleteable: 2,
			mediaBgColor: 15,
			mediaTextColor: 16,
			outline: 17,
			tooltip: 18,
			tooltipTrigger: 19
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Chip",
			options,
			id: create_fragment$n.name
		});
	}

	get class() {
		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get media() {
		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set media(value) {
		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get deleteable() {
		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set deleteable(value) {
		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mediaBgColor() {
		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mediaBgColor(value) {
		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mediaTextColor() {
		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mediaTextColor(value) {
		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outline() {
		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outline(value) {
		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltip() {
		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltip(value) {
		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltipTrigger() {
		throw new Error("<Chip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltipTrigger(value) {
		throw new Error("<Chip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/col.svelte generated by Svelte v3.31.0 */
const file$o = "node_modules/framework7-svelte/components/col.svelte";

// (76:25) 
function create_if_block_2$3(ctx) {
	let span;
	let t;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
	let if_block = /*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2] && create_if_block_3$2(ctx);
	let span_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[6])];
	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			set_attributes(span, span_data);
			add_location(span, file$o, 76, 2, 1941);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			append_dev(span, t);
			if (if_block) if_block.m(span, null);
			/*span_binding*/ ctx[19](span);
			current = true;

			if (!mounted) {
				dispose = listen_dev(span, "click", /*onClick*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}

			if (/*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2]) {
				if (if_block) ; else {
					if_block = create_if_block_3$2(ctx);
					if_block.c();
					if_block.m(span, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*span_binding*/ ctx[19](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$3.name,
		type: "if",
		source: "(76:25) ",
		ctx
	});

	return block;
}

// (64:0) {#if tag === 'div'}
function create_if_block$5(ctx) {
	let div;
	let t;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
	let if_block = /*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2] && create_if_block_1$3(ctx);
	let div_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[6])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			set_attributes(div, div_data);
			add_location(div, file$o, 64, 2, 1695);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_dev(div, t);
			if (if_block) if_block.m(div, null);
			/*div_binding*/ ctx[18](div);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*onClick*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}

			if (/*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2]) {
				if (if_block) ; else {
					if_block = create_if_block_1$3(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*div_binding*/ ctx[18](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(64:0) {#if tag === 'div'}",
		ctx
	});

	return block;
}

// (84:4) {#if resizable && resizableHandler}
function create_if_block_3$2(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "resize-handler");
			add_location(span, file$o, 84, 6, 2104);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$2.name,
		type: "if",
		source: "(84:4) {#if resizable && resizableHandler}",
		ctx
	});

	return block;
}

// (72:4) {#if resizable && resizableHandler}
function create_if_block_1$3(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "resize-handler");
			add_location(span, file$o, 72, 6, 1857);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(72:4) {#if resizable && resizableHandler}",
		ctx
	});

	return block;
}

function create_fragment$o(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$5, create_if_block_2$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[0] === "div") return 0;
		if (/*tag*/ ctx[0] === "span") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$n($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","tag","width","xsmall","small","medium","large","xlarge","resizable","resizableFixed","resizableAbsolute","resizableHandler"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Col", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { tag = "div" } = $$props;
	let { width = "auto" } = $$props;
	let { xsmall = undefined } = $$props;
	let { small = undefined } = $$props;
	let { medium = undefined } = $$props;
	let { large = undefined } = $$props;
	let { xlarge = undefined } = $$props;
	let { resizable = false } = $$props;
	let { resizableFixed = false } = $$props;
	let { resizableAbsolute = false } = $$props;
	let { resizableHandler = true } = $$props;
	let el;

	function onClick() {
		dispatch("click");
		if (typeof $$props.onClick === "function") $$props.onClick();
	}

	function onResize(targetEl) {
		if (el !== targetEl) return;
		dispatch("gridResize");
		if (typeof $$props.onGridResize === "function") $$props.onGridResize();
	}

	onMount(() => {
		f7.ready(() => {
			f7.instance.on("gridResize", onResize);
		});
	});

	onDestroy(() => {
		if (!f7.instance) return;
		f7.instance.off("gridResize", onResize);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	function span_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(7, className = $$new_props.class);
		if ("tag" in $$new_props) $$invalidate(0, tag = $$new_props.tag);
		if ("width" in $$new_props) $$invalidate(8, width = $$new_props.width);
		if ("xsmall" in $$new_props) $$invalidate(9, xsmall = $$new_props.xsmall);
		if ("small" in $$new_props) $$invalidate(10, small = $$new_props.small);
		if ("medium" in $$new_props) $$invalidate(11, medium = $$new_props.medium);
		if ("large" in $$new_props) $$invalidate(12, large = $$new_props.large);
		if ("xlarge" in $$new_props) $$invalidate(13, xlarge = $$new_props.xlarge);
		if ("resizable" in $$new_props) $$invalidate(1, resizable = $$new_props.resizable);
		if ("resizableFixed" in $$new_props) $$invalidate(14, resizableFixed = $$new_props.resizableFixed);
		if ("resizableAbsolute" in $$new_props) $$invalidate(15, resizableAbsolute = $$new_props.resizableAbsolute);
		if ("resizableHandler" in $$new_props) $$invalidate(2, resizableHandler = $$new_props.resizableHandler);
		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		tag,
		width,
		xsmall,
		small,
		medium,
		large,
		xlarge,
		resizable,
		resizableFixed,
		resizableAbsolute,
		resizableHandler,
		el,
		onClick,
		onResize,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(7, className = $$new_props.className);
		if ("tag" in $$props) $$invalidate(0, tag = $$new_props.tag);
		if ("width" in $$props) $$invalidate(8, width = $$new_props.width);
		if ("xsmall" in $$props) $$invalidate(9, xsmall = $$new_props.xsmall);
		if ("small" in $$props) $$invalidate(10, small = $$new_props.small);
		if ("medium" in $$props) $$invalidate(11, medium = $$new_props.medium);
		if ("large" in $$props) $$invalidate(12, large = $$new_props.large);
		if ("xlarge" in $$props) $$invalidate(13, xlarge = $$new_props.xlarge);
		if ("resizable" in $$props) $$invalidate(1, resizable = $$new_props.resizable);
		if ("resizableFixed" in $$props) $$invalidate(14, resizableFixed = $$new_props.resizableFixed);
		if ("resizableAbsolute" in $$props) $$invalidate(15, resizableAbsolute = $$new_props.resizableAbsolute);
		if ("resizableHandler" in $$props) $$invalidate(2, resizableHandler = $$new_props.resizableHandler);
		if ("el" in $$props) $$invalidate(3, el = $$new_props.el);
		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(4, classes = Utils.classNames(
			className,
			{
				col: width === "auto",
				[`col-${width}`]: width !== "auto",
				[`xsmall-${xsmall}`]: xsmall,
				[`small-${small}`]: small,
				[`medium-${medium}`]: medium,
				[`large-${large}`]: large,
				[`xlarge-${xlarge}`]: xlarge,
				resizable,
				"resizable-fixed": resizableFixed,
				"resizable-absolute": resizableAbsolute
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		tag,
		resizable,
		resizableHandler,
		el,
		classes,
		onClick,
		$$restProps,
		className,
		width,
		xsmall,
		small,
		medium,
		large,
		xlarge,
		resizableFixed,
		resizableAbsolute,
		$$scope,
		slots,
		div_binding,
		span_binding
	];
}

class Col extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$n, create_fragment$o, safe_not_equal, {
			class: 7,
			tag: 0,
			width: 8,
			xsmall: 9,
			small: 10,
			medium: 11,
			large: 12,
			xlarge: 13,
			resizable: 1,
			resizableFixed: 14,
			resizableAbsolute: 15,
			resizableHandler: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Col",
			options,
			id: create_fragment$o.name
		});
	}

	get class() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tag() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tag(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xsmall() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xsmall(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get small() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set small(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get medium() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set medium(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get large() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set large(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xlarge() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xlarge(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizable() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizable(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizableFixed() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizableFixed(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizableAbsolute() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizableAbsolute(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizableHandler() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizableHandler(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/fab-backdrop.svelte generated by Svelte v3.31.0 */
const file$p = "node_modules/framework7-svelte/components/fab-backdrop.svelte";

function create_fragment$p(ctx) {
	let div;

	let div_levels = [
		{ class: /*classes*/ ctx[1] },
		{ "data-f7-slot": /*f7Slot*/ ctx[0] },
		restProps(/*$$restProps*/ ctx[2])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			set_attributes(div, div_data);
			add_location(div, file$p, 15, 0, 274);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		p: function update(ctx, [dirty]) {
			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*classes*/ 2 && { class: /*classes*/ ctx[1] },
				dirty & /*f7Slot*/ 1 && { "data-f7-slot": /*f7Slot*/ ctx[0] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$o($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","f7Slot"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Fab_backdrop", slots, []);
	let { class: className = undefined } = $$props;
	let { f7Slot = "fixed" } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("f7Slot" in $$new_props) $$invalidate(0, f7Slot = $$new_props.f7Slot);
	};

	$$self.$capture_state = () => ({
		Utils,
		restProps,
		className,
		f7Slot,
		classes
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("f7Slot" in $$props) $$invalidate(0, f7Slot = $$new_props.f7Slot);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 8) {
			 $$invalidate(1, classes = Utils.classNames(className, "fab-backdrop"));
		}
	};

	return [f7Slot, classes, $$restProps, className];
}

class Fab_backdrop extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$o, create_fragment$p, safe_not_equal, { class: 3, f7Slot: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Fab_backdrop",
			options,
			id: create_fragment$p.name
		});
	}

	get class() {
		throw new Error("<Fab_backdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Fab_backdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get f7Slot() {
		throw new Error("<Fab_backdrop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set f7Slot(value) {
		throw new Error("<Fab_backdrop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/fab-button.svelte generated by Svelte v3.31.0 */
const file$q = "node_modules/framework7-svelte/components/fab-button.svelte";

// (87:2) {#if typeof label !== 'undefined'}
function create_if_block$6(ctx) {
	let span;
	let t_value = Utils.text(/*label*/ ctx[0]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			attr_dev(span, "class", "fab-label");
			add_location(span, file$q, 87, 4, 1968);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*label*/ 1 && t_value !== (t_value = Utils.text(/*label*/ ctx[0]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(87:2) {#if typeof label !== 'undefined'}",
		ctx
	});

	return block;
}

function create_fragment$q(ctx) {
	let a;
	let t;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);
	let if_block = typeof /*label*/ ctx[0] !== "undefined" && create_if_block$6(ctx);

	let a_levels = [
		{ target: /*target*/ ctx[1] },
		{ class: /*classes*/ ctx[3] },
		restProps(/*$$restProps*/ ctx[5])
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			set_attributes(a, a_data);
			add_location(a, file$q, 78, 0, 1807);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			append_dev(a, t);
			if (if_block) if_block.m(a, null);
			/*a_binding*/ ctx[12](a);
			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1024) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, null, null);
				}
			}

			if (typeof /*label*/ ctx[0] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$6(ctx);
					if_block.c();
					if_block.m(a, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*target*/ 2) && { target: /*target*/ ctx[1] },
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				dirty & /*$$restProps*/ 32 && restProps(/*$$restProps*/ ctx[5])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*a_binding*/ ctx[12](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$p($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","fabClose","label","target","tooltip","tooltipTrigger"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Fab_button", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { fabClose = false } = $$props;
	let { label = undefined } = $$props;
	let { target = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let el;
	let f7Tooltip;
	let tooltipText = tooltip;

	function watchTooltip(newText) {
		const oldText = tooltipText;
		if (oldText === newText) return;
		tooltipText = newText;

		if (!newText && f7Tooltip) {
			f7Tooltip.destroy();
			f7Tooltip = null;
			return;
		}

		if (newText && !f7Tooltip && f7.instance) {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: newText,
				trigger: tooltipTrigger
			});

			return;
		}

		if (!newText || !f7Tooltip) return;
		f7Tooltip.setText(newText);
	}

	function onClick() {
		dispatch("click");
		if (typeof $$props.onClick === "function") $$props.onClick();
	}

	onMount(() => {
		f7.ready(() => {
			if (tooltip) {
				f7Tooltip = f7.instance.tooltip.create({
					targetEl: el,
					text: tooltip,
					trigger: tooltipTrigger
				});
			}
		});
	});

	onDestroy(() => {
		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
			f7Tooltip = null;
		}
	});

	function a_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ("fabClose" in $$new_props) $$invalidate(7, fabClose = $$new_props.fabClose);
		if ("label" in $$new_props) $$invalidate(0, label = $$new_props.label);
		if ("target" in $$new_props) $$invalidate(1, target = $$new_props.target);
		if ("tooltip" in $$new_props) $$invalidate(8, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$new_props) $$invalidate(9, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		fabClose,
		label,
		target,
		tooltip,
		tooltipTrigger,
		el,
		f7Tooltip,
		tooltipText,
		watchTooltip,
		onClick,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(17, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
		if ("fabClose" in $$props) $$invalidate(7, fabClose = $$new_props.fabClose);
		if ("label" in $$props) $$invalidate(0, label = $$new_props.label);
		if ("target" in $$props) $$invalidate(1, target = $$new_props.target);
		if ("tooltip" in $$props) $$invalidate(8, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$props) $$invalidate(9, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("el" in $$props) $$invalidate(2, el = $$new_props.el);
		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(3, classes = Utils.classNames(
			className,
			{
				"fab-close": fabClose,
				"fab-label-button": label
			},
			Mixins.colorClasses($$props)
		));

		if ($$self.$$.dirty & /*tooltip*/ 256) {
			 watchTooltip(tooltip);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		label,
		target,
		el,
		classes,
		onClick,
		$$restProps,
		className,
		fabClose,
		tooltip,
		tooltipTrigger,
		$$scope,
		slots,
		a_binding
	];
}

class Fab_button extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$p, create_fragment$q, safe_not_equal, {
			class: 6,
			fabClose: 7,
			label: 0,
			target: 1,
			tooltip: 8,
			tooltipTrigger: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Fab_button",
			options,
			id: create_fragment$q.name
		});
	}

	get class() {
		throw new Error("<Fab_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Fab_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fabClose() {
		throw new Error("<Fab_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fabClose(value) {
		throw new Error("<Fab_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Fab_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Fab_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get target() {
		throw new Error("<Fab_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set target(value) {
		throw new Error("<Fab_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltip() {
		throw new Error("<Fab_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltip(value) {
		throw new Error("<Fab_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltipTrigger() {
		throw new Error("<Fab_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltipTrigger(value) {
		throw new Error("<Fab_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/fab-buttons.svelte generated by Svelte v3.31.0 */
const file$r = "node_modules/framework7-svelte/components/fab-buttons.svelte";

function create_fragment$r(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$r, 19, 0, 379);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$q($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","position"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Fab_buttons", slots, ['default']);
	let { class: className = undefined } = $$props;
	let { position = "top" } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("position" in $$new_props) $$invalidate(3, position = $$new_props.position);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		position,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("position" in $$props) $$invalidate(3, position = $$new_props.position);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "fab-buttons", `fab-buttons-${position}`, Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, position, $$scope, slots];
}

class Fab_buttons extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$q, create_fragment$r, safe_not_equal, { class: 2, position: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Fab_buttons",
			options,
			id: create_fragment$r.name
		});
	}

	get class() {
		throw new Error("<Fab_buttons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Fab_buttons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get position() {
		throw new Error("<Fab_buttons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set position(value) {
		throw new Error("<Fab_buttons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/fab.svelte generated by Svelte v3.31.0 */
const file$s = "node_modules/framework7-svelte/components/fab.svelte";
const get_root_slot_changes = dirty => ({});
const get_root_slot_context = ctx => ({});
const get_link_slot_changes = dirty => ({});
const get_link_slot_context = ctx => ({});
const get_text_slot_changes$1 = dirty => ({});
const get_text_slot_context$1 = ctx => ({});

// (114:4) {#if typeof text !== 'undefined' || hasTextSlots}
function create_if_block$7(ctx) {
	let div;
	let t_value = Utils.text(/*text*/ ctx[2]) + "";
	let t;
	let current;
	const text_slot_template = /*#slots*/ ctx[18].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[17], get_text_slot_context$1);

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			if (text_slot) text_slot.c();
			attr_dev(div, "class", "fab-text");
			add_location(div, file$s, 114, 6, 2832);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);

			if (text_slot) {
				text_slot.m(div, null);
			}

			/*div_binding*/ ctx[19](div);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*text*/ 4) && t_value !== (t_value = Utils.text(/*text*/ ctx[2]) + "")) set_data_dev(t, t_value);

			if (text_slot) {
				if (text_slot.p && dirty & /*$$scope*/ 131072) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[17], dirty, get_text_slot_changes$1, get_text_slot_context$1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (text_slot) text_slot.d(detaching);
			/*div_binding*/ ctx[19](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(114:4) {#if typeof text !== 'undefined' || hasTextSlots}",
		ctx
	});

	return block;
}

function create_fragment$s(ctx) {
	let div;
	let a;
	let t0;
	let t1;
	let t2;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);
	let if_block = (typeof /*text*/ ctx[2] !== "undefined" || /*hasTextSlots*/ ctx[5]) && create_if_block$7(ctx);
	const link_slot_template = /*#slots*/ ctx[18].link;
	const link_slot = create_slot(link_slot_template, ctx, /*$$scope*/ ctx[17], get_link_slot_context);
	const root_slot_template = /*#slots*/ ctx[18].root;
	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[17], get_root_slot_context);

	let div_levels = [
		{ class: /*classes*/ ctx[9] },
		{ "data-morph-to": /*morphTo*/ ctx[0] },
		{ "data-f7-slot": /*f7Slot*/ ctx[3] },
		restProps(/*$$restProps*/ ctx[11])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			a = element("a");
			if (default_slot) default_slot.c();
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			if (link_slot) link_slot.c();
			t2 = space();
			if (root_slot) root_slot.c();
			attr_dev(a, "target", /*target*/ ctx[1]);
			attr_dev(a, "href", /*hrefComputed*/ ctx[8]);
			add_location(a, file$s, 111, 2, 2681);
			set_attributes(div, div_data);
			add_location(div, file$s, 104, 0, 2557);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, a);

			if (default_slot) {
				default_slot.m(a, null);
			}

			append_dev(a, t0);
			if (if_block) if_block.m(a, null);
			append_dev(a, t1);

			if (link_slot) {
				link_slot.m(a, null);
			}

			/*a_binding*/ ctx[20](a);
			append_dev(div, t2);

			if (root_slot) {
				root_slot.m(div, null);
			}

			/*div_binding_1*/ ctx[21](div);
			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[10], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 131072) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[17], dirty, null, null);
				}
			}

			if (typeof /*text*/ ctx[2] !== "undefined" || /*hasTextSlots*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*text, hasTextSlots*/ 36) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$7(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(a, t1);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (link_slot) {
				if (link_slot.p && dirty & /*$$scope*/ 131072) {
					update_slot(link_slot, link_slot_template, ctx, /*$$scope*/ ctx[17], dirty, get_link_slot_changes, get_link_slot_context);
				}
			}

			if (!current || dirty & /*target*/ 2) {
				attr_dev(a, "target", /*target*/ ctx[1]);
			}

			if (!current || dirty & /*hrefComputed*/ 256) {
				attr_dev(a, "href", /*hrefComputed*/ ctx[8]);
			}

			if (root_slot) {
				if (root_slot.p && dirty & /*$$scope*/ 131072) {
					update_slot(root_slot, root_slot_template, ctx, /*$$scope*/ ctx[17], dirty, get_root_slot_changes, get_root_slot_context);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 512) && { class: /*classes*/ ctx[9] },
				(!current || dirty & /*morphTo*/ 1) && { "data-morph-to": /*morphTo*/ ctx[0] },
				(!current || dirty & /*f7Slot*/ 8) && { "data-f7-slot": /*f7Slot*/ ctx[3] },
				dirty & /*$$restProps*/ 2048 && restProps(/*$$restProps*/ ctx[11])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			transition_in(if_block);
			transition_in(link_slot, local);
			transition_in(root_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			transition_out(if_block);
			transition_out(link_slot, local);
			transition_out(root_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			if (link_slot) link_slot.d(detaching);
			/*a_binding*/ ctx[20](null);
			if (root_slot) root_slot.d(detaching);
			/*div_binding_1*/ ctx[21](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$r($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","morphTo","href","target","text","position","tooltip","tooltipTrigger","f7Slot"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Fab", slots, ['default','text','link','root']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { morphTo = undefined } = $$props;
	let { href = undefined } = $$props;
	let { target = undefined } = $$props;
	let { text = undefined } = $$props;
	let { position = "right-bottom" } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let { f7Slot = "fixed" } = $$props;
	let el;
	let linkEl;
	let textEl;
	let f7Tooltip;
	let tooltipText = tooltip;

	function watchTooltip(newText) {
		const oldText = tooltipText;
		if (oldText === newText) return;
		tooltipText = newText;

		if (!newText && f7Tooltip) {
			f7Tooltip.destroy();
			f7Tooltip = null;
			return;
		}

		if (newText && !f7Tooltip && f7.instance) {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: linkEl,
				text: newText,
				trigger: tooltipTrigger
			});

			return;
		}

		if (!newText || !f7Tooltip) return;
		f7Tooltip.setText(newText);
	}

	function onClick() {
		dispatch("click");
		if (typeof $$props.onClick === "function") $$props.onClick();
	}

	onMount(() => {
		f7.ready(() => {
			const dom7 = f7.instance.$;
			const rootEls = dom7(linkEl).children(".fab-buttons");

			if (rootEls.length) {
				dom7(el).append(rootEls);
			}

			if (tooltip) {
				f7Tooltip = f7.instance.tooltip.create({
					targetEl: linkEl,
					text: tooltip,
					trigger: tooltipTrigger
				});
			}
		});
	});

	afterUpdate(() => {
		if (!f7.instance) return;
		const dom7 = f7.instance.$;
		const rootEls = dom7(linkEl).children(".fab-buttons");

		if (rootEls.length) {
			dom7(el).append(rootEls);
		}
	});

	onDestroy(() => {
		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
			f7Tooltip = null;
		}
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			textEl = $$value;
			$$invalidate(4, textEl);
		});
	}

	function a_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			linkEl = $$value;
			$$invalidate(7, linkEl);
		});
	}

	function div_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(6, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(26, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(12, className = $$new_props.class);
		if ("morphTo" in $$new_props) $$invalidate(0, morphTo = $$new_props.morphTo);
		if ("href" in $$new_props) $$invalidate(13, href = $$new_props.href);
		if ("target" in $$new_props) $$invalidate(1, target = $$new_props.target);
		if ("text" in $$new_props) $$invalidate(2, text = $$new_props.text);
		if ("position" in $$new_props) $$invalidate(14, position = $$new_props.position);
		if ("tooltip" in $$new_props) $$invalidate(15, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$new_props) $$invalidate(16, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("f7Slot" in $$new_props) $$invalidate(3, f7Slot = $$new_props.f7Slot);
		if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		afterUpdate,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		hasSlots,
		dispatch,
		className,
		morphTo,
		href,
		target,
		text,
		position,
		tooltip,
		tooltipTrigger,
		f7Slot,
		el,
		linkEl,
		textEl,
		f7Tooltip,
		tooltipText,
		watchTooltip,
		onClick,
		hrefComputed,
		hasTextSlots,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(26, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(12, className = $$new_props.className);
		if ("morphTo" in $$props) $$invalidate(0, morphTo = $$new_props.morphTo);
		if ("href" in $$props) $$invalidate(13, href = $$new_props.href);
		if ("target" in $$props) $$invalidate(1, target = $$new_props.target);
		if ("text" in $$props) $$invalidate(2, text = $$new_props.text);
		if ("position" in $$props) $$invalidate(14, position = $$new_props.position);
		if ("tooltip" in $$props) $$invalidate(15, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$props) $$invalidate(16, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("f7Slot" in $$props) $$invalidate(3, f7Slot = $$new_props.f7Slot);
		if ("el" in $$props) $$invalidate(6, el = $$new_props.el);
		if ("linkEl" in $$props) $$invalidate(7, linkEl = $$new_props.linkEl);
		if ("textEl" in $$props) $$invalidate(4, textEl = $$new_props.textEl);
		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
		if ("hrefComputed" in $$props) $$invalidate(8, hrefComputed = $$new_props.hrefComputed);
		if ("hasTextSlots" in $$props) $$invalidate(5, hasTextSlots = $$new_props.hasTextSlots);
		if ("classes" in $$props) $$invalidate(9, classes = $$new_props.classes);
	};

	let hrefComputed;
	let hasTextSlots;
	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*href*/ 8192) {
			 $$invalidate(8, hrefComputed = href === true ? "#" : href || undefined);
		}

		 $$invalidate(9, classes = Utils.classNames(
			className,
			"fab",
			`fab-${position}`,
			{
				"fab-morph": morphTo,
				"fab-extended": text || hasTextSlots || typeof textEl !== "undefined"
			},
			Mixins.colorClasses($$props)
		));

		if ($$self.$$.dirty & /*tooltip*/ 32768) {
			 watchTooltip(tooltip);
		}
	};

	 $$invalidate(5, hasTextSlots = hasSlots(arguments, "text"));
	$$props = exclude_internal_props($$props);

	return [
		morphTo,
		target,
		text,
		f7Slot,
		textEl,
		hasTextSlots,
		el,
		linkEl,
		hrefComputed,
		classes,
		onClick,
		$$restProps,
		className,
		href,
		position,
		tooltip,
		tooltipTrigger,
		$$scope,
		slots,
		div_binding,
		a_binding,
		div_binding_1
	];
}

class Fab extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$r, create_fragment$s, safe_not_equal, {
			class: 12,
			morphTo: 0,
			href: 13,
			target: 1,
			text: 2,
			position: 14,
			tooltip: 15,
			tooltipTrigger: 16,
			f7Slot: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Fab",
			options,
			id: create_fragment$s.name
		});
	}

	get class() {
		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get morphTo() {
		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set morphTo(value) {
		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get target() {
		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set target(value) {
		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get position() {
		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set position(value) {
		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltip() {
		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltip(value) {
		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltipTrigger() {
		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltipTrigger(value) {
		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get f7Slot() {
		throw new Error("<Fab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set f7Slot(value) {
		throw new Error("<Fab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/gauge.svelte generated by Svelte v3.31.0 */
const file$t = "node_modules/framework7-svelte/components/gauge.svelte";

// (42:4) {#if semiCircle}
function create_if_block_4$1(ctx) {
	let path0;
	let path0_d_value;
	let path0_fill_value;
	let path1;
	let path1_d_value;
	let path1_stroke_dasharray_value;
	let path1_stroke_dashoffset_value;
	let path1_fill_value;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			attr_dev(path0, "class", "gauge-back-semi");
			attr_dev(path0, "d", path0_d_value = `M${/*size*/ ctx[0] - /*borderWidth*/ ctx[4] / 2},${/*size*/ ctx[0] / 2} a1,1 0 0,0 -${/*size*/ ctx[0] - /*borderWidth*/ ctx[4]},0`);
			attr_dev(path0, "stroke", /*borderBgColor*/ ctx[2]);
			attr_dev(path0, "stroke-width", /*borderWidth*/ ctx[4]);
			attr_dev(path0, "fill", path0_fill_value = /*bgColor*/ ctx[1] || "none");
			add_location(path0, file$t, 42, 6, 1170);
			attr_dev(path1, "class", "gauge-front-semi");
			attr_dev(path1, "d", path1_d_value = `M${/*size*/ ctx[0] - /*borderWidth*/ ctx[4] / 2},${/*size*/ ctx[0] / 2} a1,1 0 0,0 -${/*size*/ ctx[0] - /*borderWidth*/ ctx[4]},0`);
			attr_dev(path1, "stroke", /*borderColor*/ ctx[3]);
			attr_dev(path1, "stroke-width", /*borderWidth*/ ctx[4]);
			attr_dev(path1, "stroke-dasharray", path1_stroke_dasharray_value = /*length*/ ctx[16] / 2);
			attr_dev(path1, "stroke-dashoffset", path1_stroke_dashoffset_value = /*length*/ ctx[16] / 2 * (1 + /*progress*/ ctx[17]));

			attr_dev(path1, "fill", path1_fill_value = /*borderBgColor*/ ctx[2]
			? "none"
			: /*bgColor*/ ctx[1] || "none");

			add_location(path1, file$t, 49, 6, 1413);
		},
		m: function mount(target, anchor) {
			insert_dev(target, path0, anchor);
			insert_dev(target, path1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*size, borderWidth*/ 17 && path0_d_value !== (path0_d_value = `M${/*size*/ ctx[0] - /*borderWidth*/ ctx[4] / 2},${/*size*/ ctx[0] / 2} a1,1 0 0,0 -${/*size*/ ctx[0] - /*borderWidth*/ ctx[4]},0`)) {
				attr_dev(path0, "d", path0_d_value);
			}

			if (dirty & /*borderBgColor*/ 4) {
				attr_dev(path0, "stroke", /*borderBgColor*/ ctx[2]);
			}

			if (dirty & /*borderWidth*/ 16) {
				attr_dev(path0, "stroke-width", /*borderWidth*/ ctx[4]);
			}

			if (dirty & /*bgColor*/ 2 && path0_fill_value !== (path0_fill_value = /*bgColor*/ ctx[1] || "none")) {
				attr_dev(path0, "fill", path0_fill_value);
			}

			if (dirty & /*size, borderWidth*/ 17 && path1_d_value !== (path1_d_value = `M${/*size*/ ctx[0] - /*borderWidth*/ ctx[4] / 2},${/*size*/ ctx[0] / 2} a1,1 0 0,0 -${/*size*/ ctx[0] - /*borderWidth*/ ctx[4]},0`)) {
				attr_dev(path1, "d", path1_d_value);
			}

			if (dirty & /*borderColor*/ 8) {
				attr_dev(path1, "stroke", /*borderColor*/ ctx[3]);
			}

			if (dirty & /*borderWidth*/ 16) {
				attr_dev(path1, "stroke-width", /*borderWidth*/ ctx[4]);
			}

			if (dirty & /*length*/ 65536 && path1_stroke_dasharray_value !== (path1_stroke_dasharray_value = /*length*/ ctx[16] / 2)) {
				attr_dev(path1, "stroke-dasharray", path1_stroke_dasharray_value);
			}

			if (dirty & /*length, progress*/ 196608 && path1_stroke_dashoffset_value !== (path1_stroke_dashoffset_value = /*length*/ ctx[16] / 2 * (1 + /*progress*/ ctx[17]))) {
				attr_dev(path1, "stroke-dashoffset", path1_stroke_dashoffset_value);
			}

			if (dirty & /*borderBgColor, bgColor*/ 6 && path1_fill_value !== (path1_fill_value = /*borderBgColor*/ ctx[2]
			? "none"
			: /*bgColor*/ ctx[1] || "none")) {
				attr_dev(path1, "fill", path1_fill_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$1.name,
		type: "if",
		source: "(42:4) {#if semiCircle}",
		ctx
	});

	return block;
}

// (60:4) {#if !semiCircle}
function create_if_block_2$4(ctx) {
	let circle;
	let circle_transform_value;
	let circle_stroke_dashoffset_value;
	let circle_fill_value;
	let circle_cx_value;
	let circle_cy_value;
	let if_block = /*borderBgColor*/ ctx[2] && create_if_block_3$3(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			circle = svg_element("circle");
			attr_dev(circle, "class", "gauge-front-circle");
			attr_dev(circle, "transform", circle_transform_value = `rotate(-90 ${/*size*/ ctx[0] / 2} ${/*size*/ ctx[0] / 2})`);
			attr_dev(circle, "stroke", /*borderColor*/ ctx[3]);
			attr_dev(circle, "stroke-width", /*borderWidth*/ ctx[4]);
			attr_dev(circle, "stroke-dasharray", /*length*/ ctx[16]);
			attr_dev(circle, "stroke-dashoffset", circle_stroke_dashoffset_value = /*length*/ ctx[16] * (1 - /*progress*/ ctx[17]));

			attr_dev(circle, "fill", circle_fill_value = /*borderBgColor*/ ctx[2]
			? "none"
			: /*bgColor*/ ctx[1] || "none");

			attr_dev(circle, "cx", circle_cx_value = /*size*/ ctx[0] / 2);
			attr_dev(circle, "cy", circle_cy_value = /*size*/ ctx[0] / 2);
			attr_dev(circle, "r", /*radius*/ ctx[13]);
			add_location(circle, file$t, 71, 6, 2085);
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, circle, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*borderBgColor*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3$3(ctx);
					if_block.c();
					if_block.m(circle.parentNode, circle);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*size*/ 1 && circle_transform_value !== (circle_transform_value = `rotate(-90 ${/*size*/ ctx[0] / 2} ${/*size*/ ctx[0] / 2})`)) {
				attr_dev(circle, "transform", circle_transform_value);
			}

			if (dirty & /*borderColor*/ 8) {
				attr_dev(circle, "stroke", /*borderColor*/ ctx[3]);
			}

			if (dirty & /*borderWidth*/ 16) {
				attr_dev(circle, "stroke-width", /*borderWidth*/ ctx[4]);
			}

			if (dirty & /*length*/ 65536) {
				attr_dev(circle, "stroke-dasharray", /*length*/ ctx[16]);
			}

			if (dirty & /*length, progress*/ 196608 && circle_stroke_dashoffset_value !== (circle_stroke_dashoffset_value = /*length*/ ctx[16] * (1 - /*progress*/ ctx[17]))) {
				attr_dev(circle, "stroke-dashoffset", circle_stroke_dashoffset_value);
			}

			if (dirty & /*borderBgColor, bgColor*/ 6 && circle_fill_value !== (circle_fill_value = /*borderBgColor*/ ctx[2]
			? "none"
			: /*bgColor*/ ctx[1] || "none")) {
				attr_dev(circle, "fill", circle_fill_value);
			}

			if (dirty & /*size*/ 1 && circle_cx_value !== (circle_cx_value = /*size*/ ctx[0] / 2)) {
				attr_dev(circle, "cx", circle_cx_value);
			}

			if (dirty & /*size*/ 1 && circle_cy_value !== (circle_cy_value = /*size*/ ctx[0] / 2)) {
				attr_dev(circle, "cy", circle_cy_value);
			}

			if (dirty & /*radius*/ 8192) {
				attr_dev(circle, "r", /*radius*/ ctx[13]);
			}
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$4.name,
		type: "if",
		source: "(60:4) {#if !semiCircle}",
		ctx
	});

	return block;
}

// (61:6) {#if borderBgColor}
function create_if_block_3$3(ctx) {
	let circle;
	let circle_fill_value;
	let circle_cx_value;
	let circle_cy_value;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			attr_dev(circle, "class", "gauge-back-circle");
			attr_dev(circle, "stroke", /*borderBgColor*/ ctx[2]);
			attr_dev(circle, "stroke-width", /*borderWidth*/ ctx[4]);
			attr_dev(circle, "fill", circle_fill_value = /*bgColor*/ ctx[1] || "none");
			attr_dev(circle, "cx", circle_cx_value = /*size*/ ctx[0] / 2);
			attr_dev(circle, "cy", circle_cy_value = /*size*/ ctx[0] / 2);
			attr_dev(circle, "r", /*radius*/ ctx[13]);
			add_location(circle, file$t, 61, 8, 1838);
		},
		m: function mount(target, anchor) {
			insert_dev(target, circle, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*borderBgColor*/ 4) {
				attr_dev(circle, "stroke", /*borderBgColor*/ ctx[2]);
			}

			if (dirty & /*borderWidth*/ 16) {
				attr_dev(circle, "stroke-width", /*borderWidth*/ ctx[4]);
			}

			if (dirty & /*bgColor*/ 2 && circle_fill_value !== (circle_fill_value = /*bgColor*/ ctx[1] || "none")) {
				attr_dev(circle, "fill", circle_fill_value);
			}

			if (dirty & /*size*/ 1 && circle_cx_value !== (circle_cx_value = /*size*/ ctx[0] / 2)) {
				attr_dev(circle, "cx", circle_cx_value);
			}

			if (dirty & /*size*/ 1 && circle_cy_value !== (circle_cy_value = /*size*/ ctx[0] / 2)) {
				attr_dev(circle, "cy", circle_cy_value);
			}

			if (dirty & /*radius*/ 8192) {
				attr_dev(circle, "r", /*radius*/ ctx[13]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$3.name,
		type: "if",
		source: "(61:6) {#if borderBgColor}",
		ctx
	});

	return block;
}

// (85:4) {#if valueText}
function create_if_block_1$4(ctx) {
	let text_1;
	let t;
	let text_1_y_value;
	let text_1_dy_value;
	let text_1_dominant_baseline_value;

	const block = {
		c: function create() {
			text_1 = svg_element("text");
			t = text(/*valueText*/ ctx[5]);
			attr_dev(text_1, "class", "gauge-value-text");
			attr_dev(text_1, "x", "50%");
			attr_dev(text_1, "y", text_1_y_value = /*semiCircle*/ ctx[15] ? "100%" : "50%");
			attr_dev(text_1, "font-weight", /*valueFontWeight*/ ctx[8]);
			attr_dev(text_1, "font-size", /*valueFontSize*/ ctx[7]);
			attr_dev(text_1, "fill", /*valueTextColor*/ ctx[6]);

			attr_dev(text_1, "dy", text_1_dy_value = /*semiCircle*/ ctx[15]
			? /*labelText*/ ctx[9]
				? -/*labelFontSize*/ ctx[11] - 15
				: -5
			: 0);

			attr_dev(text_1, "text-anchor", "middle");
			attr_dev(text_1, "dominant-baseline", text_1_dominant_baseline_value = !/*semiCircle*/ ctx[15] ? "middle" : null);
			add_location(text_1, file$t, 85, 6, 2502);
		},
		m: function mount(target, anchor) {
			insert_dev(target, text_1, anchor);
			append_dev(text_1, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*valueText*/ 32) set_data_dev(t, /*valueText*/ ctx[5]);

			if (dirty & /*semiCircle*/ 32768 && text_1_y_value !== (text_1_y_value = /*semiCircle*/ ctx[15] ? "100%" : "50%")) {
				attr_dev(text_1, "y", text_1_y_value);
			}

			if (dirty & /*valueFontWeight*/ 256) {
				attr_dev(text_1, "font-weight", /*valueFontWeight*/ ctx[8]);
			}

			if (dirty & /*valueFontSize*/ 128) {
				attr_dev(text_1, "font-size", /*valueFontSize*/ ctx[7]);
			}

			if (dirty & /*valueTextColor*/ 64) {
				attr_dev(text_1, "fill", /*valueTextColor*/ ctx[6]);
			}

			if (dirty & /*semiCircle, labelText, labelFontSize*/ 35328 && text_1_dy_value !== (text_1_dy_value = /*semiCircle*/ ctx[15]
			? /*labelText*/ ctx[9]
				? -/*labelFontSize*/ ctx[11] - 15
				: -5
			: 0)) {
				attr_dev(text_1, "dy", text_1_dy_value);
			}

			if (dirty & /*semiCircle*/ 32768 && text_1_dominant_baseline_value !== (text_1_dominant_baseline_value = !/*semiCircle*/ ctx[15] ? "middle" : null)) {
				attr_dev(text_1, "dominant-baseline", text_1_dominant_baseline_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(text_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(85:4) {#if valueText}",
		ctx
	});

	return block;
}

// (98:4) {#if labelText}
function create_if_block$8(ctx) {
	let text_1;
	let t;
	let text_1_y_value;
	let text_1_dy_value;
	let text_1_dominant_baseline_value;

	const block = {
		c: function create() {
			text_1 = svg_element("text");
			t = text(/*labelText*/ ctx[9]);
			attr_dev(text_1, "class", "gauge-label-text");
			attr_dev(text_1, "x", "50%");
			attr_dev(text_1, "y", text_1_y_value = /*semiCircle*/ ctx[15] ? "100%" : "50%");
			attr_dev(text_1, "font-weight", /*labelFontWeight*/ ctx[12]);
			attr_dev(text_1, "font-size", /*labelFontSize*/ ctx[11]);
			attr_dev(text_1, "fill", /*labelTextColor*/ ctx[10]);

			attr_dev(text_1, "dy", text_1_dy_value = /*semiCircle*/ ctx[15]
			? -5
			: /*valueText*/ ctx[5]
				? /*valueFontSize*/ ctx[7] / 2 + 10
				: 0);

			attr_dev(text_1, "text-anchor", "middle");
			attr_dev(text_1, "dominant-baseline", text_1_dominant_baseline_value = !/*semiCircle*/ ctx[15] ? "middle" : null);
			add_location(text_1, file$t, 98, 6, 2917);
		},
		m: function mount(target, anchor) {
			insert_dev(target, text_1, anchor);
			append_dev(text_1, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*labelText*/ 512) set_data_dev(t, /*labelText*/ ctx[9]);

			if (dirty & /*semiCircle*/ 32768 && text_1_y_value !== (text_1_y_value = /*semiCircle*/ ctx[15] ? "100%" : "50%")) {
				attr_dev(text_1, "y", text_1_y_value);
			}

			if (dirty & /*labelFontWeight*/ 4096) {
				attr_dev(text_1, "font-weight", /*labelFontWeight*/ ctx[12]);
			}

			if (dirty & /*labelFontSize*/ 2048) {
				attr_dev(text_1, "font-size", /*labelFontSize*/ ctx[11]);
			}

			if (dirty & /*labelTextColor*/ 1024) {
				attr_dev(text_1, "fill", /*labelTextColor*/ ctx[10]);
			}

			if (dirty & /*semiCircle, valueText, valueFontSize*/ 32928 && text_1_dy_value !== (text_1_dy_value = /*semiCircle*/ ctx[15]
			? -5
			: /*valueText*/ ctx[5]
				? /*valueFontSize*/ ctx[7] / 2 + 10
				: 0)) {
				attr_dev(text_1, "dy", text_1_dy_value);
			}

			if (dirty & /*semiCircle*/ 32768 && text_1_dominant_baseline_value !== (text_1_dominant_baseline_value = !/*semiCircle*/ ctx[15] ? "middle" : null)) {
				attr_dev(text_1, "dominant-baseline", text_1_dominant_baseline_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(text_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$8.name,
		type: "if",
		source: "(98:4) {#if labelText}",
		ctx
	});

	return block;
}

function create_fragment$t(ctx) {
	let div;
	let svg;
	let if_block0_anchor;
	let if_block1_anchor;
	let if_block2_anchor;
	let svg_width_value;
	let svg_height_value;
	let svg_viewBox_value;
	let if_block0 = /*semiCircle*/ ctx[15] && create_if_block_4$1(ctx);
	let if_block1 = !/*semiCircle*/ ctx[15] && create_if_block_2$4(ctx);
	let if_block2 = /*valueText*/ ctx[5] && create_if_block_1$4(ctx);
	let if_block3 = /*labelText*/ ctx[9] && create_if_block$8(ctx);
	let div_levels = [{ class: /*classes*/ ctx[14] }, restProps(/*$$restProps*/ ctx[18])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");
			if (if_block0) if_block0.c();
			if_block0_anchor = empty();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
			if (if_block3) if_block3.c();
			attr_dev(svg, "class", "gauge-svg");
			attr_dev(svg, "width", svg_width_value = `${/*size*/ ctx[0]}px`);

			attr_dev(svg, "height", svg_height_value = `${/*semiCircle*/ ctx[15]
			? /*size*/ ctx[0] / 2
			: /*size*/ ctx[0]}px`);

			attr_dev(svg, "viewBox", svg_viewBox_value = `0 0 ${/*size*/ ctx[0]} ${/*semiCircle*/ ctx[15]
			? /*size*/ ctx[0] / 2
			: /*size*/ ctx[0]}`);

			add_location(svg, file$t, 35, 2, 979);
			set_attributes(div, div_data);
			add_location(div, file$t, 34, 0, 927);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, svg);
			if (if_block0) if_block0.m(svg, null);
			append_dev(svg, if_block0_anchor);
			if (if_block1) if_block1.m(svg, null);
			append_dev(svg, if_block1_anchor);
			if (if_block2) if_block2.m(svg, null);
			append_dev(svg, if_block2_anchor);
			if (if_block3) if_block3.m(svg, null);
		},
		p: function update(ctx, [dirty]) {
			if (/*semiCircle*/ ctx[15]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4$1(ctx);
					if_block0.c();
					if_block0.m(svg, if_block0_anchor);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!/*semiCircle*/ ctx[15]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2$4(ctx);
					if_block1.c();
					if_block1.m(svg, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*valueText*/ ctx[5]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_1$4(ctx);
					if_block2.c();
					if_block2.m(svg, if_block2_anchor);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*labelText*/ ctx[9]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block$8(ctx);
					if_block3.c();
					if_block3.m(svg, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (dirty & /*size*/ 1 && svg_width_value !== (svg_width_value = `${/*size*/ ctx[0]}px`)) {
				attr_dev(svg, "width", svg_width_value);
			}

			if (dirty & /*semiCircle, size*/ 32769 && svg_height_value !== (svg_height_value = `${/*semiCircle*/ ctx[15]
			? /*size*/ ctx[0] / 2
			: /*size*/ ctx[0]}px`)) {
				attr_dev(svg, "height", svg_height_value);
			}

			if (dirty & /*size, semiCircle*/ 32769 && svg_viewBox_value !== (svg_viewBox_value = `0 0 ${/*size*/ ctx[0]} ${/*semiCircle*/ ctx[15]
			? /*size*/ ctx[0] / 2
			: /*size*/ ctx[0]}`)) {
				attr_dev(svg, "viewBox", svg_viewBox_value);
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				dirty & /*classes*/ 16384 && { class: /*classes*/ ctx[14] },
				dirty & /*$$restProps*/ 262144 && restProps(/*$$restProps*/ ctx[18])
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$s($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","type","value","size","bgColor","borderBgColor","borderColor","borderWidth","valueText","valueTextColor","valueFontSize","valueFontWeight","labelText","labelTextColor","labelFontSize","labelFontWeight"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Gauge", slots, []);
	let { class: className = undefined } = $$props;
	let { type = "circle" } = $$props;
	let { value = 0 } = $$props;
	let { size = 200 } = $$props;
	let { bgColor = "transparent" } = $$props;
	let { borderBgColor = "#eeeeee" } = $$props;
	let { borderColor = "#000000" } = $$props;
	let { borderWidth = 10 } = $$props;
	let { valueText = undefined } = $$props;
	let { valueTextColor = "#000000" } = $$props;
	let { valueFontSize = 31 } = $$props;
	let { valueFontWeight = 500 } = $$props;
	let { labelText = undefined } = $$props;
	let { labelTextColor = "#888888" } = $$props;
	let { labelFontSize = 14 } = $$props;
	let { labelFontWeight = 400 } = $$props;

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(18, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(19, className = $$new_props.class);
		if ("type" in $$new_props) $$invalidate(20, type = $$new_props.type);
		if ("value" in $$new_props) $$invalidate(21, value = $$new_props.value);
		if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
		if ("bgColor" in $$new_props) $$invalidate(1, bgColor = $$new_props.bgColor);
		if ("borderBgColor" in $$new_props) $$invalidate(2, borderBgColor = $$new_props.borderBgColor);
		if ("borderColor" in $$new_props) $$invalidate(3, borderColor = $$new_props.borderColor);
		if ("borderWidth" in $$new_props) $$invalidate(4, borderWidth = $$new_props.borderWidth);
		if ("valueText" in $$new_props) $$invalidate(5, valueText = $$new_props.valueText);
		if ("valueTextColor" in $$new_props) $$invalidate(6, valueTextColor = $$new_props.valueTextColor);
		if ("valueFontSize" in $$new_props) $$invalidate(7, valueFontSize = $$new_props.valueFontSize);
		if ("valueFontWeight" in $$new_props) $$invalidate(8, valueFontWeight = $$new_props.valueFontWeight);
		if ("labelText" in $$new_props) $$invalidate(9, labelText = $$new_props.labelText);
		if ("labelTextColor" in $$new_props) $$invalidate(10, labelTextColor = $$new_props.labelTextColor);
		if ("labelFontSize" in $$new_props) $$invalidate(11, labelFontSize = $$new_props.labelFontSize);
		if ("labelFontWeight" in $$new_props) $$invalidate(12, labelFontWeight = $$new_props.labelFontWeight);
	};

	$$self.$capture_state = () => ({
		Utils,
		restProps,
		className,
		type,
		value,
		size,
		bgColor,
		borderBgColor,
		borderColor,
		borderWidth,
		valueText,
		valueTextColor,
		valueFontSize,
		valueFontWeight,
		labelText,
		labelTextColor,
		labelFontSize,
		labelFontWeight,
		classes,
		semiCircle,
		radius,
		length,
		progress
	});

	$$self.$inject_state = $$new_props => {
		if ("className" in $$props) $$invalidate(19, className = $$new_props.className);
		if ("type" in $$props) $$invalidate(20, type = $$new_props.type);
		if ("value" in $$props) $$invalidate(21, value = $$new_props.value);
		if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
		if ("bgColor" in $$props) $$invalidate(1, bgColor = $$new_props.bgColor);
		if ("borderBgColor" in $$props) $$invalidate(2, borderBgColor = $$new_props.borderBgColor);
		if ("borderColor" in $$props) $$invalidate(3, borderColor = $$new_props.borderColor);
		if ("borderWidth" in $$props) $$invalidate(4, borderWidth = $$new_props.borderWidth);
		if ("valueText" in $$props) $$invalidate(5, valueText = $$new_props.valueText);
		if ("valueTextColor" in $$props) $$invalidate(6, valueTextColor = $$new_props.valueTextColor);
		if ("valueFontSize" in $$props) $$invalidate(7, valueFontSize = $$new_props.valueFontSize);
		if ("valueFontWeight" in $$props) $$invalidate(8, valueFontWeight = $$new_props.valueFontWeight);
		if ("labelText" in $$props) $$invalidate(9, labelText = $$new_props.labelText);
		if ("labelTextColor" in $$props) $$invalidate(10, labelTextColor = $$new_props.labelTextColor);
		if ("labelFontSize" in $$props) $$invalidate(11, labelFontSize = $$new_props.labelFontSize);
		if ("labelFontWeight" in $$props) $$invalidate(12, labelFontWeight = $$new_props.labelFontWeight);
		if ("classes" in $$props) $$invalidate(14, classes = $$new_props.classes);
		if ("semiCircle" in $$props) $$invalidate(15, semiCircle = $$new_props.semiCircle);
		if ("radius" in $$props) $$invalidate(13, radius = $$new_props.radius);
		if ("length" in $$props) $$invalidate(16, length = $$new_props.length);
		if ("progress" in $$props) $$invalidate(17, progress = $$new_props.progress);
	};

	let classes;
	let semiCircle;
	let radius;
	let length;
	let progress;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className*/ 524288) {
			 $$invalidate(14, classes = Utils.classNames(className, "gauge"));
		}

		if ($$self.$$.dirty & /*type*/ 1048576) {
			 $$invalidate(15, semiCircle = type === "semicircle");
		}

		if ($$self.$$.dirty & /*size, borderWidth*/ 17) {
			 $$invalidate(13, radius = size / 2 - borderWidth / 2);
		}

		if ($$self.$$.dirty & /*radius*/ 8192) {
			 $$invalidate(16, length = 2 * Math.PI * radius);
		}

		if ($$self.$$.dirty & /*value*/ 2097152) {
			 $$invalidate(17, progress = Math.max(Math.min(value, 1), 0));
		}
	};

	return [
		size,
		bgColor,
		borderBgColor,
		borderColor,
		borderWidth,
		valueText,
		valueTextColor,
		valueFontSize,
		valueFontWeight,
		labelText,
		labelTextColor,
		labelFontSize,
		labelFontWeight,
		radius,
		classes,
		semiCircle,
		length,
		progress,
		$$restProps,
		className,
		type,
		value
	];
}

class Gauge extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$s, create_fragment$t, safe_not_equal, {
			class: 19,
			type: 20,
			value: 21,
			size: 0,
			bgColor: 1,
			borderBgColor: 2,
			borderColor: 3,
			borderWidth: 4,
			valueText: 5,
			valueTextColor: 6,
			valueFontSize: 7,
			valueFontWeight: 8,
			labelText: 9,
			labelTextColor: 10,
			labelFontSize: 11,
			labelFontWeight: 12
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Gauge",
			options,
			id: create_fragment$t.name
		});
	}

	get class() {
		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bgColor() {
		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bgColor(value) {
		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get borderBgColor() {
		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set borderBgColor(value) {
		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get borderColor() {
		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set borderColor(value) {
		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get borderWidth() {
		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set borderWidth(value) {
		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valueText() {
		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valueText(value) {
		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valueTextColor() {
		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valueTextColor(value) {
		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valueFontSize() {
		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valueFontSize(value) {
		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valueFontWeight() {
		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valueFontWeight(value) {
		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get labelText() {
		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set labelText(value) {
		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get labelTextColor() {
		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set labelTextColor(value) {
		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get labelFontSize() {
		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set labelFontSize(value) {
		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get labelFontWeight() {
		throw new Error("<Gauge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set labelFontWeight(value) {
		throw new Error("<Gauge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/toggle.svelte generated by Svelte v3.31.0 */
const file$u = "node_modules/framework7-svelte/components/toggle.svelte";

function create_fragment$u(ctx) {
	let label;
	let input;
	let input_value_value;
	let t;
	let span;
	let mounted;
	let dispose;
	let label_levels = [{ class: /*classes*/ ctx[7] }, restProps(/*$$restProps*/ ctx[9])];
	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	const block = {
		c: function create() {
			label = element("label");
			input = element("input");
			t = space();
			span = element("span");
			attr_dev(input, "type", "checkbox");
			attr_dev(input, "name", /*name*/ ctx[3]);
			input.disabled = /*disabled*/ ctx[1];
			input.readOnly = /*readonly*/ ctx[2];
			input.checked = /*checked*/ ctx[0];

			input.value = input_value_value = typeof /*value*/ ctx[4] === "undefined"
			? ""
			: /*value*/ ctx[4];

			add_location(input, file$u, 78, 2, 1784);
			attr_dev(span, "class", "toggle-icon");
			add_location(span, file$u, 88, 2, 2007);
			set_attributes(label, label_data);
			add_location(label, file$u, 77, 0, 1715);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, input);
			/*input_binding*/ ctx[14](input);
			append_dev(label, t);
			append_dev(label, span);
			/*label_binding*/ ctx[15](label);

			if (!mounted) {
				dispose = listen_dev(input, "change", /*onChange*/ ctx[8], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*name*/ 8) {
				attr_dev(input, "name", /*name*/ ctx[3]);
			}

			if (dirty & /*disabled*/ 2) {
				prop_dev(input, "disabled", /*disabled*/ ctx[1]);
			}

			if (dirty & /*readonly*/ 4) {
				prop_dev(input, "readOnly", /*readonly*/ ctx[2]);
			}

			if (dirty & /*checked*/ 1) {
				prop_dev(input, "checked", /*checked*/ ctx[0]);
			}

			if (dirty & /*value*/ 16 && input_value_value !== (input_value_value = typeof /*value*/ ctx[4] === "undefined"
			? ""
			: /*value*/ ctx[4])) {
				prop_dev(input, "value", input_value_value);
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				dirty & /*classes*/ 128 && { class: /*classes*/ ctx[7] },
				dirty & /*$$restProps*/ 512 && restProps(/*$$restProps*/ ctx[9])
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			/*input_binding*/ ctx[14](null);
			/*label_binding*/ ctx[15](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$u.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$1($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","init","checked","disabled","readonly","name","value","instance","toggle"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Toggle", slots, []);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { init = true } = $$props;
	let { checked = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let { name = undefined } = $$props;
	let { value = undefined } = $$props;
	let el;
	let inputEl;
	let f7Toggle;

	function instance() {
		return f7Toggle;
	}

	function toggle() {
		if (f7Toggle && f7Toggle.toggle) f7Toggle.toggle();
	}

	let initialWatched = false;

	function watchChecked(isChecked) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7Toggle) return;
		f7Toggle.checked = isChecked;
	}

	function onChange(event) {
		dispatch("change", [event]);
		if (typeof $$props.onChange === "function") $$props.onChange(event);
	}

	onMount(() => {
		if (!init) return;

		f7.ready(() => {
			f7Toggle = f7.instance.toggle.create({
				el,
				on: {
					change(toggle) {
						dispatch("toggleChange", [toggle.checked]);
						if (typeof $$props.onToggleChange === "function") $$props.onToggleChange(toggle.checked);
					}
				}
			});
		});
	});

	onDestroy(() => {
		if (f7Toggle && f7Toggle.destroy && f7Toggle.$el) f7Toggle.destroy();
	});

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(6, inputEl);
		});
	}

	function label_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(5, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(20, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(10, className = $$new_props.class);
		if ("init" in $$new_props) $$invalidate(11, init = $$new_props.init);
		if ("checked" in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ("disabled" in $$new_props) $$invalidate(1, disabled = $$new_props.disabled);
		if ("readonly" in $$new_props) $$invalidate(2, readonly = $$new_props.readonly);
		if ("name" in $$new_props) $$invalidate(3, name = $$new_props.name);
		if ("value" in $$new_props) $$invalidate(4, value = $$new_props.value);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		init,
		checked,
		disabled,
		readonly,
		name,
		value,
		el,
		inputEl,
		f7Toggle,
		instance,
		toggle,
		initialWatched,
		watchChecked,
		onChange,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(20, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(10, className = $$new_props.className);
		if ("init" in $$props) $$invalidate(11, init = $$new_props.init);
		if ("checked" in $$props) $$invalidate(0, checked = $$new_props.checked);
		if ("disabled" in $$props) $$invalidate(1, disabled = $$new_props.disabled);
		if ("readonly" in $$props) $$invalidate(2, readonly = $$new_props.readonly);
		if ("name" in $$props) $$invalidate(3, name = $$new_props.name);
		if ("value" in $$props) $$invalidate(4, value = $$new_props.value);
		if ("el" in $$props) $$invalidate(5, el = $$new_props.el);
		if ("inputEl" in $$props) $$invalidate(6, inputEl = $$new_props.inputEl);
		if ("f7Toggle" in $$props) f7Toggle = $$new_props.f7Toggle;
		if ("initialWatched" in $$props) initialWatched = $$new_props.initialWatched;
		if ("classes" in $$props) $$invalidate(7, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(7, classes = Utils.classNames("toggle", className, { disabled }, Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*checked*/ 1) {
			 watchChecked(checked);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		checked,
		disabled,
		readonly,
		name,
		value,
		el,
		inputEl,
		classes,
		onChange,
		$$restProps,
		className,
		init,
		instance,
		toggle,
		input_binding,
		label_binding
	];
}

class Toggle extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance_1$1, create_fragment$u, safe_not_equal, {
			class: 10,
			init: 11,
			checked: 0,
			disabled: 1,
			readonly: 2,
			name: 3,
			value: 4,
			instance: 12,
			toggle: 13
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Toggle",
			options,
			id: create_fragment$u.name
		});
	}

	get class() {
		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get init() {
		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set init(value) {
		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[12];
	}

	set instance(value) {
		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		return this.$$.ctx[13];
	}

	set toggle(value) {
		throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/range.svelte generated by Svelte v3.31.0 */
const file$v = "node_modules/framework7-svelte/components/range.svelte";

// (113:2) {#if input}
function create_if_block$9(ctx) {
	let input_1;

	const block = {
		c: function create() {
			input_1 = element("input");
			attr_dev(input_1, "type", "range");
			attr_dev(input_1, "name", /*name*/ ctx[0]);
			attr_dev(input_1, "id", /*inputId*/ ctx[2]);
			add_location(input_1, file$v, 113, 4, 2714);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*name*/ 1) {
				attr_dev(input_1, "name", /*name*/ ctx[0]);
			}

			if (dirty[0] & /*inputId*/ 4) {
				attr_dev(input_1, "id", /*inputId*/ ctx[2]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$9.name,
		type: "if",
		source: "(113:2) {#if input}",
		ctx
	});

	return block;
}

function create_fragment$v(ctx) {
	let div;
	let t;
	let current;
	let if_block = /*input*/ ctx[1] && create_if_block$9(ctx);
	const default_slot_template = /*#slots*/ ctx[28].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[27], null);
	let div_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[5])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$v, 107, 0, 2624);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[29](div);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*input*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$9(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 134217728) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[27], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty[0] & /*$$restProps*/ 32 && restProps(/*$$restProps*/ ctx[5])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[29](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$v.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$2($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","init","value","min","max","step","label","dual","vertical","verticalReversed","draggableBar","formatLabel","scale","scaleSteps","scaleSubSteps","formatScaleLabel","limitKnobPosition","name","input","inputId","disabled","instance","setValue","getValue"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Range", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { init = true } = $$props;
	let { value = 0 } = $$props;
	let { min = 0 } = $$props;
	let { max = 100 } = $$props;
	let { step = 1 } = $$props;
	let { label = false } = $$props;
	let { dual = false } = $$props;
	let { vertical = false } = $$props;
	let { verticalReversed = false } = $$props;
	let { draggableBar = true } = $$props;
	let { formatLabel = undefined } = $$props;
	let { scale = false } = $$props;
	let { scaleSteps = 5 } = $$props;
	let { scaleSubSteps = 0 } = $$props;
	let { formatScaleLabel = undefined } = $$props;
	let { limitKnobPosition = undefined } = $$props;
	let { name = undefined } = $$props;
	let { input = false } = $$props;
	let { inputId = undefined } = $$props;
	let { disabled = false } = $$props;
	let el;
	let f7Range;

	function instance() {
		return f7Range;
	}

	function setValue(newValue) {
		if (f7Range && f7Range.setValue) f7Range.setValue(newValue);
	}

	function getValue() {
		if (f7Range && f7Range.getValue) {
			return f7Range.getValue();
		}

		return undefined;
	}

	function watchValue(newValue) {
		if (!f7Range) return;
		f7Range.setValue(newValue);
	}

	onMount(() => {
		if (!init) return;

		f7.ready(() => {
			f7Range = f7.instance.range.create(Utils.noUndefinedProps({
				el,
				value,
				min,
				max,
				step,
				label,
				dual,
				draggableBar,
				vertical,
				verticalReversed,
				formatLabel,
				scale,
				scaleSteps,
				scaleSubSteps,
				formatScaleLabel,
				limitKnobPosition,
				on: {
					change(range, val) {
						dispatch("rangeChange", [val]);
						if (typeof $$props.onRangeChange === "function") $$props.onRangeChange(val);
					},
					changed(range, val) {
						dispatch("rangeChanged", [val]);
						if (typeof $$props.onRangeChanged === "function") $$props.onRangeChanged(val);
					}
				}
			}));
		});
	});

	onDestroy(() => {
		if (f7Range && f7Range.destroy) f7Range.destroy();
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(33, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ("init" in $$new_props) $$invalidate(7, init = $$new_props.init);
		if ("value" in $$new_props) $$invalidate(8, value = $$new_props.value);
		if ("min" in $$new_props) $$invalidate(9, min = $$new_props.min);
		if ("max" in $$new_props) $$invalidate(10, max = $$new_props.max);
		if ("step" in $$new_props) $$invalidate(11, step = $$new_props.step);
		if ("label" in $$new_props) $$invalidate(12, label = $$new_props.label);
		if ("dual" in $$new_props) $$invalidate(13, dual = $$new_props.dual);
		if ("vertical" in $$new_props) $$invalidate(14, vertical = $$new_props.vertical);
		if ("verticalReversed" in $$new_props) $$invalidate(15, verticalReversed = $$new_props.verticalReversed);
		if ("draggableBar" in $$new_props) $$invalidate(16, draggableBar = $$new_props.draggableBar);
		if ("formatLabel" in $$new_props) $$invalidate(17, formatLabel = $$new_props.formatLabel);
		if ("scale" in $$new_props) $$invalidate(18, scale = $$new_props.scale);
		if ("scaleSteps" in $$new_props) $$invalidate(19, scaleSteps = $$new_props.scaleSteps);
		if ("scaleSubSteps" in $$new_props) $$invalidate(20, scaleSubSteps = $$new_props.scaleSubSteps);
		if ("formatScaleLabel" in $$new_props) $$invalidate(21, formatScaleLabel = $$new_props.formatScaleLabel);
		if ("limitKnobPosition" in $$new_props) $$invalidate(22, limitKnobPosition = $$new_props.limitKnobPosition);
		if ("name" in $$new_props) $$invalidate(0, name = $$new_props.name);
		if ("input" in $$new_props) $$invalidate(1, input = $$new_props.input);
		if ("inputId" in $$new_props) $$invalidate(2, inputId = $$new_props.inputId);
		if ("disabled" in $$new_props) $$invalidate(23, disabled = $$new_props.disabled);
		if ("$$scope" in $$new_props) $$invalidate(27, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		init,
		value,
		min,
		max,
		step,
		label,
		dual,
		vertical,
		verticalReversed,
		draggableBar,
		formatLabel,
		scale,
		scaleSteps,
		scaleSubSteps,
		formatScaleLabel,
		limitKnobPosition,
		name,
		input,
		inputId,
		disabled,
		el,
		f7Range,
		instance,
		setValue,
		getValue,
		watchValue,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(33, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
		if ("init" in $$props) $$invalidate(7, init = $$new_props.init);
		if ("value" in $$props) $$invalidate(8, value = $$new_props.value);
		if ("min" in $$props) $$invalidate(9, min = $$new_props.min);
		if ("max" in $$props) $$invalidate(10, max = $$new_props.max);
		if ("step" in $$props) $$invalidate(11, step = $$new_props.step);
		if ("label" in $$props) $$invalidate(12, label = $$new_props.label);
		if ("dual" in $$props) $$invalidate(13, dual = $$new_props.dual);
		if ("vertical" in $$props) $$invalidate(14, vertical = $$new_props.vertical);
		if ("verticalReversed" in $$props) $$invalidate(15, verticalReversed = $$new_props.verticalReversed);
		if ("draggableBar" in $$props) $$invalidate(16, draggableBar = $$new_props.draggableBar);
		if ("formatLabel" in $$props) $$invalidate(17, formatLabel = $$new_props.formatLabel);
		if ("scale" in $$props) $$invalidate(18, scale = $$new_props.scale);
		if ("scaleSteps" in $$props) $$invalidate(19, scaleSteps = $$new_props.scaleSteps);
		if ("scaleSubSteps" in $$props) $$invalidate(20, scaleSubSteps = $$new_props.scaleSubSteps);
		if ("formatScaleLabel" in $$props) $$invalidate(21, formatScaleLabel = $$new_props.formatScaleLabel);
		if ("limitKnobPosition" in $$props) $$invalidate(22, limitKnobPosition = $$new_props.limitKnobPosition);
		if ("name" in $$props) $$invalidate(0, name = $$new_props.name);
		if ("input" in $$props) $$invalidate(1, input = $$new_props.input);
		if ("inputId" in $$props) $$invalidate(2, inputId = $$new_props.inputId);
		if ("disabled" in $$props) $$invalidate(23, disabled = $$new_props.disabled);
		if ("el" in $$props) $$invalidate(3, el = $$new_props.el);
		if ("f7Range" in $$props) f7Range = $$new_props.f7Range;
		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(4, classes = Utils.classNames(
			className,
			"range-slider",
			{
				"range-slider-horizontal": !vertical,
				"range-slider-vertical": vertical,
				"range-slider-vertical-reversed": vertical && verticalReversed,
				disabled
			},
			Mixins.colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*value*/ 256) {
			 watchValue(value);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		name,
		input,
		inputId,
		el,
		classes,
		$$restProps,
		className,
		init,
		value,
		min,
		max,
		step,
		label,
		dual,
		vertical,
		verticalReversed,
		draggableBar,
		formatLabel,
		scale,
		scaleSteps,
		scaleSubSteps,
		formatScaleLabel,
		limitKnobPosition,
		disabled,
		instance,
		setValue,
		getValue,
		$$scope,
		slots,
		div_binding
	];
}

class Range extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance_1$2,
			create_fragment$v,
			safe_not_equal,
			{
				class: 6,
				init: 7,
				value: 8,
				min: 9,
				max: 10,
				step: 11,
				label: 12,
				dual: 13,
				vertical: 14,
				verticalReversed: 15,
				draggableBar: 16,
				formatLabel: 17,
				scale: 18,
				scaleSteps: 19,
				scaleSubSteps: 20,
				formatScaleLabel: 21,
				limitKnobPosition: 22,
				name: 0,
				input: 1,
				inputId: 2,
				disabled: 23,
				instance: 24,
				setValue: 25,
				getValue: 26
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Range",
			options,
			id: create_fragment$v.name
		});
	}

	get class() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get init() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set init(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get step() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set step(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dual() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dual(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get vertical() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set vertical(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get verticalReversed() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set verticalReversed(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get draggableBar() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set draggableBar(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get formatLabel() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set formatLabel(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scale() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scale(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scaleSteps() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scaleSteps(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scaleSubSteps() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scaleSubSteps(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get formatScaleLabel() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set formatScaleLabel(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get limitKnobPosition() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set limitKnobPosition(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get input() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputId() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputId(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[24];
	}

	set instance(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setValue() {
		return this.$$.ctx[25];
	}

	set setValue(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getValue() {
		return this.$$.ctx[26];
	}

	set getValue(value) {
		throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/text-editor.svelte generated by Svelte v3.31.0 */
const file$w = "node_modules/framework7-svelte/components/text-editor.svelte";
const get_root_slot_changes$1 = dirty => ({});
const get_root_slot_context$1 = ctx => ({});
const get_root_end_slot_changes = dirty => ({});
const get_root_end_slot_context = ctx => ({});
const get_root_start_slot_changes = dirty => ({});
const get_root_start_slot_context = ctx => ({});

function create_fragment$w(ctx) {
	let div1;
	let t0;
	let div0;
	let t1;
	let t2;
	let current;
	const root_start_slot_template = /*#slots*/ ctx[16]["root-start"];
	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[15], get_root_start_slot_context);
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
	const root_end_slot_template = /*#slots*/ ctx[16]["root-end"];
	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[15], get_root_end_slot_context);
	const root_slot_template = /*#slots*/ ctx[16].root;
	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[15], get_root_slot_context$1);
	let div1_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			if (root_start_slot) root_start_slot.c();
			t0 = space();
			div0 = element("div");
			if (default_slot) default_slot.c();
			t1 = space();
			if (root_end_slot) root_end_slot.c();
			t2 = space();
			if (root_slot) root_slot.c();
			attr_dev(div0, "class", "text-editor-content");
			attr_dev(div0, "contenteditable", "");
			add_location(div0, file$w, 120, 2, 3480);
			set_attributes(div1, div1_data);
			add_location(div1, file$w, 118, 0, 3384);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);

			if (root_start_slot) {
				root_start_slot.m(div1, null);
			}

			append_dev(div1, t0);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			append_dev(div1, t1);

			if (root_end_slot) {
				root_end_slot.m(div1, null);
			}

			append_dev(div1, t2);

			if (root_slot) {
				root_slot.m(div1, null);
			}

			/*div1_binding*/ ctx[17](div1);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (root_start_slot) {
				if (root_start_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(root_start_slot, root_start_slot_template, ctx, /*$$scope*/ ctx[15], dirty, get_root_start_slot_changes, get_root_start_slot_context);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			}

			if (root_end_slot) {
				if (root_end_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(root_end_slot, root_end_slot_template, ctx, /*$$scope*/ ctx[15], dirty, get_root_end_slot_changes, get_root_end_slot_context);
				}
			}

			if (root_slot) {
				if (root_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(root_slot, root_slot_template, ctx, /*$$scope*/ ctx[15], dirty, get_root_slot_changes$1, get_root_slot_context$1);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(root_start_slot, local);
			transition_in(default_slot, local);
			transition_in(root_end_slot, local);
			transition_in(root_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(root_start_slot, local);
			transition_out(default_slot, local);
			transition_out(root_end_slot, local);
			transition_out(root_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (root_start_slot) root_start_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (root_end_slot) root_end_slot.d(detaching);
			if (root_slot) root_slot.d(detaching);
			/*div1_binding*/ ctx[17](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$w.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$3($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","mode","value","buttons","customButtons","dividers","imageUrlText","linkUrlText","placeholder","clearFormattingOnPaste","resizable","instance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Text_editor", slots, ['root-start','default','root-end','root']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { mode = undefined } = $$props;
	let { value = undefined } = $$props;
	let { buttons = undefined } = $$props;
	let { customButtons = undefined } = $$props;
	let { dividers = undefined } = $$props;
	let { imageUrlText = undefined } = $$props;
	let { linkUrlText = undefined } = $$props;
	let { placeholder = undefined } = $$props;
	let { clearFormattingOnPaste = undefined } = $$props;
	let { resizable = false } = $$props;
	let el;
	let f7TextEditor;

	function instance() {
		return f7TextEditor;
	}

	function watchValue(newValue) {
		if (f7TextEditor) {
			f7TextEditor.setValue(newValue);
		}
	}

	function onChange(editor, editorValue) {
		dispatch("textEditorChange", [editorValue]);
		if (typeof $$props.onTextEditorChange === "function") $$props.onTextEditorChange(editorValue);
	}

	function onInput() {
		dispatch("textEditorChange");
		if (typeof $$props.onTextEditorChange === "function") $$props.onTextEditorChange();
	}

	function onFocus() {
		dispatch("textEditorFocus");
		if (typeof $$props.onTextEditorFocus === "function") $$props.onTextEditorFocus();
	}

	function onBlur() {
		dispatch("textEditorBlur");
		if (typeof $$props.onTextEditorBlur === "function") $$props.onTextEditorBlur();
	}

	function onButtonClick(editor, button) {
		dispatch("textEditorButtonClick", [button]);
		if (typeof $$props.onTextEditorButtonClick === "function") $$props.onTextEditorButtonClick(button);
	}

	function onKeyboardOpen() {
		dispatch("textEditorKeyboardOpen");
		if (typeof $$props.onTextEditorKeyboardOpen === "function") $$props.onTextEditorKeyboardOpen();
	}

	function onKeyboardClose() {
		dispatch("textEditorKeyboardClose");
		if (typeof $$props.onTextEditorKeyboardClose === "function") $$props.onTextEditorKeyboardClose();
	}

	function onPopoverOpen() {
		dispatch("textEditorPopoverOpen");
		if (typeof $$props.onTextEditorPopoverOpen === "function") $$props.onTextEditorPopoverOpen();
	}

	function onPopoverClose() {
		dispatch("textEditorPopoverClose");
		if (typeof $$props.onTextEditorPopoverClose === "function") $$props.onTextEditorPopoverClose();
	}

	onMount(() => {
		const params = Utils.noUndefinedProps({
			el,
			mode,
			value,
			buttons,
			customButtons,
			dividers,
			imageUrlText,
			linkUrlText,
			placeholder,
			clearFormattingOnPaste,
			on: {
				change: onChange,
				input: onInput,
				focus: onFocus,
				blur: onBlur,
				buttonClick: onButtonClick,
				keyboardOpen: onKeyboardOpen,
				keyboardClose: onKeyboardClose,
				popoverOpen: onPopoverOpen,
				popoverClose: onPopoverClose
			}
		});

		f7.ready(() => {
			f7TextEditor = f7.instance.textEditor.create(params);
		});
	});

	onDestroy(() => {
		if (f7TextEditor && f7TextEditor.destroy) {
			f7TextEditor.destroy();
		}
	});

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(30, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("mode" in $$new_props) $$invalidate(4, mode = $$new_props.mode);
		if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
		if ("buttons" in $$new_props) $$invalidate(6, buttons = $$new_props.buttons);
		if ("customButtons" in $$new_props) $$invalidate(7, customButtons = $$new_props.customButtons);
		if ("dividers" in $$new_props) $$invalidate(8, dividers = $$new_props.dividers);
		if ("imageUrlText" in $$new_props) $$invalidate(9, imageUrlText = $$new_props.imageUrlText);
		if ("linkUrlText" in $$new_props) $$invalidate(10, linkUrlText = $$new_props.linkUrlText);
		if ("placeholder" in $$new_props) $$invalidate(11, placeholder = $$new_props.placeholder);
		if ("clearFormattingOnPaste" in $$new_props) $$invalidate(12, clearFormattingOnPaste = $$new_props.clearFormattingOnPaste);
		if ("resizable" in $$new_props) $$invalidate(13, resizable = $$new_props.resizable);
		if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		mode,
		value,
		buttons,
		customButtons,
		dividers,
		imageUrlText,
		linkUrlText,
		placeholder,
		clearFormattingOnPaste,
		resizable,
		el,
		f7TextEditor,
		instance,
		watchValue,
		onChange,
		onInput,
		onFocus,
		onBlur,
		onButtonClick,
		onKeyboardOpen,
		onKeyboardClose,
		onPopoverOpen,
		onPopoverClose,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(30, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("mode" in $$props) $$invalidate(4, mode = $$new_props.mode);
		if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
		if ("buttons" in $$props) $$invalidate(6, buttons = $$new_props.buttons);
		if ("customButtons" in $$props) $$invalidate(7, customButtons = $$new_props.customButtons);
		if ("dividers" in $$props) $$invalidate(8, dividers = $$new_props.dividers);
		if ("imageUrlText" in $$props) $$invalidate(9, imageUrlText = $$new_props.imageUrlText);
		if ("linkUrlText" in $$props) $$invalidate(10, linkUrlText = $$new_props.linkUrlText);
		if ("placeholder" in $$props) $$invalidate(11, placeholder = $$new_props.placeholder);
		if ("clearFormattingOnPaste" in $$props) $$invalidate(12, clearFormattingOnPaste = $$new_props.clearFormattingOnPaste);
		if ("resizable" in $$props) $$invalidate(13, resizable = $$new_props.resizable);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("f7TextEditor" in $$props) f7TextEditor = $$new_props.f7TextEditor;
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classes = Utils.classNames(className, "text-editor", resizable && "text-editor-resizable", Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*value*/ 32) {
			 watchValue(value);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		classes,
		$$restProps,
		className,
		mode,
		value,
		buttons,
		customButtons,
		dividers,
		imageUrlText,
		linkUrlText,
		placeholder,
		clearFormattingOnPaste,
		resizable,
		instance,
		$$scope,
		slots,
		div1_binding
	];
}

class Text_editor extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance_1$3, create_fragment$w, safe_not_equal, {
			class: 3,
			mode: 4,
			value: 5,
			buttons: 6,
			customButtons: 7,
			dividers: 8,
			imageUrlText: 9,
			linkUrlText: 10,
			placeholder: 11,
			clearFormattingOnPaste: 12,
			resizable: 13,
			instance: 14
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Text_editor",
			options,
			id: create_fragment$w.name
		});
	}

	get class() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mode() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mode(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get buttons() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set buttons(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get customButtons() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set customButtons(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dividers() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dividers(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get imageUrlText() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set imageUrlText(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linkUrlText() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linkUrlText(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clearFormattingOnPaste() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set clearFormattingOnPaste(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizable() {
		throw new Error("<Text_editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizable(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[14];
	}

	set instance(value) {
		throw new Error("<Text_editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/input.svelte generated by Svelte v3.31.0 */
const file$x = "node_modules/framework7-svelte/components/input.svelte";
const get_info_slot_changes = dirty => ({});
const get_info_slot_context = ctx => ({});

// (614:2) {:else}
function create_else_block_1(ctx) {
	let input;
	let input_validate_value;
	let input_data_validate_value;
	let input_data_validate_on_blur_value;
	let input_data_error_message_value;
	let input_value_value;
	let mounted;
	let dispose;

	let input_levels = [
		{ style: /*inputStyle*/ ctx[23] },
		{ name: /*name*/ ctx[1] },
		{ type: /*inputType*/ ctx[35] },
		{ placeholder: /*placeholder*/ ctx[3] },
		{ id: /*inputId*/ ctx[4] },
		{ size: /*size*/ ctx[5] },
		{ accept: /*accept*/ ctx[6] },
		{ autocomplete: /*autocomplete*/ ctx[7] },
		{ autocorrect: /*autocorrect*/ ctx[8] },
		{
			autocapitalize: /*autocapitalize*/ ctx[9]
		},
		{ spellcheck: /*spellcheck*/ ctx[10] },
		{ autofocus: /*autofocus*/ ctx[11] },
		{ autosave: /*autosave*/ ctx[12] },
		{ checked: /*checked*/ ctx[13] },
		{ disabled: /*disabled*/ ctx[14] },
		{ max: /*max*/ ctx[15] },
		{ maxlength: /*maxlength*/ ctx[18] },
		{ min: /*min*/ ctx[16] },
		{ minlength: /*minlength*/ ctx[19] },
		{ step: /*step*/ ctx[17] },
		{ multiple: /*multiple*/ ctx[20] },
		{ readOnly: /*readonly*/ ctx[21] },
		{ required: /*required*/ ctx[22] },
		{ pattern: /*pattern*/ ctx[24] },
		{
			validate: input_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined
		},
		{
			"data-validate": input_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined
		},
		{
			"data-validate-on-blur": input_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined
		},
		{ tabindex: /*tabindex*/ ctx[27] },
		{
			"data-error-message": input_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30]
		},
		{ class: /*inputClassName*/ ctx[39] },
		{
			value: input_value_value = /*type*/ ctx[0] === "datepicker" || /*type*/ ctx[0] === "colorpicker" || /*type*/ ctx[0] === "file"
			? ""
			: /*inputValue*/ ctx[37]
		},
		restProps(/*$$restProps*/ ctx[45])
	];

	let input_data = {};

	for (let i = 0; i < input_levels.length; i += 1) {
		input_data = assign(input_data, input_levels[i]);
	}

	const block = {
		c: function create() {
			input = element("input");
			set_attributes(input, input_data);
			add_location(input, file$x, 614, 4, 18208);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			input.value = input_data.value;
			/*input_binding_1*/ ctx[64](input);

			if (!mounted) {
				dispose = [
					listen_dev(input, "focus", /*onFocus*/ ctx[42], false, false, false),
					listen_dev(input, "blur", /*onBlur*/ ctx[43], false, false, false),
					listen_dev(input, "input", /*onInput*/ ctx[41], false, false, false),
					listen_dev(input, "change", /*onChange*/ ctx[44], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(input, input_data = get_spread_update(input_levels, [
				dirty[0] & /*inputStyle*/ 8388608 && { style: /*inputStyle*/ ctx[23] },
				dirty[0] & /*name*/ 2 && { name: /*name*/ ctx[1] },
				dirty[1] & /*inputType*/ 16 && { type: /*inputType*/ ctx[35] },
				dirty[0] & /*placeholder*/ 8 && { placeholder: /*placeholder*/ ctx[3] },
				dirty[0] & /*inputId*/ 16 && { id: /*inputId*/ ctx[4] },
				dirty[0] & /*size*/ 32 && { size: /*size*/ ctx[5] },
				dirty[0] & /*accept*/ 64 && { accept: /*accept*/ ctx[6] },
				dirty[0] & /*autocomplete*/ 128 && { autocomplete: /*autocomplete*/ ctx[7] },
				dirty[0] & /*autocorrect*/ 256 && { autocorrect: /*autocorrect*/ ctx[8] },
				dirty[0] & /*autocapitalize*/ 512 && {
					autocapitalize: /*autocapitalize*/ ctx[9]
				},
				dirty[0] & /*spellcheck*/ 1024 && { spellcheck: /*spellcheck*/ ctx[10] },
				dirty[0] & /*autofocus*/ 2048 && { autofocus: /*autofocus*/ ctx[11] },
				dirty[0] & /*autosave*/ 4096 && { autosave: /*autosave*/ ctx[12] },
				dirty[0] & /*checked*/ 8192 && { checked: /*checked*/ ctx[13] },
				dirty[0] & /*disabled*/ 16384 && { disabled: /*disabled*/ ctx[14] },
				dirty[0] & /*max*/ 32768 && { max: /*max*/ ctx[15] },
				dirty[0] & /*maxlength*/ 262144 && { maxlength: /*maxlength*/ ctx[18] },
				dirty[0] & /*min*/ 65536 && { min: /*min*/ ctx[16] },
				dirty[0] & /*minlength*/ 524288 && { minlength: /*minlength*/ ctx[19] },
				dirty[0] & /*step*/ 131072 && { step: /*step*/ ctx[17] },
				dirty[0] & /*multiple*/ 1048576 && { multiple: /*multiple*/ ctx[20] },
				dirty[0] & /*readonly*/ 2097152 && { readOnly: /*readonly*/ ctx[21] },
				dirty[0] & /*required*/ 4194304 && { required: /*required*/ ctx[22] },
				dirty[0] & /*pattern*/ 16777216 && { pattern: /*pattern*/ ctx[24] },
				dirty[0] & /*validate*/ 33554432 && input_validate_value !== (input_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
				? /*validate*/ ctx[25]
				: undefined) && { validate: input_validate_value },
				dirty[0] & /*validate, validateOnBlur*/ 100663296 && input_data_validate_value !== (input_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
				? true
				: undefined) && {
					"data-validate": input_data_validate_value
				},
				dirty[0] & /*validateOnBlur*/ 67108864 && input_data_validate_on_blur_value !== (input_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
				? true
				: undefined) && {
					"data-validate-on-blur": input_data_validate_on_blur_value
				},
				dirty[0] & /*tabindex*/ 134217728 && { tabindex: /*tabindex*/ ctx[27] },
				dirty[0] & /*errorMessage*/ 1073741824 | dirty[1] & /*errorMessageForce*/ 1 && input_data_error_message_value !== (input_data_error_message_value = /*errorMessageForce*/ ctx[31]
				? undefined
				: /*errorMessage*/ ctx[30]) && {
					"data-error-message": input_data_error_message_value
				},
				dirty[1] & /*inputClassName*/ 256 && { class: /*inputClassName*/ ctx[39] },
				dirty[0] & /*type*/ 1 | dirty[1] & /*inputValue*/ 64 && input_value_value !== (input_value_value = /*type*/ ctx[0] === "datepicker" || /*type*/ ctx[0] === "colorpicker" || /*type*/ ctx[0] === "file"
				? ""
				: /*inputValue*/ ctx[37]) && input.value !== input_value_value && { value: input_value_value },
				dirty[1] & /*$$restProps*/ 16384 && restProps(/*$$restProps*/ ctx[45])
			]));

			if ("value" in input_data) {
				input.value = input_data.value;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			/*input_binding_1*/ ctx[64](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(614:2) {:else}",
		ctx
	});

	return block;
}

// (602:34) 
function create_if_block_13(ctx) {
	let texteditor;
	let current;

	const texteditor_spread_levels = [
		{
			value: typeof /*value*/ ctx[2] === "undefined"
			? ""
			: /*value*/ ctx[2]
		},
		{ resizable: /*resizable*/ ctx[28] },
		{ placeholder: /*placeholder*/ ctx[3] },
		{ onTextEditorFocus: /*onFocus*/ ctx[42] },
		{ onTextEditorBlur: /*onBlur*/ ctx[43] },
		{ onTextEditorInput: /*onInput*/ ctx[41] },
		{ onTextEditorChange: /*onChange*/ ctx[44] },
		/*textEditorParams*/ ctx[34],
		restProps(/*$$restProps*/ ctx[45])
	];

	let texteditor_props = {};

	for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
		texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
	}

	texteditor = new Text_editor({ props: texteditor_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(texteditor.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(texteditor, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const texteditor_changes = (dirty[0] & /*value, resizable, placeholder*/ 268435468 | dirty[1] & /*onFocus, onBlur, onInput, onChange, textEditorParams, $$restProps*/ 31752)
			? get_spread_update(texteditor_spread_levels, [
					dirty[0] & /*value*/ 4 && {
						value: typeof /*value*/ ctx[2] === "undefined"
						? ""
						: /*value*/ ctx[2]
					},
					dirty[0] & /*resizable*/ 268435456 && { resizable: /*resizable*/ ctx[28] },
					dirty[0] & /*placeholder*/ 8 && { placeholder: /*placeholder*/ ctx[3] },
					dirty[1] & /*onFocus*/ 2048 && { onTextEditorFocus: /*onFocus*/ ctx[42] },
					dirty[1] & /*onBlur*/ 4096 && { onTextEditorBlur: /*onBlur*/ ctx[43] },
					dirty[1] & /*onInput*/ 1024 && { onTextEditorInput: /*onInput*/ ctx[41] },
					dirty[1] & /*onChange*/ 8192 && { onTextEditorChange: /*onChange*/ ctx[44] },
					dirty[1] & /*textEditorParams*/ 8 && get_spread_object(/*textEditorParams*/ ctx[34]),
					dirty[1] & /*$$restProps*/ 16384 && get_spread_object(restProps(/*$$restProps*/ ctx[45]))
				])
			: {};

			texteditor.$set(texteditor_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(texteditor.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(texteditor.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(texteditor, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_13.name,
		type: "if",
		source: "(602:34) ",
		ctx
	});

	return block;
}

// (589:29) 
function create_if_block_12(ctx) {
	let range;
	let current;

	const range_spread_levels = [
		{ value: /*value*/ ctx[2] },
		{ disabled: /*disabled*/ ctx[14] },
		{ min: /*min*/ ctx[16] },
		{ max: /*max*/ ctx[15] },
		{ step: /*step*/ ctx[17] },
		{ name: /*name*/ ctx[1] },
		{ id: /*inputId*/ ctx[4] },
		{ input: true },
		restProps(/*$$restProps*/ ctx[45])
	];

	let range_props = {};

	for (let i = 0; i < range_spread_levels.length; i += 1) {
		range_props = assign(range_props, range_spread_levels[i]);
	}

	range = new Range({ props: range_props, $$inline: true });
	range.$on("rangeChange", /*onChange*/ ctx[44]);

	const block = {
		c: function create() {
			create_component(range.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(range, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const range_changes = (dirty[0] & /*value, disabled, min, max, step, name, inputId*/ 245782 | dirty[1] & /*$$restProps*/ 16384)
			? get_spread_update(range_spread_levels, [
					dirty[0] & /*value*/ 4 && { value: /*value*/ ctx[2] },
					dirty[0] & /*disabled*/ 16384 && { disabled: /*disabled*/ ctx[14] },
					dirty[0] & /*min*/ 65536 && { min: /*min*/ ctx[16] },
					dirty[0] & /*max*/ 32768 && { max: /*max*/ ctx[15] },
					dirty[0] & /*step*/ 131072 && { step: /*step*/ ctx[17] },
					dirty[0] & /*name*/ 2 && { name: /*name*/ ctx[1] },
					dirty[0] & /*inputId*/ 16 && { id: /*inputId*/ ctx[4] },
					range_spread_levels[7],
					dirty[1] & /*$$restProps*/ 16384 && get_spread_object(restProps(/*$$restProps*/ ctx[45]))
				])
			: {};

			range.$set(range_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(range.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(range.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(range, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_12.name,
		type: "if",
		source: "(589:29) ",
		ctx
	});

	return block;
}

// (578:30) 
function create_if_block_11(ctx) {
	let toggle;
	let current;

	const toggle_spread_levels = [
		{ checked: /*checked*/ ctx[13] },
		{ readonly: /*readonly*/ ctx[21] },
		{ name: /*name*/ ctx[1] },
		{ value: /*value*/ ctx[2] },
		{ disabled: /*disabled*/ ctx[14] },
		{ id: /*inputId*/ ctx[4] },
		restProps(/*$$restProps*/ ctx[45])
	];

	let toggle_props = {};

	for (let i = 0; i < toggle_spread_levels.length; i += 1) {
		toggle_props = assign(toggle_props, toggle_spread_levels[i]);
	}

	toggle = new Toggle({ props: toggle_props, $$inline: true });
	toggle.$on("change", /*onChange*/ ctx[44]);

	const block = {
		c: function create() {
			create_component(toggle.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(toggle, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const toggle_changes = (dirty[0] & /*checked, readonly, name, value, disabled, inputId*/ 2121750 | dirty[1] & /*$$restProps*/ 16384)
			? get_spread_update(toggle_spread_levels, [
					dirty[0] & /*checked*/ 8192 && { checked: /*checked*/ ctx[13] },
					dirty[0] & /*readonly*/ 2097152 && { readonly: /*readonly*/ ctx[21] },
					dirty[0] & /*name*/ 2 && { name: /*name*/ ctx[1] },
					dirty[0] & /*value*/ 4 && { value: /*value*/ ctx[2] },
					dirty[0] & /*disabled*/ 16384 && { disabled: /*disabled*/ ctx[14] },
					dirty[0] & /*inputId*/ 16 && { id: /*inputId*/ ctx[4] },
					dirty[1] & /*$$restProps*/ 16384 && get_spread_object(restProps(/*$$restProps*/ ctx[45]))
				])
			: {};

			toggle.$set(toggle_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(toggle.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(toggle, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_11.name,
		type: "if",
		source: "(578:30) ",
		ctx
	});

	return block;
}

// (539:32) 
function create_if_block_10(ctx) {
	let textarea;
	let textarea_validate_value;
	let textarea_data_validate_value;
	let textarea_data_validate_on_blur_value;
	let textarea_data_error_message_value;
	let mounted;
	let dispose;

	let textarea_levels = [
		{ style: /*inputStyle*/ ctx[23] },
		{ name: /*name*/ ctx[1] },
		{ placeholder: /*placeholder*/ ctx[3] },
		{ id: /*inputId*/ ctx[4] },
		{ size: /*size*/ ctx[5] },
		{ accept: /*accept*/ ctx[6] },
		{ autocomplete: /*autocomplete*/ ctx[7] },
		{ autocorrect: /*autocorrect*/ ctx[8] },
		{
			autocapitalize: /*autocapitalize*/ ctx[9]
		},
		{ spellcheck: /*spellcheck*/ ctx[10] },
		{ autofocus: /*autofocus*/ ctx[11] },
		{ autosave: /*autosave*/ ctx[12] },
		{ checked: /*checked*/ ctx[13] },
		{ disabled: /*disabled*/ ctx[14] },
		{ max: /*max*/ ctx[15] },
		{ maxlength: /*maxlength*/ ctx[18] },
		{ min: /*min*/ ctx[16] },
		{ minlength: /*minlength*/ ctx[19] },
		{ step: /*step*/ ctx[17] },
		{ multiple: /*multiple*/ ctx[20] },
		{ readOnly: /*readonly*/ ctx[21] },
		{ required: /*required*/ ctx[22] },
		{ pattern: /*pattern*/ ctx[24] },
		{
			validate: textarea_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined
		},
		{
			"data-validate": textarea_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined
		},
		{
			"data-validate-on-blur": textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined
		},
		{ tabindex: /*tabindex*/ ctx[27] },
		{
			"data-error-message": textarea_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30]
		},
		{ class: /*inputClassName*/ ctx[39] },
		{ value: /*inputValue*/ ctx[37] },
		restProps(/*$$restProps*/ ctx[45])
	];

	let textarea_data = {};

	for (let i = 0; i < textarea_levels.length; i += 1) {
		textarea_data = assign(textarea_data, textarea_levels[i]);
	}

	const block = {
		c: function create() {
			textarea = element("textarea");
			set_attributes(textarea, textarea_data);
			add_location(textarea, file$x, 539, 4, 16087);
		},
		m: function mount(target, anchor) {
			insert_dev(target, textarea, anchor);
			/*textarea_binding_1*/ ctx[63](textarea);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "focus", /*onFocus*/ ctx[42], false, false, false),
					listen_dev(textarea, "blur", /*onBlur*/ ctx[43], false, false, false),
					listen_dev(textarea, "input", /*onInput*/ ctx[41], false, false, false),
					listen_dev(textarea, "change", /*onChange*/ ctx[44], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
				dirty[0] & /*inputStyle*/ 8388608 && { style: /*inputStyle*/ ctx[23] },
				dirty[0] & /*name*/ 2 && { name: /*name*/ ctx[1] },
				dirty[0] & /*placeholder*/ 8 && { placeholder: /*placeholder*/ ctx[3] },
				dirty[0] & /*inputId*/ 16 && { id: /*inputId*/ ctx[4] },
				dirty[0] & /*size*/ 32 && { size: /*size*/ ctx[5] },
				dirty[0] & /*accept*/ 64 && { accept: /*accept*/ ctx[6] },
				dirty[0] & /*autocomplete*/ 128 && { autocomplete: /*autocomplete*/ ctx[7] },
				dirty[0] & /*autocorrect*/ 256 && { autocorrect: /*autocorrect*/ ctx[8] },
				dirty[0] & /*autocapitalize*/ 512 && {
					autocapitalize: /*autocapitalize*/ ctx[9]
				},
				dirty[0] & /*spellcheck*/ 1024 && { spellcheck: /*spellcheck*/ ctx[10] },
				dirty[0] & /*autofocus*/ 2048 && { autofocus: /*autofocus*/ ctx[11] },
				dirty[0] & /*autosave*/ 4096 && { autosave: /*autosave*/ ctx[12] },
				dirty[0] & /*checked*/ 8192 && { checked: /*checked*/ ctx[13] },
				dirty[0] & /*disabled*/ 16384 && { disabled: /*disabled*/ ctx[14] },
				dirty[0] & /*max*/ 32768 && { max: /*max*/ ctx[15] },
				dirty[0] & /*maxlength*/ 262144 && { maxlength: /*maxlength*/ ctx[18] },
				dirty[0] & /*min*/ 65536 && { min: /*min*/ ctx[16] },
				dirty[0] & /*minlength*/ 524288 && { minlength: /*minlength*/ ctx[19] },
				dirty[0] & /*step*/ 131072 && { step: /*step*/ ctx[17] },
				dirty[0] & /*multiple*/ 1048576 && { multiple: /*multiple*/ ctx[20] },
				dirty[0] & /*readonly*/ 2097152 && { readOnly: /*readonly*/ ctx[21] },
				dirty[0] & /*required*/ 4194304 && { required: /*required*/ ctx[22] },
				dirty[0] & /*pattern*/ 16777216 && { pattern: /*pattern*/ ctx[24] },
				dirty[0] & /*validate*/ 33554432 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
				? /*validate*/ ctx[25]
				: undefined) && { validate: textarea_validate_value },
				dirty[0] & /*validate, validateOnBlur*/ 100663296 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
				? true
				: undefined) && {
					"data-validate": textarea_data_validate_value
				},
				dirty[0] & /*validateOnBlur*/ 67108864 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
				? true
				: undefined) && {
					"data-validate-on-blur": textarea_data_validate_on_blur_value
				},
				dirty[0] & /*tabindex*/ 134217728 && { tabindex: /*tabindex*/ ctx[27] },
				dirty[0] & /*errorMessage*/ 1073741824 | dirty[1] & /*errorMessageForce*/ 1 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/ ctx[31]
				? undefined
				: /*errorMessage*/ ctx[30]) && {
					"data-error-message": textarea_data_error_message_value
				},
				dirty[1] & /*inputClassName*/ 256 && { class: /*inputClassName*/ ctx[39] },
				dirty[1] & /*inputValue*/ 64 && { value: /*inputValue*/ ctx[37] },
				dirty[1] & /*$$restProps*/ 16384 && restProps(/*$$restProps*/ ctx[45])
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			/*textarea_binding_1*/ ctx[63](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10.name,
		type: "if",
		source: "(539:32) ",
		ctx
	});

	return block;
}

// (498:2) {#if type === 'select'}
function create_if_block_9(ctx) {
	let select;
	let select_validate_value;
	let select_data_validate_value;
	let select_data_validate_on_blur_value;
	let select_data_error_message_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[58].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[57], null);

	let select_levels = [
		{ style: /*inputStyle*/ ctx[23] },
		{ name: /*name*/ ctx[1] },
		{ placeholder: /*placeholder*/ ctx[3] },
		{ id: /*inputId*/ ctx[4] },
		{ size: /*size*/ ctx[5] },
		{ accept: /*accept*/ ctx[6] },
		{ autocomplete: /*autocomplete*/ ctx[7] },
		{ autocorrect: /*autocorrect*/ ctx[8] },
		{
			autocapitalize: /*autocapitalize*/ ctx[9]
		},
		{ spellcheck: /*spellcheck*/ ctx[10] },
		{ autofocus: /*autofocus*/ ctx[11] },
		{ autosave: /*autosave*/ ctx[12] },
		{ checked: /*checked*/ ctx[13] },
		{ disabled: /*disabled*/ ctx[14] },
		{ max: /*max*/ ctx[15] },
		{ maxlength: /*maxlength*/ ctx[18] },
		{ min: /*min*/ ctx[16] },
		{ minlength: /*minlength*/ ctx[19] },
		{ step: /*step*/ ctx[17] },
		{ multiple: /*multiple*/ ctx[20] },
		{ readonly: /*readonly*/ ctx[21] },
		{ required: /*required*/ ctx[22] },
		{ pattern: /*pattern*/ ctx[24] },
		{
			validate: select_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined
		},
		{
			"data-validate": select_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined
		},
		{
			"data-validate-on-blur": select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined
		},
		{ tabindex: /*tabindex*/ ctx[27] },
		{
			"data-error-message": select_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30]
		},
		{ class: /*inputClassName*/ ctx[39] },
		{ value: /*inputValue*/ ctx[37] },
		restProps(/*$$restProps*/ ctx[45])
	];

	let select_data = {};

	for (let i = 0; i < select_levels.length; i += 1) {
		select_data = assign(select_data, select_levels[i]);
	}

	const block = {
		c: function create() {
			select = element("select");
			if (default_slot) default_slot.c();
			set_attributes(select, select_data);
			add_location(select, file$x, 498, 4, 14799);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			if (select_data.multiple) select_options(select, select_data.value);
			/*select_binding_1*/ ctx[62](select);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(select, "focus", /*onFocus*/ ctx[42], false, false, false),
					listen_dev(select, "blur", /*onBlur*/ ctx[43], false, false, false),
					listen_dev(select, "input", /*onInput*/ ctx[41], false, false, false),
					listen_dev(select, "change", /*onChange*/ ctx[44], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 67108864) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[57], dirty, null, null);
				}
			}

			set_attributes(select, select_data = get_spread_update(select_levels, [
				(!current || dirty[0] & /*inputStyle*/ 8388608) && { style: /*inputStyle*/ ctx[23] },
				(!current || dirty[0] & /*name*/ 2) && { name: /*name*/ ctx[1] },
				(!current || dirty[0] & /*placeholder*/ 8) && { placeholder: /*placeholder*/ ctx[3] },
				(!current || dirty[0] & /*inputId*/ 16) && { id: /*inputId*/ ctx[4] },
				(!current || dirty[0] & /*size*/ 32) && { size: /*size*/ ctx[5] },
				(!current || dirty[0] & /*accept*/ 64) && { accept: /*accept*/ ctx[6] },
				(!current || dirty[0] & /*autocomplete*/ 128) && { autocomplete: /*autocomplete*/ ctx[7] },
				(!current || dirty[0] & /*autocorrect*/ 256) && { autocorrect: /*autocorrect*/ ctx[8] },
				(!current || dirty[0] & /*autocapitalize*/ 512) && {
					autocapitalize: /*autocapitalize*/ ctx[9]
				},
				(!current || dirty[0] & /*spellcheck*/ 1024) && { spellcheck: /*spellcheck*/ ctx[10] },
				(!current || dirty[0] & /*autofocus*/ 2048) && { autofocus: /*autofocus*/ ctx[11] },
				(!current || dirty[0] & /*autosave*/ 4096) && { autosave: /*autosave*/ ctx[12] },
				(!current || dirty[0] & /*checked*/ 8192) && { checked: /*checked*/ ctx[13] },
				(!current || dirty[0] & /*disabled*/ 16384) && { disabled: /*disabled*/ ctx[14] },
				(!current || dirty[0] & /*max*/ 32768) && { max: /*max*/ ctx[15] },
				(!current || dirty[0] & /*maxlength*/ 262144) && { maxlength: /*maxlength*/ ctx[18] },
				(!current || dirty[0] & /*min*/ 65536) && { min: /*min*/ ctx[16] },
				(!current || dirty[0] & /*minlength*/ 524288) && { minlength: /*minlength*/ ctx[19] },
				(!current || dirty[0] & /*step*/ 131072) && { step: /*step*/ ctx[17] },
				(!current || dirty[0] & /*multiple*/ 1048576) && { multiple: /*multiple*/ ctx[20] },
				(!current || dirty[0] & /*readonly*/ 2097152) && { readonly: /*readonly*/ ctx[21] },
				(!current || dirty[0] & /*required*/ 4194304) && { required: /*required*/ ctx[22] },
				(!current || dirty[0] & /*pattern*/ 16777216) && { pattern: /*pattern*/ ctx[24] },
				(!current || dirty[0] & /*validate*/ 33554432 && select_validate_value !== (select_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
				? /*validate*/ ctx[25]
				: undefined)) && { validate: select_validate_value },
				(!current || dirty[0] & /*validate, validateOnBlur*/ 100663296 && select_data_validate_value !== (select_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
				? true
				: undefined)) && {
					"data-validate": select_data_validate_value
				},
				(!current || dirty[0] & /*validateOnBlur*/ 67108864 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
				? true
				: undefined)) && {
					"data-validate-on-blur": select_data_validate_on_blur_value
				},
				(!current || dirty[0] & /*tabindex*/ 134217728) && { tabindex: /*tabindex*/ ctx[27] },
				(!current || dirty[0] & /*errorMessage*/ 1073741824 | dirty[1] & /*errorMessageForce*/ 1 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/ ctx[31]
				? undefined
				: /*errorMessage*/ ctx[30])) && {
					"data-error-message": select_data_error_message_value
				},
				(!current || dirty[1] & /*inputClassName*/ 256) && { class: /*inputClassName*/ ctx[39] },
				(!current || dirty[1] & /*inputValue*/ 64) && { value: /*inputValue*/ ctx[37] },
				dirty[1] & /*$$restProps*/ 16384 && restProps(/*$$restProps*/ ctx[45])
			]));

			if (dirty[0] & /*inputStyle, name, placeholder, inputId, size, accept, autocomplete, autocorrect, autocapitalize, spellcheck, autofocus, autosave, checked, disabled, max, maxlength, min, minlength, step, multiple, readonly, required, pattern, validate, validateOnBlur, tabindex, errorMessage*/ 1342177274 | dirty[1] & /*errorMessageForce, inputClassName, inputValue, $$restProps*/ 16705 && select_data.multiple) select_options(select, select_data.value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select);
			if (default_slot) default_slot.d(detaching);
			/*select_binding_1*/ ctx[62](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9.name,
		type: "if",
		source: "(498:2) {#if type === 'select'}",
		ctx
	});

	return block;
}

// (331:0) {#if wrap}
function create_if_block$a(ctx) {
	let div;
	let current_block_type_index;
	let if_block0;
	let t0;
	let t1;
	let t2;
	let current;

	const if_block_creators = [
		create_if_block_4$2,
		create_if_block_5,
		create_if_block_6,
		create_if_block_7,
		create_if_block_8,
		create_else_block$2
	];

	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*type*/ ctx[0] === "select") return 0;
		if (/*type*/ ctx[0] === "textarea") return 1;
		if (/*type*/ ctx[0] === "toggle") return 2;
		if (/*type*/ ctx[0] === "range") return 3;
		if (/*type*/ ctx[0] === "texteditor") return 4;
		return 5;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*errorMessage*/ ctx[30] && /*errorMessageForce*/ ctx[31] && create_if_block_3$4(ctx);
	let if_block2 = /*clearButton*/ ctx[29] && create_if_block_2$5(ctx);
	let if_block3 = (/*info*/ ctx[32] || /*hasInfoSlots*/ ctx[40]) && create_if_block_1$5(ctx);
	let div_levels = [{ class: /*wrapClasses*/ ctx[38] }, restProps(/*$$restProps*/ ctx[45])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (if_block2) if_block2.c();
			t2 = space();
			if (if_block3) if_block3.c();
			set_attributes(div, div_data);
			add_location(div, file$x, 331, 2, 9515);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t1);
			if (if_block2) if_block2.m(div, null);
			append_dev(div, t2);
			if (if_block3) if_block3.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(div, t0);
			}

			if (/*errorMessage*/ ctx[30] && /*errorMessageForce*/ ctx[31]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3$4(ctx);
					if_block1.c();
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*clearButton*/ ctx[29]) {
				if (if_block2) ; else {
					if_block2 = create_if_block_2$5(ctx);
					if_block2.c();
					if_block2.m(div, t2);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*info*/ ctx[32] || /*hasInfoSlots*/ ctx[40]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*info, hasInfoSlots*/ 514) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_1$5(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div, null);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[1] & /*wrapClasses*/ 128) && { class: /*wrapClasses*/ ctx[38] },
				dirty[1] & /*$$restProps*/ 16384 && restProps(/*$$restProps*/ ctx[45])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block3);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block3);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$a.name,
		type: "if",
		source: "(331:0) {#if wrap}",
		ctx
	});

	return block;
}

// (444:4) {:else}
function create_else_block$2(ctx) {
	let input;
	let input_validate_value;
	let input_data_validate_value;
	let input_data_validate_on_blur_value;
	let input_data_error_message_value;
	let input_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			attr_dev(input, "style", /*inputStyle*/ ctx[23]);
			attr_dev(input, "name", /*name*/ ctx[1]);
			attr_dev(input, "type", /*inputType*/ ctx[35]);
			attr_dev(input, "placeholder", /*placeholder*/ ctx[3]);
			attr_dev(input, "id", /*inputId*/ ctx[4]);
			attr_dev(input, "size", /*size*/ ctx[5]);
			attr_dev(input, "accept", /*accept*/ ctx[6]);
			attr_dev(input, "autocomplete", /*autocomplete*/ ctx[7]);
			attr_dev(input, "autocorrect", /*autocorrect*/ ctx[8]);
			attr_dev(input, "autocapitalize", /*autocapitalize*/ ctx[9]);
			attr_dev(input, "spellcheck", /*spellcheck*/ ctx[10]);
			input.autofocus = /*autofocus*/ ctx[11];
			attr_dev(input, "autosave", /*autosave*/ ctx[12]);
			input.checked = /*checked*/ ctx[13];
			input.disabled = /*disabled*/ ctx[14];
			attr_dev(input, "max", /*max*/ ctx[15]);
			attr_dev(input, "maxlength", /*maxlength*/ ctx[18]);
			attr_dev(input, "min", /*min*/ ctx[16]);
			attr_dev(input, "minlength", /*minlength*/ ctx[19]);
			attr_dev(input, "step", /*step*/ ctx[17]);
			input.multiple = /*multiple*/ ctx[20];
			input.readOnly = /*readonly*/ ctx[21];
			input.required = /*required*/ ctx[22];
			attr_dev(input, "pattern", /*pattern*/ ctx[24]);

			attr_dev(input, "validate", input_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined);

			attr_dev(input, "data-validate", input_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined);

			attr_dev(input, "data-validate-on-blur", input_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined);

			attr_dev(input, "tabindex", /*tabindex*/ ctx[27]);

			attr_dev(input, "data-error-message", input_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30]);

			attr_dev(input, "class", /*inputClassName*/ ctx[39]);

			input.value = input_value_value = /*type*/ ctx[0] === "datepicker" || /*type*/ ctx[0] === "colorpicker" || /*type*/ ctx[0] === "file"
			? ""
			: /*inputValue*/ ctx[37];

			add_location(input, file$x, 444, 6, 13064);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			/*input_binding*/ ctx[61](input);

			if (!mounted) {
				dispose = [
					listen_dev(input, "focus", /*onFocus*/ ctx[42], false, false, false),
					listen_dev(input, "blur", /*onBlur*/ ctx[43], false, false, false),
					listen_dev(input, "input", /*onInput*/ ctx[41], false, false, false),
					listen_dev(input, "change", /*onChange*/ ctx[44], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 8388608) {
				attr_dev(input, "style", /*inputStyle*/ ctx[23]);
			}

			if (dirty[0] & /*name*/ 2) {
				attr_dev(input, "name", /*name*/ ctx[1]);
			}

			if (dirty[1] & /*inputType*/ 16) {
				attr_dev(input, "type", /*inputType*/ ctx[35]);
			}

			if (dirty[0] & /*placeholder*/ 8) {
				attr_dev(input, "placeholder", /*placeholder*/ ctx[3]);
			}

			if (dirty[0] & /*inputId*/ 16) {
				attr_dev(input, "id", /*inputId*/ ctx[4]);
			}

			if (dirty[0] & /*size*/ 32) {
				attr_dev(input, "size", /*size*/ ctx[5]);
			}

			if (dirty[0] & /*accept*/ 64) {
				attr_dev(input, "accept", /*accept*/ ctx[6]);
			}

			if (dirty[0] & /*autocomplete*/ 128) {
				attr_dev(input, "autocomplete", /*autocomplete*/ ctx[7]);
			}

			if (dirty[0] & /*autocorrect*/ 256) {
				attr_dev(input, "autocorrect", /*autocorrect*/ ctx[8]);
			}

			if (dirty[0] & /*autocapitalize*/ 512) {
				attr_dev(input, "autocapitalize", /*autocapitalize*/ ctx[9]);
			}

			if (dirty[0] & /*spellcheck*/ 1024) {
				attr_dev(input, "spellcheck", /*spellcheck*/ ctx[10]);
			}

			if (dirty[0] & /*autofocus*/ 2048) {
				prop_dev(input, "autofocus", /*autofocus*/ ctx[11]);
			}

			if (dirty[0] & /*autosave*/ 4096) {
				attr_dev(input, "autosave", /*autosave*/ ctx[12]);
			}

			if (dirty[0] & /*checked*/ 8192) {
				prop_dev(input, "checked", /*checked*/ ctx[13]);
			}

			if (dirty[0] & /*disabled*/ 16384) {
				prop_dev(input, "disabled", /*disabled*/ ctx[14]);
			}

			if (dirty[0] & /*max*/ 32768) {
				attr_dev(input, "max", /*max*/ ctx[15]);
			}

			if (dirty[0] & /*maxlength*/ 262144) {
				attr_dev(input, "maxlength", /*maxlength*/ ctx[18]);
			}

			if (dirty[0] & /*min*/ 65536) {
				attr_dev(input, "min", /*min*/ ctx[16]);
			}

			if (dirty[0] & /*minlength*/ 524288) {
				attr_dev(input, "minlength", /*minlength*/ ctx[19]);
			}

			if (dirty[0] & /*step*/ 131072) {
				attr_dev(input, "step", /*step*/ ctx[17]);
			}

			if (dirty[0] & /*multiple*/ 1048576) {
				prop_dev(input, "multiple", /*multiple*/ ctx[20]);
			}

			if (dirty[0] & /*readonly*/ 2097152) {
				prop_dev(input, "readOnly", /*readonly*/ ctx[21]);
			}

			if (dirty[0] & /*required*/ 4194304) {
				prop_dev(input, "required", /*required*/ ctx[22]);
			}

			if (dirty[0] & /*pattern*/ 16777216) {
				attr_dev(input, "pattern", /*pattern*/ ctx[24]);
			}

			if (dirty[0] & /*validate*/ 33554432 && input_validate_value !== (input_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined)) {
				attr_dev(input, "validate", input_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 100663296 && input_data_validate_value !== (input_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined)) {
				attr_dev(input, "data-validate", input_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 67108864 && input_data_validate_on_blur_value !== (input_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined)) {
				attr_dev(input, "data-validate-on-blur", input_data_validate_on_blur_value);
			}

			if (dirty[0] & /*tabindex*/ 134217728) {
				attr_dev(input, "tabindex", /*tabindex*/ ctx[27]);
			}

			if (dirty[0] & /*errorMessage*/ 1073741824 | dirty[1] & /*errorMessageForce*/ 1 && input_data_error_message_value !== (input_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30])) {
				attr_dev(input, "data-error-message", input_data_error_message_value);
			}

			if (dirty[1] & /*inputClassName*/ 256) {
				attr_dev(input, "class", /*inputClassName*/ ctx[39]);
			}

			if (dirty[0] & /*type*/ 1 | dirty[1] & /*inputValue*/ 64 && input_value_value !== (input_value_value = /*type*/ ctx[0] === "datepicker" || /*type*/ ctx[0] === "colorpicker" || /*type*/ ctx[0] === "file"
			? ""
			: /*inputValue*/ ctx[37]) && input.value !== input_value_value) {
				prop_dev(input, "value", input_value_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			/*input_binding*/ ctx[61](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(444:4) {:else}",
		ctx
	});

	return block;
}

// (433:36) 
function create_if_block_8(ctx) {
	let texteditor;
	let current;

	const texteditor_spread_levels = [
		{
			value: typeof /*value*/ ctx[2] === "undefined"
			? ""
			: /*value*/ ctx[2]
		},
		{ resizable: /*resizable*/ ctx[28] },
		{ placeholder: /*placeholder*/ ctx[3] },
		{ onTextEditorFocus: /*onFocus*/ ctx[42] },
		{ onTextEditorBlur: /*onBlur*/ ctx[43] },
		{ onTextEditorInput: /*onInput*/ ctx[41] },
		{ onTextEditorChange: /*onChange*/ ctx[44] },
		/*textEditorParams*/ ctx[34]
	];

	let texteditor_props = {};

	for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
		texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
	}

	texteditor = new Text_editor({ props: texteditor_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(texteditor.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(texteditor, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const texteditor_changes = (dirty[0] & /*value, resizable, placeholder*/ 268435468 | dirty[1] & /*onFocus, onBlur, onInput, onChange, textEditorParams*/ 15368)
			? get_spread_update(texteditor_spread_levels, [
					dirty[0] & /*value*/ 4 && {
						value: typeof /*value*/ ctx[2] === "undefined"
						? ""
						: /*value*/ ctx[2]
					},
					dirty[0] & /*resizable*/ 268435456 && { resizable: /*resizable*/ ctx[28] },
					dirty[0] & /*placeholder*/ 8 && { placeholder: /*placeholder*/ ctx[3] },
					dirty[1] & /*onFocus*/ 2048 && { onTextEditorFocus: /*onFocus*/ ctx[42] },
					dirty[1] & /*onBlur*/ 4096 && { onTextEditorBlur: /*onBlur*/ ctx[43] },
					dirty[1] & /*onInput*/ 1024 && { onTextEditorInput: /*onInput*/ ctx[41] },
					dirty[1] & /*onChange*/ 8192 && { onTextEditorChange: /*onChange*/ ctx[44] },
					dirty[1] & /*textEditorParams*/ 8 && get_spread_object(/*textEditorParams*/ ctx[34])
				])
			: {};

			texteditor.$set(texteditor_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(texteditor.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(texteditor.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(texteditor, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(433:36) ",
		ctx
	});

	return block;
}

// (421:31) 
function create_if_block_7(ctx) {
	let range;
	let current;

	range = new Range({
			props: {
				value: /*value*/ ctx[2],
				disabled: /*disabled*/ ctx[14],
				min: /*min*/ ctx[16],
				max: /*max*/ ctx[15],
				step: /*step*/ ctx[17],
				name: /*name*/ ctx[1],
				id: /*inputId*/ ctx[4],
				input: true
			},
			$$inline: true
		});

	range.$on("rangeChange", /*onChange*/ ctx[44]);

	const block = {
		c: function create() {
			create_component(range.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(range, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const range_changes = {};
			if (dirty[0] & /*value*/ 4) range_changes.value = /*value*/ ctx[2];
			if (dirty[0] & /*disabled*/ 16384) range_changes.disabled = /*disabled*/ ctx[14];
			if (dirty[0] & /*min*/ 65536) range_changes.min = /*min*/ ctx[16];
			if (dirty[0] & /*max*/ 32768) range_changes.max = /*max*/ ctx[15];
			if (dirty[0] & /*step*/ 131072) range_changes.step = /*step*/ ctx[17];
			if (dirty[0] & /*name*/ 2) range_changes.name = /*name*/ ctx[1];
			if (dirty[0] & /*inputId*/ 16) range_changes.id = /*inputId*/ ctx[4];
			range.$set(range_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(range.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(range.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(range, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(421:31) ",
		ctx
	});

	return block;
}

// (411:32) 
function create_if_block_6(ctx) {
	let toggle;
	let current;

	toggle = new Toggle({
			props: {
				checked: /*checked*/ ctx[13],
				readonly: /*readonly*/ ctx[21],
				name: /*name*/ ctx[1],
				value: /*value*/ ctx[2],
				disabled: /*disabled*/ ctx[14],
				id: /*inputId*/ ctx[4]
			},
			$$inline: true
		});

	toggle.$on("change", /*onChange*/ ctx[44]);

	const block = {
		c: function create() {
			create_component(toggle.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(toggle, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const toggle_changes = {};
			if (dirty[0] & /*checked*/ 8192) toggle_changes.checked = /*checked*/ ctx[13];
			if (dirty[0] & /*readonly*/ 2097152) toggle_changes.readonly = /*readonly*/ ctx[21];
			if (dirty[0] & /*name*/ 2) toggle_changes.name = /*name*/ ctx[1];
			if (dirty[0] & /*value*/ 4) toggle_changes.value = /*value*/ ctx[2];
			if (dirty[0] & /*disabled*/ 16384) toggle_changes.disabled = /*disabled*/ ctx[14];
			if (dirty[0] & /*inputId*/ 16) toggle_changes.id = /*inputId*/ ctx[4];
			toggle.$set(toggle_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(toggle.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(toggle.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(toggle, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(411:32) ",
		ctx
	});

	return block;
}

// (373:34) 
function create_if_block_5(ctx) {
	let textarea;
	let textarea_validate_value;
	let textarea_data_validate_value;
	let textarea_data_validate_on_blur_value;
	let textarea_data_error_message_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			textarea = element("textarea");
			attr_dev(textarea, "style", /*inputStyle*/ ctx[23]);
			attr_dev(textarea, "name", /*name*/ ctx[1]);
			attr_dev(textarea, "placeholder", /*placeholder*/ ctx[3]);
			attr_dev(textarea, "id", /*inputId*/ ctx[4]);
			attr_dev(textarea, "size", /*size*/ ctx[5]);
			attr_dev(textarea, "accept", /*accept*/ ctx[6]);
			attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[7]);
			attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[8]);
			attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[9]);
			attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[10]);
			textarea.autofocus = /*autofocus*/ ctx[11];
			attr_dev(textarea, "autosave", /*autosave*/ ctx[12]);
			attr_dev(textarea, "checked", /*checked*/ ctx[13]);
			textarea.disabled = /*disabled*/ ctx[14];
			attr_dev(textarea, "max", /*max*/ ctx[15]);
			attr_dev(textarea, "maxlength", /*maxlength*/ ctx[18]);
			attr_dev(textarea, "min", /*min*/ ctx[16]);
			attr_dev(textarea, "minlength", /*minlength*/ ctx[19]);
			attr_dev(textarea, "step", /*step*/ ctx[17]);
			attr_dev(textarea, "multiple", /*multiple*/ ctx[20]);
			textarea.readOnly = /*readonly*/ ctx[21];
			textarea.required = /*required*/ ctx[22];
			attr_dev(textarea, "pattern", /*pattern*/ ctx[24]);

			attr_dev(textarea, "validate", textarea_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined);

			attr_dev(textarea, "data-validate", textarea_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined);

			attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined);

			attr_dev(textarea, "tabindex", /*tabindex*/ ctx[27]);

			attr_dev(textarea, "data-error-message", textarea_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30]);

			attr_dev(textarea, "class", /*inputClassName*/ ctx[39]);
			textarea.value = /*inputValue*/ ctx[37];
			add_location(textarea, file$x, 373, 6, 10937);
		},
		m: function mount(target, anchor) {
			insert_dev(target, textarea, anchor);
			/*textarea_binding*/ ctx[60](textarea);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "focus", /*onFocus*/ ctx[42], false, false, false),
					listen_dev(textarea, "blur", /*onBlur*/ ctx[43], false, false, false),
					listen_dev(textarea, "input", /*onInput*/ ctx[41], false, false, false),
					listen_dev(textarea, "change", /*onChange*/ ctx[44], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 8388608) {
				attr_dev(textarea, "style", /*inputStyle*/ ctx[23]);
			}

			if (dirty[0] & /*name*/ 2) {
				attr_dev(textarea, "name", /*name*/ ctx[1]);
			}

			if (dirty[0] & /*placeholder*/ 8) {
				attr_dev(textarea, "placeholder", /*placeholder*/ ctx[3]);
			}

			if (dirty[0] & /*inputId*/ 16) {
				attr_dev(textarea, "id", /*inputId*/ ctx[4]);
			}

			if (dirty[0] & /*size*/ 32) {
				attr_dev(textarea, "size", /*size*/ ctx[5]);
			}

			if (dirty[0] & /*accept*/ 64) {
				attr_dev(textarea, "accept", /*accept*/ ctx[6]);
			}

			if (dirty[0] & /*autocomplete*/ 128) {
				attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[7]);
			}

			if (dirty[0] & /*autocorrect*/ 256) {
				attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[8]);
			}

			if (dirty[0] & /*autocapitalize*/ 512) {
				attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[9]);
			}

			if (dirty[0] & /*spellcheck*/ 1024) {
				attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[10]);
			}

			if (dirty[0] & /*autofocus*/ 2048) {
				prop_dev(textarea, "autofocus", /*autofocus*/ ctx[11]);
			}

			if (dirty[0] & /*autosave*/ 4096) {
				attr_dev(textarea, "autosave", /*autosave*/ ctx[12]);
			}

			if (dirty[0] & /*checked*/ 8192) {
				attr_dev(textarea, "checked", /*checked*/ ctx[13]);
			}

			if (dirty[0] & /*disabled*/ 16384) {
				prop_dev(textarea, "disabled", /*disabled*/ ctx[14]);
			}

			if (dirty[0] & /*max*/ 32768) {
				attr_dev(textarea, "max", /*max*/ ctx[15]);
			}

			if (dirty[0] & /*maxlength*/ 262144) {
				attr_dev(textarea, "maxlength", /*maxlength*/ ctx[18]);
			}

			if (dirty[0] & /*min*/ 65536) {
				attr_dev(textarea, "min", /*min*/ ctx[16]);
			}

			if (dirty[0] & /*minlength*/ 524288) {
				attr_dev(textarea, "minlength", /*minlength*/ ctx[19]);
			}

			if (dirty[0] & /*step*/ 131072) {
				attr_dev(textarea, "step", /*step*/ ctx[17]);
			}

			if (dirty[0] & /*multiple*/ 1048576) {
				attr_dev(textarea, "multiple", /*multiple*/ ctx[20]);
			}

			if (dirty[0] & /*readonly*/ 2097152) {
				prop_dev(textarea, "readOnly", /*readonly*/ ctx[21]);
			}

			if (dirty[0] & /*required*/ 4194304) {
				prop_dev(textarea, "required", /*required*/ ctx[22]);
			}

			if (dirty[0] & /*pattern*/ 16777216) {
				attr_dev(textarea, "pattern", /*pattern*/ ctx[24]);
			}

			if (dirty[0] & /*validate*/ 33554432 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined)) {
				attr_dev(textarea, "validate", textarea_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 100663296 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined)) {
				attr_dev(textarea, "data-validate", textarea_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 67108864 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined)) {
				attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value);
			}

			if (dirty[0] & /*tabindex*/ 134217728) {
				attr_dev(textarea, "tabindex", /*tabindex*/ ctx[27]);
			}

			if (dirty[0] & /*errorMessage*/ 1073741824 | dirty[1] & /*errorMessageForce*/ 1 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30])) {
				attr_dev(textarea, "data-error-message", textarea_data_error_message_value);
			}

			if (dirty[1] & /*inputClassName*/ 256) {
				attr_dev(textarea, "class", /*inputClassName*/ ctx[39]);
			}

			if (dirty[1] & /*inputValue*/ 64) {
				prop_dev(textarea, "value", /*inputValue*/ ctx[37]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			/*textarea_binding*/ ctx[60](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(373:34) ",
		ctx
	});

	return block;
}

// (333:4) {#if type === 'select'}
function create_if_block_4$2(ctx) {
	let select;
	let select_validate_value;
	let select_data_validate_value;
	let select_data_validate_on_blur_value;
	let select_data_error_message_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[58].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[57], null);

	const block = {
		c: function create() {
			select = element("select");
			if (default_slot) default_slot.c();
			attr_dev(select, "style", /*inputStyle*/ ctx[23]);
			attr_dev(select, "name", /*name*/ ctx[1]);
			attr_dev(select, "placeholder", /*placeholder*/ ctx[3]);
			attr_dev(select, "id", /*inputId*/ ctx[4]);
			attr_dev(select, "size", /*size*/ ctx[5]);
			attr_dev(select, "accept", /*accept*/ ctx[6]);
			attr_dev(select, "autocomplete", /*autocomplete*/ ctx[7]);
			attr_dev(select, "autocorrect", /*autocorrect*/ ctx[8]);
			attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[9]);
			attr_dev(select, "spellcheck", /*spellcheck*/ ctx[10]);
			select.autofocus = /*autofocus*/ ctx[11];
			attr_dev(select, "autosave", /*autosave*/ ctx[12]);
			attr_dev(select, "checked", /*checked*/ ctx[13]);
			select.disabled = /*disabled*/ ctx[14];
			attr_dev(select, "max", /*max*/ ctx[15]);
			attr_dev(select, "maxlength", /*maxlength*/ ctx[18]);
			attr_dev(select, "min", /*min*/ ctx[16]);
			attr_dev(select, "minlength", /*minlength*/ ctx[19]);
			attr_dev(select, "step", /*step*/ ctx[17]);
			select.multiple = /*multiple*/ ctx[20];
			attr_dev(select, "readonly", /*readonly*/ ctx[21]);
			select.required = /*required*/ ctx[22];
			attr_dev(select, "pattern", /*pattern*/ ctx[24]);

			attr_dev(select, "validate", select_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined);

			attr_dev(select, "data-validate", select_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined);

			attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined);

			attr_dev(select, "tabindex", /*tabindex*/ ctx[27]);

			attr_dev(select, "data-error-message", select_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30]);

			attr_dev(select, "class", /*inputClassName*/ ctx[39]);
			add_location(select, file$x, 333, 6, 9603);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			select_option(select, /*inputValue*/ ctx[37]);
			/*select_binding*/ ctx[59](select);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(select, "focus", /*onFocus*/ ctx[42], false, false, false),
					listen_dev(select, "blur", /*onBlur*/ ctx[43], false, false, false),
					listen_dev(select, "input", /*onInput*/ ctx[41], false, false, false),
					listen_dev(select, "change", /*onChange*/ ctx[44], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 67108864) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[57], dirty, null, null);
				}
			}

			if (!current || dirty[0] & /*inputStyle*/ 8388608) {
				attr_dev(select, "style", /*inputStyle*/ ctx[23]);
			}

			if (!current || dirty[0] & /*name*/ 2) {
				attr_dev(select, "name", /*name*/ ctx[1]);
			}

			if (!current || dirty[0] & /*placeholder*/ 8) {
				attr_dev(select, "placeholder", /*placeholder*/ ctx[3]);
			}

			if (!current || dirty[0] & /*inputId*/ 16) {
				attr_dev(select, "id", /*inputId*/ ctx[4]);
			}

			if (!current || dirty[0] & /*size*/ 32) {
				attr_dev(select, "size", /*size*/ ctx[5]);
			}

			if (!current || dirty[0] & /*accept*/ 64) {
				attr_dev(select, "accept", /*accept*/ ctx[6]);
			}

			if (!current || dirty[0] & /*autocomplete*/ 128) {
				attr_dev(select, "autocomplete", /*autocomplete*/ ctx[7]);
			}

			if (!current || dirty[0] & /*autocorrect*/ 256) {
				attr_dev(select, "autocorrect", /*autocorrect*/ ctx[8]);
			}

			if (!current || dirty[0] & /*autocapitalize*/ 512) {
				attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[9]);
			}

			if (!current || dirty[0] & /*spellcheck*/ 1024) {
				attr_dev(select, "spellcheck", /*spellcheck*/ ctx[10]);
			}

			if (!current || dirty[0] & /*autofocus*/ 2048) {
				prop_dev(select, "autofocus", /*autofocus*/ ctx[11]);
			}

			if (!current || dirty[0] & /*autosave*/ 4096) {
				attr_dev(select, "autosave", /*autosave*/ ctx[12]);
			}

			if (!current || dirty[0] & /*checked*/ 8192) {
				attr_dev(select, "checked", /*checked*/ ctx[13]);
			}

			if (!current || dirty[0] & /*disabled*/ 16384) {
				prop_dev(select, "disabled", /*disabled*/ ctx[14]);
			}

			if (!current || dirty[0] & /*max*/ 32768) {
				attr_dev(select, "max", /*max*/ ctx[15]);
			}

			if (!current || dirty[0] & /*maxlength*/ 262144) {
				attr_dev(select, "maxlength", /*maxlength*/ ctx[18]);
			}

			if (!current || dirty[0] & /*min*/ 65536) {
				attr_dev(select, "min", /*min*/ ctx[16]);
			}

			if (!current || dirty[0] & /*minlength*/ 524288) {
				attr_dev(select, "minlength", /*minlength*/ ctx[19]);
			}

			if (!current || dirty[0] & /*step*/ 131072) {
				attr_dev(select, "step", /*step*/ ctx[17]);
			}

			if (!current || dirty[0] & /*multiple*/ 1048576) {
				prop_dev(select, "multiple", /*multiple*/ ctx[20]);
			}

			if (!current || dirty[0] & /*readonly*/ 2097152) {
				attr_dev(select, "readonly", /*readonly*/ ctx[21]);
			}

			if (!current || dirty[0] & /*required*/ 4194304) {
				prop_dev(select, "required", /*required*/ ctx[22]);
			}

			if (!current || dirty[0] & /*pattern*/ 16777216) {
				attr_dev(select, "pattern", /*pattern*/ ctx[24]);
			}

			if (!current || dirty[0] & /*validate*/ 33554432 && select_validate_value !== (select_validate_value = typeof /*validate*/ ctx[25] === "string" && /*validate*/ ctx[25].length
			? /*validate*/ ctx[25]
			: undefined)) {
				attr_dev(select, "validate", select_validate_value);
			}

			if (!current || dirty[0] & /*validate, validateOnBlur*/ 100663296 && select_data_validate_value !== (select_data_validate_value = /*validate*/ ctx[25] === true || /*validate*/ ctx[25] === "" || /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined)) {
				attr_dev(select, "data-validate", select_data_validate_value);
			}

			if (!current || dirty[0] & /*validateOnBlur*/ 67108864 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[26] === true || /*validateOnBlur*/ ctx[26] === ""
			? true
			: undefined)) {
				attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value);
			}

			if (!current || dirty[0] & /*tabindex*/ 134217728) {
				attr_dev(select, "tabindex", /*tabindex*/ ctx[27]);
			}

			if (!current || dirty[0] & /*errorMessage*/ 1073741824 | dirty[1] & /*errorMessageForce*/ 1 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/ ctx[31]
			? undefined
			: /*errorMessage*/ ctx[30])) {
				attr_dev(select, "data-error-message", select_data_error_message_value);
			}

			if (!current || dirty[1] & /*inputClassName*/ 256) {
				attr_dev(select, "class", /*inputClassName*/ ctx[39]);
			}

			if (!current || dirty[1] & /*inputValue*/ 64) {
				select_option(select, /*inputValue*/ ctx[37]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select);
			if (default_slot) default_slot.d(detaching);
			/*select_binding*/ ctx[59](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$2.name,
		type: "if",
		source: "(333:4) {#if type === 'select'}",
		ctx
	});

	return block;
}

// (484:4) {#if errorMessage && errorMessageForce}
function create_if_block_3$4(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*errorMessage*/ ctx[30]);
			attr_dev(div, "class", "input-error-message");
			add_location(div, file$x, 484, 6, 14483);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*errorMessage*/ 1073741824) set_data_dev(t, /*errorMessage*/ ctx[30]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$4.name,
		type: "if",
		source: "(484:4) {#if errorMessage && errorMessageForce}",
		ctx
	});

	return block;
}

// (487:4) {#if clearButton}
function create_if_block_2$5(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "input-clear-button");
			add_location(span, file$x, 487, 6, 14575);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$5.name,
		type: "if",
		source: "(487:4) {#if clearButton}",
		ctx
	});

	return block;
}

// (490:4) {#if (info || hasInfoSlots)}
function create_if_block_1$5(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	const info_slot_template = /*#slots*/ ctx[58].info;
	const info_slot = create_slot(info_slot_template, ctx, /*$$scope*/ ctx[57], get_info_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(/*info*/ ctx[32]);
			t1 = space();
			if (info_slot) info_slot.c();
			attr_dev(div, "class", "input-info");
			add_location(div, file$x, 490, 6, 14660);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (info_slot) {
				info_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (!current || dirty[1] & /*info*/ 2) set_data_dev(t0, /*info*/ ctx[32]);

			if (info_slot) {
				if (info_slot.p && dirty[1] & /*$$scope*/ 67108864) {
					update_slot(info_slot, info_slot_template, ctx, /*$$scope*/ ctx[57], dirty, get_info_slot_changes, get_info_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(info_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(info_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (info_slot) info_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(490:4) {#if (info || hasInfoSlots)}",
		ctx
	});

	return block;
}

function create_fragment$x(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block$a,
		create_if_block_9,
		create_if_block_10,
		create_if_block_11,
		create_if_block_12,
		create_if_block_13,
		create_else_block_1
	];

	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*wrap*/ ctx[33]) return 0;
		if (/*type*/ ctx[0] === "select") return 1;
		if (/*type*/ ctx[0] === "textarea") return 2;
		if (/*type*/ ctx[0] === "toggle") return 3;
		if (/*type*/ ctx[0] === "range") return 4;
		if (/*type*/ ctx[0] === "texteditor") return 5;
		return 6;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$x.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$t($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","type","name","value","placeholder","inputId","size","accept","autocomplete","autocorrect","autocapitalize","spellcheck","autofocus","autosave","checked","disabled","max","min","step","maxlength","minlength","multiple","readonly","required","inputStyle","pattern","validate","validateOnBlur","onValidate","tabindex","resizable","clearButton","noFormStoreData","noStoreData","ignoreStoreData","errorMessage","errorMessageForce","info","outline","wrap","dropdown","calendarParams","colorPickerParams","textEditorParams"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Input", slots, ['default','info']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { type = undefined } = $$props;
	let { name = undefined } = $$props;
	let { value = undefined } = $$props;
	let { placeholder = undefined } = $$props;
	let { inputId = undefined } = $$props;
	let { size = undefined } = $$props;
	let { accept = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { autofocus = undefined } = $$props;
	let { autosave = undefined } = $$props;
	let { checked = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { max = undefined } = $$props;
	let { min = undefined } = $$props;
	let { step = undefined } = $$props;
	let { maxlength = undefined } = $$props;
	let { minlength = undefined } = $$props;
	let { multiple = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let { required = undefined } = $$props;
	let { inputStyle = undefined } = $$props;
	let { pattern = undefined } = $$props;
	let { validate = undefined } = $$props;
	let { validateOnBlur = undefined } = $$props;
	let { onValidate = undefined } = $$props;
	let { tabindex = undefined } = $$props;
	let { resizable = undefined } = $$props;
	let { clearButton = undefined } = $$props;
	let { noFormStoreData = undefined } = $$props;
	let { noStoreData = undefined } = $$props;
	let { ignoreStoreData = undefined } = $$props;
	let { errorMessage = undefined } = $$props;
	let { errorMessageForce = undefined } = $$props;
	let { info = undefined } = $$props;
	let { outline = undefined } = $$props;
	let { wrap = true } = $$props;
	let { dropdown = "auto" } = $$props;
	let { calendarParams = undefined } = $$props;
	let { colorPickerParams = undefined } = $$props;
	let { textEditorParams = undefined } = $$props;

	// State
	let inputEl;

	let inputFocused = false;
	let inputInvalid = false;
	let updateInputOnDidUpdate = false;
	let f7Calendar;
	let f7ColorPicker;

	function domValue() {
		if (!inputEl) return undefined;
		return inputEl.value;
	}

	function inputHasValue() {
		if (type === "datepicker" && Array.isArray(value) && value.length === 0) {
			return false;
		}

		const domV = domValue();

		return typeof value === "undefined"
		? domV || domV === 0
		: value || value === 0;
	}

	function validateInput() {
		if (!f7.instance || !inputEl) return;
		const validity = inputEl.validity;
		if (!validity) return;

		if (!validity.valid) {
			if (onValidate) onValidate(false);

			if (inputInvalid !== true) {
				$$invalidate(56, inputInvalid = true);
			}
		} else if (inputInvalid !== false) {
			if (onValidate) onValidate(true);
			$$invalidate(56, inputInvalid = false);
		}
	}

	let initialWatched = false;

	function watchValue() {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (type === "range" || type === "toggle") return;
		if (!f7.instance) return;
		updateInputOnDidUpdate = true;

		if (f7Calendar) {
			f7Calendar.setValue(value);
		}

		if (f7ColorPicker) {
			f7ColorPicker.setValue(value);
		}
	}

	function onTextareaResize(event) {
		dispatch("textareaResize", [event]);
		if (typeof $$props.onTextareaResize === "function") $$props.onTextareaResize(event);
	}

	function onInputNotEmpty(event) {
		dispatch("inputNotEmpty", [event]);
		if (typeof $$props.onInputNotEmpty === "function") $$props.onInputNotEmpty(event);
	}

	function onInputEmpty(event) {
		dispatch("inputEmpty", [event]);
		if (typeof $$props.onInputEmpty === "function") $$props.onInputEmpty(event);
	}

	function onInputClear(event) {
		dispatch("inputClear", [event]);
		if (typeof $$props.onInputClear === "function") $$props.onInputClear(event);
	}

	function onInput(...args) {
		dispatch("input", [...args]);
		if (typeof $$props.onInput === "function") $$props.onInput(...args);

		if (!(validateOnBlur || validateOnBlur === "") && (validate || validate === "") && inputEl) {
			validateInput();
		}
	}

	function onFocus(...args) {
		dispatch("focus", [...args]);
		if (typeof $$props.onFocus === "function") $$props.onFocus(...args);
		$$invalidate(55, inputFocused = true);
	}

	function onBlur(...args) {
		dispatch("blur", [...args]);
		if (typeof $$props.onBlur === "function") $$props.onBlur(...args);

		if ((validate || validate === "" || validateOnBlur || validateOnBlur === "") && inputEl) {
			validateInput();
		}

		$$invalidate(55, inputFocused = false);
	}

	function onChange(...args) {
		dispatch("change", [...args]);
		if (typeof $$props.onChange === "function") $$props.onChange(...args);

		if (type === "texteditor") {
			dispatch("textEditorChange", [args[1]]);
		}
	}

	onMount(() => {
		f7.ready(() => {
			if (type === "range" || type === "toggle") return;
			if (!inputEl) return;
			inputEl.addEventListener("input:notempty", onInputNotEmpty, false);

			if (type === "textarea" && resizable) {
				inputEl.addEventListener("textarea:resize", onTextareaResize, false);
			}

			if (clearButton) {
				inputEl.addEventListener("input:empty", onInputEmpty, false);
				inputEl.addEventListener("input:clear", onInputClear, false);
			}

			if (type === "datepicker") {
				f7Calendar = f7.instance.calendar.create({
					inputEl,
					value,
					on: {
						change(calendar, calendarValue) {
							dispatch("calendarChange", [calendarValue]);
							if (typeof $$props.onCalendarChange === "function") $$props.onCalendarChange(calendarValue);
						}
					},
					...calendarParams || {}
				});
			}

			if (type === "colorpicker") {
				f7ColorPicker = f7.instance.colorPicker.create({
					inputEl,
					value,
					on: {
						change(colorPicker, colorPickerValue) {
							dispatch("colorpickerChange", [colorPickerValue]);
							if (typeof $$props.onColorpickerChange === "function") $$props.onColorpickerChange(colorPickerValue);
						}
					},
					...colorPickerParams || {}
				});
			}

			f7.instance.input.checkEmptyState(inputEl);

			if (!(validateOnBlur || validateOnBlur === "") && (validate || validate === "") && (typeof value !== "undefined" && value !== null && value !== "")) {
				setTimeout(
					() => {
						validateInput();
					},
					0
				);
			}

			if (resizable) {
				f7.instance.input.resizeTextarea(inputEl);
			}
		});
	});

	afterUpdate(() => {
		if (!f7.instance) return;

		if (updateInputOnDidUpdate) {
			if (!inputEl) return;
			updateInputOnDidUpdate = false;
			f7.instance.input.checkEmptyState(inputEl);

			if (validate && !validateOnBlur) {
				validateInput();
			}

			if (resizable) {
				f7.instance.input.resizeTextarea(inputEl);
			}
		}
	});

	onDestroy(() => {
		if (type === "range" || type === "toggle") return;
		if (!inputEl) return;
		inputEl.removeEventListener("input:notempty", onInputNotEmpty, false);

		if (type === "textarea" && resizable) {
			inputEl.removeEventListener("textarea:resize", onTextareaResize, false);
		}

		if (clearButton) {
			inputEl.removeEventListener("input:empty", onInputEmpty, false);
			inputEl.removeEventListener("input:clear", onInputClear, false);
		}

		if (f7Calendar && f7Calendar.destroy) {
			f7Calendar.destroy();
		}

		if (f7ColorPicker && f7ColorPicker.destroy) {
			f7ColorPicker.destroy();
		}

		f7Calendar = null;
		f7ColorPicker = null;
	});

	function select_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(36, inputEl);
		});
	}

	function textarea_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(36, inputEl);
		});
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(36, inputEl);
		});
	}

	function select_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(36, inputEl);
		});
	}

	function textarea_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(36, inputEl);
		});
	}

	function input_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(36, inputEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(80, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(45, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(46, className = $$new_props.class);
		if ("type" in $$new_props) $$invalidate(0, type = $$new_props.type);
		if ("name" in $$new_props) $$invalidate(1, name = $$new_props.name);
		if ("value" in $$new_props) $$invalidate(2, value = $$new_props.value);
		if ("placeholder" in $$new_props) $$invalidate(3, placeholder = $$new_props.placeholder);
		if ("inputId" in $$new_props) $$invalidate(4, inputId = $$new_props.inputId);
		if ("size" in $$new_props) $$invalidate(5, size = $$new_props.size);
		if ("accept" in $$new_props) $$invalidate(6, accept = $$new_props.accept);
		if ("autocomplete" in $$new_props) $$invalidate(7, autocomplete = $$new_props.autocomplete);
		if ("autocorrect" in $$new_props) $$invalidate(8, autocorrect = $$new_props.autocorrect);
		if ("autocapitalize" in $$new_props) $$invalidate(9, autocapitalize = $$new_props.autocapitalize);
		if ("spellcheck" in $$new_props) $$invalidate(10, spellcheck = $$new_props.spellcheck);
		if ("autofocus" in $$new_props) $$invalidate(11, autofocus = $$new_props.autofocus);
		if ("autosave" in $$new_props) $$invalidate(12, autosave = $$new_props.autosave);
		if ("checked" in $$new_props) $$invalidate(13, checked = $$new_props.checked);
		if ("disabled" in $$new_props) $$invalidate(14, disabled = $$new_props.disabled);
		if ("max" in $$new_props) $$invalidate(15, max = $$new_props.max);
		if ("min" in $$new_props) $$invalidate(16, min = $$new_props.min);
		if ("step" in $$new_props) $$invalidate(17, step = $$new_props.step);
		if ("maxlength" in $$new_props) $$invalidate(18, maxlength = $$new_props.maxlength);
		if ("minlength" in $$new_props) $$invalidate(19, minlength = $$new_props.minlength);
		if ("multiple" in $$new_props) $$invalidate(20, multiple = $$new_props.multiple);
		if ("readonly" in $$new_props) $$invalidate(21, readonly = $$new_props.readonly);
		if ("required" in $$new_props) $$invalidate(22, required = $$new_props.required);
		if ("inputStyle" in $$new_props) $$invalidate(23, inputStyle = $$new_props.inputStyle);
		if ("pattern" in $$new_props) $$invalidate(24, pattern = $$new_props.pattern);
		if ("validate" in $$new_props) $$invalidate(25, validate = $$new_props.validate);
		if ("validateOnBlur" in $$new_props) $$invalidate(26, validateOnBlur = $$new_props.validateOnBlur);
		if ("onValidate" in $$new_props) $$invalidate(47, onValidate = $$new_props.onValidate);
		if ("tabindex" in $$new_props) $$invalidate(27, tabindex = $$new_props.tabindex);
		if ("resizable" in $$new_props) $$invalidate(28, resizable = $$new_props.resizable);
		if ("clearButton" in $$new_props) $$invalidate(29, clearButton = $$new_props.clearButton);
		if ("noFormStoreData" in $$new_props) $$invalidate(48, noFormStoreData = $$new_props.noFormStoreData);
		if ("noStoreData" in $$new_props) $$invalidate(49, noStoreData = $$new_props.noStoreData);
		if ("ignoreStoreData" in $$new_props) $$invalidate(50, ignoreStoreData = $$new_props.ignoreStoreData);
		if ("errorMessage" in $$new_props) $$invalidate(30, errorMessage = $$new_props.errorMessage);
		if ("errorMessageForce" in $$new_props) $$invalidate(31, errorMessageForce = $$new_props.errorMessageForce);
		if ("info" in $$new_props) $$invalidate(32, info = $$new_props.info);
		if ("outline" in $$new_props) $$invalidate(51, outline = $$new_props.outline);
		if ("wrap" in $$new_props) $$invalidate(33, wrap = $$new_props.wrap);
		if ("dropdown" in $$new_props) $$invalidate(52, dropdown = $$new_props.dropdown);
		if ("calendarParams" in $$new_props) $$invalidate(53, calendarParams = $$new_props.calendarParams);
		if ("colorPickerParams" in $$new_props) $$invalidate(54, colorPickerParams = $$new_props.colorPickerParams);
		if ("textEditorParams" in $$new_props) $$invalidate(34, textEditorParams = $$new_props.textEditorParams);
		if ("$$scope" in $$new_props) $$invalidate(57, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		afterUpdate,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		hasSlots,
		Toggle,
		Range,
		TextEditor: Text_editor,
		dispatch,
		className,
		type,
		name,
		value,
		placeholder,
		inputId,
		size,
		accept,
		autocomplete,
		autocorrect,
		autocapitalize,
		spellcheck,
		autofocus,
		autosave,
		checked,
		disabled,
		max,
		min,
		step,
		maxlength,
		minlength,
		multiple,
		readonly,
		required,
		inputStyle,
		pattern,
		validate,
		validateOnBlur,
		onValidate,
		tabindex,
		resizable,
		clearButton,
		noFormStoreData,
		noStoreData,
		ignoreStoreData,
		errorMessage,
		errorMessageForce,
		info,
		outline,
		wrap,
		dropdown,
		calendarParams,
		colorPickerParams,
		textEditorParams,
		inputEl,
		inputFocused,
		inputInvalid,
		updateInputOnDidUpdate,
		f7Calendar,
		f7ColorPicker,
		domValue,
		inputHasValue,
		validateInput,
		initialWatched,
		watchValue,
		onTextareaResize,
		onInputNotEmpty,
		onInputEmpty,
		onInputClear,
		onInput,
		onFocus,
		onBlur,
		onChange,
		inputType,
		needsValue,
		inputValue,
		classes,
		wrapClasses,
		inputClassName,
		hasInfoSlots
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(80, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(46, className = $$new_props.className);
		if ("type" in $$props) $$invalidate(0, type = $$new_props.type);
		if ("name" in $$props) $$invalidate(1, name = $$new_props.name);
		if ("value" in $$props) $$invalidate(2, value = $$new_props.value);
		if ("placeholder" in $$props) $$invalidate(3, placeholder = $$new_props.placeholder);
		if ("inputId" in $$props) $$invalidate(4, inputId = $$new_props.inputId);
		if ("size" in $$props) $$invalidate(5, size = $$new_props.size);
		if ("accept" in $$props) $$invalidate(6, accept = $$new_props.accept);
		if ("autocomplete" in $$props) $$invalidate(7, autocomplete = $$new_props.autocomplete);
		if ("autocorrect" in $$props) $$invalidate(8, autocorrect = $$new_props.autocorrect);
		if ("autocapitalize" in $$props) $$invalidate(9, autocapitalize = $$new_props.autocapitalize);
		if ("spellcheck" in $$props) $$invalidate(10, spellcheck = $$new_props.spellcheck);
		if ("autofocus" in $$props) $$invalidate(11, autofocus = $$new_props.autofocus);
		if ("autosave" in $$props) $$invalidate(12, autosave = $$new_props.autosave);
		if ("checked" in $$props) $$invalidate(13, checked = $$new_props.checked);
		if ("disabled" in $$props) $$invalidate(14, disabled = $$new_props.disabled);
		if ("max" in $$props) $$invalidate(15, max = $$new_props.max);
		if ("min" in $$props) $$invalidate(16, min = $$new_props.min);
		if ("step" in $$props) $$invalidate(17, step = $$new_props.step);
		if ("maxlength" in $$props) $$invalidate(18, maxlength = $$new_props.maxlength);
		if ("minlength" in $$props) $$invalidate(19, minlength = $$new_props.minlength);
		if ("multiple" in $$props) $$invalidate(20, multiple = $$new_props.multiple);
		if ("readonly" in $$props) $$invalidate(21, readonly = $$new_props.readonly);
		if ("required" in $$props) $$invalidate(22, required = $$new_props.required);
		if ("inputStyle" in $$props) $$invalidate(23, inputStyle = $$new_props.inputStyle);
		if ("pattern" in $$props) $$invalidate(24, pattern = $$new_props.pattern);
		if ("validate" in $$props) $$invalidate(25, validate = $$new_props.validate);
		if ("validateOnBlur" in $$props) $$invalidate(26, validateOnBlur = $$new_props.validateOnBlur);
		if ("onValidate" in $$props) $$invalidate(47, onValidate = $$new_props.onValidate);
		if ("tabindex" in $$props) $$invalidate(27, tabindex = $$new_props.tabindex);
		if ("resizable" in $$props) $$invalidate(28, resizable = $$new_props.resizable);
		if ("clearButton" in $$props) $$invalidate(29, clearButton = $$new_props.clearButton);
		if ("noFormStoreData" in $$props) $$invalidate(48, noFormStoreData = $$new_props.noFormStoreData);
		if ("noStoreData" in $$props) $$invalidate(49, noStoreData = $$new_props.noStoreData);
		if ("ignoreStoreData" in $$props) $$invalidate(50, ignoreStoreData = $$new_props.ignoreStoreData);
		if ("errorMessage" in $$props) $$invalidate(30, errorMessage = $$new_props.errorMessage);
		if ("errorMessageForce" in $$props) $$invalidate(31, errorMessageForce = $$new_props.errorMessageForce);
		if ("info" in $$props) $$invalidate(32, info = $$new_props.info);
		if ("outline" in $$props) $$invalidate(51, outline = $$new_props.outline);
		if ("wrap" in $$props) $$invalidate(33, wrap = $$new_props.wrap);
		if ("dropdown" in $$props) $$invalidate(52, dropdown = $$new_props.dropdown);
		if ("calendarParams" in $$props) $$invalidate(53, calendarParams = $$new_props.calendarParams);
		if ("colorPickerParams" in $$props) $$invalidate(54, colorPickerParams = $$new_props.colorPickerParams);
		if ("textEditorParams" in $$props) $$invalidate(34, textEditorParams = $$new_props.textEditorParams);
		if ("inputEl" in $$props) $$invalidate(36, inputEl = $$new_props.inputEl);
		if ("inputFocused" in $$props) $$invalidate(55, inputFocused = $$new_props.inputFocused);
		if ("inputInvalid" in $$props) $$invalidate(56, inputInvalid = $$new_props.inputInvalid);
		if ("updateInputOnDidUpdate" in $$props) updateInputOnDidUpdate = $$new_props.updateInputOnDidUpdate;
		if ("f7Calendar" in $$props) f7Calendar = $$new_props.f7Calendar;
		if ("f7ColorPicker" in $$props) f7ColorPicker = $$new_props.f7ColorPicker;
		if ("initialWatched" in $$props) initialWatched = $$new_props.initialWatched;
		if ("inputType" in $$props) $$invalidate(35, inputType = $$new_props.inputType);
		if ("needsValue" in $$props) needsValue = $$new_props.needsValue;
		if ("inputValue" in $$props) $$invalidate(37, inputValue = $$new_props.inputValue);
		if ("classes" in $$props) classes = $$new_props.classes;
		if ("wrapClasses" in $$props) $$invalidate(38, wrapClasses = $$new_props.wrapClasses);
		if ("inputClassName" in $$props) $$invalidate(39, inputClassName = $$new_props.inputClassName);
		if ("hasInfoSlots" in $$props) $$invalidate(40, hasInfoSlots = $$new_props.hasInfoSlots);
	};

	let inputType;
	let needsValue;
	let inputValue;
	let classes;
	let wrapClasses;
	let inputClassName;
	let hasInfoSlots;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value*/ 4) {
			 watchValue();
		}

		if ($$self.$$.dirty[0] & /*type*/ 1) {
			 $$invalidate(35, inputType = type === "datepicker" || type === "colorpicker"
			? "text"
			: type);
		}

		if ($$self.$$.dirty[0] & /*type*/ 1) {
			 needsValue = type !== "file" && type !== "datepicker" && type !== "colorpicker";
		}

		if ($$self.$$.dirty[0] & /*value*/ 4) {
			 $$invalidate(37, inputValue = (() => {
				let v;

				if (typeof value !== "undefined") {
					v = value;
				} else {
					v = domValue();
				}

				if (typeof v === "undefined" || v === null) return "";
				return v;
			})());
		}

		if ($$self.$$.dirty[0] & /*resizable, errorMessage*/ 1342177280 | $$self.$$.dirty[1] & /*wrap, className, inputType, noFormStoreData, noStoreData, ignoreStoreData, errorMessageForce, inputInvalid, inputFocused*/ 51281941) {
			 classes = Utils.classNames(!wrap && className, {
				resizable: inputType === "textarea" && resizable,
				"no-store-data": noFormStoreData || noStoreData || ignoreStoreData,
				"input-invalid": errorMessage && errorMessageForce || inputInvalid,
				"input-with-value": inputHasValue(),
				"input-focused": inputFocused
			});
		}

		 $$invalidate(38, wrapClasses = Utils.classNames(
			className,
			"input",
			{
				"input-outline": outline,
				"input-dropdown": dropdown === "auto" ? type === "select" : dropdown
			},
			Mixins.colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*resizable, errorMessage*/ 1342177280 | $$self.$$.dirty[1] & /*wrap, className, inputType, noFormStoreData, noStoreData, ignoreStoreData, errorMessageForce, inputInvalid, inputFocused*/ 51281941) {
			 $$invalidate(39, inputClassName = Utils.classNames(!wrap && className, {
				resizable: inputType === "textarea" && resizable,
				"no-store-data": noFormStoreData || noStoreData || ignoreStoreData,
				"input-invalid": errorMessage && errorMessageForce || inputInvalid,
				"input-with-value": inputHasValue(),
				"input-focused": inputFocused
			}));
		}
	};

	 $$invalidate(40, hasInfoSlots = hasSlots(arguments, "info"));
	$$props = exclude_internal_props($$props);

	return [
		type,
		name,
		value,
		placeholder,
		inputId,
		size,
		accept,
		autocomplete,
		autocorrect,
		autocapitalize,
		spellcheck,
		autofocus,
		autosave,
		checked,
		disabled,
		max,
		min,
		step,
		maxlength,
		minlength,
		multiple,
		readonly,
		required,
		inputStyle,
		pattern,
		validate,
		validateOnBlur,
		tabindex,
		resizable,
		clearButton,
		errorMessage,
		errorMessageForce,
		info,
		wrap,
		textEditorParams,
		inputType,
		inputEl,
		inputValue,
		wrapClasses,
		inputClassName,
		hasInfoSlots,
		onInput,
		onFocus,
		onBlur,
		onChange,
		$$restProps,
		className,
		onValidate,
		noFormStoreData,
		noStoreData,
		ignoreStoreData,
		outline,
		dropdown,
		calendarParams,
		colorPickerParams,
		inputFocused,
		inputInvalid,
		$$scope,
		slots,
		select_binding,
		textarea_binding,
		input_binding,
		select_binding_1,
		textarea_binding_1,
		input_binding_1
	];
}

class Input extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$t,
			create_fragment$x,
			safe_not_equal,
			{
				class: 46,
				type: 0,
				name: 1,
				value: 2,
				placeholder: 3,
				inputId: 4,
				size: 5,
				accept: 6,
				autocomplete: 7,
				autocorrect: 8,
				autocapitalize: 9,
				spellcheck: 10,
				autofocus: 11,
				autosave: 12,
				checked: 13,
				disabled: 14,
				max: 15,
				min: 16,
				step: 17,
				maxlength: 18,
				minlength: 19,
				multiple: 20,
				readonly: 21,
				required: 22,
				inputStyle: 23,
				pattern: 24,
				validate: 25,
				validateOnBlur: 26,
				onValidate: 47,
				tabindex: 27,
				resizable: 28,
				clearButton: 29,
				noFormStoreData: 48,
				noStoreData: 49,
				ignoreStoreData: 50,
				errorMessage: 30,
				errorMessageForce: 31,
				info: 32,
				outline: 51,
				wrap: 33,
				dropdown: 52,
				calendarParams: 53,
				colorPickerParams: 54,
				textEditorParams: 34
			},
			[-1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Input",
			options,
			id: create_fragment$x.name
		});
	}

	get class() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputId() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputId(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accept() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accept(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autocomplete() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autocomplete(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autocorrect() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autocorrect(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autocapitalize() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autocapitalize(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get spellcheck() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set spellcheck(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autofocus() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autofocus(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autosave() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autosave(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get step() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set step(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get maxlength() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set maxlength(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get minlength() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set minlength(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get multiple() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multiple(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get required() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set required(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputStyle() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputStyle(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pattern() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pattern(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get validate() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set validate(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get validateOnBlur() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set validateOnBlur(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onValidate() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onValidate(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabindex() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabindex(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizable() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizable(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clearButton() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set clearButton(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noFormStoreData() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noFormStoreData(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noStoreData() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noStoreData(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ignoreStoreData() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ignoreStoreData(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errorMessage() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorMessage(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errorMessageForce() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorMessageForce(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get info() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set info(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outline() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outline(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get wrap() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set wrap(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dropdown() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dropdown(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get calendarParams() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set calendarParams(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get colorPickerParams() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set colorPickerParams(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get textEditorParams() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set textEditorParams(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/link.svelte generated by Svelte v3.31.0 */
const file$y = "node_modules/framework7-svelte/components/link.svelte";

// (159:2) {#if hasIcon}
function create_if_block_2$6(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				material: /*$$props*/ ctx[10].iconMaterial,
				f7: /*$$props*/ ctx[10].iconF7,
				icon: /*$$props*/ ctx[10].icon,
				md: /*$$props*/ ctx[10].iconMd,
				ios: /*$$props*/ ctx[10].iconIos,
				aurora: /*$$props*/ ctx[10].iconAurora,
				color: /*$$props*/ ctx[10].iconColor,
				size: /*$$props*/ ctx[10].iconSize,
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty[0] & /*$$props*/ 1024) icon_changes.material = /*$$props*/ ctx[10].iconMaterial;
			if (dirty[0] & /*$$props*/ 1024) icon_changes.f7 = /*$$props*/ ctx[10].iconF7;
			if (dirty[0] & /*$$props*/ 1024) icon_changes.icon = /*$$props*/ ctx[10].icon;
			if (dirty[0] & /*$$props*/ 1024) icon_changes.md = /*$$props*/ ctx[10].iconMd;
			if (dirty[0] & /*$$props*/ 1024) icon_changes.ios = /*$$props*/ ctx[10].iconIos;
			if (dirty[0] & /*$$props*/ 1024) icon_changes.aurora = /*$$props*/ ctx[10].iconAurora;
			if (dirty[0] & /*$$props*/ 1024) icon_changes.color = /*$$props*/ ctx[10].iconColor;
			if (dirty[0] & /*$$props*/ 1024) icon_changes.size = /*$$props*/ ctx[10].iconSize;

			if (dirty[0] & /*$$scope, badgeColor, iconBadge*/ 268435468) {
				icon_changes.$$scope = { dirty, ctx };
			}

			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$6.name,
		type: "if",
		source: "(159:2) {#if hasIcon}",
		ctx
	});

	return block;
}

// (169:5) {#if iconBadge}
function create_if_block_3$5(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[2],
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4) badge_1_changes.color = /*badgeColor*/ ctx[2];

			if (dirty[0] & /*$$scope, iconBadge*/ 268435464) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$5.name,
		type: "if",
		source: "(169:5) {#if iconBadge}",
		ctx
	});

	return block;
}

// (169:20) <Badge color={badgeColor}>
function create_default_slot_2$1(ctx) {
	let t;

	const block = {
		c: function create() {
			t = text(/*iconBadge*/ ctx[3]);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*iconBadge*/ 8) set_data_dev(t, /*iconBadge*/ ctx[3]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$1.name,
		type: "slot",
		source: "(169:20) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (160:4) <Icon       material={$$props.iconMaterial}       f7={$$props.iconF7}       icon={$$props.icon}       md={$$props.iconMd}       ios={$$props.iconIos}       aurora={$$props.iconAurora}       color={$$props.iconColor}       size={$$props.iconSize}     >
function create_default_slot_1$1(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*iconBadge*/ ctx[3] && create_if_block_3$5(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*iconBadge*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*iconBadge*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_3$5(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(160:4) <Icon       material={$$props.iconMaterial}       f7={$$props.iconF7}       icon={$$props.icon}       md={$$props.iconMd}       ios={$$props.iconIos}       aurora={$$props.iconAurora}       color={$$props.iconColor}       size={$$props.iconSize}     >",
		ctx
	});

	return block;
}

// (172:2) {#if typeof text !== 'undefined' || typeof badge !== 'undefined'}
function create_if_block$b(ctx) {
	let span;
	let t0_value = Utils.text(/*text*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	let if_block = typeof /*badge*/ ctx[1] !== "undefined" && create_if_block_1$6(ctx);

	const block = {
		c: function create() {
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			toggle_class(span, "tabbar-label", /*isTabbarLabel*/ ctx[4]);
			add_location(span, file$y, 172, 4, 4480);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t0);
			append_dev(span, t1);
			if (if_block) if_block.m(span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 1) && t0_value !== (t0_value = Utils.text(/*text*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (typeof /*badge*/ ctx[1] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$6(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(span, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (dirty[0] & /*isTabbarLabel*/ 16) {
				toggle_class(span, "tabbar-label", /*isTabbarLabel*/ ctx[4]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$b.name,
		type: "if",
		source: "(172:2) {#if typeof text !== 'undefined' || typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (175:6) {#if typeof badge !== 'undefined'}
function create_if_block_1$6(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[2],
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 4) badge_1_changes.color = /*badgeColor*/ ctx[2];

			if (dirty[0] & /*$$scope, badge*/ 268435458) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$6.name,
		type: "if",
		source: "(175:6) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (175:40) <Badge color={badgeColor}>
function create_default_slot$1(ctx) {
	let t_value = Utils.text(/*badge*/ ctx[1]) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 2 && t_value !== (t_value = Utils.text(/*badge*/ ctx[1]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(175:40) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

function create_fragment$y(ctx) {
	let a;
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*hasIcon*/ ctx[8] && create_if_block_2$6(ctx);
	const default_slot_template = /*#slots*/ ctx[26].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[28], null);
	let if_block1 = (typeof /*text*/ ctx[0] !== "undefined" || typeof /*badge*/ ctx[1] !== "undefined") && create_if_block$b(ctx);
	let a_levels = [{ class: /*classes*/ ctx[7] }, /*attrs*/ ctx[6]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (if_block0) if_block0.c();
			t0 = space();
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			set_attributes(a, a_data);
			add_location(a, file$y, 152, 0, 3971);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			if (if_block0) if_block0.m(a, null);
			append_dev(a, t0);

			if (default_slot) {
				default_slot.m(a, null);
			}

			append_dev(a, t1);
			if (if_block1) if_block1.m(a, null);
			/*a_binding*/ ctx[27](a);
			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[9], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*hasIcon*/ ctx[8]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*hasIcon*/ 256) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$6(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(a, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 268435456) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[28], dirty, null, null);
				}
			}

			if (typeof /*text*/ ctx[0] !== "undefined" || typeof /*badge*/ ctx[1] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*text, badge*/ 3) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$b(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(a, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty[0] & /*classes*/ 128) && { class: /*classes*/ ctx[7] },
				dirty[0] & /*attrs*/ 64 && /*attrs*/ ctx[6]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
			/*a_binding*/ ctx[27](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$u($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","noLinkClass","text","tabLink","tabLinkActive","tabbarLabel","iconOnly","badge","badgeColor","iconBadge","href","target","tooltip","tooltipTrigger","smartSelect","smartSelectParams"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Link", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { noLinkClass = false } = $$props;
	let { text = undefined } = $$props;
	let { tabLink = undefined } = $$props;
	let { tabLinkActive = false } = $$props;
	let { tabbarLabel = false } = $$props;
	let { iconOnly = false } = $$props;
	let { badge = undefined } = $$props;
	let { badgeColor = undefined } = $$props;
	let { iconBadge = undefined } = $$props;
	let { href = "#" } = $$props;
	let { target = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let { smartSelect = false } = $$props;
	let { smartSelectParams = undefined } = $$props;
	let el;
	let f7Tooltip;
	let f7SmartSelect;
	let isTabbarLabel = tabbarLabel;
	let tooltipText = tooltip;

	function watchTooltip(newText) {
		const oldText = tooltipText;
		if (oldText === newText) return;
		tooltipText = newText;

		if (!newText && f7Tooltip) {
			f7Tooltip.destroy();
			f7Tooltip = null;
			return;
		}

		if (newText && !f7Tooltip && f7.instance) {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: newText,
				trigger: tooltipTrigger
			});

			return;
		}

		if (!newText || !f7Tooltip) return;
		f7Tooltip.setText(newText);
	}

	function onClick() {
		dispatch("click");
		if (typeof $$props.onClick === "function") $$props.onClick();
	}

	onMount(() => {
		if ($$props.routeProps) {
			$$invalidate(5, el.f7RouteProps = $$props.routeProps, el);
		}

		f7.ready(() => {
			if (tabbarLabel || (tabLink || tabLink === "") && f7.instance.$(el).parents(".tabbar-labels").length) {
				$$invalidate(4, isTabbarLabel = true);
			}

			if (smartSelect) {
				const ssParams = Utils.extend({ el }, smartSelectParams || {});
				f7SmartSelect = f7.instance.smartSelect.create(ssParams);
			}

			if (tooltip) {
				f7Tooltip = f7.instance.tooltip.create({
					targetEl: el,
					text: tooltip,
					trigger: tooltipTrigger
				});
			}
		});
	});

	afterUpdate(() => {
		if ($$props.routeProps) {
			$$invalidate(5, el.f7RouteProps = $$props.routeProps, el);
		}
	});

	onDestroy(() => {
		if (el) delete el.f7RouteProps;

		if (f7SmartSelect && f7SmartSelect.destroy) {
			f7SmartSelect.destroy();
			f7SmartSelect = null;
		}

		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
			f7Tooltip = null;
		}
	});

	function a_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(5, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(35, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(11, className = $$new_props.class);
		if ("noLinkClass" in $$new_props) $$invalidate(12, noLinkClass = $$new_props.noLinkClass);
		if ("text" in $$new_props) $$invalidate(0, text = $$new_props.text);
		if ("tabLink" in $$new_props) $$invalidate(13, tabLink = $$new_props.tabLink);
		if ("tabLinkActive" in $$new_props) $$invalidate(14, tabLinkActive = $$new_props.tabLinkActive);
		if ("tabbarLabel" in $$new_props) $$invalidate(15, tabbarLabel = $$new_props.tabbarLabel);
		if ("iconOnly" in $$new_props) $$invalidate(16, iconOnly = $$new_props.iconOnly);
		if ("badge" in $$new_props) $$invalidate(1, badge = $$new_props.badge);
		if ("badgeColor" in $$new_props) $$invalidate(2, badgeColor = $$new_props.badgeColor);
		if ("iconBadge" in $$new_props) $$invalidate(3, iconBadge = $$new_props.iconBadge);
		if ("href" in $$new_props) $$invalidate(17, href = $$new_props.href);
		if ("target" in $$new_props) $$invalidate(18, target = $$new_props.target);
		if ("tooltip" in $$new_props) $$invalidate(19, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$new_props) $$invalidate(20, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("smartSelect" in $$new_props) $$invalidate(21, smartSelect = $$new_props.smartSelect);
		if ("smartSelectParams" in $$new_props) $$invalidate(22, smartSelectParams = $$new_props.smartSelectParams);
		if ("$$scope" in $$new_props) $$invalidate(28, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		afterUpdate,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		hasSlots,
		Badge,
		Icon,
		dispatch,
		className,
		noLinkClass,
		text,
		tabLink,
		tabLinkActive,
		tabbarLabel,
		iconOnly,
		badge,
		badgeColor,
		iconBadge,
		href,
		target,
		tooltip,
		tooltipTrigger,
		smartSelect,
		smartSelectParams,
		el,
		f7Tooltip,
		f7SmartSelect,
		isTabbarLabel,
		tooltipText,
		watchTooltip,
		onClick,
		hrefComputed,
		attrs,
		hasDefaultSlots,
		iconOnlyComputed,
		classes,
		hasIcon,
		hasIconBadge
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(11, className = $$new_props.className);
		if ("noLinkClass" in $$props) $$invalidate(12, noLinkClass = $$new_props.noLinkClass);
		if ("text" in $$props) $$invalidate(0, text = $$new_props.text);
		if ("tabLink" in $$props) $$invalidate(13, tabLink = $$new_props.tabLink);
		if ("tabLinkActive" in $$props) $$invalidate(14, tabLinkActive = $$new_props.tabLinkActive);
		if ("tabbarLabel" in $$props) $$invalidate(15, tabbarLabel = $$new_props.tabbarLabel);
		if ("iconOnly" in $$props) $$invalidate(16, iconOnly = $$new_props.iconOnly);
		if ("badge" in $$props) $$invalidate(1, badge = $$new_props.badge);
		if ("badgeColor" in $$props) $$invalidate(2, badgeColor = $$new_props.badgeColor);
		if ("iconBadge" in $$props) $$invalidate(3, iconBadge = $$new_props.iconBadge);
		if ("href" in $$props) $$invalidate(17, href = $$new_props.href);
		if ("target" in $$props) $$invalidate(18, target = $$new_props.target);
		if ("tooltip" in $$props) $$invalidate(19, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$props) $$invalidate(20, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("smartSelect" in $$props) $$invalidate(21, smartSelect = $$new_props.smartSelect);
		if ("smartSelectParams" in $$props) $$invalidate(22, smartSelectParams = $$new_props.smartSelectParams);
		if ("el" in $$props) $$invalidate(5, el = $$new_props.el);
		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
		if ("f7SmartSelect" in $$props) f7SmartSelect = $$new_props.f7SmartSelect;
		if ("isTabbarLabel" in $$props) $$invalidate(4, isTabbarLabel = $$new_props.isTabbarLabel);
		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
		if ("hrefComputed" in $$props) $$invalidate(23, hrefComputed = $$new_props.hrefComputed);
		if ("attrs" in $$props) $$invalidate(6, attrs = $$new_props.attrs);
		if ("hasDefaultSlots" in $$props) $$invalidate(24, hasDefaultSlots = $$new_props.hasDefaultSlots);
		if ("iconOnlyComputed" in $$props) $$invalidate(25, iconOnlyComputed = $$new_props.iconOnlyComputed);
		if ("classes" in $$props) $$invalidate(7, classes = $$new_props.classes);
		if ("hasIcon" in $$props) $$invalidate(8, hasIcon = $$new_props.hasIcon);
		if ("hasIconBadge" in $$props) hasIconBadge = $$new_props.hasIconBadge;
	};

	let hrefComputed;
	let attrs;
	let hasDefaultSlots;
	let iconOnlyComputed;
	let classes;
	let hasIcon;
	let hasIconBadge;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*href*/ 131072) {
			 $$invalidate(23, hrefComputed = href === true ? "#" : href || undefined);
		}

		 $$invalidate(6, attrs = Utils.extend(
			{
				href: hrefComputed,
				target,
				"data-tab": Utils.isStringProp(tabLink) && tabLink || undefined,
				...restProps($$restProps)
			},
			Mixins.linkRouterAttrs($$props),
			Mixins.linkActionsAttrs($$props)
		));

		if ($$self.$$.dirty[0] & /*iconOnly, text, hasDefaultSlots*/ 16842753) {
			 $$invalidate(25, iconOnlyComputed = iconOnly || !text && !hasDefaultSlots);
		}

		 $$invalidate(7, classes = Utils.classNames(
			className,
			{
				link: !(noLinkClass || isTabbarLabel),
				"icon-only": iconOnlyComputed,
				"tab-link": tabLink || tabLink === "",
				"tab-link-active": tabLinkActive,
				"smart-select": smartSelect
			},
			Mixins.colorClasses($$props),
			Mixins.linkRouterClasses($$props),
			Mixins.linkActionsClasses($$props)
		));

		 $$invalidate(8, hasIcon = $$props.icon || $$props.iconMaterial || $$props.iconF7 || $$props.iconMd || $$props.iconIos || $$props.iconAurora);
		 hasIconBadge = $$props.hasIconBadge;

		if ($$self.$$.dirty[0] & /*tooltip*/ 524288) {
			 watchTooltip(tooltip);
		}
	};

	 $$invalidate(24, hasDefaultSlots = hasSlots(arguments, "default"));
	$$props = exclude_internal_props($$props);

	return [
		text,
		badge,
		badgeColor,
		iconBadge,
		isTabbarLabel,
		el,
		attrs,
		classes,
		hasIcon,
		onClick,
		$$props,
		className,
		noLinkClass,
		tabLink,
		tabLinkActive,
		tabbarLabel,
		iconOnly,
		href,
		target,
		tooltip,
		tooltipTrigger,
		smartSelect,
		smartSelectParams,
		hrefComputed,
		hasDefaultSlots,
		iconOnlyComputed,
		slots,
		a_binding,
		$$scope
	];
}

class Link extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$u,
			create_fragment$y,
			safe_not_equal,
			{
				class: 11,
				noLinkClass: 12,
				text: 0,
				tabLink: 13,
				tabLinkActive: 14,
				tabbarLabel: 15,
				iconOnly: 16,
				badge: 1,
				badgeColor: 2,
				iconBadge: 3,
				href: 17,
				target: 18,
				tooltip: 19,
				tooltipTrigger: 20,
				smartSelect: 21,
				smartSelectParams: 22
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Link",
			options,
			id: create_fragment$y.name
		});
	}

	get class() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noLinkClass() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noLinkClass(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabLink() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabLink(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabLinkActive() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabLinkActive(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabbarLabel() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabbarLabel(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iconOnly() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconOnly(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get badge() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set badge(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get badgeColor() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set badgeColor(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iconBadge() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconBadge(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get target() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set target(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltip() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltip(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltipTrigger() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltipTrigger(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smartSelect() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smartSelect(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smartSelectParams() {
		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smartSelectParams(value) {
		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/list-button.svelte generated by Svelte v3.31.0 */
const file$z = "node_modules/framework7-svelte/components/list-button.svelte";

// (108:10) {title || text}
function fallback_block(ctx) {
	let t_value = (/*title*/ ctx[1] || /*text*/ ctx[2]) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title, text*/ 6 && t_value !== (t_value = (/*title*/ ctx[1] || /*text*/ ctx[2]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(108:10) {title || text}",
		ctx
	});

	return block;
}

function create_fragment$z(ctx) {
	let li;
	let a;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);
	let a_levels = [{ class: /*classes*/ ctx[4] }, /*attrs*/ ctx[3]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	let li_levels = [{ class: /*className*/ ctx[0] }, restProps(/*$$restProps*/ ctx[6])];
	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			set_attributes(a, a_data);
			add_location(a, file$z, 106, 2, 2681);
			set_attributes(li, li_data);
			add_location(li, file$z, 105, 0, 2628);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 32768) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title, text*/ 6) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*attrs*/ 8 && /*attrs*/ ctx[3]
			]));

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$v($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","title","text","tabLink","tabLinkActive","link","href","target","tooltip","tooltipTrigger"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("List_button", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { title = undefined } = $$props;
	let { text = undefined } = $$props;
	let { tabLink = undefined } = $$props;
	let { tabLinkActive = false } = $$props;
	let { link = undefined } = $$props;
	let { href = undefined } = $$props;
	let { target = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let el;
	let f7Tooltip;
	let tooltipText = tooltip;

	function watchTooltip(newText) {
		const oldText = tooltipText;
		if (oldText === newText) return;
		tooltipText = newText;

		if (!newText && f7Tooltip) {
			f7Tooltip.destroy();
			f7Tooltip = null;
			return;
		}

		if (newText && !f7Tooltip && f7.instance) {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: newText,
				trigger: tooltipTrigger
			});

			return;
		}

		if (!newText || !f7Tooltip) return;
		f7Tooltip.setText(newText);
	}

	function onClick() {
		dispatch("click");
		if (typeof $$props.onClick === "function") $$props.onClick();
	}

	onMount(() => {
		if ($$props.routeProps) {
			el.f7RouteProps = $$props.routeProps;
		}

		f7.ready(() => {
			if (tooltip) {
				f7Tooltip = f7.instance.tooltip.create({
					targetEl: el,
					text: tooltip,
					trigger: tooltipTrigger
				});
			}
		});
	});

	afterUpdate(() => {
		if ($$props.routeProps) {
			el.f7RouteProps = $$props.routeProps;
		}
	});

	onDestroy(() => {
		if (el) delete el.f7RouteProps;

		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
			f7Tooltip = null;
		}
	});

	$$self.$$set = $$new_props => {
		$$invalidate(22, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
		if ("title" in $$new_props) $$invalidate(1, title = $$new_props.title);
		if ("text" in $$new_props) $$invalidate(2, text = $$new_props.text);
		if ("tabLink" in $$new_props) $$invalidate(7, tabLink = $$new_props.tabLink);
		if ("tabLinkActive" in $$new_props) $$invalidate(8, tabLinkActive = $$new_props.tabLinkActive);
		if ("link" in $$new_props) $$invalidate(9, link = $$new_props.link);
		if ("href" in $$new_props) $$invalidate(10, href = $$new_props.href);
		if ("target" in $$new_props) $$invalidate(11, target = $$new_props.target);
		if ("tooltip" in $$new_props) $$invalidate(12, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$new_props) $$invalidate(13, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		afterUpdate,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		title,
		text,
		tabLink,
		tabLinkActive,
		link,
		href,
		target,
		tooltip,
		tooltipTrigger,
		el,
		f7Tooltip,
		tooltipText,
		watchTooltip,
		onClick,
		hrefComputed,
		attrs,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(22, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
		if ("title" in $$props) $$invalidate(1, title = $$new_props.title);
		if ("text" in $$props) $$invalidate(2, text = $$new_props.text);
		if ("tabLink" in $$props) $$invalidate(7, tabLink = $$new_props.tabLink);
		if ("tabLinkActive" in $$props) $$invalidate(8, tabLinkActive = $$new_props.tabLinkActive);
		if ("link" in $$props) $$invalidate(9, link = $$new_props.link);
		if ("href" in $$props) $$invalidate(10, href = $$new_props.href);
		if ("target" in $$props) $$invalidate(11, target = $$new_props.target);
		if ("tooltip" in $$props) $$invalidate(12, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$props) $$invalidate(13, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("el" in $$props) el = $$new_props.el;
		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
		if ("hrefComputed" in $$props) $$invalidate(14, hrefComputed = $$new_props.hrefComputed);
		if ("attrs" in $$props) $$invalidate(3, attrs = $$new_props.attrs);
		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
	};

	let hrefComputed;
	let attrs;
	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*link, href*/ 1536) {
			 $$invalidate(14, hrefComputed = typeof link === "boolean" && typeof href === "boolean"
			? "#"
			: link || href);
		}

		 $$invalidate(3, attrs = Utils.extend(
			{
				href: hrefComputed,
				target,
				"data-tab": Utils.isStringProp(tabLink) && tabLink || undefined
			},
			Mixins.linkRouterAttrs($$props),
			Mixins.linkActionsAttrs($$props)
		));

		 $$invalidate(4, classes = Utils.classNames(
			{
				"list-button": true,
				"tab-link": tabLink || tabLink === "",
				"tab-link-active": tabLinkActive
			},
			Mixins.colorClasses($$props),
			Mixins.linkRouterClasses($$props),
			Mixins.linkActionsClasses($$props)
		));

		if ($$self.$$.dirty & /*tooltip*/ 4096) {
			 watchTooltip(tooltip);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		className,
		title,
		text,
		attrs,
		classes,
		onClick,
		$$restProps,
		tabLink,
		tabLinkActive,
		link,
		href,
		target,
		tooltip,
		tooltipTrigger,
		hrefComputed,
		$$scope,
		slots
	];
}

class List_button extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$v, create_fragment$z, safe_not_equal, {
			class: 0,
			title: 1,
			text: 2,
			tabLink: 7,
			tabLinkActive: 8,
			link: 9,
			href: 10,
			target: 11,
			tooltip: 12,
			tooltipTrigger: 13
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "List_button",
			options,
			id: create_fragment$z.name
		});
	}

	get class() {
		throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabLink() {
		throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabLink(value) {
		throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabLinkActive() {
		throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabLinkActive(value) {
		throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get link() {
		throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set link(value) {
		throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get target() {
		throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set target(value) {
		throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltip() {
		throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltip(value) {
		throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltipTrigger() {
		throw new Error("<List_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltipTrigger(value) {
		throw new Error("<List_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/list-group.svelte generated by Svelte v3.31.0 */
const file$A = "node_modules/framework7-svelte/components/list-group.svelte";

function create_fragment$A(ctx) {
	let div;
	let ul;
	let div_data_sortable_move_elements_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	let div_levels = [
		{ class: /*classes*/ ctx[1] },
		{
			"data-sortable-move-elements": div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[0] !== "undefined"
			? /*sortableMoveElements*/ ctx[0].toString()
			: undefined
		},
		restProps(/*$$restProps*/ ctx[2])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			ul = element("ul");
			if (default_slot) default_slot.c();
			add_location(ul, file$A, 41, 2, 1203);
			set_attributes(div, div_data);
			add_location(div, file$A, 40, 0, 1031);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, ul);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				(!current || dirty & /*sortableMoveElements*/ 1 && div_data_sortable_move_elements_value !== (div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[0] !== "undefined"
				? /*sortableMoveElements*/ ctx[0].toString()
				: undefined)) && {
					"data-sortable-move-elements": div_data_sortable_move_elements_value
				},
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$A.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$w($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","mediaList","sortable","sortableOpposite","sortableTapHold","sortableMoveElements"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("List_group", slots, ['default']);
	let { class: className = undefined } = $$props;
	let { mediaList = undefined } = $$props;
	let { sortable = undefined } = $$props;
	let { sortableOpposite = undefined } = $$props;
	let { sortableTapHold = false } = $$props;
	let { sortableMoveElements = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("mediaList" in $$new_props) $$invalidate(4, mediaList = $$new_props.mediaList);
		if ("sortable" in $$new_props) $$invalidate(5, sortable = $$new_props.sortable);
		if ("sortableOpposite" in $$new_props) $$invalidate(6, sortableOpposite = $$new_props.sortableOpposite);
		if ("sortableTapHold" in $$new_props) $$invalidate(7, sortableTapHold = $$new_props.sortableTapHold);
		if ("sortableMoveElements" in $$new_props) $$invalidate(0, sortableMoveElements = $$new_props.sortableMoveElements);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		setContext,
		Mixins,
		Utils,
		restProps,
		className,
		mediaList,
		sortable,
		sortableOpposite,
		sortableTapHold,
		sortableMoveElements,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("mediaList" in $$props) $$invalidate(4, mediaList = $$new_props.mediaList);
		if ("sortable" in $$props) $$invalidate(5, sortable = $$new_props.sortable);
		if ("sortableOpposite" in $$props) $$invalidate(6, sortableOpposite = $$new_props.sortableOpposite);
		if ("sortableTapHold" in $$props) $$invalidate(7, sortableTapHold = $$new_props.sortableTapHold);
		if ("sortableMoveElements" in $$props) $$invalidate(0, sortableMoveElements = $$new_props.sortableMoveElements);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*mediaList*/ 16) {
			 if (typeof mediaList !== "undefined") {
				setContext("f7ListMedia", mediaList);
			}
		}

		if ($$self.$$.dirty & /*sortable*/ 32) {
			 if (typeof sortable !== "undefined") {
				setContext("f7ListSortable", sortable);
			}
		}

		if ($$self.$$.dirty & /*sortable, sortableOpposite*/ 96) {
			 if (typeof sortable !== "undefined" && typeof sortableOpposite !== "undefined") {
				setContext("f7ListSortableOpposite", sortable);
			}
		}

		 $$invalidate(1, classes = Utils.classNames(
			className,
			"list-group",
			{
				"media-list": mediaList,
				sortable,
				"sortable-tap-hold": sortableTapHold,
				"sortable-opposite": sortableOpposite
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		sortableMoveElements,
		classes,
		$$restProps,
		className,
		mediaList,
		sortable,
		sortableOpposite,
		sortableTapHold,
		$$scope,
		slots
	];
}

class List_group extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$w, create_fragment$A, safe_not_equal, {
			class: 3,
			mediaList: 4,
			sortable: 5,
			sortableOpposite: 6,
			sortableTapHold: 7,
			sortableMoveElements: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "List_group",
			options,
			id: create_fragment$A.name
		});
	}

	get class() {
		throw new Error("<List_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<List_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mediaList() {
		throw new Error("<List_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mediaList(value) {
		throw new Error("<List_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortable() {
		throw new Error("<List_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortable(value) {
		throw new Error("<List_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortableOpposite() {
		throw new Error("<List_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortableOpposite(value) {
		throw new Error("<List_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortableTapHold() {
		throw new Error("<List_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortableTapHold(value) {
		throw new Error("<List_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortableMoveElements() {
		throw new Error("<List_group>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortableMoveElements(value) {
		throw new Error("<List_group>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/list-index.svelte generated by Svelte v3.31.0 */
const file$B = "node_modules/framework7-svelte/components/list-index.svelte";

function create_fragment$B(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);

	let div_levels = [
		{ class: /*classes*/ ctx[2] },
		{ "data-f7-slot": /*f7Slot*/ ctx[0] },
		restProps(/*$$restProps*/ ctx[3])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$B, 87, 0, 1977);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[18](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				(!current || dirty & /*f7Slot*/ 1) && { "data-f7-slot": /*f7Slot*/ ctx[0] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[18](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$B.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$4($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","init","listEl","indexes","scrollList","label","iosItemHeight","mdItemHeight","auroraItemHeight","f7Slot","instance","update","scrollListToIndex"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("List_index", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { init = true } = $$props;
	let { listEl = undefined } = $$props;
	let { indexes = "auto" } = $$props;
	let { scrollList = true } = $$props;
	let { label = false } = $$props;
	let { iosItemHeight = 14 } = $$props;
	let { mdItemHeight = 14 } = $$props;
	let { auroraItemHeight = 14 } = $$props;
	let { f7Slot = "fixed" } = $$props;
	let el;
	let f7ListIndex;

	function instance() {
		return f7ListIndex;
	}

	function update() {
		if (!f7ListIndex) return;
		f7ListIndex.update();
	}

	function scrollListToIndex(indexContent) {
		if (!f7ListIndex) return;
		f7ListIndex.scrollListToIndex(indexContent);
	}

	let initialWatched = false;

	function watchIndexes() {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7ListIndex) return;
		f7ListIndex.params.indexes = indexes;
		update();
	}

	onMount(() => {
		if (!init || !el) return;

		f7.ready(() => {
			f7ListIndex = f7.instance.listIndex.create({
				el,
				listEl,
				indexes,
				iosItemHeight,
				mdItemHeight,
				auroraItemHeight,
				scrollList,
				label,
				on: {
					select(index, itemContent, itemIndex) {
						dispatch("listIndexSelect", [itemContent, itemIndex]);
						if (typeof $$props.onListIndexSelect === "function") $$props.onListIndexSelect(itemContent, itemIndex);
					}
				}
			});
		});
	});

	onDestroy(() => {
		if (f7ListIndex && f7ListIndex.destroy) f7ListIndex.destroy();
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("init" in $$new_props) $$invalidate(5, init = $$new_props.init);
		if ("listEl" in $$new_props) $$invalidate(6, listEl = $$new_props.listEl);
		if ("indexes" in $$new_props) $$invalidate(7, indexes = $$new_props.indexes);
		if ("scrollList" in $$new_props) $$invalidate(8, scrollList = $$new_props.scrollList);
		if ("label" in $$new_props) $$invalidate(9, label = $$new_props.label);
		if ("iosItemHeight" in $$new_props) $$invalidate(10, iosItemHeight = $$new_props.iosItemHeight);
		if ("mdItemHeight" in $$new_props) $$invalidate(11, mdItemHeight = $$new_props.mdItemHeight);
		if ("auroraItemHeight" in $$new_props) $$invalidate(12, auroraItemHeight = $$new_props.auroraItemHeight);
		if ("f7Slot" in $$new_props) $$invalidate(0, f7Slot = $$new_props.f7Slot);
		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		init,
		listEl,
		indexes,
		scrollList,
		label,
		iosItemHeight,
		mdItemHeight,
		auroraItemHeight,
		f7Slot,
		el,
		f7ListIndex,
		instance,
		update,
		scrollListToIndex,
		initialWatched,
		watchIndexes,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("init" in $$props) $$invalidate(5, init = $$new_props.init);
		if ("listEl" in $$props) $$invalidate(6, listEl = $$new_props.listEl);
		if ("indexes" in $$props) $$invalidate(7, indexes = $$new_props.indexes);
		if ("scrollList" in $$props) $$invalidate(8, scrollList = $$new_props.scrollList);
		if ("label" in $$props) $$invalidate(9, label = $$new_props.label);
		if ("iosItemHeight" in $$props) $$invalidate(10, iosItemHeight = $$new_props.iosItemHeight);
		if ("mdItemHeight" in $$props) $$invalidate(11, mdItemHeight = $$new_props.mdItemHeight);
		if ("auroraItemHeight" in $$props) $$invalidate(12, auroraItemHeight = $$new_props.auroraItemHeight);
		if ("f7Slot" in $$props) $$invalidate(0, f7Slot = $$new_props.f7Slot);
		if ("el" in $$props) $$invalidate(1, el = $$new_props.el);
		if ("f7ListIndex" in $$props) f7ListIndex = $$new_props.f7ListIndex;
		if ("initialWatched" in $$props) initialWatched = $$new_props.initialWatched;
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(2, classes = Utils.classNames(className, "list-index", Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*indexes*/ 128) {
			 watchIndexes();
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		f7Slot,
		el,
		classes,
		$$restProps,
		className,
		init,
		listEl,
		indexes,
		scrollList,
		label,
		iosItemHeight,
		mdItemHeight,
		auroraItemHeight,
		instance,
		update,
		scrollListToIndex,
		$$scope,
		slots,
		div_binding
	];
}

class List_index extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance_1$4, create_fragment$B, safe_not_equal, {
			class: 4,
			init: 5,
			listEl: 6,
			indexes: 7,
			scrollList: 8,
			label: 9,
			iosItemHeight: 10,
			mdItemHeight: 11,
			auroraItemHeight: 12,
			f7Slot: 0,
			instance: 13,
			update: 14,
			scrollListToIndex: 15
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "List_index",
			options,
			id: create_fragment$B.name
		});
	}

	get class() {
		throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get init() {
		throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set init(value) {
		throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get listEl() {
		throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set listEl(value) {
		throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get indexes() {
		throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set indexes(value) {
		throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrollList() {
		throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scrollList(value) {
		throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iosItemHeight() {
		throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iosItemHeight(value) {
		throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mdItemHeight() {
		throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mdItemHeight(value) {
		throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get auroraItemHeight() {
		throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set auroraItemHeight(value) {
		throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get f7Slot() {
		throw new Error("<List_index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set f7Slot(value) {
		throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[13];
	}

	set instance(value) {
		throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get update() {
		return this.$$.ctx[14];
	}

	set update(value) {
		throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrollListToIndex() {
		return this.$$.ctx[15];
	}

	set scrollListToIndex(value) {
		throw new Error("<List_index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/list-input.svelte generated by Svelte v3.31.0 */
const file$C = "node_modules/framework7-svelte/components/list-input.svelte";
const get_content_end_slot_changes_1 = dirty => ({});
const get_content_end_slot_context_1 = ctx => ({});
const get_content_slot_changes_1 = dirty => ({});
const get_content_slot_context_1 = ctx => ({});
const get_inner_end_slot_changes_1 = dirty => ({});
const get_inner_end_slot_context_1 = ctx => ({});
const get_inner_slot_changes_1 = dirty => ({});
const get_inner_slot_context_1 = ctx => ({});
const get_info_slot_changes_1 = dirty => ({});
const get_info_slot_context_1 = ctx => ({});
const get_error_message_slot_changes_1 = dirty => ({});
const get_error_message_slot_context_1 = ctx => ({});
const get_input_slot_changes_1 = dirty => ({});
const get_input_slot_context_1 = ctx => ({});
const get_label_slot_changes_1 = dirty => ({});
const get_label_slot_context_1 = ctx => ({});
const get_inner_start_slot_changes_1 = dirty => ({});
const get_inner_start_slot_context_1 = ctx => ({});
const get_media_slot_changes_1 = dirty => ({});
const get_media_slot_context_1 = ctx => ({});
const get_content_start_slot_changes_1 = dirty => ({});
const get_content_start_slot_context_1 = ctx => ({});
const get_root_end_slot_changes$1 = dirty => ({});
const get_root_end_slot_context$1 = ctx => ({});
const get_root_slot_changes$2 = dirty => ({});
const get_root_slot_context$2 = ctx => ({});
const get_content_end_slot_changes = dirty => ({});
const get_content_end_slot_context = ctx => ({});
const get_content_slot_changes$1 = dirty => ({});
const get_content_slot_context$1 = ctx => ({});
const get_inner_end_slot_changes = dirty => ({});
const get_inner_end_slot_context = ctx => ({});
const get_inner_slot_changes = dirty => ({});
const get_inner_slot_context = ctx => ({});
const get_info_slot_changes$1 = dirty => ({});
const get_info_slot_context$1 = ctx => ({});
const get_error_message_slot_changes = dirty => ({});
const get_error_message_slot_context = ctx => ({});
const get_input_slot_changes = dirty => ({});
const get_input_slot_context = ctx => ({});
const get_label_slot_changes = dirty => ({});
const get_label_slot_context = ctx => ({});
const get_inner_start_slot_changes = dirty => ({});
const get_inner_start_slot_context = ctx => ({});
const get_media_slot_changes$2 = dirty => ({});
const get_media_slot_context$2 = ctx => ({});
const get_content_start_slot_changes = dirty => ({});
const get_content_start_slot_context = ctx => ({});
const get_root_start_slot_changes$1 = dirty => ({});
const get_root_start_slot_context$1 = ctx => ({});

// (563:0) {:else}
function create_else_block_1$1(ctx) {
	let div2;
	let t0;
	let t1;
	let t2;
	let div1;
	let t3;
	let t4;
	let div0;
	let t5;
	let t6;
	let t7;
	let t8;
	let t9;
	let t10;
	let t11;
	let t12;
	let current;
	const content_start_slot_template = /*#slots*/ ctx[76]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[75], get_content_start_slot_context_1);
	let if_block0 = /*isSortable*/ ctx[42] && /*isSortableOpposite*/ ctx[43] && create_if_block_23(ctx);
	let if_block1 = (/*media*/ ctx[0] || /*hasMediaSlots*/ ctx[45]) && create_if_block_21(ctx);
	const inner_start_slot_template = /*#slots*/ ctx[76]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[75], get_inner_start_slot_context_1);
	let if_block2 = (typeof /*label*/ ctx[36] !== "undefined" || /*hasLabelSlots*/ ctx[46]) && create_if_block_20(ctx);
	let if_block3 = /*input*/ ctx[2] && create_if_block_16(ctx);
	const input_slot_template = /*#slots*/ ctx[76].input;
	const input_slot = create_slot(input_slot_template, ctx, /*$$scope*/ ctx[75], get_input_slot_context_1);
	let if_block4 = /*hasErrorMessage*/ ctx[40] && /*errorMessageForce*/ ctx[34] && create_if_block_15(ctx);
	let if_block5 = /*clearButton*/ ctx[32] && create_if_block_14(ctx);
	let if_block6 = (typeof /*info*/ ctx[35] !== "undefined" || /*hasInfoSlots*/ ctx[39]) && create_if_block_13$1(ctx);
	const inner_slot_template = /*#slots*/ ctx[76].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[75], get_inner_slot_context_1);
	const inner_end_slot_template = /*#slots*/ ctx[76]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[75], get_inner_end_slot_context_1);
	const content_slot_template = /*#slots*/ ctx[76].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[75], get_content_slot_context_1);
	const content_end_slot_template = /*#slots*/ ctx[76]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[75], get_content_end_slot_context_1);
	let div2_levels = [{ class: /*itemContentClasses*/ ctx[48] }, restProps(/*$$restProps*/ ctx[56])];
	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div1 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			div0 = element("div");
			if (if_block3) if_block3.c();
			t5 = space();
			if (input_slot) input_slot.c();
			t6 = space();
			if (if_block4) if_block4.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			t9 = space();
			if (inner_slot) inner_slot.c();
			t10 = space();
			if (inner_end_slot) inner_end_slot.c();
			t11 = space();
			if (content_slot) content_slot.c();
			t12 = space();
			if (content_end_slot) content_end_slot.c();
			attr_dev(div0, "class", /*inputWrapClasses*/ ctx[50]);
			add_location(div0, file$C, 585, 6, 18868);
			attr_dev(div1, "class", "item-inner");
			add_location(div1, file$C, 577, 4, 18621);
			set_attributes(div2, div2_data);
			add_location(div2, file$C, 563, 2, 18224);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);

			if (content_start_slot) {
				content_start_slot.m(div2, null);
			}

			append_dev(div2, t0);
			if (if_block0) if_block0.m(div2, null);
			append_dev(div2, t1);
			if (if_block1) if_block1.m(div2, null);
			append_dev(div2, t2);
			append_dev(div2, div1);

			if (inner_start_slot) {
				inner_start_slot.m(div1, null);
			}

			append_dev(div1, t3);
			if (if_block2) if_block2.m(div1, null);
			append_dev(div1, t4);
			append_dev(div1, div0);
			if (if_block3) if_block3.m(div0, null);
			append_dev(div0, t5);

			if (input_slot) {
				input_slot.m(div0, null);
			}

			append_dev(div0, t6);
			if (if_block4) if_block4.m(div0, null);
			append_dev(div0, t7);
			if (if_block5) if_block5.m(div0, null);
			append_dev(div0, t8);
			if (if_block6) if_block6.m(div0, null);
			append_dev(div1, t9);

			if (inner_slot) {
				inner_slot.m(div1, null);
			}

			append_dev(div1, t10);

			if (inner_end_slot) {
				inner_end_slot.m(div1, null);
			}

			append_dev(div2, t11);

			if (content_slot) {
				content_slot.m(div2, null);
			}

			append_dev(div2, t12);

			if (content_end_slot) {
				content_end_slot.m(div2, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_content_start_slot_changes_1, get_content_start_slot_context_1);
				}
			}

			if (/*isSortable*/ ctx[42] && /*isSortableOpposite*/ ctx[43]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_23(ctx);
					if_block0.c();
					if_block0.m(div2, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*media*/ ctx[0] || /*hasMediaSlots*/ ctx[45]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*media*/ 1 | dirty[1] & /*hasMediaSlots*/ 16384) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_21(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div2, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_inner_start_slot_changes_1, get_inner_start_slot_context_1);
				}
			}

			if (typeof /*label*/ ctx[36] !== "undefined" || /*hasLabelSlots*/ ctx[46]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*label, hasLabelSlots*/ 32800) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_20(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, t4);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*input*/ ctx[2]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*input*/ 4) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_16(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div0, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (input_slot) {
				if (input_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(input_slot, input_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_input_slot_changes_1, get_input_slot_context_1);
				}
			}

			if (/*hasErrorMessage*/ ctx[40] && /*errorMessageForce*/ ctx[34]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasErrorMessage, errorMessageForce*/ 520) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_15(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(div0, t7);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (/*clearButton*/ ctx[32]) {
				if (if_block5) ; else {
					if_block5 = create_if_block_14(ctx);
					if_block5.c();
					if_block5.m(div0, t8);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (typeof /*info*/ ctx[35] !== "undefined" || /*hasInfoSlots*/ ctx[39]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*info, hasInfoSlots*/ 272) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_13$1(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(div0, null);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}

			if (!current || dirty[1] & /*inputWrapClasses*/ 524288) {
				attr_dev(div0, "class", /*inputWrapClasses*/ ctx[50]);
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_inner_slot_changes_1, get_inner_slot_context_1);
				}
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_inner_end_slot_changes_1, get_inner_end_slot_context_1);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_content_slot_changes_1, get_content_slot_context_1);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_content_end_slot_changes_1, get_content_end_slot_context_1);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty[1] & /*itemContentClasses*/ 131072) && { class: /*itemContentClasses*/ ctx[48] },
				dirty[1] & /*$$restProps*/ 33554432 && restProps(/*$$restProps*/ ctx[56])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(input_slot, local);
			transition_in(if_block4);
			transition_in(if_block6);
			transition_in(inner_slot, local);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(input_slot, local);
			transition_out(if_block4);
			transition_out(if_block6);
			transition_out(inner_slot, local);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (input_slot) input_slot.d(detaching);
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (inner_slot) inner_slot.d(detaching);
			if (inner_end_slot) inner_end_slot.d(detaching);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$1.name,
		type: "else",
		source: "(563:0) {:else}",
		ctx
	});

	return block;
}

// (378:0) {#if wrap}
function create_if_block$c(ctx) {
	let li;
	let t0;
	let div2;
	let t1;
	let t2;
	let t3;
	let div1;
	let t4;
	let t5;
	let div0;
	let t6;
	let t7;
	let t8;
	let t9;
	let t10;
	let t11;
	let t12;
	let t13;
	let t14;
	let t15;
	let t16;
	let current;
	const root_start_slot_template = /*#slots*/ ctx[76]["root-start"];
	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[75], get_root_start_slot_context$1);
	const content_start_slot_template = /*#slots*/ ctx[76]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[75], get_content_start_slot_context);
	let if_block0 = /*isSortable*/ ctx[42] && /*isSortableOpposite*/ ctx[43] && create_if_block_12$1(ctx);
	let if_block1 = (/*media*/ ctx[0] || /*hasMediaSlots*/ ctx[45]) && create_if_block_10$1(ctx);
	const inner_start_slot_template = /*#slots*/ ctx[76]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[75], get_inner_start_slot_context);
	let if_block2 = (typeof /*label*/ ctx[36] !== "undefined" || /*hasLabelSlots*/ ctx[46]) && create_if_block_9$1(ctx);
	let if_block3 = /*input*/ ctx[2] && create_if_block_5$1(ctx);
	const input_slot_template = /*#slots*/ ctx[76].input;
	const input_slot = create_slot(input_slot_template, ctx, /*$$scope*/ ctx[75], get_input_slot_context);
	let if_block4 = /*hasErrorMessage*/ ctx[40] && /*errorMessageForce*/ ctx[34] && create_if_block_4$3(ctx);
	let if_block5 = /*clearButton*/ ctx[32] && create_if_block_3$6(ctx);
	let if_block6 = (typeof /*info*/ ctx[35] !== "undefined" || /*hasInfoSlots*/ ctx[39]) && create_if_block_2$7(ctx);
	const inner_slot_template = /*#slots*/ ctx[76].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[75], get_inner_slot_context);
	const inner_end_slot_template = /*#slots*/ ctx[76]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[75], get_inner_end_slot_context);
	const content_slot_template = /*#slots*/ ctx[76].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[75], get_content_slot_context$1);
	const content_end_slot_template = /*#slots*/ ctx[76]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[75], get_content_end_slot_context);
	let if_block7 = /*isSortable*/ ctx[42] && !/*isSortableOpposite*/ ctx[43] && create_if_block_1$7(ctx);
	const root_slot_template = /*#slots*/ ctx[76].root;
	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[75], get_root_slot_context$2);
	const root_end_slot_template = /*#slots*/ ctx[76]["root-end"];
	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[75], get_root_end_slot_context$1);
	let li_levels = [{ class: /*classes*/ ctx[51] }, restProps(/*$$restProps*/ ctx[56])];
	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			if (root_start_slot) root_start_slot.c();
			t0 = space();
			div2 = element("div");
			if (content_start_slot) content_start_slot.c();
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			div1 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			t5 = space();
			div0 = element("div");
			if (if_block3) if_block3.c();
			t6 = space();
			if (input_slot) input_slot.c();
			t7 = space();
			if (if_block4) if_block4.c();
			t8 = space();
			if (if_block5) if_block5.c();
			t9 = space();
			if (if_block6) if_block6.c();
			t10 = space();
			if (inner_slot) inner_slot.c();
			t11 = space();
			if (inner_end_slot) inner_end_slot.c();
			t12 = space();
			if (content_slot) content_slot.c();
			t13 = space();
			if (content_end_slot) content_end_slot.c();
			t14 = space();
			if (if_block7) if_block7.c();
			t15 = space();
			if (root_slot) root_slot.c();
			t16 = space();
			if (root_end_slot) root_end_slot.c();
			attr_dev(div0, "class", /*inputWrapClasses*/ ctx[50]);
			add_location(div0, file$C, 402, 8, 11894);
			attr_dev(div1, "class", "item-inner");
			add_location(div1, file$C, 394, 6, 11631);
			attr_dev(div2, "class", /*itemContentClasses*/ ctx[48]);
			add_location(div2, file$C, 380, 4, 11236);
			set_attributes(li, li_data);
			add_location(li, file$C, 378, 2, 11152);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);

			if (root_start_slot) {
				root_start_slot.m(li, null);
			}

			append_dev(li, t0);
			append_dev(li, div2);

			if (content_start_slot) {
				content_start_slot.m(div2, null);
			}

			append_dev(div2, t1);
			if (if_block0) if_block0.m(div2, null);
			append_dev(div2, t2);
			if (if_block1) if_block1.m(div2, null);
			append_dev(div2, t3);
			append_dev(div2, div1);

			if (inner_start_slot) {
				inner_start_slot.m(div1, null);
			}

			append_dev(div1, t4);
			if (if_block2) if_block2.m(div1, null);
			append_dev(div1, t5);
			append_dev(div1, div0);
			if (if_block3) if_block3.m(div0, null);
			append_dev(div0, t6);

			if (input_slot) {
				input_slot.m(div0, null);
			}

			append_dev(div0, t7);
			if (if_block4) if_block4.m(div0, null);
			append_dev(div0, t8);
			if (if_block5) if_block5.m(div0, null);
			append_dev(div0, t9);
			if (if_block6) if_block6.m(div0, null);
			append_dev(div1, t10);

			if (inner_slot) {
				inner_slot.m(div1, null);
			}

			append_dev(div1, t11);

			if (inner_end_slot) {
				inner_end_slot.m(div1, null);
			}

			append_dev(div2, t12);

			if (content_slot) {
				content_slot.m(div2, null);
			}

			append_dev(div2, t13);

			if (content_end_slot) {
				content_end_slot.m(div2, null);
			}

			append_dev(li, t14);
			if (if_block7) if_block7.m(li, null);
			append_dev(li, t15);

			if (root_slot) {
				root_slot.m(li, null);
			}

			append_dev(li, t16);

			if (root_end_slot) {
				root_end_slot.m(li, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (root_start_slot) {
				if (root_start_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(root_start_slot, root_start_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_root_start_slot_changes$1, get_root_start_slot_context$1);
				}
			}

			if (content_start_slot) {
				if (content_start_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_content_start_slot_changes, get_content_start_slot_context);
				}
			}

			if (/*isSortable*/ ctx[42] && /*isSortableOpposite*/ ctx[43]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_12$1(ctx);
					if_block0.c();
					if_block0.m(div2, t2);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*media*/ ctx[0] || /*hasMediaSlots*/ ctx[45]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*media*/ 1 | dirty[1] & /*hasMediaSlots*/ 16384) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_10$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div2, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_inner_start_slot_changes, get_inner_start_slot_context);
				}
			}

			if (typeof /*label*/ ctx[36] !== "undefined" || /*hasLabelSlots*/ ctx[46]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*label, hasLabelSlots*/ 32800) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_9$1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, t5);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*input*/ ctx[2]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*input*/ 4) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_5$1(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div0, t6);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (input_slot) {
				if (input_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(input_slot, input_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_input_slot_changes, get_input_slot_context);
				}
			}

			if (/*hasErrorMessage*/ ctx[40] && /*errorMessageForce*/ ctx[34]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasErrorMessage, errorMessageForce*/ 520) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_4$3(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(div0, t8);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (/*clearButton*/ ctx[32]) {
				if (if_block5) ; else {
					if_block5 = create_if_block_3$6(ctx);
					if_block5.c();
					if_block5.m(div0, t9);
				}
			} else if (if_block5) {
				if_block5.d(1);
				if_block5 = null;
			}

			if (typeof /*info*/ ctx[35] !== "undefined" || /*hasInfoSlots*/ ctx[39]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*info, hasInfoSlots*/ 272) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_2$7(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(div0, null);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}

			if (!current || dirty[1] & /*inputWrapClasses*/ 524288) {
				attr_dev(div0, "class", /*inputWrapClasses*/ ctx[50]);
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_inner_slot_changes, get_inner_slot_context);
				}
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_inner_end_slot_changes, get_inner_end_slot_context);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_content_slot_changes$1, get_content_slot_context$1);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_content_end_slot_changes, get_content_end_slot_context);
				}
			}

			if (!current || dirty[1] & /*itemContentClasses*/ 131072) {
				attr_dev(div2, "class", /*itemContentClasses*/ ctx[48]);
			}

			if (/*isSortable*/ ctx[42] && !/*isSortableOpposite*/ ctx[43]) {
				if (if_block7) ; else {
					if_block7 = create_if_block_1$7(ctx);
					if_block7.c();
					if_block7.m(li, t15);
				}
			} else if (if_block7) {
				if_block7.d(1);
				if_block7 = null;
			}

			if (root_slot) {
				if (root_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(root_slot, root_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_root_slot_changes$2, get_root_slot_context$2);
				}
			}

			if (root_end_slot) {
				if (root_end_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(root_end_slot, root_end_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_root_end_slot_changes$1, get_root_end_slot_context$1);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty[1] & /*classes*/ 1048576) && { class: /*classes*/ ctx[51] },
				dirty[1] & /*$$restProps*/ 33554432 && restProps(/*$$restProps*/ ctx[56])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(root_start_slot, local);
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(input_slot, local);
			transition_in(if_block4);
			transition_in(if_block6);
			transition_in(inner_slot, local);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			transition_in(root_slot, local);
			transition_in(root_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(root_start_slot, local);
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(input_slot, local);
			transition_out(if_block4);
			transition_out(if_block6);
			transition_out(inner_slot, local);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			transition_out(root_slot, local);
			transition_out(root_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (root_start_slot) root_start_slot.d(detaching);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (input_slot) input_slot.d(detaching);
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (inner_slot) inner_slot.d(detaching);
			if (inner_end_slot) inner_end_slot.d(detaching);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			if (if_block7) if_block7.d();
			if (root_slot) root_slot.d(detaching);
			if (root_end_slot) root_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$c.name,
		type: "if",
		source: "(378:0) {#if wrap}",
		ctx
	});

	return block;
}

// (566:4) {#if isSortable && isSortableOpposite}
function create_if_block_23(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$C, 566, 6, 18368);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_23.name,
		type: "if",
		source: "(566:4) {#if isSortable && isSortableOpposite}",
		ctx
	});

	return block;
}

// (570:4) {#if (media || hasMediaSlots)}
function create_if_block_21(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[0] !== "undefined" && create_if_block_22(ctx);
	const media_slot_template = /*#slots*/ ctx[76].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[75], get_media_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "item-media");
			add_location(div, file$C, 570, 6, 18453);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*media*/ ctx[0] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_22(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_media_slot_changes_1, get_media_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_21.name,
		type: "if",
		source: "(570:4) {#if (media || hasMediaSlots)}",
		ctx
	});

	return block;
}

// (572:8) {#if typeof media !== 'undefined'}
function create_if_block_22(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*media*/ ctx[0])) attr_dev(img, "src", img_src_value);
			add_location(img, file$C, 572, 10, 18531);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 1 && img.src !== (img_src_value = /*media*/ ctx[0])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_22.name,
		type: "if",
		source: "(572:8) {#if typeof media !== 'undefined'}",
		ctx
	});

	return block;
}

// (580:6) {#if (typeof label !== 'undefined' || hasLabelSlots)}
function create_if_block_20(ctx) {
	let div;
	let t0_value = Utils.text(/*label*/ ctx[36]) + "";
	let t0;
	let t1;
	let current;
	const label_slot_template = /*#slots*/ ctx[76].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[75], get_label_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (label_slot) label_slot.c();
			attr_dev(div, "class", /*labelClasses*/ ctx[49]);
			add_location(div, file$C, 580, 8, 18747);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (label_slot) {
				label_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[1] & /*label*/ 32) && t0_value !== (t0_value = Utils.text(/*label*/ ctx[36]) + "")) set_data_dev(t0, t0_value);

			if (label_slot) {
				if (label_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(label_slot, label_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_label_slot_changes_1, get_label_slot_context_1);
				}
			}

			if (!current || dirty[1] & /*labelClasses*/ 262144) {
				attr_dev(div, "class", /*labelClasses*/ ctx[49]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (label_slot) label_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_20.name,
		type: "if",
		source: "(580:6) {#if (typeof label !== 'undefined' || hasLabelSlots)}",
		ctx
	});

	return block;
}

// (587:8) {#if input}
function create_if_block_16(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	const if_block_creators = [
		create_if_block_17,
		create_if_block_18,
		create_if_block_19,
		create_else_block_2
	];

	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*type*/ ctx[3] === "select") return 0;
		if (/*type*/ ctx[3] === "textarea") return 1;
		if (/*type*/ ctx[3] === "texteditor") return 2;
		return 3;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_16.name,
		type: "if",
		source: "(587:8) {#if input}",
		ctx
	});

	return block;
}

// (676:10) {:else}
function create_else_block_2(ctx) {
	let input_1;
	let input_1_validate_value;
	let input_1_data_validate_value;
	let input_1_data_validate_on_blur_value;
	let input_1_data_error_message_value;
	let input_1_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input_1 = element("input");
			attr_dev(input_1, "style", /*inputStyle*/ ctx[26]);
			attr_dev(input_1, "name", /*name*/ ctx[4]);
			attr_dev(input_1, "type", /*inputType*/ ctx[38]);
			attr_dev(input_1, "inputmode", /*inputmode*/ ctx[6]);
			attr_dev(input_1, "placeholder", /*placeholder*/ ctx[10]);
			attr_dev(input_1, "id", /*inputId*/ ctx[11]);
			attr_dev(input_1, "size", /*size*/ ctx[12]);
			attr_dev(input_1, "accept", /*accept*/ ctx[13]);
			attr_dev(input_1, "autocomplete", /*autocomplete*/ ctx[14]);
			attr_dev(input_1, "autocorrect", /*autocorrect*/ ctx[15]);
			attr_dev(input_1, "autocapitalize", /*autocapitalize*/ ctx[16]);
			attr_dev(input_1, "spellcheck", /*spellcheck*/ ctx[17]);
			input_1.autofocus = /*autofocus*/ ctx[18];
			attr_dev(input_1, "autosave", /*autosave*/ ctx[19]);
			input_1.disabled = /*disabled*/ ctx[9];
			attr_dev(input_1, "max", /*max*/ ctx[20]);
			attr_dev(input_1, "maxlength", /*maxlength*/ ctx[23]);
			attr_dev(input_1, "min", /*min*/ ctx[21]);
			attr_dev(input_1, "minlength", /*minlength*/ ctx[24]);
			attr_dev(input_1, "step", /*step*/ ctx[22]);
			input_1.multiple = /*multiple*/ ctx[25];
			input_1.readOnly = /*readonly*/ ctx[7];
			input_1.required = /*required*/ ctx[8];
			attr_dev(input_1, "pattern", /*pattern*/ ctx[27]);

			attr_dev(input_1, "validate", input_1_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined);

			attr_dev(input_1, "data-validate", input_1_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(input_1, "tabindex", /*tabindex*/ ctx[30]);

			attr_dev(input_1, "data-error-message", input_1_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33]);

			attr_dev(input_1, "class", /*inputClasses*/ ctx[47]);

			input_1.value = input_1_value_value = /*type*/ ctx[3] === "datepicker" || /*type*/ ctx[3] === "colorpicker" || /*type*/ ctx[3] === "file"
			? ""
			: /*inputValue*/ ctx[44];

			add_location(input_1, file$C, 676, 12, 22442);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			/*input_1_binding_1*/ ctx[82](input_1);

			if (!mounted) {
				dispose = [
					listen_dev(input_1, "focus", /*onFocus*/ ctx[53], false, false, false),
					listen_dev(input_1, "blur", /*onBlur*/ ctx[54], false, false, false),
					listen_dev(input_1, "input", /*onInput*/ ctx[52], false, false, false),
					listen_dev(input_1, "change", /*onChange*/ ctx[55], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 67108864) {
				attr_dev(input_1, "style", /*inputStyle*/ ctx[26]);
			}

			if (dirty[0] & /*name*/ 16) {
				attr_dev(input_1, "name", /*name*/ ctx[4]);
			}

			if (dirty[1] & /*inputType*/ 128) {
				attr_dev(input_1, "type", /*inputType*/ ctx[38]);
			}

			if (dirty[0] & /*inputmode*/ 64) {
				attr_dev(input_1, "inputmode", /*inputmode*/ ctx[6]);
			}

			if (dirty[0] & /*placeholder*/ 1024) {
				attr_dev(input_1, "placeholder", /*placeholder*/ ctx[10]);
			}

			if (dirty[0] & /*inputId*/ 2048) {
				attr_dev(input_1, "id", /*inputId*/ ctx[11]);
			}

			if (dirty[0] & /*size*/ 4096) {
				attr_dev(input_1, "size", /*size*/ ctx[12]);
			}

			if (dirty[0] & /*accept*/ 8192) {
				attr_dev(input_1, "accept", /*accept*/ ctx[13]);
			}

			if (dirty[0] & /*autocomplete*/ 16384) {
				attr_dev(input_1, "autocomplete", /*autocomplete*/ ctx[14]);
			}

			if (dirty[0] & /*autocorrect*/ 32768) {
				attr_dev(input_1, "autocorrect", /*autocorrect*/ ctx[15]);
			}

			if (dirty[0] & /*autocapitalize*/ 65536) {
				attr_dev(input_1, "autocapitalize", /*autocapitalize*/ ctx[16]);
			}

			if (dirty[0] & /*spellcheck*/ 131072) {
				attr_dev(input_1, "spellcheck", /*spellcheck*/ ctx[17]);
			}

			if (dirty[0] & /*autofocus*/ 262144) {
				prop_dev(input_1, "autofocus", /*autofocus*/ ctx[18]);
			}

			if (dirty[0] & /*autosave*/ 524288) {
				attr_dev(input_1, "autosave", /*autosave*/ ctx[19]);
			}

			if (dirty[0] & /*disabled*/ 512) {
				prop_dev(input_1, "disabled", /*disabled*/ ctx[9]);
			}

			if (dirty[0] & /*max*/ 1048576) {
				attr_dev(input_1, "max", /*max*/ ctx[20]);
			}

			if (dirty[0] & /*maxlength*/ 8388608) {
				attr_dev(input_1, "maxlength", /*maxlength*/ ctx[23]);
			}

			if (dirty[0] & /*min*/ 2097152) {
				attr_dev(input_1, "min", /*min*/ ctx[21]);
			}

			if (dirty[0] & /*minlength*/ 16777216) {
				attr_dev(input_1, "minlength", /*minlength*/ ctx[24]);
			}

			if (dirty[0] & /*step*/ 4194304) {
				attr_dev(input_1, "step", /*step*/ ctx[22]);
			}

			if (dirty[0] & /*multiple*/ 33554432) {
				prop_dev(input_1, "multiple", /*multiple*/ ctx[25]);
			}

			if (dirty[0] & /*readonly*/ 128) {
				prop_dev(input_1, "readOnly", /*readonly*/ ctx[7]);
			}

			if (dirty[0] & /*required*/ 256) {
				prop_dev(input_1, "required", /*required*/ ctx[8]);
			}

			if (dirty[0] & /*pattern*/ 134217728) {
				attr_dev(input_1, "pattern", /*pattern*/ ctx[27]);
			}

			if (dirty[0] & /*validate*/ 268435456 && input_1_validate_value !== (input_1_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined)) {
				attr_dev(input_1, "validate", input_1_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 805306368 && input_1_data_validate_value !== (input_1_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(input_1, "data-validate", input_1_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 536870912 && input_1_data_validate_on_blur_value !== (input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value);
			}

			if (dirty[0] & /*tabindex*/ 1073741824) {
				attr_dev(input_1, "tabindex", /*tabindex*/ ctx[30]);
			}

			if (dirty[1] & /*errorMessageForce, errorMessage*/ 12 && input_1_data_error_message_value !== (input_1_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33])) {
				attr_dev(input_1, "data-error-message", input_1_data_error_message_value);
			}

			if (dirty[1] & /*inputClasses*/ 65536) {
				attr_dev(input_1, "class", /*inputClasses*/ ctx[47]);
			}

			if (dirty[0] & /*type*/ 8 | dirty[1] & /*inputValue*/ 8192 && input_1_value_value !== (input_1_value_value = /*type*/ ctx[3] === "datepicker" || /*type*/ ctx[3] === "colorpicker" || /*type*/ ctx[3] === "file"
			? ""
			: /*inputValue*/ ctx[44]) && input_1.value !== input_1_value_value) {
				prop_dev(input_1, "value", input_1_value_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			/*input_1_binding_1*/ ctx[82](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(676:10) {:else}",
		ctx
	});

	return block;
}

// (665:42) 
function create_if_block_19(ctx) {
	let texteditor;
	let current;

	const texteditor_spread_levels = [
		{
			value: typeof /*value*/ ctx[5] === "undefined"
			? ""
			: /*value*/ ctx[5]
		},
		{ resizable: /*resizable*/ ctx[31] },
		{ placeholder: /*placeholder*/ ctx[10] },
		{ onTextEditorFocus: /*onFocus*/ ctx[53] },
		{ onTextEditorBlur: /*onBlur*/ ctx[54] },
		{ onTextEditorInput: /*onInput*/ ctx[52] },
		{ onTextEditorChange: /*onChange*/ ctx[55] },
		/*textEditorParams*/ ctx[37]
	];

	let texteditor_props = {};

	for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
		texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
	}

	texteditor = new Text_editor({ props: texteditor_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(texteditor.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(texteditor, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const texteditor_changes = (dirty[0] & /*value, placeholder*/ 1056 | dirty[1] & /*resizable, onFocus, onBlur, onInput, onChange, textEditorParams*/ 31457345)
			? get_spread_update(texteditor_spread_levels, [
					dirty[0] & /*value*/ 32 && {
						value: typeof /*value*/ ctx[5] === "undefined"
						? ""
						: /*value*/ ctx[5]
					},
					dirty[1] & /*resizable*/ 1 && { resizable: /*resizable*/ ctx[31] },
					dirty[0] & /*placeholder*/ 1024 && { placeholder: /*placeholder*/ ctx[10] },
					dirty[1] & /*onFocus*/ 4194304 && { onTextEditorFocus: /*onFocus*/ ctx[53] },
					dirty[1] & /*onBlur*/ 8388608 && { onTextEditorBlur: /*onBlur*/ ctx[54] },
					dirty[1] & /*onInput*/ 2097152 && { onTextEditorInput: /*onInput*/ ctx[52] },
					dirty[1] & /*onChange*/ 16777216 && { onTextEditorChange: /*onChange*/ ctx[55] },
					dirty[1] & /*textEditorParams*/ 64 && get_spread_object(/*textEditorParams*/ ctx[37])
				])
			: {};

			texteditor.$set(texteditor_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(texteditor.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(texteditor.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(texteditor, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_19.name,
		type: "if",
		source: "(665:42) ",
		ctx
	});

	return block;
}

// (627:40) 
function create_if_block_18(ctx) {
	let textarea;
	let textarea_validate_value;
	let textarea_data_validate_value;
	let textarea_data_validate_on_blur_value;
	let textarea_data_error_message_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			textarea = element("textarea");
			attr_dev(textarea, "style", /*inputStyle*/ ctx[26]);
			attr_dev(textarea, "name", /*name*/ ctx[4]);
			attr_dev(textarea, "placeholder", /*placeholder*/ ctx[10]);
			attr_dev(textarea, "id", /*inputId*/ ctx[11]);
			attr_dev(textarea, "size", /*size*/ ctx[12]);
			attr_dev(textarea, "inputmode", /*inputmode*/ ctx[6]);
			attr_dev(textarea, "accept", /*accept*/ ctx[13]);
			attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[14]);
			attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[15]);
			attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
			attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[17]);
			textarea.autofocus = /*autofocus*/ ctx[18];
			attr_dev(textarea, "autosave", /*autosave*/ ctx[19]);
			textarea.disabled = /*disabled*/ ctx[9];
			attr_dev(textarea, "max", /*max*/ ctx[20]);
			attr_dev(textarea, "maxlength", /*maxlength*/ ctx[23]);
			attr_dev(textarea, "min", /*min*/ ctx[21]);
			attr_dev(textarea, "minlength", /*minlength*/ ctx[24]);
			attr_dev(textarea, "step", /*step*/ ctx[22]);
			attr_dev(textarea, "multiple", /*multiple*/ ctx[25]);
			textarea.readOnly = /*readonly*/ ctx[7];
			textarea.required = /*required*/ ctx[8];
			attr_dev(textarea, "pattern", /*pattern*/ ctx[27]);

			attr_dev(textarea, "validate", textarea_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined);

			attr_dev(textarea, "data-validate", textarea_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(textarea, "tabindex", /*tabindex*/ ctx[30]);

			attr_dev(textarea, "data-error-message", textarea_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33]);

			attr_dev(textarea, "class", /*inputClasses*/ ctx[47]);
			textarea.value = /*inputValue*/ ctx[44];
			add_location(textarea, file$C, 627, 12, 20505);
		},
		m: function mount(target, anchor) {
			insert_dev(target, textarea, anchor);
			/*textarea_binding_1*/ ctx[81](textarea);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "focus", /*onFocus*/ ctx[53], false, false, false),
					listen_dev(textarea, "blur", /*onBlur*/ ctx[54], false, false, false),
					listen_dev(textarea, "input", /*onInput*/ ctx[52], false, false, false),
					listen_dev(textarea, "change", /*onChange*/ ctx[55], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 67108864) {
				attr_dev(textarea, "style", /*inputStyle*/ ctx[26]);
			}

			if (dirty[0] & /*name*/ 16) {
				attr_dev(textarea, "name", /*name*/ ctx[4]);
			}

			if (dirty[0] & /*placeholder*/ 1024) {
				attr_dev(textarea, "placeholder", /*placeholder*/ ctx[10]);
			}

			if (dirty[0] & /*inputId*/ 2048) {
				attr_dev(textarea, "id", /*inputId*/ ctx[11]);
			}

			if (dirty[0] & /*size*/ 4096) {
				attr_dev(textarea, "size", /*size*/ ctx[12]);
			}

			if (dirty[0] & /*inputmode*/ 64) {
				attr_dev(textarea, "inputmode", /*inputmode*/ ctx[6]);
			}

			if (dirty[0] & /*accept*/ 8192) {
				attr_dev(textarea, "accept", /*accept*/ ctx[13]);
			}

			if (dirty[0] & /*autocomplete*/ 16384) {
				attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[14]);
			}

			if (dirty[0] & /*autocorrect*/ 32768) {
				attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[15]);
			}

			if (dirty[0] & /*autocapitalize*/ 65536) {
				attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
			}

			if (dirty[0] & /*spellcheck*/ 131072) {
				attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[17]);
			}

			if (dirty[0] & /*autofocus*/ 262144) {
				prop_dev(textarea, "autofocus", /*autofocus*/ ctx[18]);
			}

			if (dirty[0] & /*autosave*/ 524288) {
				attr_dev(textarea, "autosave", /*autosave*/ ctx[19]);
			}

			if (dirty[0] & /*disabled*/ 512) {
				prop_dev(textarea, "disabled", /*disabled*/ ctx[9]);
			}

			if (dirty[0] & /*max*/ 1048576) {
				attr_dev(textarea, "max", /*max*/ ctx[20]);
			}

			if (dirty[0] & /*maxlength*/ 8388608) {
				attr_dev(textarea, "maxlength", /*maxlength*/ ctx[23]);
			}

			if (dirty[0] & /*min*/ 2097152) {
				attr_dev(textarea, "min", /*min*/ ctx[21]);
			}

			if (dirty[0] & /*minlength*/ 16777216) {
				attr_dev(textarea, "minlength", /*minlength*/ ctx[24]);
			}

			if (dirty[0] & /*step*/ 4194304) {
				attr_dev(textarea, "step", /*step*/ ctx[22]);
			}

			if (dirty[0] & /*multiple*/ 33554432) {
				attr_dev(textarea, "multiple", /*multiple*/ ctx[25]);
			}

			if (dirty[0] & /*readonly*/ 128) {
				prop_dev(textarea, "readOnly", /*readonly*/ ctx[7]);
			}

			if (dirty[0] & /*required*/ 256) {
				prop_dev(textarea, "required", /*required*/ ctx[8]);
			}

			if (dirty[0] & /*pattern*/ 134217728) {
				attr_dev(textarea, "pattern", /*pattern*/ ctx[27]);
			}

			if (dirty[0] & /*validate*/ 268435456 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined)) {
				attr_dev(textarea, "validate", textarea_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 805306368 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(textarea, "data-validate", textarea_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 536870912 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value);
			}

			if (dirty[0] & /*tabindex*/ 1073741824) {
				attr_dev(textarea, "tabindex", /*tabindex*/ ctx[30]);
			}

			if (dirty[1] & /*errorMessageForce, errorMessage*/ 12 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33])) {
				attr_dev(textarea, "data-error-message", textarea_data_error_message_value);
			}

			if (dirty[1] & /*inputClasses*/ 65536) {
				attr_dev(textarea, "class", /*inputClasses*/ ctx[47]);
			}

			if (dirty[1] & /*inputValue*/ 8192) {
				prop_dev(textarea, "value", /*inputValue*/ ctx[44]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			/*textarea_binding_1*/ ctx[81](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_18.name,
		type: "if",
		source: "(627:40) ",
		ctx
	});

	return block;
}

// (588:10) {#if type === 'select'}
function create_if_block_17(ctx) {
	let select;
	let select_validate_value;
	let select_data_validate_value;
	let select_data_validate_on_blur_value;
	let select_data_error_message_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[76].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[75], null);

	const block = {
		c: function create() {
			select = element("select");
			if (default_slot) default_slot.c();
			attr_dev(select, "style", /*inputStyle*/ ctx[26]);
			attr_dev(select, "name", /*name*/ ctx[4]);
			attr_dev(select, "placeholder", /*placeholder*/ ctx[10]);
			attr_dev(select, "id", /*inputId*/ ctx[11]);
			attr_dev(select, "size", /*size*/ ctx[12]);
			attr_dev(select, "accept", /*accept*/ ctx[13]);
			attr_dev(select, "autocomplete", /*autocomplete*/ ctx[14]);
			attr_dev(select, "autocorrect", /*autocorrect*/ ctx[15]);
			attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[16]);
			attr_dev(select, "spellcheck", /*spellcheck*/ ctx[17]);
			select.autofocus = /*autofocus*/ ctx[18];
			attr_dev(select, "autosave", /*autosave*/ ctx[19]);
			select.disabled = /*disabled*/ ctx[9];
			attr_dev(select, "max", /*max*/ ctx[20]);
			attr_dev(select, "maxlength", /*maxlength*/ ctx[23]);
			attr_dev(select, "min", /*min*/ ctx[21]);
			attr_dev(select, "minlength", /*minlength*/ ctx[24]);
			attr_dev(select, "step", /*step*/ ctx[22]);
			select.multiple = /*multiple*/ ctx[25];
			attr_dev(select, "readonly", /*readonly*/ ctx[7]);
			select.required = /*required*/ ctx[8];
			attr_dev(select, "pattern", /*pattern*/ ctx[27]);

			attr_dev(select, "validate", select_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined);

			attr_dev(select, "data-validate", select_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(select, "tabindex", /*tabindex*/ ctx[30]);

			attr_dev(select, "data-error-message", select_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33]);

			attr_dev(select, "class", /*inputClasses*/ ctx[47]);
			add_location(select, file$C, 588, 12, 18965);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			select_option(select, /*inputValue*/ ctx[44]);
			/*select_binding_1*/ ctx[80](select);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(select, "focus", /*onFocus*/ ctx[53], false, false, false),
					listen_dev(select, "blur", /*onBlur*/ ctx[54], false, false, false),
					listen_dev(select, "input", /*onInput*/ ctx[52], false, false, false),
					listen_dev(select, "change", /*onChange*/ ctx[55], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[75], dirty, null, null);
				}
			}

			if (!current || dirty[0] & /*inputStyle*/ 67108864) {
				attr_dev(select, "style", /*inputStyle*/ ctx[26]);
			}

			if (!current || dirty[0] & /*name*/ 16) {
				attr_dev(select, "name", /*name*/ ctx[4]);
			}

			if (!current || dirty[0] & /*placeholder*/ 1024) {
				attr_dev(select, "placeholder", /*placeholder*/ ctx[10]);
			}

			if (!current || dirty[0] & /*inputId*/ 2048) {
				attr_dev(select, "id", /*inputId*/ ctx[11]);
			}

			if (!current || dirty[0] & /*size*/ 4096) {
				attr_dev(select, "size", /*size*/ ctx[12]);
			}

			if (!current || dirty[0] & /*accept*/ 8192) {
				attr_dev(select, "accept", /*accept*/ ctx[13]);
			}

			if (!current || dirty[0] & /*autocomplete*/ 16384) {
				attr_dev(select, "autocomplete", /*autocomplete*/ ctx[14]);
			}

			if (!current || dirty[0] & /*autocorrect*/ 32768) {
				attr_dev(select, "autocorrect", /*autocorrect*/ ctx[15]);
			}

			if (!current || dirty[0] & /*autocapitalize*/ 65536) {
				attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[16]);
			}

			if (!current || dirty[0] & /*spellcheck*/ 131072) {
				attr_dev(select, "spellcheck", /*spellcheck*/ ctx[17]);
			}

			if (!current || dirty[0] & /*autofocus*/ 262144) {
				prop_dev(select, "autofocus", /*autofocus*/ ctx[18]);
			}

			if (!current || dirty[0] & /*autosave*/ 524288) {
				attr_dev(select, "autosave", /*autosave*/ ctx[19]);
			}

			if (!current || dirty[0] & /*disabled*/ 512) {
				prop_dev(select, "disabled", /*disabled*/ ctx[9]);
			}

			if (!current || dirty[0] & /*max*/ 1048576) {
				attr_dev(select, "max", /*max*/ ctx[20]);
			}

			if (!current || dirty[0] & /*maxlength*/ 8388608) {
				attr_dev(select, "maxlength", /*maxlength*/ ctx[23]);
			}

			if (!current || dirty[0] & /*min*/ 2097152) {
				attr_dev(select, "min", /*min*/ ctx[21]);
			}

			if (!current || dirty[0] & /*minlength*/ 16777216) {
				attr_dev(select, "minlength", /*minlength*/ ctx[24]);
			}

			if (!current || dirty[0] & /*step*/ 4194304) {
				attr_dev(select, "step", /*step*/ ctx[22]);
			}

			if (!current || dirty[0] & /*multiple*/ 33554432) {
				prop_dev(select, "multiple", /*multiple*/ ctx[25]);
			}

			if (!current || dirty[0] & /*readonly*/ 128) {
				attr_dev(select, "readonly", /*readonly*/ ctx[7]);
			}

			if (!current || dirty[0] & /*required*/ 256) {
				prop_dev(select, "required", /*required*/ ctx[8]);
			}

			if (!current || dirty[0] & /*pattern*/ 134217728) {
				attr_dev(select, "pattern", /*pattern*/ ctx[27]);
			}

			if (!current || dirty[0] & /*validate*/ 268435456 && select_validate_value !== (select_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined)) {
				attr_dev(select, "validate", select_validate_value);
			}

			if (!current || dirty[0] & /*validate, validateOnBlur*/ 805306368 && select_data_validate_value !== (select_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(select, "data-validate", select_data_validate_value);
			}

			if (!current || dirty[0] & /*validateOnBlur*/ 536870912 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value);
			}

			if (!current || dirty[0] & /*tabindex*/ 1073741824) {
				attr_dev(select, "tabindex", /*tabindex*/ ctx[30]);
			}

			if (!current || dirty[1] & /*errorMessageForce, errorMessage*/ 12 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33])) {
				attr_dev(select, "data-error-message", select_data_error_message_value);
			}

			if (!current || dirty[1] & /*inputClasses*/ 65536) {
				attr_dev(select, "class", /*inputClasses*/ ctx[47]);
			}

			if (!current || dirty[1] & /*inputValue*/ 8192) {
				select_option(select, /*inputValue*/ ctx[44]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select);
			if (default_slot) default_slot.d(detaching);
			/*select_binding_1*/ ctx[80](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_17.name,
		type: "if",
		source: "(588:10) {#if type === 'select'}",
		ctx
	});

	return block;
}

// (718:8) {#if hasErrorMessage && errorMessageForce}
function create_if_block_15(ctx) {
	let div;
	let t0_value = Utils.text(/*errorMessage*/ ctx[33]) + "";
	let t0;
	let t1;
	let current;
	const error_message_slot_template = /*#slots*/ ctx[76]["error-message"];
	const error_message_slot = create_slot(error_message_slot_template, ctx, /*$$scope*/ ctx[75], get_error_message_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (error_message_slot) error_message_slot.c();
			attr_dev(div, "class", "item-input-error-message");
			add_location(div, file$C, 718, 10, 24146);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (error_message_slot) {
				error_message_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[1] & /*errorMessage*/ 4) && t0_value !== (t0_value = Utils.text(/*errorMessage*/ ctx[33]) + "")) set_data_dev(t0, t0_value);

			if (error_message_slot) {
				if (error_message_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(error_message_slot, error_message_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_error_message_slot_changes_1, get_error_message_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error_message_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error_message_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (error_message_slot) error_message_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_15.name,
		type: "if",
		source: "(718:8) {#if hasErrorMessage && errorMessageForce}",
		ctx
	});

	return block;
}

// (724:8) {#if clearButton}
function create_if_block_14(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "input-clear-button");
			add_location(span, file$C, 724, 10, 24332);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_14.name,
		type: "if",
		source: "(724:8) {#if clearButton}",
		ctx
	});

	return block;
}

// (727:8) {#if (typeof info !== 'undefined' || hasInfoSlots)}
function create_if_block_13$1(ctx) {
	let div;
	let t0_value = Utils.text(/*info*/ ctx[35]) + "";
	let t0;
	let t1;
	let current;
	const info_slot_template = /*#slots*/ ctx[76].info;
	const info_slot = create_slot(info_slot_template, ctx, /*$$scope*/ ctx[75], get_info_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (info_slot) info_slot.c();
			attr_dev(div, "class", "item-input-info");
			add_location(div, file$C, 727, 10, 24452);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (info_slot) {
				info_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[1] & /*info*/ 16) && t0_value !== (t0_value = Utils.text(/*info*/ ctx[35]) + "")) set_data_dev(t0, t0_value);

			if (info_slot) {
				if (info_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(info_slot, info_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_info_slot_changes_1, get_info_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(info_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(info_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (info_slot) info_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_13$1.name,
		type: "if",
		source: "(727:8) {#if (typeof info !== 'undefined' || hasInfoSlots)}",
		ctx
	});

	return block;
}

// (383:6) {#if isSortable && isSortableOpposite}
function create_if_block_12$1(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$C, 383, 8, 11358);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_12$1.name,
		type: "if",
		source: "(383:6) {#if isSortable && isSortableOpposite}",
		ctx
	});

	return block;
}

// (387:6) {#if (media || hasMediaSlots)}
function create_if_block_10$1(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[0] !== "undefined" && create_if_block_11$1(ctx);
	const media_slot_template = /*#slots*/ ctx[76].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[75], get_media_slot_context$2);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "item-media");
			add_location(div, file$C, 387, 8, 11449);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*media*/ ctx[0] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_11$1(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_media_slot_changes$2, get_media_slot_context$2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10$1.name,
		type: "if",
		source: "(387:6) {#if (media || hasMediaSlots)}",
		ctx
	});

	return block;
}

// (389:10) {#if typeof media !== 'undefined'}
function create_if_block_11$1(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*media*/ ctx[0])) attr_dev(img, "src", img_src_value);
			add_location(img, file$C, 389, 12, 11531);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 1 && img.src !== (img_src_value = /*media*/ ctx[0])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_11$1.name,
		type: "if",
		source: "(389:10) {#if typeof media !== 'undefined'}",
		ctx
	});

	return block;
}

// (397:8) {#if (typeof label !== 'undefined' || hasLabelSlots)}
function create_if_block_9$1(ctx) {
	let div;
	let t0_value = Utils.text(/*label*/ ctx[36]) + "";
	let t0;
	let t1;
	let current;
	const label_slot_template = /*#slots*/ ctx[76].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[75], get_label_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (label_slot) label_slot.c();
			attr_dev(div, "class", /*labelClasses*/ ctx[49]);
			add_location(div, file$C, 397, 10, 11763);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (label_slot) {
				label_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[1] & /*label*/ 32) && t0_value !== (t0_value = Utils.text(/*label*/ ctx[36]) + "")) set_data_dev(t0, t0_value);

			if (label_slot) {
				if (label_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(label_slot, label_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_label_slot_changes, get_label_slot_context);
				}
			}

			if (!current || dirty[1] & /*labelClasses*/ 262144) {
				attr_dev(div, "class", /*labelClasses*/ ctx[49]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(label_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(label_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (label_slot) label_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9$1.name,
		type: "if",
		source: "(397:8) {#if (typeof label !== 'undefined' || hasLabelSlots)}",
		ctx
	});

	return block;
}

// (404:10) {#if input}
function create_if_block_5$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_6$1, create_if_block_7$1, create_if_block_8$1, create_else_block$3];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*type*/ ctx[3] === "select") return 0;
		if (/*type*/ ctx[3] === "textarea") return 1;
		if (/*type*/ ctx[3] === "texteditor") return 2;
		return 3;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5$1.name,
		type: "if",
		source: "(404:10) {#if input}",
		ctx
	});

	return block;
}

// (493:12) {:else}
function create_else_block$3(ctx) {
	let input_1;
	let input_1_validate_value;
	let input_1_data_validate_value;
	let input_1_data_validate_on_blur_value;
	let input_1_data_error_message_value;
	let input_1_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input_1 = element("input");
			attr_dev(input_1, "style", /*inputStyle*/ ctx[26]);
			attr_dev(input_1, "name", /*name*/ ctx[4]);
			attr_dev(input_1, "type", /*inputType*/ ctx[38]);
			attr_dev(input_1, "inputmode", /*inputmode*/ ctx[6]);
			attr_dev(input_1, "placeholder", /*placeholder*/ ctx[10]);
			attr_dev(input_1, "id", /*inputId*/ ctx[11]);
			attr_dev(input_1, "size", /*size*/ ctx[12]);
			attr_dev(input_1, "accept", /*accept*/ ctx[13]);
			attr_dev(input_1, "autocomplete", /*autocomplete*/ ctx[14]);
			attr_dev(input_1, "autocorrect", /*autocorrect*/ ctx[15]);
			attr_dev(input_1, "autocapitalize", /*autocapitalize*/ ctx[16]);
			attr_dev(input_1, "spellcheck", /*spellcheck*/ ctx[17]);
			input_1.autofocus = /*autofocus*/ ctx[18];
			attr_dev(input_1, "autosave", /*autosave*/ ctx[19]);
			input_1.disabled = /*disabled*/ ctx[9];
			attr_dev(input_1, "max", /*max*/ ctx[20]);
			attr_dev(input_1, "maxlength", /*maxlength*/ ctx[23]);
			attr_dev(input_1, "min", /*min*/ ctx[21]);
			attr_dev(input_1, "minlength", /*minlength*/ ctx[24]);
			attr_dev(input_1, "step", /*step*/ ctx[22]);
			input_1.multiple = /*multiple*/ ctx[25];
			input_1.readOnly = /*readonly*/ ctx[7];
			input_1.required = /*required*/ ctx[8];
			attr_dev(input_1, "pattern", /*pattern*/ ctx[27]);

			attr_dev(input_1, "validate", input_1_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined);

			attr_dev(input_1, "data-validate", input_1_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(input_1, "tabindex", /*tabindex*/ ctx[30]);

			attr_dev(input_1, "data-error-message", input_1_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33]);

			attr_dev(input_1, "class", /*inputClasses*/ ctx[47]);

			input_1.value = input_1_value_value = /*type*/ ctx[3] === "datepicker" || /*type*/ ctx[3] === "colorpicker" || /*type*/ ctx[3] === "file"
			? ""
			: /*inputValue*/ ctx[44];

			add_location(input_1, file$C, 493, 14, 15650);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input_1, anchor);
			/*input_1_binding*/ ctx[79](input_1);

			if (!mounted) {
				dispose = [
					listen_dev(input_1, "focus", /*onFocus*/ ctx[53], false, false, false),
					listen_dev(input_1, "blur", /*onBlur*/ ctx[54], false, false, false),
					listen_dev(input_1, "input", /*onInput*/ ctx[52], false, false, false),
					listen_dev(input_1, "change", /*onChange*/ ctx[55], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 67108864) {
				attr_dev(input_1, "style", /*inputStyle*/ ctx[26]);
			}

			if (dirty[0] & /*name*/ 16) {
				attr_dev(input_1, "name", /*name*/ ctx[4]);
			}

			if (dirty[1] & /*inputType*/ 128) {
				attr_dev(input_1, "type", /*inputType*/ ctx[38]);
			}

			if (dirty[0] & /*inputmode*/ 64) {
				attr_dev(input_1, "inputmode", /*inputmode*/ ctx[6]);
			}

			if (dirty[0] & /*placeholder*/ 1024) {
				attr_dev(input_1, "placeholder", /*placeholder*/ ctx[10]);
			}

			if (dirty[0] & /*inputId*/ 2048) {
				attr_dev(input_1, "id", /*inputId*/ ctx[11]);
			}

			if (dirty[0] & /*size*/ 4096) {
				attr_dev(input_1, "size", /*size*/ ctx[12]);
			}

			if (dirty[0] & /*accept*/ 8192) {
				attr_dev(input_1, "accept", /*accept*/ ctx[13]);
			}

			if (dirty[0] & /*autocomplete*/ 16384) {
				attr_dev(input_1, "autocomplete", /*autocomplete*/ ctx[14]);
			}

			if (dirty[0] & /*autocorrect*/ 32768) {
				attr_dev(input_1, "autocorrect", /*autocorrect*/ ctx[15]);
			}

			if (dirty[0] & /*autocapitalize*/ 65536) {
				attr_dev(input_1, "autocapitalize", /*autocapitalize*/ ctx[16]);
			}

			if (dirty[0] & /*spellcheck*/ 131072) {
				attr_dev(input_1, "spellcheck", /*spellcheck*/ ctx[17]);
			}

			if (dirty[0] & /*autofocus*/ 262144) {
				prop_dev(input_1, "autofocus", /*autofocus*/ ctx[18]);
			}

			if (dirty[0] & /*autosave*/ 524288) {
				attr_dev(input_1, "autosave", /*autosave*/ ctx[19]);
			}

			if (dirty[0] & /*disabled*/ 512) {
				prop_dev(input_1, "disabled", /*disabled*/ ctx[9]);
			}

			if (dirty[0] & /*max*/ 1048576) {
				attr_dev(input_1, "max", /*max*/ ctx[20]);
			}

			if (dirty[0] & /*maxlength*/ 8388608) {
				attr_dev(input_1, "maxlength", /*maxlength*/ ctx[23]);
			}

			if (dirty[0] & /*min*/ 2097152) {
				attr_dev(input_1, "min", /*min*/ ctx[21]);
			}

			if (dirty[0] & /*minlength*/ 16777216) {
				attr_dev(input_1, "minlength", /*minlength*/ ctx[24]);
			}

			if (dirty[0] & /*step*/ 4194304) {
				attr_dev(input_1, "step", /*step*/ ctx[22]);
			}

			if (dirty[0] & /*multiple*/ 33554432) {
				prop_dev(input_1, "multiple", /*multiple*/ ctx[25]);
			}

			if (dirty[0] & /*readonly*/ 128) {
				prop_dev(input_1, "readOnly", /*readonly*/ ctx[7]);
			}

			if (dirty[0] & /*required*/ 256) {
				prop_dev(input_1, "required", /*required*/ ctx[8]);
			}

			if (dirty[0] & /*pattern*/ 134217728) {
				attr_dev(input_1, "pattern", /*pattern*/ ctx[27]);
			}

			if (dirty[0] & /*validate*/ 268435456 && input_1_validate_value !== (input_1_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined)) {
				attr_dev(input_1, "validate", input_1_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 805306368 && input_1_data_validate_value !== (input_1_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(input_1, "data-validate", input_1_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 536870912 && input_1_data_validate_on_blur_value !== (input_1_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(input_1, "data-validate-on-blur", input_1_data_validate_on_blur_value);
			}

			if (dirty[0] & /*tabindex*/ 1073741824) {
				attr_dev(input_1, "tabindex", /*tabindex*/ ctx[30]);
			}

			if (dirty[1] & /*errorMessageForce, errorMessage*/ 12 && input_1_data_error_message_value !== (input_1_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33])) {
				attr_dev(input_1, "data-error-message", input_1_data_error_message_value);
			}

			if (dirty[1] & /*inputClasses*/ 65536) {
				attr_dev(input_1, "class", /*inputClasses*/ ctx[47]);
			}

			if (dirty[0] & /*type*/ 8 | dirty[1] & /*inputValue*/ 8192 && input_1_value_value !== (input_1_value_value = /*type*/ ctx[3] === "datepicker" || /*type*/ ctx[3] === "colorpicker" || /*type*/ ctx[3] === "file"
			? ""
			: /*inputValue*/ ctx[44]) && input_1.value !== input_1_value_value) {
				prop_dev(input_1, "value", input_1_value_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input_1);
			/*input_1_binding*/ ctx[79](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$3.name,
		type: "else",
		source: "(493:12) {:else}",
		ctx
	});

	return block;
}

// (482:44) 
function create_if_block_8$1(ctx) {
	let texteditor;
	let current;

	const texteditor_spread_levels = [
		{
			value: typeof /*value*/ ctx[5] === "undefined"
			? ""
			: /*value*/ ctx[5]
		},
		{ resizable: /*resizable*/ ctx[31] },
		{ placeholder: /*placeholder*/ ctx[10] },
		{ onTextEditorFocus: /*onFocus*/ ctx[53] },
		{ onTextEditorBlur: /*onBlur*/ ctx[54] },
		{ onTextEditorInput: /*onInput*/ ctx[52] },
		{ onTextEditorChange: /*onChange*/ ctx[55] },
		/*textEditorParams*/ ctx[37]
	];

	let texteditor_props = {};

	for (let i = 0; i < texteditor_spread_levels.length; i += 1) {
		texteditor_props = assign(texteditor_props, texteditor_spread_levels[i]);
	}

	texteditor = new Text_editor({ props: texteditor_props, $$inline: true });

	const block = {
		c: function create() {
			create_component(texteditor.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(texteditor, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const texteditor_changes = (dirty[0] & /*value, placeholder*/ 1056 | dirty[1] & /*resizable, onFocus, onBlur, onInput, onChange, textEditorParams*/ 31457345)
			? get_spread_update(texteditor_spread_levels, [
					dirty[0] & /*value*/ 32 && {
						value: typeof /*value*/ ctx[5] === "undefined"
						? ""
						: /*value*/ ctx[5]
					},
					dirty[1] & /*resizable*/ 1 && { resizable: /*resizable*/ ctx[31] },
					dirty[0] & /*placeholder*/ 1024 && { placeholder: /*placeholder*/ ctx[10] },
					dirty[1] & /*onFocus*/ 4194304 && { onTextEditorFocus: /*onFocus*/ ctx[53] },
					dirty[1] & /*onBlur*/ 8388608 && { onTextEditorBlur: /*onBlur*/ ctx[54] },
					dirty[1] & /*onInput*/ 2097152 && { onTextEditorInput: /*onInput*/ ctx[52] },
					dirty[1] & /*onChange*/ 16777216 && { onTextEditorChange: /*onChange*/ ctx[55] },
					dirty[1] & /*textEditorParams*/ 64 && get_spread_object(/*textEditorParams*/ ctx[37])
				])
			: {};

			texteditor.$set(texteditor_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(texteditor.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(texteditor.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(texteditor, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8$1.name,
		type: "if",
		source: "(482:44) ",
		ctx
	});

	return block;
}

// (444:42) 
function create_if_block_7$1(ctx) {
	let textarea;
	let textarea_validate_value;
	let textarea_data_validate_value;
	let textarea_data_validate_on_blur_value;
	let textarea_data_error_message_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			textarea = element("textarea");
			attr_dev(textarea, "style", /*inputStyle*/ ctx[26]);
			attr_dev(textarea, "name", /*name*/ ctx[4]);
			attr_dev(textarea, "placeholder", /*placeholder*/ ctx[10]);
			attr_dev(textarea, "id", /*inputId*/ ctx[11]);
			attr_dev(textarea, "size", /*size*/ ctx[12]);
			attr_dev(textarea, "inputmode", /*inputmode*/ ctx[6]);
			attr_dev(textarea, "accept", /*accept*/ ctx[13]);
			attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[14]);
			attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[15]);
			attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
			attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[17]);
			textarea.autofocus = /*autofocus*/ ctx[18];
			attr_dev(textarea, "autosave", /*autosave*/ ctx[19]);
			textarea.disabled = /*disabled*/ ctx[9];
			attr_dev(textarea, "max", /*max*/ ctx[20]);
			attr_dev(textarea, "maxlength", /*maxlength*/ ctx[23]);
			attr_dev(textarea, "min", /*min*/ ctx[21]);
			attr_dev(textarea, "minlength", /*minlength*/ ctx[24]);
			attr_dev(textarea, "step", /*step*/ ctx[22]);
			attr_dev(textarea, "multiple", /*multiple*/ ctx[25]);
			textarea.readOnly = /*readonly*/ ctx[7];
			textarea.required = /*required*/ ctx[8];
			attr_dev(textarea, "pattern", /*pattern*/ ctx[27]);

			attr_dev(textarea, "validate", textarea_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined);

			attr_dev(textarea, "data-validate", textarea_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(textarea, "tabindex", /*tabindex*/ ctx[30]);

			attr_dev(textarea, "data-error-message", textarea_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33]);

			attr_dev(textarea, "class", /*inputClasses*/ ctx[47]);
			textarea.value = /*inputValue*/ ctx[44];
			add_location(textarea, file$C, 444, 14, 13615);
		},
		m: function mount(target, anchor) {
			insert_dev(target, textarea, anchor);
			/*textarea_binding*/ ctx[78](textarea);

			if (!mounted) {
				dispose = [
					listen_dev(textarea, "focus", /*onFocus*/ ctx[53], false, false, false),
					listen_dev(textarea, "blur", /*onBlur*/ ctx[54], false, false, false),
					listen_dev(textarea, "input", /*onInput*/ ctx[52], false, false, false),
					listen_dev(textarea, "change", /*onChange*/ ctx[55], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*inputStyle*/ 67108864) {
				attr_dev(textarea, "style", /*inputStyle*/ ctx[26]);
			}

			if (dirty[0] & /*name*/ 16) {
				attr_dev(textarea, "name", /*name*/ ctx[4]);
			}

			if (dirty[0] & /*placeholder*/ 1024) {
				attr_dev(textarea, "placeholder", /*placeholder*/ ctx[10]);
			}

			if (dirty[0] & /*inputId*/ 2048) {
				attr_dev(textarea, "id", /*inputId*/ ctx[11]);
			}

			if (dirty[0] & /*size*/ 4096) {
				attr_dev(textarea, "size", /*size*/ ctx[12]);
			}

			if (dirty[0] & /*inputmode*/ 64) {
				attr_dev(textarea, "inputmode", /*inputmode*/ ctx[6]);
			}

			if (dirty[0] & /*accept*/ 8192) {
				attr_dev(textarea, "accept", /*accept*/ ctx[13]);
			}

			if (dirty[0] & /*autocomplete*/ 16384) {
				attr_dev(textarea, "autocomplete", /*autocomplete*/ ctx[14]);
			}

			if (dirty[0] & /*autocorrect*/ 32768) {
				attr_dev(textarea, "autocorrect", /*autocorrect*/ ctx[15]);
			}

			if (dirty[0] & /*autocapitalize*/ 65536) {
				attr_dev(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
			}

			if (dirty[0] & /*spellcheck*/ 131072) {
				attr_dev(textarea, "spellcheck", /*spellcheck*/ ctx[17]);
			}

			if (dirty[0] & /*autofocus*/ 262144) {
				prop_dev(textarea, "autofocus", /*autofocus*/ ctx[18]);
			}

			if (dirty[0] & /*autosave*/ 524288) {
				attr_dev(textarea, "autosave", /*autosave*/ ctx[19]);
			}

			if (dirty[0] & /*disabled*/ 512) {
				prop_dev(textarea, "disabled", /*disabled*/ ctx[9]);
			}

			if (dirty[0] & /*max*/ 1048576) {
				attr_dev(textarea, "max", /*max*/ ctx[20]);
			}

			if (dirty[0] & /*maxlength*/ 8388608) {
				attr_dev(textarea, "maxlength", /*maxlength*/ ctx[23]);
			}

			if (dirty[0] & /*min*/ 2097152) {
				attr_dev(textarea, "min", /*min*/ ctx[21]);
			}

			if (dirty[0] & /*minlength*/ 16777216) {
				attr_dev(textarea, "minlength", /*minlength*/ ctx[24]);
			}

			if (dirty[0] & /*step*/ 4194304) {
				attr_dev(textarea, "step", /*step*/ ctx[22]);
			}

			if (dirty[0] & /*multiple*/ 33554432) {
				attr_dev(textarea, "multiple", /*multiple*/ ctx[25]);
			}

			if (dirty[0] & /*readonly*/ 128) {
				prop_dev(textarea, "readOnly", /*readonly*/ ctx[7]);
			}

			if (dirty[0] & /*required*/ 256) {
				prop_dev(textarea, "required", /*required*/ ctx[8]);
			}

			if (dirty[0] & /*pattern*/ 134217728) {
				attr_dev(textarea, "pattern", /*pattern*/ ctx[27]);
			}

			if (dirty[0] & /*validate*/ 268435456 && textarea_validate_value !== (textarea_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined)) {
				attr_dev(textarea, "validate", textarea_validate_value);
			}

			if (dirty[0] & /*validate, validateOnBlur*/ 805306368 && textarea_data_validate_value !== (textarea_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(textarea, "data-validate", textarea_data_validate_value);
			}

			if (dirty[0] & /*validateOnBlur*/ 536870912 && textarea_data_validate_on_blur_value !== (textarea_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(textarea, "data-validate-on-blur", textarea_data_validate_on_blur_value);
			}

			if (dirty[0] & /*tabindex*/ 1073741824) {
				attr_dev(textarea, "tabindex", /*tabindex*/ ctx[30]);
			}

			if (dirty[1] & /*errorMessageForce, errorMessage*/ 12 && textarea_data_error_message_value !== (textarea_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33])) {
				attr_dev(textarea, "data-error-message", textarea_data_error_message_value);
			}

			if (dirty[1] & /*inputClasses*/ 65536) {
				attr_dev(textarea, "class", /*inputClasses*/ ctx[47]);
			}

			if (dirty[1] & /*inputValue*/ 8192) {
				prop_dev(textarea, "value", /*inputValue*/ ctx[44]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			/*textarea_binding*/ ctx[78](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7$1.name,
		type: "if",
		source: "(444:42) ",
		ctx
	});

	return block;
}

// (405:12) {#if type === 'select'}
function create_if_block_6$1(ctx) {
	let select;
	let select_validate_value;
	let select_data_validate_value;
	let select_data_validate_on_blur_value;
	let select_data_error_message_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[76].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[75], null);

	const block = {
		c: function create() {
			select = element("select");
			if (default_slot) default_slot.c();
			attr_dev(select, "style", /*inputStyle*/ ctx[26]);
			attr_dev(select, "name", /*name*/ ctx[4]);
			attr_dev(select, "placeholder", /*placeholder*/ ctx[10]);
			attr_dev(select, "id", /*inputId*/ ctx[11]);
			attr_dev(select, "size", /*size*/ ctx[12]);
			attr_dev(select, "accept", /*accept*/ ctx[13]);
			attr_dev(select, "autocomplete", /*autocomplete*/ ctx[14]);
			attr_dev(select, "autocorrect", /*autocorrect*/ ctx[15]);
			attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[16]);
			attr_dev(select, "spellcheck", /*spellcheck*/ ctx[17]);
			select.autofocus = /*autofocus*/ ctx[18];
			attr_dev(select, "autosave", /*autosave*/ ctx[19]);
			select.disabled = /*disabled*/ ctx[9];
			attr_dev(select, "max", /*max*/ ctx[20]);
			attr_dev(select, "maxlength", /*maxlength*/ ctx[23]);
			attr_dev(select, "min", /*min*/ ctx[21]);
			attr_dev(select, "minlength", /*minlength*/ ctx[24]);
			attr_dev(select, "step", /*step*/ ctx[22]);
			select.multiple = /*multiple*/ ctx[25];
			attr_dev(select, "readonly", /*readonly*/ ctx[7]);
			select.required = /*required*/ ctx[8];
			attr_dev(select, "pattern", /*pattern*/ ctx[27]);

			attr_dev(select, "validate", select_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined);

			attr_dev(select, "data-validate", select_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined);

			attr_dev(select, "tabindex", /*tabindex*/ ctx[30]);

			attr_dev(select, "data-error-message", select_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33]);

			attr_dev(select, "class", /*inputClasses*/ ctx[47]);
			add_location(select, file$C, 405, 14, 11997);
		},
		m: function mount(target, anchor) {
			insert_dev(target, select, anchor);

			if (default_slot) {
				default_slot.m(select, null);
			}

			select_option(select, /*inputValue*/ ctx[44]);
			/*select_binding*/ ctx[77](select);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(select, "focus", /*onFocus*/ ctx[53], false, false, false),
					listen_dev(select, "blur", /*onBlur*/ ctx[54], false, false, false),
					listen_dev(select, "input", /*onInput*/ ctx[52], false, false, false),
					listen_dev(select, "change", /*onChange*/ ctx[55], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[75], dirty, null, null);
				}
			}

			if (!current || dirty[0] & /*inputStyle*/ 67108864) {
				attr_dev(select, "style", /*inputStyle*/ ctx[26]);
			}

			if (!current || dirty[0] & /*name*/ 16) {
				attr_dev(select, "name", /*name*/ ctx[4]);
			}

			if (!current || dirty[0] & /*placeholder*/ 1024) {
				attr_dev(select, "placeholder", /*placeholder*/ ctx[10]);
			}

			if (!current || dirty[0] & /*inputId*/ 2048) {
				attr_dev(select, "id", /*inputId*/ ctx[11]);
			}

			if (!current || dirty[0] & /*size*/ 4096) {
				attr_dev(select, "size", /*size*/ ctx[12]);
			}

			if (!current || dirty[0] & /*accept*/ 8192) {
				attr_dev(select, "accept", /*accept*/ ctx[13]);
			}

			if (!current || dirty[0] & /*autocomplete*/ 16384) {
				attr_dev(select, "autocomplete", /*autocomplete*/ ctx[14]);
			}

			if (!current || dirty[0] & /*autocorrect*/ 32768) {
				attr_dev(select, "autocorrect", /*autocorrect*/ ctx[15]);
			}

			if (!current || dirty[0] & /*autocapitalize*/ 65536) {
				attr_dev(select, "autocapitalize", /*autocapitalize*/ ctx[16]);
			}

			if (!current || dirty[0] & /*spellcheck*/ 131072) {
				attr_dev(select, "spellcheck", /*spellcheck*/ ctx[17]);
			}

			if (!current || dirty[0] & /*autofocus*/ 262144) {
				prop_dev(select, "autofocus", /*autofocus*/ ctx[18]);
			}

			if (!current || dirty[0] & /*autosave*/ 524288) {
				attr_dev(select, "autosave", /*autosave*/ ctx[19]);
			}

			if (!current || dirty[0] & /*disabled*/ 512) {
				prop_dev(select, "disabled", /*disabled*/ ctx[9]);
			}

			if (!current || dirty[0] & /*max*/ 1048576) {
				attr_dev(select, "max", /*max*/ ctx[20]);
			}

			if (!current || dirty[0] & /*maxlength*/ 8388608) {
				attr_dev(select, "maxlength", /*maxlength*/ ctx[23]);
			}

			if (!current || dirty[0] & /*min*/ 2097152) {
				attr_dev(select, "min", /*min*/ ctx[21]);
			}

			if (!current || dirty[0] & /*minlength*/ 16777216) {
				attr_dev(select, "minlength", /*minlength*/ ctx[24]);
			}

			if (!current || dirty[0] & /*step*/ 4194304) {
				attr_dev(select, "step", /*step*/ ctx[22]);
			}

			if (!current || dirty[0] & /*multiple*/ 33554432) {
				prop_dev(select, "multiple", /*multiple*/ ctx[25]);
			}

			if (!current || dirty[0] & /*readonly*/ 128) {
				attr_dev(select, "readonly", /*readonly*/ ctx[7]);
			}

			if (!current || dirty[0] & /*required*/ 256) {
				prop_dev(select, "required", /*required*/ ctx[8]);
			}

			if (!current || dirty[0] & /*pattern*/ 134217728) {
				attr_dev(select, "pattern", /*pattern*/ ctx[27]);
			}

			if (!current || dirty[0] & /*validate*/ 268435456 && select_validate_value !== (select_validate_value = typeof /*validate*/ ctx[28] === "string" && /*validate*/ ctx[28].length
			? /*validate*/ ctx[28]
			: undefined)) {
				attr_dev(select, "validate", select_validate_value);
			}

			if (!current || dirty[0] & /*validate, validateOnBlur*/ 805306368 && select_data_validate_value !== (select_data_validate_value = /*validate*/ ctx[28] === true || /*validate*/ ctx[28] === "" || /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(select, "data-validate", select_data_validate_value);
			}

			if (!current || dirty[0] & /*validateOnBlur*/ 536870912 && select_data_validate_on_blur_value !== (select_data_validate_on_blur_value = /*validateOnBlur*/ ctx[29] === true || /*validateOnBlur*/ ctx[29] === ""
			? true
			: undefined)) {
				attr_dev(select, "data-validate-on-blur", select_data_validate_on_blur_value);
			}

			if (!current || dirty[0] & /*tabindex*/ 1073741824) {
				attr_dev(select, "tabindex", /*tabindex*/ ctx[30]);
			}

			if (!current || dirty[1] & /*errorMessageForce, errorMessage*/ 12 && select_data_error_message_value !== (select_data_error_message_value = /*errorMessageForce*/ ctx[34]
			? undefined
			: /*errorMessage*/ ctx[33])) {
				attr_dev(select, "data-error-message", select_data_error_message_value);
			}

			if (!current || dirty[1] & /*inputClasses*/ 65536) {
				attr_dev(select, "class", /*inputClasses*/ ctx[47]);
			}

			if (!current || dirty[1] & /*inputValue*/ 8192) {
				select_option(select, /*inputValue*/ ctx[44]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(select);
			if (default_slot) default_slot.d(detaching);
			/*select_binding*/ ctx[77](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6$1.name,
		type: "if",
		source: "(405:12) {#if type === 'select'}",
		ctx
	});

	return block;
}

// (535:10) {#if hasErrorMessage && errorMessageForce}
function create_if_block_4$3(ctx) {
	let div;
	let t0_value = Utils.text(/*errorMessage*/ ctx[33]) + "";
	let t0;
	let t1;
	let current;
	const error_message_slot_template = /*#slots*/ ctx[76]["error-message"];
	const error_message_slot = create_slot(error_message_slot_template, ctx, /*$$scope*/ ctx[75], get_error_message_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (error_message_slot) error_message_slot.c();
			attr_dev(div, "class", "item-input-error-message");
			add_location(div, file$C, 535, 12, 17438);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (error_message_slot) {
				error_message_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[1] & /*errorMessage*/ 4) && t0_value !== (t0_value = Utils.text(/*errorMessage*/ ctx[33]) + "")) set_data_dev(t0, t0_value);

			if (error_message_slot) {
				if (error_message_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(error_message_slot, error_message_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_error_message_slot_changes, get_error_message_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(error_message_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(error_message_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (error_message_slot) error_message_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$3.name,
		type: "if",
		source: "(535:10) {#if hasErrorMessage && errorMessageForce}",
		ctx
	});

	return block;
}

// (541:10) {#if clearButton}
function create_if_block_3$6(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "input-clear-button");
			add_location(span, file$C, 541, 12, 17636);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$6.name,
		type: "if",
		source: "(541:10) {#if clearButton}",
		ctx
	});

	return block;
}

// (544:10) {#if (typeof info !== 'undefined' || hasInfoSlots)}
function create_if_block_2$7(ctx) {
	let div;
	let t0_value = Utils.text(/*info*/ ctx[35]) + "";
	let t0;
	let t1;
	let current;
	const info_slot_template = /*#slots*/ ctx[76].info;
	const info_slot = create_slot(info_slot_template, ctx, /*$$scope*/ ctx[75], get_info_slot_context$1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (info_slot) info_slot.c();
			attr_dev(div, "class", "item-input-info");
			add_location(div, file$C, 544, 12, 17762);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (info_slot) {
				info_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[1] & /*info*/ 16) && t0_value !== (t0_value = Utils.text(/*info*/ ctx[35]) + "")) set_data_dev(t0, t0_value);

			if (info_slot) {
				if (info_slot.p && dirty[2] & /*$$scope*/ 8192) {
					update_slot(info_slot, info_slot_template, ctx, /*$$scope*/ ctx[75], dirty, get_info_slot_changes$1, get_info_slot_context$1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(info_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(info_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (info_slot) info_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$7.name,
		type: "if",
		source: "(544:10) {#if (typeof info !== 'undefined' || hasInfoSlots)}",
		ctx
	});

	return block;
}

// (557:4) {#if isSortable && !isSortableOpposite}
function create_if_block_1$7(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$C, 557, 6, 18109);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$7.name,
		type: "if",
		source: "(557:4) {#if isSortable && !isSortableOpposite}",
		ctx
	});

	return block;
}

function create_fragment$C(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$c, create_else_block_1$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*wrap*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$C.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$x($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","sortable","sortableOpposite","media","dropdown","wrap","input","type","name","value","inputmode","readonly","required","disabled","placeholder","inputId","size","accept","autocomplete","autocorrect","autocapitalize","spellcheck","autofocus","autosave","max","min","step","maxlength","minlength","multiple","inputStyle","pattern","validate","validateOnBlur","onValidate","tabindex","resizable","clearButton","noFormStoreData","noStoreData","ignoreStoreData","errorMessage","errorMessageForce","info","outline","label","inlineLabel","floatingLabel","calendarParams","colorPickerParams","textEditorParams","calendarInstance","colorPickerInstance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;

	validate_slots("List_input", slots, [
		'root-start','content-start','media','inner-start','label','default','input','error-message','info','inner','inner-end','content','content-end','root','root-end'
	]);

	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { sortable = undefined } = $$props;
	let { sortableOpposite = undefined } = $$props;
	let { media = undefined } = $$props;
	let { dropdown = "auto" } = $$props;
	let { wrap = true } = $$props;
	let { input = true } = $$props;
	let { type = "text" } = $$props;
	let { name = undefined } = $$props;
	let { value = undefined } = $$props;
	let { inputmode = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let { required = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { placeholder = undefined } = $$props;
	let { inputId = undefined } = $$props;
	let { size = undefined } = $$props;
	let { accept = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { autofocus = undefined } = $$props;
	let { autosave = undefined } = $$props;
	let { max = undefined } = $$props;
	let { min = undefined } = $$props;
	let { step = undefined } = $$props;
	let { maxlength = undefined } = $$props;
	let { minlength = undefined } = $$props;
	let { multiple = undefined } = $$props;
	let { inputStyle = undefined } = $$props;
	let { pattern = undefined } = $$props;
	let { validate = undefined } = $$props;
	let { validateOnBlur = undefined } = $$props;
	let { onValidate = undefined } = $$props;
	let { tabindex = undefined } = $$props;
	let { resizable = undefined } = $$props;
	let { clearButton = undefined } = $$props;
	let { noFormStoreData = undefined } = $$props;
	let { noStoreData = undefined } = $$props;
	let { ignoreStoreData = undefined } = $$props;
	let { errorMessage = undefined } = $$props;
	let { errorMessageForce = undefined } = $$props;
	let { info = undefined } = $$props;
	let { outline = undefined } = $$props;
	let { label = undefined } = $$props;
	let { inlineLabel = undefined } = $$props;
	let { floatingLabel = undefined } = $$props;
	let { calendarParams = undefined } = $$props;
	let { colorPickerParams = undefined } = $$props;
	let { textEditorParams = undefined } = $$props;

	// State
	let inputEl;

	let inputFocused = false;
	let inputInvalid = false;
	let updateInputOnDidUpdate = false;
	let f7Calendar;
	let f7ColorPicker;

	function calendarInstance() {
		return f7Calendar;
	}

	function colorPickerInstance() {
		return f7ColorPicker;
	}

	function domValue() {
		if (!inputEl) return undefined;
		return inputEl.value;
	}

	function inputHasValue() {
		if (type === "datepicker" && Array.isArray(value) && value.length === 0) {
			return false;
		}

		const domV = domValue();

		return typeof value === "undefined"
		? domV || domV === 0
		: value || value === 0;
	}

	function validateInput() {
		if (!f7.instance || !inputEl) return;
		const validity = inputEl.validity;
		if (!validity) return;

		if (!validity.valid) {
			if (onValidate) onValidate(false);

			if (inputInvalid !== true) {
				$$invalidate(73, inputInvalid = true);
			}
		} else if (inputInvalid !== false) {
			if (onValidate) onValidate(true);
			$$invalidate(73, inputInvalid = false);
		}
	}

	let initialWatched = false;

	function watchValue() {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (type === "range" || type === "toggle") return;
		if (!f7.instance) return;
		updateInputOnDidUpdate = true;

		if (f7Calendar) {
			f7Calendar.setValue(value);
		}

		if (f7ColorPicker) {
			f7ColorPicker.setValue(value);
		}
	}

	function watchColorPickerParams() {
		if (!f7.instance || !f7ColorPicker) return;
		Utils.extend(f7ColorPicker.params, colorPickerParams || {});
	}

	function watchCalendarParams() {
		if (!f7.instance || !f7Calendar) return;
		Utils.extend(f7Calendar.params, calendarParams || {});
	}

	function onTextareaResize(event) {
		dispatch("textareaResize", [event]);
		if (typeof $$props.onTextareaResize === "function") $$props.onTextareaResize(event);
	}

	function onInputNotEmpty(event) {
		dispatch("inputNotEmpty", [event]);
		if (typeof $$props.onInputNotEmpty === "function") $$props.onInputNotEmpty(event);
	}

	function onInputEmpty(event) {
		dispatch("inputEmpty", [event]);
		if (typeof $$props.onInputEmpty === "function") $$props.onInputEmpty(event);
	}

	function onInputClear(event) {
		dispatch("inputClear", [event]);
		if (typeof $$props.onInputClear === "function") $$props.onInputClear(event);
	}

	function onInput(...args) {
		dispatch("input", [...args]);
		if (typeof $$props.onInput === "function") $$props.onInput(...args);

		if (!(validateOnBlur || validateOnBlur === "") && (validate || validate === "") && inputEl) {
			validateInput();
		}
	}

	function onFocus(...args) {
		dispatch("focus", [...args]);
		if (typeof $$props.onFocus === "function") $$props.onFocus(...args);
		$$invalidate(72, inputFocused = true);
	}

	function onBlur(...args) {
		dispatch("blur", [...args]);
		if (typeof $$props.onBlur === "function") $$props.onBlur(...args);

		if ((validate || validate === "" || validateOnBlur || validateOnBlur === "") && inputEl) {
			validateInput();
		}

		$$invalidate(72, inputFocused = false);
	}

	function onChange(...args) {
		dispatch("change", [...args]);
		if (typeof $$props.onChange === "function") $$props.onChange(...args);

		if (type === "texteditor") {
			dispatch("textEditorChange", [args[1]]);
			if (typeof $$props.onTextEditorChange === "function") $$props.onTextEditorChange(...args);
		}
	}

	onMount(() => {
		f7.ready(() => {
			if (type === "range" || type === "toggle") return;
			if (!inputEl) return;
			inputEl.addEventListener("input:notempty", onInputNotEmpty, false);

			if (type === "textarea" && resizable) {
				inputEl.addEventListener("textarea:resize", onTextareaResize, false);
			}

			if (clearButton) {
				inputEl.addEventListener("input:empty", onInputEmpty, false);
				inputEl.addEventListener("input:clear", onInputClear, false);
			}

			if (type === "datepicker") {
				f7Calendar = f7.instance.calendar.create({
					inputEl,
					value,
					on: {
						change(calendar, calendarValue) {
							dispatch("calendarChange", [calendarValue]);
							if (typeof $$props.onCalendarChange === "function") $$props.onCalendarChange(calendarValue);
						}
					},
					...calendarParams || {}
				});
			}

			if (type === "colorpicker") {
				f7ColorPicker = f7.instance.colorPicker.create({
					inputEl,
					value,
					on: {
						change(colorPicker, colorPickerValue) {
							dispatch("colorPickerChange", [colorPickerValue]);
							if (typeof $$props.onColorPickerChange === "function") $$props.onColorPickerChange(colorPickerValue);
						}
					},
					...colorPickerParams || {}
				});
			}

			f7.instance.input.checkEmptyState(inputEl);

			if (!(validateOnBlur || validateOnBlur === "") && (validate || validate === "") && (typeof value !== "undefined" && value !== null && value !== "")) {
				setTimeout(
					() => {
						validateInput();
					},
					0
				);
			}

			if (resizable) {
				f7.instance.input.resizeTextarea(inputEl);
			}
		});
	});

	afterUpdate(() => {
		if (!f7.instance) return;

		if (updateInputOnDidUpdate) {
			if (!inputEl) return;
			updateInputOnDidUpdate = false;
			f7.instance.input.checkEmptyState(inputEl);

			if (validate && !validateOnBlur) {
				validateInput();
			}

			if (resizable) {
				f7.instance.input.resizeTextarea(inputEl);
			}
		}
	});

	onDestroy(() => {
		if (type === "range" || type === "toggle") return;
		if (!inputEl) return;
		inputEl.removeEventListener("input:notempty", onInputNotEmpty, false);

		if (type === "textarea" && resizable) {
			inputEl.removeEventListener("textarea:resize", onTextareaResize, false);
		}

		if (clearButton) {
			inputEl.removeEventListener("input:empty", onInputEmpty, false);
			inputEl.removeEventListener("input:clear", onInputClear, false);
		}

		if (f7Calendar && f7Calendar.destroy) {
			f7Calendar.destroy();
		}

		if (f7ColorPicker && f7ColorPicker.destroy) {
			f7ColorPicker.destroy();
		}

		f7Calendar = null;
		f7ColorPicker = null;
	});

	function select_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(41, inputEl);
		});
	}

	function textarea_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(41, inputEl);
		});
	}

	function input_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(41, inputEl);
		});
	}

	function select_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(41, inputEl);
		});
	}

	function textarea_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(41, inputEl);
		});
	}

	function input_1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(41, inputEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(99, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(56, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(57, className = $$new_props.class);
		if ("sortable" in $$new_props) $$invalidate(58, sortable = $$new_props.sortable);
		if ("sortableOpposite" in $$new_props) $$invalidate(59, sortableOpposite = $$new_props.sortableOpposite);
		if ("media" in $$new_props) $$invalidate(0, media = $$new_props.media);
		if ("dropdown" in $$new_props) $$invalidate(60, dropdown = $$new_props.dropdown);
		if ("wrap" in $$new_props) $$invalidate(1, wrap = $$new_props.wrap);
		if ("input" in $$new_props) $$invalidate(2, input = $$new_props.input);
		if ("type" in $$new_props) $$invalidate(3, type = $$new_props.type);
		if ("name" in $$new_props) $$invalidate(4, name = $$new_props.name);
		if ("value" in $$new_props) $$invalidate(5, value = $$new_props.value);
		if ("inputmode" in $$new_props) $$invalidate(6, inputmode = $$new_props.inputmode);
		if ("readonly" in $$new_props) $$invalidate(7, readonly = $$new_props.readonly);
		if ("required" in $$new_props) $$invalidate(8, required = $$new_props.required);
		if ("disabled" in $$new_props) $$invalidate(9, disabled = $$new_props.disabled);
		if ("placeholder" in $$new_props) $$invalidate(10, placeholder = $$new_props.placeholder);
		if ("inputId" in $$new_props) $$invalidate(11, inputId = $$new_props.inputId);
		if ("size" in $$new_props) $$invalidate(12, size = $$new_props.size);
		if ("accept" in $$new_props) $$invalidate(13, accept = $$new_props.accept);
		if ("autocomplete" in $$new_props) $$invalidate(14, autocomplete = $$new_props.autocomplete);
		if ("autocorrect" in $$new_props) $$invalidate(15, autocorrect = $$new_props.autocorrect);
		if ("autocapitalize" in $$new_props) $$invalidate(16, autocapitalize = $$new_props.autocapitalize);
		if ("spellcheck" in $$new_props) $$invalidate(17, spellcheck = $$new_props.spellcheck);
		if ("autofocus" in $$new_props) $$invalidate(18, autofocus = $$new_props.autofocus);
		if ("autosave" in $$new_props) $$invalidate(19, autosave = $$new_props.autosave);
		if ("max" in $$new_props) $$invalidate(20, max = $$new_props.max);
		if ("min" in $$new_props) $$invalidate(21, min = $$new_props.min);
		if ("step" in $$new_props) $$invalidate(22, step = $$new_props.step);
		if ("maxlength" in $$new_props) $$invalidate(23, maxlength = $$new_props.maxlength);
		if ("minlength" in $$new_props) $$invalidate(24, minlength = $$new_props.minlength);
		if ("multiple" in $$new_props) $$invalidate(25, multiple = $$new_props.multiple);
		if ("inputStyle" in $$new_props) $$invalidate(26, inputStyle = $$new_props.inputStyle);
		if ("pattern" in $$new_props) $$invalidate(27, pattern = $$new_props.pattern);
		if ("validate" in $$new_props) $$invalidate(28, validate = $$new_props.validate);
		if ("validateOnBlur" in $$new_props) $$invalidate(29, validateOnBlur = $$new_props.validateOnBlur);
		if ("onValidate" in $$new_props) $$invalidate(61, onValidate = $$new_props.onValidate);
		if ("tabindex" in $$new_props) $$invalidate(30, tabindex = $$new_props.tabindex);
		if ("resizable" in $$new_props) $$invalidate(31, resizable = $$new_props.resizable);
		if ("clearButton" in $$new_props) $$invalidate(32, clearButton = $$new_props.clearButton);
		if ("noFormStoreData" in $$new_props) $$invalidate(62, noFormStoreData = $$new_props.noFormStoreData);
		if ("noStoreData" in $$new_props) $$invalidate(63, noStoreData = $$new_props.noStoreData);
		if ("ignoreStoreData" in $$new_props) $$invalidate(64, ignoreStoreData = $$new_props.ignoreStoreData);
		if ("errorMessage" in $$new_props) $$invalidate(33, errorMessage = $$new_props.errorMessage);
		if ("errorMessageForce" in $$new_props) $$invalidate(34, errorMessageForce = $$new_props.errorMessageForce);
		if ("info" in $$new_props) $$invalidate(35, info = $$new_props.info);
		if ("outline" in $$new_props) $$invalidate(65, outline = $$new_props.outline);
		if ("label" in $$new_props) $$invalidate(36, label = $$new_props.label);
		if ("inlineLabel" in $$new_props) $$invalidate(66, inlineLabel = $$new_props.inlineLabel);
		if ("floatingLabel" in $$new_props) $$invalidate(67, floatingLabel = $$new_props.floatingLabel);
		if ("calendarParams" in $$new_props) $$invalidate(68, calendarParams = $$new_props.calendarParams);
		if ("colorPickerParams" in $$new_props) $$invalidate(69, colorPickerParams = $$new_props.colorPickerParams);
		if ("textEditorParams" in $$new_props) $$invalidate(37, textEditorParams = $$new_props.textEditorParams);
		if ("$$scope" in $$new_props) $$invalidate(75, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		afterUpdate,
		onDestroy,
		getContext,
		Mixins,
		Utils,
		restProps,
		f7,
		hasSlots,
		TextEditor: Text_editor,
		dispatch,
		className,
		sortable,
		sortableOpposite,
		media,
		dropdown,
		wrap,
		input,
		type,
		name,
		value,
		inputmode,
		readonly,
		required,
		disabled,
		placeholder,
		inputId,
		size,
		accept,
		autocomplete,
		autocorrect,
		autocapitalize,
		spellcheck,
		autofocus,
		autosave,
		max,
		min,
		step,
		maxlength,
		minlength,
		multiple,
		inputStyle,
		pattern,
		validate,
		validateOnBlur,
		onValidate,
		tabindex,
		resizable,
		clearButton,
		noFormStoreData,
		noStoreData,
		ignoreStoreData,
		errorMessage,
		errorMessageForce,
		info,
		outline,
		label,
		inlineLabel,
		floatingLabel,
		calendarParams,
		colorPickerParams,
		textEditorParams,
		inputEl,
		inputFocused,
		inputInvalid,
		updateInputOnDidUpdate,
		f7Calendar,
		f7ColorPicker,
		calendarInstance,
		colorPickerInstance,
		domValue,
		inputHasValue,
		validateInput,
		initialWatched,
		watchValue,
		watchColorPickerParams,
		watchCalendarParams,
		onTextareaResize,
		onInputNotEmpty,
		onInputEmpty,
		onInputClear,
		onInput,
		onFocus,
		onBlur,
		onChange,
		isSortable,
		isSortableOpposite,
		inputType,
		needsValue,
		inputValue,
		hasInfoSlots,
		hasErrorSlots,
		hasMediaSlots,
		hasLabelSlots,
		hasErrorMessage,
		inputClasses,
		itemContentClasses,
		labelClasses,
		inputWrapClasses,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(99, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(57, className = $$new_props.className);
		if ("sortable" in $$props) $$invalidate(58, sortable = $$new_props.sortable);
		if ("sortableOpposite" in $$props) $$invalidate(59, sortableOpposite = $$new_props.sortableOpposite);
		if ("media" in $$props) $$invalidate(0, media = $$new_props.media);
		if ("dropdown" in $$props) $$invalidate(60, dropdown = $$new_props.dropdown);
		if ("wrap" in $$props) $$invalidate(1, wrap = $$new_props.wrap);
		if ("input" in $$props) $$invalidate(2, input = $$new_props.input);
		if ("type" in $$props) $$invalidate(3, type = $$new_props.type);
		if ("name" in $$props) $$invalidate(4, name = $$new_props.name);
		if ("value" in $$props) $$invalidate(5, value = $$new_props.value);
		if ("inputmode" in $$props) $$invalidate(6, inputmode = $$new_props.inputmode);
		if ("readonly" in $$props) $$invalidate(7, readonly = $$new_props.readonly);
		if ("required" in $$props) $$invalidate(8, required = $$new_props.required);
		if ("disabled" in $$props) $$invalidate(9, disabled = $$new_props.disabled);
		if ("placeholder" in $$props) $$invalidate(10, placeholder = $$new_props.placeholder);
		if ("inputId" in $$props) $$invalidate(11, inputId = $$new_props.inputId);
		if ("size" in $$props) $$invalidate(12, size = $$new_props.size);
		if ("accept" in $$props) $$invalidate(13, accept = $$new_props.accept);
		if ("autocomplete" in $$props) $$invalidate(14, autocomplete = $$new_props.autocomplete);
		if ("autocorrect" in $$props) $$invalidate(15, autocorrect = $$new_props.autocorrect);
		if ("autocapitalize" in $$props) $$invalidate(16, autocapitalize = $$new_props.autocapitalize);
		if ("spellcheck" in $$props) $$invalidate(17, spellcheck = $$new_props.spellcheck);
		if ("autofocus" in $$props) $$invalidate(18, autofocus = $$new_props.autofocus);
		if ("autosave" in $$props) $$invalidate(19, autosave = $$new_props.autosave);
		if ("max" in $$props) $$invalidate(20, max = $$new_props.max);
		if ("min" in $$props) $$invalidate(21, min = $$new_props.min);
		if ("step" in $$props) $$invalidate(22, step = $$new_props.step);
		if ("maxlength" in $$props) $$invalidate(23, maxlength = $$new_props.maxlength);
		if ("minlength" in $$props) $$invalidate(24, minlength = $$new_props.minlength);
		if ("multiple" in $$props) $$invalidate(25, multiple = $$new_props.multiple);
		if ("inputStyle" in $$props) $$invalidate(26, inputStyle = $$new_props.inputStyle);
		if ("pattern" in $$props) $$invalidate(27, pattern = $$new_props.pattern);
		if ("validate" in $$props) $$invalidate(28, validate = $$new_props.validate);
		if ("validateOnBlur" in $$props) $$invalidate(29, validateOnBlur = $$new_props.validateOnBlur);
		if ("onValidate" in $$props) $$invalidate(61, onValidate = $$new_props.onValidate);
		if ("tabindex" in $$props) $$invalidate(30, tabindex = $$new_props.tabindex);
		if ("resizable" in $$props) $$invalidate(31, resizable = $$new_props.resizable);
		if ("clearButton" in $$props) $$invalidate(32, clearButton = $$new_props.clearButton);
		if ("noFormStoreData" in $$props) $$invalidate(62, noFormStoreData = $$new_props.noFormStoreData);
		if ("noStoreData" in $$props) $$invalidate(63, noStoreData = $$new_props.noStoreData);
		if ("ignoreStoreData" in $$props) $$invalidate(64, ignoreStoreData = $$new_props.ignoreStoreData);
		if ("errorMessage" in $$props) $$invalidate(33, errorMessage = $$new_props.errorMessage);
		if ("errorMessageForce" in $$props) $$invalidate(34, errorMessageForce = $$new_props.errorMessageForce);
		if ("info" in $$props) $$invalidate(35, info = $$new_props.info);
		if ("outline" in $$props) $$invalidate(65, outline = $$new_props.outline);
		if ("label" in $$props) $$invalidate(36, label = $$new_props.label);
		if ("inlineLabel" in $$props) $$invalidate(66, inlineLabel = $$new_props.inlineLabel);
		if ("floatingLabel" in $$props) $$invalidate(67, floatingLabel = $$new_props.floatingLabel);
		if ("calendarParams" in $$props) $$invalidate(68, calendarParams = $$new_props.calendarParams);
		if ("colorPickerParams" in $$props) $$invalidate(69, colorPickerParams = $$new_props.colorPickerParams);
		if ("textEditorParams" in $$props) $$invalidate(37, textEditorParams = $$new_props.textEditorParams);
		if ("inputEl" in $$props) $$invalidate(41, inputEl = $$new_props.inputEl);
		if ("inputFocused" in $$props) $$invalidate(72, inputFocused = $$new_props.inputFocused);
		if ("inputInvalid" in $$props) $$invalidate(73, inputInvalid = $$new_props.inputInvalid);
		if ("updateInputOnDidUpdate" in $$props) updateInputOnDidUpdate = $$new_props.updateInputOnDidUpdate;
		if ("f7Calendar" in $$props) f7Calendar = $$new_props.f7Calendar;
		if ("f7ColorPicker" in $$props) f7ColorPicker = $$new_props.f7ColorPicker;
		if ("initialWatched" in $$props) initialWatched = $$new_props.initialWatched;
		if ("isSortable" in $$props) $$invalidate(42, isSortable = $$new_props.isSortable);
		if ("isSortableOpposite" in $$props) $$invalidate(43, isSortableOpposite = $$new_props.isSortableOpposite);
		if ("inputType" in $$props) $$invalidate(38, inputType = $$new_props.inputType);
		if ("needsValue" in $$props) needsValue = $$new_props.needsValue;
		if ("inputValue" in $$props) $$invalidate(44, inputValue = $$new_props.inputValue);
		if ("hasInfoSlots" in $$props) $$invalidate(39, hasInfoSlots = $$new_props.hasInfoSlots);
		if ("hasErrorSlots" in $$props) $$invalidate(74, hasErrorSlots = $$new_props.hasErrorSlots);
		if ("hasMediaSlots" in $$props) $$invalidate(45, hasMediaSlots = $$new_props.hasMediaSlots);
		if ("hasLabelSlots" in $$props) $$invalidate(46, hasLabelSlots = $$new_props.hasLabelSlots);
		if ("hasErrorMessage" in $$props) $$invalidate(40, hasErrorMessage = $$new_props.hasErrorMessage);
		if ("inputClasses" in $$props) $$invalidate(47, inputClasses = $$new_props.inputClasses);
		if ("itemContentClasses" in $$props) $$invalidate(48, itemContentClasses = $$new_props.itemContentClasses);
		if ("labelClasses" in $$props) $$invalidate(49, labelClasses = $$new_props.labelClasses);
		if ("inputWrapClasses" in $$props) $$invalidate(50, inputWrapClasses = $$new_props.inputWrapClasses);
		if ("classes" in $$props) $$invalidate(51, classes = $$new_props.classes);
	};

	let isSortable;
	let isSortableOpposite;
	let inputType;
	let needsValue;
	let inputValue;
	let hasInfoSlots;
	let hasErrorSlots;
	let hasMediaSlots;
	let hasLabelSlots;
	let hasErrorMessage;
	let inputClasses;
	let itemContentClasses;
	let labelClasses;
	let inputWrapClasses;
	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[1] & /*sortable*/ 134217728) {
			 $$invalidate(42, isSortable = sortable || getContext("f7ListSortable"));
		}

		if ($$self.$$.dirty[1] & /*sortableOpposite*/ 268435456) {
			 $$invalidate(43, isSortableOpposite = sortableOpposite || getContext("f7ListSortableOpposite"));
		}

		if ($$self.$$.dirty[0] & /*value*/ 32) {
			 watchValue();
		}

		if ($$self.$$.dirty[2] & /*colorPickerParams*/ 128) {
			 watchColorPickerParams();
		}

		if ($$self.$$.dirty[2] & /*calendarParams*/ 64) {
			 watchCalendarParams();
		}

		if ($$self.$$.dirty[0] & /*type*/ 8) {
			 $$invalidate(38, inputType = type === "datepicker" || type === "colorpicker"
			? "text"
			: type);
		}

		if ($$self.$$.dirty[0] & /*type*/ 8) {
			 needsValue = type !== "file" && type !== "datepicker" && type !== "colorpicker";
		}

		if ($$self.$$.dirty[0] & /*value*/ 32) {
			 $$invalidate(44, inputValue = (() => {
				let v;

				if (typeof value !== "undefined") {
					v = value;
				} else {
					v = domValue();
				}

				if (typeof v === "undefined" || v === null) return "";
				return v;
			})());
		}

		if ($$self.$$.dirty[1] & /*errorMessage*/ 4 | $$self.$$.dirty[2] & /*hasErrorSlots*/ 4096) {
			 $$invalidate(40, hasErrorMessage = !!errorMessage || hasErrorSlots);
		}

		if ($$self.$$.dirty[1] & /*inputType, resizable, errorMessage, errorMessageForce*/ 141 | $$self.$$.dirty[2] & /*noFormStoreData, noStoreData, ignoreStoreData, inputInvalid, inputFocused*/ 3079) {
			 $$invalidate(47, inputClasses = Utils.classNames({
				resizable: inputType === "textarea" && resizable,
				"no-store-data": noFormStoreData || noStoreData || ignoreStoreData,
				"input-invalid": errorMessage && errorMessageForce || inputInvalid,
				"input-with-value": inputHasValue(),
				"input-focused": inputFocused
			}));
		}

		 $$invalidate(48, itemContentClasses = Utils.classNames("item-content item-input", !wrap && className, !wrap && { disabled }, !wrap && Mixins.colorClasses($$props), {
			"inline-label": inlineLabel,
			"item-input-outline": outline,
			"item-input-focused": inputFocused,
			"item-input-with-info": !!info || hasInfoSlots,
			"item-input-with-value": inputHasValue(),
			"item-input-with-error-message": hasErrorMessage && errorMessageForce || inputInvalid,
			"item-input-invalid": hasErrorMessage && errorMessageForce || inputInvalid
		}));

		if ($$self.$$.dirty[2] & /*floatingLabel*/ 32) {
			 $$invalidate(49, labelClasses = Utils.classNames("item-title item-label", { "item-floating-label": floatingLabel }));
		}

		if ($$self.$$.dirty[0] & /*type*/ 8 | $$self.$$.dirty[1] & /*dropdown*/ 536870912) {
			 $$invalidate(50, inputWrapClasses = Utils.classNames("item-input-wrap", {
				"input-dropdown": dropdown === "auto" ? type === "select" : dropdown
			}));
		}

		 $$invalidate(51, classes = Utils.classNames(className, { disabled }, Mixins.colorClasses($$props)));
	};

	 $$invalidate(39, hasInfoSlots = hasSlots(arguments, "info"));

	// eslint-disable-next-line
	 $$invalidate(74, hasErrorSlots = hasSlots(arguments, "error-message"));

	// eslint-disable-next-line
	 $$invalidate(45, hasMediaSlots = hasSlots(arguments, "media"));

	// eslint-disable-next-line
	 $$invalidate(46, hasLabelSlots = hasSlots(arguments, "label"));

	$$props = exclude_internal_props($$props);

	return [
		media,
		wrap,
		input,
		type,
		name,
		value,
		inputmode,
		readonly,
		required,
		disabled,
		placeholder,
		inputId,
		size,
		accept,
		autocomplete,
		autocorrect,
		autocapitalize,
		spellcheck,
		autofocus,
		autosave,
		max,
		min,
		step,
		maxlength,
		minlength,
		multiple,
		inputStyle,
		pattern,
		validate,
		validateOnBlur,
		tabindex,
		resizable,
		clearButton,
		errorMessage,
		errorMessageForce,
		info,
		label,
		textEditorParams,
		inputType,
		hasInfoSlots,
		hasErrorMessage,
		inputEl,
		isSortable,
		isSortableOpposite,
		inputValue,
		hasMediaSlots,
		hasLabelSlots,
		inputClasses,
		itemContentClasses,
		labelClasses,
		inputWrapClasses,
		classes,
		onInput,
		onFocus,
		onBlur,
		onChange,
		$$restProps,
		className,
		sortable,
		sortableOpposite,
		dropdown,
		onValidate,
		noFormStoreData,
		noStoreData,
		ignoreStoreData,
		outline,
		inlineLabel,
		floatingLabel,
		calendarParams,
		colorPickerParams,
		calendarInstance,
		colorPickerInstance,
		inputFocused,
		inputInvalid,
		hasErrorSlots,
		$$scope,
		slots,
		select_binding,
		textarea_binding,
		input_1_binding,
		select_binding_1,
		textarea_binding_1,
		input_1_binding_1
	];
}

class List_input extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$x,
			create_fragment$C,
			safe_not_equal,
			{
				class: 57,
				sortable: 58,
				sortableOpposite: 59,
				media: 0,
				dropdown: 60,
				wrap: 1,
				input: 2,
				type: 3,
				name: 4,
				value: 5,
				inputmode: 6,
				readonly: 7,
				required: 8,
				disabled: 9,
				placeholder: 10,
				inputId: 11,
				size: 12,
				accept: 13,
				autocomplete: 14,
				autocorrect: 15,
				autocapitalize: 16,
				spellcheck: 17,
				autofocus: 18,
				autosave: 19,
				max: 20,
				min: 21,
				step: 22,
				maxlength: 23,
				minlength: 24,
				multiple: 25,
				inputStyle: 26,
				pattern: 27,
				validate: 28,
				validateOnBlur: 29,
				onValidate: 61,
				tabindex: 30,
				resizable: 31,
				clearButton: 32,
				noFormStoreData: 62,
				noStoreData: 63,
				ignoreStoreData: 64,
				errorMessage: 33,
				errorMessageForce: 34,
				info: 35,
				outline: 65,
				label: 36,
				inlineLabel: 66,
				floatingLabel: 67,
				calendarParams: 68,
				colorPickerParams: 69,
				textEditorParams: 37,
				calendarInstance: 70,
				colorPickerInstance: 71
			},
			[-1, -1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "List_input",
			options,
			id: create_fragment$C.name
		});
	}

	get class() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortable() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortable(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortableOpposite() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortableOpposite(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get media() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set media(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dropdown() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dropdown(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get wrap() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set wrap(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get input() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputmode() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputmode(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get required() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set required(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputId() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputId(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accept() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accept(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autocomplete() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autocomplete(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autocorrect() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autocorrect(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autocapitalize() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autocapitalize(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get spellcheck() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set spellcheck(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autofocus() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autofocus(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autosave() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autosave(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get step() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set step(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get maxlength() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set maxlength(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get minlength() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set minlength(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get multiple() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set multiple(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputStyle() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputStyle(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pattern() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pattern(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get validate() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set validate(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get validateOnBlur() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set validateOnBlur(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get onValidate() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set onValidate(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabindex() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabindex(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizable() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizable(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clearButton() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set clearButton(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noFormStoreData() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noFormStoreData(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noStoreData() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noStoreData(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ignoreStoreData() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ignoreStoreData(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errorMessage() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorMessage(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get errorMessageForce() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set errorMessageForce(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get info() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set info(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outline() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outline(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inlineLabel() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inlineLabel(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get floatingLabel() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set floatingLabel(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get calendarParams() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set calendarParams(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get colorPickerParams() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set colorPickerParams(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get textEditorParams() {
		throw new Error("<List_input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set textEditorParams(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get calendarInstance() {
		return this.$$.ctx[70];
	}

	set calendarInstance(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get colorPickerInstance() {
		return this.$$.ctx[71];
	}

	set colorPickerInstance(value) {
		throw new Error("<List_input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/list-item-cell.svelte generated by Svelte v3.31.0 */
const file$D = "node_modules/framework7-svelte/components/list-item-cell.svelte";

function create_fragment$D(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$D, 16, 0, 314);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$D.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$y($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("List_item_cell", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "item-cell", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class List_item_cell extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$y, create_fragment$D, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "List_item_cell",
			options,
			id: create_fragment$D.name
		});
	}

	get class() {
		throw new Error("<List_item_cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<List_item_cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/list-item-row.svelte generated by Svelte v3.31.0 */
const file$E = "node_modules/framework7-svelte/components/list-item-row.svelte";

function create_fragment$E(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$E, 16, 0, 313);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$E.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$z($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("List_item_row", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "item-row", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class List_item_row extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$z, create_fragment$E, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "List_item_row",
			options,
			id: create_fragment$E.name
		});
	}

	get class() {
		throw new Error("<List_item_row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<List_item_row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/list-item.svelte generated by Svelte v3.31.0 */
const file$F = "node_modules/framework7-svelte/components/list-item.svelte";
const get_root_end_slot_changes$2 = dirty => ({});
const get_root_end_slot_context$2 = ctx => ({});
const get_root_slot_changes$3 = dirty => ({});
const get_root_slot_context$3 = ctx => ({});
const get_content_end_slot_changes_5 = dirty => ({});
const get_content_end_slot_context_5 = ctx => ({});
const get_content_slot_changes_5 = dirty => ({});
const get_content_slot_context_5 = ctx => ({});
const get_inner_end_slot_changes_5 = dirty => ({});
const get_inner_end_slot_context_5 = ctx => ({});
const get_inner_slot_changes_11 = dirty => ({});
const get_inner_slot_context_11 = ctx => ({});
const get_after_end_slot_changes_11 = dirty => ({});
const get_after_end_slot_context_11 = ctx => ({});
const get_after_slot_changes_11 = dirty => ({});
const get_after_slot_context_11 = ctx => ({});
const get_after_start_slot_changes_11 = dirty => ({});
const get_after_start_slot_context_11 = ctx => ({});
const get_after_title_slot_changes_11 = dirty => ({});
const get_after_title_slot_context_11 = ctx => ({});
const get_footer_slot_changes_11 = dirty => ({});
const get_footer_slot_context_11 = ctx => ({});
const get_title_slot_changes_11 = dirty => ({});
const get_title_slot_context_11 = ctx => ({});
const get_header_slot_changes_11 = dirty => ({});
const get_header_slot_context_11 = ctx => ({});
const get_before_title_slot_changes_11 = dirty => ({});
const get_before_title_slot_context_11 = ctx => ({});
const get_footer_slot_changes_10 = dirty => ({});
const get_footer_slot_context_10 = ctx => ({});
const get_inner_slot_changes_10 = dirty => ({});
const get_inner_slot_context_10 = ctx => ({});
const get_text_slot_changes_5 = dirty => ({});
const get_text_slot_context_5 = ctx => ({});
const get_subtitle_slot_changes_5 = dirty => ({});
const get_subtitle_slot_context_5 = ctx => ({});
const get_after_end_slot_changes_10 = dirty => ({});
const get_after_end_slot_context_10 = ctx => ({});
const get_after_slot_changes_10 = dirty => ({});
const get_after_slot_context_10 = ctx => ({});
const get_after_start_slot_changes_10 = dirty => ({});
const get_after_start_slot_context_10 = ctx => ({});
const get_after_title_slot_changes_10 = dirty => ({});
const get_after_title_slot_context_10 = ctx => ({});
const get_title_slot_changes_10 = dirty => ({});
const get_title_slot_context_10 = ctx => ({});
const get_before_title_slot_changes_10 = dirty => ({});
const get_before_title_slot_context_10 = ctx => ({});
const get_header_slot_changes_10 = dirty => ({});
const get_header_slot_context_10 = ctx => ({});
const get_inner_start_slot_changes_5 = dirty => ({});
const get_inner_start_slot_context_5 = ctx => ({});
const get_media_slot_changes_5 = dirty => ({});
const get_media_slot_context_5 = ctx => ({});
const get_content_start_slot_changes_5 = dirty => ({});
const get_content_start_slot_context_5 = ctx => ({});
const get_content_end_slot_changes_4 = dirty => ({});
const get_content_end_slot_context_4 = ctx => ({});
const get_content_slot_changes_4 = dirty => ({});
const get_content_slot_context_4 = ctx => ({});
const get_inner_end_slot_changes_4 = dirty => ({});
const get_inner_end_slot_context_4 = ctx => ({});
const get_inner_slot_changes_9 = dirty => ({});
const get_inner_slot_context_9 = ctx => ({});
const get_after_end_slot_changes_9 = dirty => ({});
const get_after_end_slot_context_9 = ctx => ({});
const get_after_slot_changes_9 = dirty => ({});
const get_after_slot_context_9 = ctx => ({});
const get_after_start_slot_changes_9 = dirty => ({});
const get_after_start_slot_context_9 = ctx => ({});
const get_after_title_slot_changes_9 = dirty => ({});
const get_after_title_slot_context_9 = ctx => ({});
const get_footer_slot_changes_9 = dirty => ({});
const get_footer_slot_context_9 = ctx => ({});
const get_title_slot_changes_9 = dirty => ({});
const get_title_slot_context_9 = ctx => ({});
const get_header_slot_changes_9 = dirty => ({});
const get_header_slot_context_9 = ctx => ({});
const get_before_title_slot_changes_9 = dirty => ({});
const get_before_title_slot_context_9 = ctx => ({});
const get_footer_slot_changes_8 = dirty => ({});
const get_footer_slot_context_8 = ctx => ({});
const get_inner_slot_changes_8 = dirty => ({});
const get_inner_slot_context_8 = ctx => ({});
const get_text_slot_changes_4 = dirty => ({});
const get_text_slot_context_4 = ctx => ({});
const get_subtitle_slot_changes_4 = dirty => ({});
const get_subtitle_slot_context_4 = ctx => ({});
const get_after_end_slot_changes_8 = dirty => ({});
const get_after_end_slot_context_8 = ctx => ({});
const get_after_slot_changes_8 = dirty => ({});
const get_after_slot_context_8 = ctx => ({});
const get_after_start_slot_changes_8 = dirty => ({});
const get_after_start_slot_context_8 = ctx => ({});
const get_after_title_slot_changes_8 = dirty => ({});
const get_after_title_slot_context_8 = ctx => ({});
const get_title_slot_changes_8 = dirty => ({});
const get_title_slot_context_8 = ctx => ({});
const get_before_title_slot_changes_8 = dirty => ({});
const get_before_title_slot_context_8 = ctx => ({});
const get_header_slot_changes_8 = dirty => ({});
const get_header_slot_context_8 = ctx => ({});
const get_inner_start_slot_changes_4 = dirty => ({});
const get_inner_start_slot_context_4 = ctx => ({});
const get_media_slot_changes_4 = dirty => ({});
const get_media_slot_context_4 = ctx => ({});
const get_content_start_slot_changes_4 = dirty => ({});
const get_content_start_slot_context_4 = ctx => ({});
const get_content_end_slot_changes_3 = dirty => ({});
const get_content_end_slot_context_3 = ctx => ({});
const get_content_slot_changes_3 = dirty => ({});
const get_content_slot_context_3 = ctx => ({});
const get_inner_end_slot_changes_3 = dirty => ({});
const get_inner_end_slot_context_3 = ctx => ({});
const get_inner_slot_changes_7 = dirty => ({});
const get_inner_slot_context_7 = ctx => ({});
const get_after_end_slot_changes_7 = dirty => ({});
const get_after_end_slot_context_7 = ctx => ({});
const get_after_slot_changes_7 = dirty => ({});
const get_after_slot_context_7 = ctx => ({});
const get_after_start_slot_changes_7 = dirty => ({});
const get_after_start_slot_context_7 = ctx => ({});
const get_after_title_slot_changes_7 = dirty => ({});
const get_after_title_slot_context_7 = ctx => ({});
const get_footer_slot_changes_7 = dirty => ({});
const get_footer_slot_context_7 = ctx => ({});
const get_title_slot_changes_7 = dirty => ({});
const get_title_slot_context_7 = ctx => ({});
const get_header_slot_changes_7 = dirty => ({});
const get_header_slot_context_7 = ctx => ({});
const get_before_title_slot_changes_7 = dirty => ({});
const get_before_title_slot_context_7 = ctx => ({});
const get_footer_slot_changes_6 = dirty => ({});
const get_footer_slot_context_6 = ctx => ({});
const get_inner_slot_changes_6 = dirty => ({});
const get_inner_slot_context_6 = ctx => ({});
const get_text_slot_changes_3 = dirty => ({});
const get_text_slot_context_3 = ctx => ({});
const get_subtitle_slot_changes_3 = dirty => ({});
const get_subtitle_slot_context_3 = ctx => ({});
const get_after_end_slot_changes_6 = dirty => ({});
const get_after_end_slot_context_6 = ctx => ({});
const get_after_slot_changes_6 = dirty => ({});
const get_after_slot_context_6 = ctx => ({});
const get_after_start_slot_changes_6 = dirty => ({});
const get_after_start_slot_context_6 = ctx => ({});
const get_after_title_slot_changes_6 = dirty => ({});
const get_after_title_slot_context_6 = ctx => ({});
const get_title_slot_changes_6 = dirty => ({});
const get_title_slot_context_6 = ctx => ({});
const get_before_title_slot_changes_6 = dirty => ({});
const get_before_title_slot_context_6 = ctx => ({});
const get_header_slot_changes_6 = dirty => ({});
const get_header_slot_context_6 = ctx => ({});
const get_inner_start_slot_changes_3 = dirty => ({});
const get_inner_start_slot_context_3 = ctx => ({});
const get_media_slot_changes_3 = dirty => ({});
const get_media_slot_context_3 = ctx => ({});
const get_content_start_slot_changes_3 = dirty => ({});
const get_content_start_slot_context_3 = ctx => ({});
const get_content_end_slot_changes_2 = dirty => ({});
const get_content_end_slot_context_2 = ctx => ({});
const get_content_slot_changes_2 = dirty => ({});
const get_content_slot_context_2 = ctx => ({});
const get_inner_end_slot_changes_2 = dirty => ({});
const get_inner_end_slot_context_2 = ctx => ({});
const get_inner_slot_changes_5 = dirty => ({});
const get_inner_slot_context_5 = ctx => ({});
const get_after_end_slot_changes_5 = dirty => ({});
const get_after_end_slot_context_5 = ctx => ({});
const get_after_slot_changes_5 = dirty => ({});
const get_after_slot_context_5 = ctx => ({});
const get_after_start_slot_changes_5 = dirty => ({});
const get_after_start_slot_context_5 = ctx => ({});
const get_after_title_slot_changes_5 = dirty => ({});
const get_after_title_slot_context_5 = ctx => ({});
const get_footer_slot_changes_5 = dirty => ({});
const get_footer_slot_context_5 = ctx => ({});
const get_title_slot_changes_5 = dirty => ({});
const get_title_slot_context_5 = ctx => ({});
const get_header_slot_changes_5 = dirty => ({});
const get_header_slot_context_5 = ctx => ({});
const get_before_title_slot_changes_5 = dirty => ({});
const get_before_title_slot_context_5 = ctx => ({});
const get_footer_slot_changes_4 = dirty => ({});
const get_footer_slot_context_4 = ctx => ({});
const get_inner_slot_changes_4 = dirty => ({});
const get_inner_slot_context_4 = ctx => ({});
const get_text_slot_changes_2 = dirty => ({});
const get_text_slot_context_2 = ctx => ({});
const get_subtitle_slot_changes_2 = dirty => ({});
const get_subtitle_slot_context_2 = ctx => ({});
const get_after_end_slot_changes_4 = dirty => ({});
const get_after_end_slot_context_4 = ctx => ({});
const get_after_slot_changes_4 = dirty => ({});
const get_after_slot_context_4 = ctx => ({});
const get_after_start_slot_changes_4 = dirty => ({});
const get_after_start_slot_context_4 = ctx => ({});
const get_after_title_slot_changes_4 = dirty => ({});
const get_after_title_slot_context_4 = ctx => ({});
const get_title_slot_changes_4 = dirty => ({});
const get_title_slot_context_4 = ctx => ({});
const get_before_title_slot_changes_4 = dirty => ({});
const get_before_title_slot_context_4 = ctx => ({});
const get_header_slot_changes_4 = dirty => ({});
const get_header_slot_context_4 = ctx => ({});
const get_inner_start_slot_changes_2 = dirty => ({});
const get_inner_start_slot_context_2 = ctx => ({});
const get_media_slot_changes_2 = dirty => ({});
const get_media_slot_context_2 = ctx => ({});
const get_content_start_slot_changes_2 = dirty => ({});
const get_content_start_slot_context_2 = ctx => ({});
const get_content_end_slot_changes_1$1 = dirty => ({});
const get_content_end_slot_context_1$1 = ctx => ({});
const get_content_slot_changes_1$1 = dirty => ({});
const get_content_slot_context_1$1 = ctx => ({});
const get_inner_end_slot_changes_1$1 = dirty => ({});
const get_inner_end_slot_context_1$1 = ctx => ({});
const get_inner_slot_changes_3 = dirty => ({});
const get_inner_slot_context_3 = ctx => ({});
const get_after_end_slot_changes_3 = dirty => ({});
const get_after_end_slot_context_3 = ctx => ({});
const get_after_slot_changes_3 = dirty => ({});
const get_after_slot_context_3 = ctx => ({});
const get_after_start_slot_changes_3 = dirty => ({});
const get_after_start_slot_context_3 = ctx => ({});
const get_after_title_slot_changes_3 = dirty => ({});
const get_after_title_slot_context_3 = ctx => ({});
const get_footer_slot_changes_3 = dirty => ({});
const get_footer_slot_context_3 = ctx => ({});
const get_title_slot_changes_3 = dirty => ({});
const get_title_slot_context_3 = ctx => ({});
const get_header_slot_changes_3 = dirty => ({});
const get_header_slot_context_3 = ctx => ({});
const get_before_title_slot_changes_3 = dirty => ({});
const get_before_title_slot_context_3 = ctx => ({});
const get_footer_slot_changes_2 = dirty => ({});
const get_footer_slot_context_2 = ctx => ({});
const get_inner_slot_changes_2 = dirty => ({});
const get_inner_slot_context_2 = ctx => ({});
const get_text_slot_changes_1 = dirty => ({});
const get_text_slot_context_1 = ctx => ({});
const get_subtitle_slot_changes_1 = dirty => ({});
const get_subtitle_slot_context_1 = ctx => ({});
const get_after_end_slot_changes_2 = dirty => ({});
const get_after_end_slot_context_2 = ctx => ({});
const get_after_slot_changes_2 = dirty => ({});
const get_after_slot_context_2 = ctx => ({});
const get_after_start_slot_changes_2 = dirty => ({});
const get_after_start_slot_context_2 = ctx => ({});
const get_after_title_slot_changes_2 = dirty => ({});
const get_after_title_slot_context_2 = ctx => ({});
const get_title_slot_changes_2 = dirty => ({});
const get_title_slot_context_2 = ctx => ({});
const get_before_title_slot_changes_2 = dirty => ({});
const get_before_title_slot_context_2 = ctx => ({});
const get_header_slot_changes_2 = dirty => ({});
const get_header_slot_context_2 = ctx => ({});
const get_inner_start_slot_changes_1$1 = dirty => ({});
const get_inner_start_slot_context_1$1 = ctx => ({});
const get_media_slot_changes_1$1 = dirty => ({});
const get_media_slot_context_1$1 = ctx => ({});
const get_content_start_slot_changes_1$1 = dirty => ({});
const get_content_start_slot_context_1$1 = ctx => ({});
const get_content_end_slot_changes$1 = dirty => ({});
const get_content_end_slot_context$1 = ctx => ({});
const get_content_slot_changes$2 = dirty => ({});
const get_content_slot_context$2 = ctx => ({});
const get_inner_end_slot_changes$1 = dirty => ({});
const get_inner_end_slot_context$1 = ctx => ({});
const get_inner_slot_changes_1$1 = dirty => ({});
const get_inner_slot_context_1$1 = ctx => ({});
const get_after_end_slot_changes_1 = dirty => ({});
const get_after_end_slot_context_1 = ctx => ({});
const get_after_slot_changes_1 = dirty => ({});
const get_after_slot_context_1 = ctx => ({});
const get_after_start_slot_changes_1 = dirty => ({});
const get_after_start_slot_context_1 = ctx => ({});
const get_after_title_slot_changes_1 = dirty => ({});
const get_after_title_slot_context_1 = ctx => ({});
const get_footer_slot_changes_1 = dirty => ({});
const get_footer_slot_context_1 = ctx => ({});
const get_title_slot_changes_1 = dirty => ({});
const get_title_slot_context_1 = ctx => ({});
const get_header_slot_changes_1 = dirty => ({});
const get_header_slot_context_1 = ctx => ({});
const get_before_title_slot_changes_1 = dirty => ({});
const get_before_title_slot_context_1 = ctx => ({});
const get_footer_slot_changes$1 = dirty => ({});
const get_footer_slot_context$1 = ctx => ({});
const get_inner_slot_changes$1 = dirty => ({});
const get_inner_slot_context$1 = ctx => ({});
const get_text_slot_changes$2 = dirty => ({});
const get_text_slot_context$2 = ctx => ({});
const get_subtitle_slot_changes = dirty => ({});
const get_subtitle_slot_context = ctx => ({});
const get_after_end_slot_changes = dirty => ({});
const get_after_end_slot_context = ctx => ({});
const get_after_slot_changes = dirty => ({});
const get_after_slot_context = ctx => ({});
const get_after_start_slot_changes = dirty => ({});
const get_after_start_slot_context = ctx => ({});
const get_after_title_slot_changes = dirty => ({});
const get_after_title_slot_context = ctx => ({});
const get_title_slot_changes = dirty => ({});
const get_title_slot_context = ctx => ({});
const get_before_title_slot_changes = dirty => ({});
const get_before_title_slot_context = ctx => ({});
const get_header_slot_changes$1 = dirty => ({});
const get_header_slot_context$1 = ctx => ({});
const get_inner_start_slot_changes$1 = dirty => ({});
const get_inner_start_slot_context$1 = ctx => ({});
const get_media_slot_changes$3 = dirty => ({});
const get_media_slot_context$3 = ctx => ({});
const get_content_start_slot_changes$1 = dirty => ({});
const get_content_start_slot_context$1 = ctx => ({});
const get_root_start_slot_changes$2 = dirty => ({});
const get_root_start_slot_context$2 = ctx => ({});

// (370:0) {:else}
function create_else_block$4(ctx) {
	let li;
	let t0;
	let current_block_type_index;
	let if_block0;
	let t1;
	let t2;
	let t3;
	let t4;
	let current;
	const root_start_slot_template = /*#slots*/ ctx[66]["root-start"];
	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[80], get_root_start_slot_context$2);
	const if_block_creators = [create_if_block_4$4, create_if_block_67, create_else_block_7];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*swipeout*/ ctx[11]) return 0;
		if (/*isLink*/ ctx[35]) return 1;
		return 2;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && !/*isSortableOpposite*/ ctx[29] && create_if_block_3$7(ctx);
	let if_block2 = (/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_2$8(ctx);
	const root_slot_template = /*#slots*/ ctx[66].root;
	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[80], get_root_slot_context$3);
	const root_end_slot_template = /*#slots*/ ctx[66]["root-end"];
	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[80], get_root_end_slot_context$2);

	let li_levels = [
		{ class: /*liClasses*/ ctx[31] },
		{
			"data-virtual-list-index": /*virtualListIndex*/ ctx[22]
		},
		restProps(/*$$restProps*/ ctx[45])
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			if (root_start_slot) root_start_slot.c();
			t0 = space();
			if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			if (root_slot) root_slot.c();
			t4 = space();
			if (root_end_slot) root_end_slot.c();
			set_attributes(li, li_data);
			add_location(li, file$F, 370, 2, 12202);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);

			if (root_start_slot) {
				root_start_slot.m(li, null);
			}

			append_dev(li, t0);
			if_blocks[current_block_type_index].m(li, null);
			append_dev(li, t1);
			if (if_block1) if_block1.m(li, null);
			append_dev(li, t2);
			if (if_block2) if_block2.m(li, null);
			append_dev(li, t3);

			if (root_slot) {
				root_slot.m(li, null);
			}

			append_dev(li, t4);

			if (root_end_slot) {
				root_end_slot.m(li, null);
			}

			/*li_binding_2*/ ctx[79](li);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (root_start_slot) {
				if (root_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(root_start_slot, root_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_root_start_slot_changes$2, get_root_start_slot_context$2);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(li, t1);
			}

			if (/*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && !/*isSortableOpposite*/ ctx[29]) {
				if (if_block1) ; else {
					if_block1 = create_if_block_3$7(ctx);
					if_block1.c();
					if_block1.m(li, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_2$8(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(li, t3);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (root_slot) {
				if (root_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(root_slot, root_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_root_slot_changes$3, get_root_slot_context$3);
				}
			}

			if (root_end_slot) {
				if (root_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(root_end_slot, root_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_root_end_slot_changes$2, get_root_end_slot_context$2);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty[1] & /*liClasses*/ 1) && { class: /*liClasses*/ ctx[31] },
				(!current || dirty[0] & /*virtualListIndex*/ 4194304) && {
					"data-virtual-list-index": /*virtualListIndex*/ ctx[22]
				},
				dirty[1] & /*$$restProps*/ 16384 && restProps(/*$$restProps*/ ctx[45])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(root_start_slot, local);
			transition_in(if_block0);
			transition_in(if_block2);
			transition_in(root_slot, local);
			transition_in(root_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(root_start_slot, local);
			transition_out(if_block0);
			transition_out(if_block2);
			transition_out(root_slot, local);
			transition_out(root_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (root_start_slot) root_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (root_slot) root_slot.d(detaching);
			if (root_end_slot) root_end_slot.d(detaching);
			/*li_binding_2*/ ctx[79](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$4.name,
		type: "else",
		source: "(370:0) {:else}",
		ctx
	});

	return block;
}

// (365:19) 
function create_if_block_1$8(ctx) {
	let li;
	let t0_value = Utils.text(/*title*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	let li_levels = [
		{ class: /*liClasses*/ ctx[31] },
		{
			"data-virtual-list-index": /*virtualListIndex*/ ctx[22]
		},
		restProps(/*$$restProps*/ ctx[45])
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			t0 = text(t0_value);
			t1 = space();
			if (default_slot) default_slot.c();
			set_attributes(li, li_data);
			add_location(li, file$F, 365, 2, 12017);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, t0);
			append_dev(li, t1);

			if (default_slot) {
				default_slot.m(li, null);
			}

			/*li_binding_1*/ ctx[68](li);
			current = true;

			if (!mounted) {
				dispose = listen_dev(li, "click", /*onClick*/ ctx[43], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = Utils.text(/*title*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty[1] & /*liClasses*/ 1) && { class: /*liClasses*/ ctx[31] },
				(!current || dirty[0] & /*virtualListIndex*/ 4194304) && {
					"data-virtual-list-index": /*virtualListIndex*/ ctx[22]
				},
				dirty[1] & /*$$restProps*/ 16384 && restProps(/*$$restProps*/ ctx[45])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (default_slot) default_slot.d(detaching);
			/*li_binding_1*/ ctx[68](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$8.name,
		type: "if",
		source: "(365:19) ",
		ctx
	});

	return block;
}

// (361:0) {#if (divider || groupTitle)}
function create_if_block$d(ctx) {
	let li;
	let span;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);
	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

	let li_levels = [
		{ class: /*liClasses*/ ctx[31] },
		{
			"data-virtual-list-index": /*virtualListIndex*/ ctx[22]
		},
		restProps(/*$$restProps*/ ctx[45])
	];

	let li_data = {};

	for (let i = 0; i < li_levels.length; i += 1) {
		li_data = assign(li_data, li_levels[i]);
	}

	const block = {
		c: function create() {
			li = element("li");
			span = element("span");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			add_location(span, file$F, 362, 4, 11941);
			set_attributes(li, li_data);
			add_location(li, file$F, 361, 2, 11807);
		},
		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, span);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(span, null);
			}

			/*li_binding*/ ctx[67](li);
			current = true;

			if (!mounted) {
				dispose = listen_dev(li, "click", /*onClick*/ ctx[43], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty[0] & /*title*/ 1) {
					default_slot_or_fallback.p(ctx, dirty);
				}
			}

			set_attributes(li, li_data = get_spread_update(li_levels, [
				(!current || dirty[1] & /*liClasses*/ 1) && { class: /*liClasses*/ ctx[31] },
				(!current || dirty[0] & /*virtualListIndex*/ 4194304) && {
					"data-virtual-list-index": /*virtualListIndex*/ ctx[22]
				},
				dirty[1] & /*$$restProps*/ 16384 && restProps(/*$$restProps*/ ctx[45])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			/*li_binding*/ ctx[67](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$d.name,
		type: "if",
		source: "(361:0) {#if (divider || groupTitle)}",
		ctx
	});

	return block;
}

// (850:6) {:else}
function create_else_block_7(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_88, create_else_block_9];
	const if_blocks = [];

	function select_block_type_8(ctx, dirty) {
		if (/*checkbox*/ ctx[14] || /*radio*/ ctx[15]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_8(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_8(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_7.name,
		type: "else",
		source: "(850:6) {:else}",
		ctx
	});

	return block;
}

// (734:6) {#if isLink}
function create_if_block_67(ctx) {
	let a;
	let div1;
	let t0;
	let t1;
	let t2;
	let div0;
	let t3;
	let current_block_type_index;
	let if_block2;
	let t4;
	let t5;
	let t6;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*#slots*/ ctx[66]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[80], get_content_start_slot_context_3);
	let if_block0 = /*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29] && create_if_block_87(ctx);
	let if_block1 = /*hasMedia*/ ctx[36] && create_if_block_85(ctx);
	const inner_start_slot_template = /*#slots*/ ctx[66]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_start_slot_context_3);
	const if_block_creators = [create_if_block_68, create_else_block_6];
	const if_blocks = [];

	function select_block_type_7(ctx, dirty) {
		if (/*isMedia*/ ctx[23]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_7(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*#slots*/ ctx[66]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_end_slot_context_3);
	const content_slot_template = /*#slots*/ ctx[66].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[80], get_content_slot_context_3);
	const content_end_slot_template = /*#slots*/ ctx[66]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[80], get_content_end_slot_context_3);
	let a_levels = [{ class: /*linkClasses*/ ctx[33] }, /*linkAttrs*/ ctx[34]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div0 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t3 = space();
			if_block2.c();
			t4 = space();
			if (inner_end_slot) inner_end_slot.c();
			t5 = space();
			if (content_slot) content_slot.c();
			t6 = space();
			if (content_end_slot) content_end_slot.c();
			attr_dev(div0, "class", "item-inner");
			add_location(div0, file$F, 749, 12, 27154);
			attr_dev(div1, "class", /*contentClasses*/ ctx[32]);
			add_location(div1, file$F, 736, 10, 26679);
			set_attributes(a, a_data);
			add_location(a, file$F, 734, 8, 26554);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, div1);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_dev(div1, t0);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t2);
			append_dev(div1, div0);

			if (inner_start_slot) {
				inner_start_slot.m(div0, null);
			}

			append_dev(div0, t3);
			if_blocks[current_block_type_index].m(div0, null);
			append_dev(div0, t4);

			if (inner_end_slot) {
				inner_end_slot.m(div0, null);
			}

			/*div0_binding_2*/ ctx[74](div0);
			append_dev(div1, t5);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			append_dev(div1, t6);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			/*a_binding_1*/ ctx[75](a);
			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[43], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_start_slot_changes_3, get_content_start_slot_context_3);
				}
			}

			if (/*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_87(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*hasMedia*/ ctx[36]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_85(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_start_slot_changes_3, get_inner_start_slot_context_3);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_7(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(div0, t4);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_end_slot_changes_3, get_inner_end_slot_context_3);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_slot_changes_3, get_content_slot_context_3);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_end_slot_changes_3, get_content_end_slot_context_3);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2) {
				attr_dev(div1, "class", /*contentClasses*/ ctx[32]);
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty[1] & /*linkClasses*/ 4) && { class: /*linkClasses*/ ctx[33] },
				dirty[1] & /*linkAttrs*/ 8 && /*linkAttrs*/ ctx[34]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div0_binding_2*/ ctx[74](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			/*a_binding_1*/ ctx[75](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_67.name,
		type: "if",
		source: "(734:6) {#if isLink}",
		ctx
	});

	return block;
}

// (373:4) {#if swipeout}
function create_if_block_4$4(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block_5$2, create_else_block_2$1];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*isLink*/ ctx[35]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			attr_dev(div, "class", "swipeout-content");
			add_location(div, file$F, 373, 6, 12367);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$4.name,
		type: "if",
		source: "(373:4) {#if swipeout}",
		ctx
	});

	return block;
}

// (976:8) {:else}
function create_else_block_9(ctx) {
	let div1;
	let t0;
	let t1;
	let t2;
	let div0;
	let t3;
	let current_block_type_index;
	let if_block2;
	let t4;
	let t5;
	let t6;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*#slots*/ ctx[66]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[80], get_content_start_slot_context_5);
	let if_block0 = /*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29] && create_if_block_128(ctx);
	let if_block1 = /*hasMedia*/ ctx[36] && create_if_block_126(ctx);
	const inner_start_slot_template = /*#slots*/ ctx[66]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_start_slot_context_5);
	const if_block_creators = [create_if_block_109, create_else_block_10];
	const if_blocks = [];

	function select_block_type_10(ctx, dirty) {
		if (/*isMedia*/ ctx[23]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_10(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*#slots*/ ctx[66]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_end_slot_context_5);
	const content_slot_template = /*#slots*/ ctx[66].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[80], get_content_slot_context_5);
	const content_end_slot_template = /*#slots*/ ctx[66]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[80], get_content_end_slot_context_5);

	const block = {
		c: function create() {
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div0 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t3 = space();
			if_block2.c();
			t4 = space();
			if (inner_end_slot) inner_end_slot.c();
			t5 = space();
			if (content_slot) content_slot.c();
			t6 = space();
			if (content_end_slot) content_end_slot.c();
			attr_dev(div0, "class", "item-inner");
			add_location(div0, file$F, 989, 12, 36158);
			attr_dev(div1, "class", /*contentClasses*/ ctx[32]);
			add_location(div1, file$F, 976, 10, 35664);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_dev(div1, t0);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t2);
			append_dev(div1, div0);

			if (inner_start_slot) {
				inner_start_slot.m(div0, null);
			}

			append_dev(div0, t3);
			if_blocks[current_block_type_index].m(div0, null);
			append_dev(div0, t4);

			if (inner_end_slot) {
				inner_end_slot.m(div0, null);
			}

			/*div0_binding_3*/ ctx[78](div0);
			append_dev(div1, t5);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			append_dev(div1, t6);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div1, "click", /*onClick*/ ctx[43], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_start_slot_changes_5, get_content_start_slot_context_5);
				}
			}

			if (/*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_128(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*hasMedia*/ ctx[36]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_126(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_start_slot_changes_5, get_inner_start_slot_context_5);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_10(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(div0, t4);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_end_slot_changes_5, get_inner_end_slot_context_5);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_slot_changes_5, get_content_slot_context_5);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_end_slot_changes_5, get_content_end_slot_context_5);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2) {
				attr_dev(div1, "class", /*contentClasses*/ ctx[32]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div0_binding_3*/ ctx[78](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_9.name,
		type: "else",
		source: "(976:8) {:else}",
		ctx
	});

	return block;
}

// (852:8) {#if checkbox || radio}
function create_if_block_88(ctx) {
	let label;
	let t0;
	let t1;
	let input;
	let input_value_value;
	let input_type_value;
	let t2;
	let i;
	let i_class_value;
	let t3;
	let t4;
	let div;
	let t5;
	let current_block_type_index;
	let if_block2;
	let t6;
	let t7;
	let t8;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*#slots*/ ctx[66]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[80], get_content_start_slot_context_4);
	let if_block0 = /*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29] && create_if_block_108(ctx);
	let if_block1 = /*hasMedia*/ ctx[36] && create_if_block_106(ctx);
	const inner_start_slot_template = /*#slots*/ ctx[66]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_start_slot_context_4);
	const if_block_creators = [create_if_block_89, create_else_block_8];
	const if_blocks = [];

	function select_block_type_9(ctx, dirty) {
		if (/*isMedia*/ ctx[23]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_9(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*#slots*/ ctx[66]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_end_slot_context_4);
	const content_slot_template = /*#slots*/ ctx[66].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[80], get_content_slot_context_4);
	const content_end_slot_template = /*#slots*/ ctx[66]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[80], get_content_end_slot_context_4);

	const block = {
		c: function create() {
			label = element("label");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			input = element("input");
			t2 = space();
			i = element("i");
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			div = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t5 = space();
			if_block2.c();
			t6 = space();
			if (inner_end_slot) inner_end_slot.c();
			t7 = space();
			if (content_slot) content_slot.c();
			t8 = space();
			if (content_end_slot) content_end_slot.c();

			input.value = input_value_value = typeof /*value*/ ctx[18] === "undefined"
			? ""
			: /*value*/ ctx[18];

			attr_dev(input, "name", /*name*/ ctx[17]);
			input.checked = /*checked*/ ctx[16];
			input.readOnly = /*readonly*/ ctx[19];
			input.disabled = /*disabled*/ ctx[21];
			input.required = /*required*/ ctx[20];
			attr_dev(input, "type", input_type_value = /*radio*/ ctx[15] ? "radio" : "checkbox");
			add_location(input, file$F, 857, 12, 31236);
			attr_dev(i, "class", i_class_value = `icon icon-${/*radio*/ ctx[15] ? "radio" : "checkbox"}`);
			add_location(i, file$F, 868, 12, 31613);
			attr_dev(div, "class", "item-inner");
			add_location(div, file$F, 877, 12, 31937);
			attr_dev(label, "class", /*contentClasses*/ ctx[32]);
			add_location(label, file$F, 852, 10, 30994);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);

			if (content_start_slot) {
				content_start_slot.m(label, null);
			}

			append_dev(label, t0);
			if (if_block0) if_block0.m(label, null);
			append_dev(label, t1);
			append_dev(label, input);
			/*input_binding_1*/ ctx[76](input);
			append_dev(label, t2);
			append_dev(label, i);
			append_dev(label, t3);
			if (if_block1) if_block1.m(label, null);
			append_dev(label, t4);
			append_dev(label, div);

			if (inner_start_slot) {
				inner_start_slot.m(div, null);
			}

			append_dev(div, t5);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t6);

			if (inner_end_slot) {
				inner_end_slot.m(div, null);
			}

			/*div_binding_1*/ ctx[77](div);
			append_dev(label, t7);

			if (content_slot) {
				content_slot.m(label, null);
			}

			append_dev(label, t8);

			if (content_end_slot) {
				content_end_slot.m(label, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*onChange*/ ctx[44], false, false, false),
					listen_dev(label, "click", /*onClick*/ ctx[43], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_start_slot_changes_4, get_content_start_slot_context_4);
				}
			}

			if (/*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_108(ctx);
					if_block0.c();
					if_block0.m(label, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!current || dirty[0] & /*value*/ 262144 && input_value_value !== (input_value_value = typeof /*value*/ ctx[18] === "undefined"
			? ""
			: /*value*/ ctx[18]) && input.value !== input_value_value) {
				prop_dev(input, "value", input_value_value);
			}

			if (!current || dirty[0] & /*name*/ 131072) {
				attr_dev(input, "name", /*name*/ ctx[17]);
			}

			if (!current || dirty[0] & /*checked*/ 65536) {
				prop_dev(input, "checked", /*checked*/ ctx[16]);
			}

			if (!current || dirty[0] & /*readonly*/ 524288) {
				prop_dev(input, "readOnly", /*readonly*/ ctx[19]);
			}

			if (!current || dirty[0] & /*disabled*/ 2097152) {
				prop_dev(input, "disabled", /*disabled*/ ctx[21]);
			}

			if (!current || dirty[0] & /*required*/ 1048576) {
				prop_dev(input, "required", /*required*/ ctx[20]);
			}

			if (!current || dirty[0] & /*radio*/ 32768 && input_type_value !== (input_type_value = /*radio*/ ctx[15] ? "radio" : "checkbox")) {
				attr_dev(input, "type", input_type_value);
			}

			if (!current || dirty[0] & /*radio*/ 32768 && i_class_value !== (i_class_value = `icon icon-${/*radio*/ ctx[15] ? "radio" : "checkbox"}`)) {
				attr_dev(i, "class", i_class_value);
			}

			if (/*hasMedia*/ ctx[36]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_106(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(label, t4);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_start_slot_changes_4, get_inner_start_slot_context_4);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_9(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(div, t6);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_end_slot_changes_4, get_inner_end_slot_context_4);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_slot_changes_4, get_content_slot_context_4);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_end_slot_changes_4, get_content_end_slot_context_4);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2) {
				attr_dev(label, "class", /*contentClasses*/ ctx[32]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			/*input_binding_1*/ ctx[76](null);
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div_binding_1*/ ctx[77](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_88.name,
		type: "if",
		source: "(852:8) {#if checkbox || radio}",
		ctx
	});

	return block;
}

// (979:12) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_128(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$F, 979, 14, 35841);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_128.name,
		type: "if",
		source: "(979:12) {#if isSortable && sortable !== false && isSortableOpposite}",
		ctx
	});

	return block;
}

// (982:12) {#if hasMedia}
function create_if_block_126(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[2] !== "undefined" && create_if_block_127(ctx);
	const media_slot_template = /*#slots*/ ctx[66].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[80], get_media_slot_context_5);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "item-media");
			add_location(div, file$F, 982, 14, 35933);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*media*/ ctx[2] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_127(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_media_slot_changes_5, get_media_slot_context_5);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_126.name,
		type: "if",
		source: "(982:12) {#if hasMedia}",
		ctx
	});

	return block;
}

// (984:16) {#if typeof media !== 'undefined'}
function create_if_block_127(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*media*/ ctx[2])) attr_dev(img, "src", img_src_value);
			add_location(img, file$F, 984, 18, 36027);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 4 && img.src !== (img_src_value = /*media*/ ctx[2])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_127.name,
		type: "if",
		source: "(984:16) {#if typeof media !== 'undefined'}",
		ctx
	});

	return block;
}

// (1044:14) {:else}
function create_else_block_10(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*#slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_11);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) && create_if_block_123(ctx);
	const after_title_slot_template = /*#slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_11);
	let if_block1 = /*hasAfter*/ ctx[42] && create_if_block_120(ctx);
	const inner_slot_template = /*#slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_11);
	let if_block2 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_119(ctx);

	const block = {
		c: function create() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_dev(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, if_block2_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_11, get_before_title_slot_context_11);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 448) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_123(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_11, get_after_title_slot_context_11);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_120(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_11, get_inner_slot_context_11);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_119(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach_dev(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_10.name,
		type: "else",
		source: "(1044:14) {:else}",
		ctx
	});

	return block;
}

// (992:14) {#if isMedia}
function create_if_block_109(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_118(ctx);
	const before_title_slot_template = /*#slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_10);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_117(ctx);
	const after_title_slot_template = /*#slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_10);
	let if_block2 = /*hasAfter*/ ctx[42] && create_if_block_114(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[40] && create_if_block_113(ctx);
	let if_block4 = /*hasText*/ ctx[41] && create_if_block_112(ctx);
	const inner_slot_template = /*#slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_10);
	let if_block5 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_111(ctx);
	let if_block6 = /*hasFooter*/ ctx[39] && create_if_block_110(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty();
			attr_dev(div, "class", "item-title-row");
			add_location(div, file$F, 998, 16, 36496);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_dev(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_dev(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_dev(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_dev(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_dev(target, if_block6_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_118(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_10, get_before_title_slot_context_10);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_117(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_10, get_after_title_slot_context_10);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_114(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[40]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 512) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_113(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[41]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 1024) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_112(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_10, get_inner_slot_context_10);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_111(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_110(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach_dev(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach_dev(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach_dev(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach_dev(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach_dev(if_block6_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_109.name,
		type: "if",
		source: "(992:14) {#if isMedia}",
		ctx
	});

	return block;
}

// (1046:16) {#if (hasTitle || hasHeader || hasFooter)}
function create_if_block_123(ctx) {
	let div;
	let t0;
	let t1_value = Utils.text(/*title*/ ctx[0]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_125(ctx);
	const title_slot_template = /*#slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_11);
	let if_block1 = /*hasFooter*/ ctx[39] && create_if_block_124(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$F, 1046, 18, 38337);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_125(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 1) && t1_value !== (t1_value = Utils.text(/*title*/ ctx[0]) + "")) set_data_dev(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_11, get_title_slot_context_11);
				}
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_124(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_123.name,
		type: "if",
		source: "(1046:16) {#if (hasTitle || hasHeader || hasFooter)}",
		ctx
	});

	return block;
}

// (1048:20) {#if hasHeader}
function create_if_block_125(ctx) {
	let div;
	let t0_value = Utils.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_11);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$F, 1048, 22, 38420);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_11, get_header_slot_context_11);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_125.name,
		type: "if",
		source: "(1048:20) {#if hasHeader}",
		ctx
	});

	return block;
}

// (1056:20) {#if hasFooter}
function create_if_block_124(ctx) {
	let div;
	let t0_value = Utils.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_11);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$F, 1056, 22, 38733);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_11, get_footer_slot_context_11);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_124.name,
		type: "if",
		source: "(1056:20) {#if hasFooter}",
		ctx
	});

	return block;
}

// (1065:16) {#if hasAfter}
function create_if_block_120(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_11);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_122(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_121(ctx);
	const after_slot_template = /*#slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_11);
	const after_end_slot_template = /*#slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_11);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$F, 1065, 18, 39046);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_11, get_after_start_slot_context_11);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_122(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_121(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_11, get_after_slot_context_11);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_11, get_after_end_slot_context_11);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_120.name,
		type: "if",
		source: "(1065:16) {#if hasAfter}",
		ctx
	});

	return block;
}

// (1068:20) {#if typeof after !== 'undefined'}
function create_if_block_122(ctx) {
	let span;
	let t_value = Utils.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file$F, 1068, 22, 39196);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_122.name,
		type: "if",
		source: "(1068:20) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (1071:20) {#if typeof badge !== 'undefined'}
function create_if_block_121(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_11] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_121.name,
		type: "if",
		source: "(1071:20) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (1072:22) <Badge color={badgeColor}>
function create_default_slot_11(ctx) {
	let t_value = Utils.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_11.name,
		type: "slot",
		source: "(1072:22) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (1079:16) {#if !(swipeout || accordionItem)}
function create_if_block_119(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_119.name,
		type: "if",
		source: "(1079:16) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (993:16) {#if hasHeader}
function create_if_block_118(ctx) {
	let div;
	let t0_value = Utils.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_10);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$F, 993, 18, 36323);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_10, get_header_slot_context_10);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_118.name,
		type: "if",
		source: "(993:16) {#if hasHeader}",
		ctx
	});

	return block;
}

// (1001:18) {#if (hasTitle)}
function create_if_block_117(ctx) {
	let div;
	let t0_value = Utils.text(/*title*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*#slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_10);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$F, 1001, 20, 36627);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = Utils.text(/*title*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_10, get_title_slot_context_10);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (title_slot) title_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_117.name,
		type: "if",
		source: "(1001:18) {#if (hasTitle)}",
		ctx
	});

	return block;
}

// (1008:18) {#if hasAfter}
function create_if_block_114(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_10);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_116(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_115(ctx);
	const after_slot_template = /*#slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_10);
	const after_end_slot_template = /*#slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_10);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$F, 1008, 20, 36888);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_10, get_after_start_slot_context_10);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_116(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_115(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_10, get_after_slot_context_10);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_10, get_after_end_slot_context_10);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_114.name,
		type: "if",
		source: "(1008:18) {#if hasAfter}",
		ctx
	});

	return block;
}

// (1011:22) {#if typeof after !== 'undefined'}
function create_if_block_116(ctx) {
	let span;
	let t_value = Utils.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file$F, 1011, 24, 37044);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_116.name,
		type: "if",
		source: "(1011:22) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (1014:22) {#if typeof badge !== 'undefined'}
function create_if_block_115(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_115.name,
		type: "if",
		source: "(1014:22) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (1015:24) <Badge color={badgeColor}>
function create_default_slot_10(ctx) {
	let t_value = Utils.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10.name,
		type: "slot",
		source: "(1015:24) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (1022:16) {#if hasSubtitle}
function create_if_block_113(ctx) {
	let div;
	let t0_value = Utils.text(/*subtitle*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*#slots*/ ctx[66].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[80], get_subtitle_slot_context_5);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			attr_dev(div, "class", "item-subtitle");
			add_location(div, file$F, 1022, 18, 37486);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 8) && t0_value !== (t0_value = Utils.text(/*subtitle*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(subtitle_slot, subtitle_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_subtitle_slot_changes_5, get_subtitle_slot_context_5);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_113.name,
		type: "if",
		source: "(1022:16) {#if hasSubtitle}",
		ctx
	});

	return block;
}

// (1028:16) {#if hasText}
function create_if_block_112(ctx) {
	let div;
	let t0_value = Utils.text(/*text*/ ctx[1]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*#slots*/ ctx[66].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[80], get_text_slot_context_5);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			attr_dev(div, "class", "item-text");
			add_location(div, file$F, 1028, 18, 37697);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 2) && t0_value !== (t0_value = Utils.text(/*text*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_text_slot_changes_5, get_text_slot_context_5);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (text_slot) text_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_112.name,
		type: "if",
		source: "(1028:16) {#if hasText}",
		ctx
	});

	return block;
}

// (1035:16) {#if !(swipeout || accordionItem)}
function create_if_block_111(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_111.name,
		type: "if",
		source: "(1035:16) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (1038:16) {#if hasFooter}
function create_if_block_110(ctx) {
	let div;
	let t0_value = Utils.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_10);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$F, 1038, 18, 38036);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_10, get_footer_slot_context_10);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_110.name,
		type: "if",
		source: "(1038:16) {#if hasFooter}",
		ctx
	});

	return block;
}

// (855:12) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_108(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$F, 855, 14, 31173);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_108.name,
		type: "if",
		source: "(855:12) {#if isSortable && sortable !== false && isSortableOpposite}",
		ctx
	});

	return block;
}

// (870:12) {#if hasMedia}
function create_if_block_106(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[2] !== "undefined" && create_if_block_107(ctx);
	const media_slot_template = /*#slots*/ ctx[66].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[80], get_media_slot_context_4);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "item-media");
			add_location(div, file$F, 870, 14, 31712);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*media*/ ctx[2] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_107(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_media_slot_changes_4, get_media_slot_context_4);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_106.name,
		type: "if",
		source: "(870:12) {#if hasMedia}",
		ctx
	});

	return block;
}

// (872:16) {#if typeof media !== 'undefined'}
function create_if_block_107(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*media*/ ctx[2])) attr_dev(img, "src", img_src_value);
			add_location(img, file$F, 872, 18, 31806);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 4 && img.src !== (img_src_value = /*media*/ ctx[2])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_107.name,
		type: "if",
		source: "(872:16) {#if typeof media !== 'undefined'}",
		ctx
	});

	return block;
}

// (932:14) {:else}
function create_else_block_8(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*#slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_9);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) && create_if_block_103(ctx);
	const after_title_slot_template = /*#slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_9);
	let if_block1 = /*hasAfter*/ ctx[42] && create_if_block_100(ctx);
	const inner_slot_template = /*#slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_9);
	let if_block2 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_99(ctx);

	const block = {
		c: function create() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_dev(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, if_block2_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_9, get_before_title_slot_context_9);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 448) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_103(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_9, get_after_title_slot_context_9);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_100(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_9, get_inner_slot_context_9);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_99(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach_dev(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_8.name,
		type: "else",
		source: "(932:14) {:else}",
		ctx
	});

	return block;
}

// (880:14) {#if isMedia}
function create_if_block_89(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_98(ctx);
	const before_title_slot_template = /*#slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_8);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_97(ctx);
	const after_title_slot_template = /*#slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_8);
	let if_block2 = /*hasAfter*/ ctx[42] && create_if_block_94(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[40] && create_if_block_93(ctx);
	let if_block4 = /*hasText*/ ctx[41] && create_if_block_92(ctx);
	const inner_slot_template = /*#slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_8);
	let if_block5 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_91(ctx);
	let if_block6 = /*hasFooter*/ ctx[39] && create_if_block_90(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty();
			attr_dev(div, "class", "item-title-row");
			add_location(div, file$F, 886, 16, 32275);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_dev(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_dev(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_dev(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_dev(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_dev(target, if_block6_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_98(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_8, get_before_title_slot_context_8);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_97(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_8, get_after_title_slot_context_8);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_94(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[40]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 512) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_93(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[41]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 1024) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_92(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_8, get_inner_slot_context_8);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_91(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_90(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach_dev(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach_dev(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach_dev(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach_dev(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach_dev(if_block6_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_89.name,
		type: "if",
		source: "(880:14) {#if isMedia}",
		ctx
	});

	return block;
}

// (934:16) {#if (hasTitle || hasHeader || hasFooter)}
function create_if_block_103(ctx) {
	let div;
	let t0;
	let t1_value = Utils.text(/*title*/ ctx[0]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_105(ctx);
	const title_slot_template = /*#slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_9);
	let if_block1 = /*hasFooter*/ ctx[39] && create_if_block_104(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$F, 934, 18, 34116);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_105(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 1) && t1_value !== (t1_value = Utils.text(/*title*/ ctx[0]) + "")) set_data_dev(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_9, get_title_slot_context_9);
				}
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_104(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_103.name,
		type: "if",
		source: "(934:16) {#if (hasTitle || hasHeader || hasFooter)}",
		ctx
	});

	return block;
}

// (936:20) {#if hasHeader}
function create_if_block_105(ctx) {
	let div;
	let t0_value = Utils.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_9);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$F, 936, 22, 34199);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_9, get_header_slot_context_9);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_105.name,
		type: "if",
		source: "(936:20) {#if hasHeader}",
		ctx
	});

	return block;
}

// (944:20) {#if hasFooter}
function create_if_block_104(ctx) {
	let div;
	let t0_value = Utils.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_9);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$F, 944, 22, 34512);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_9, get_footer_slot_context_9);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_104.name,
		type: "if",
		source: "(944:20) {#if hasFooter}",
		ctx
	});

	return block;
}

// (953:16) {#if hasAfter}
function create_if_block_100(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_9);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_102(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_101(ctx);
	const after_slot_template = /*#slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_9);
	const after_end_slot_template = /*#slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_9);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$F, 953, 18, 34825);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_9, get_after_start_slot_context_9);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_102(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_101(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_9, get_after_slot_context_9);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_9, get_after_end_slot_context_9);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_100.name,
		type: "if",
		source: "(953:16) {#if hasAfter}",
		ctx
	});

	return block;
}

// (956:20) {#if typeof after !== 'undefined'}
function create_if_block_102(ctx) {
	let span;
	let t_value = Utils.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file$F, 956, 22, 34975);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_102.name,
		type: "if",
		source: "(956:20) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (959:20) {#if typeof badge !== 'undefined'}
function create_if_block_101(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_101.name,
		type: "if",
		source: "(959:20) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (960:22) <Badge color={badgeColor}>
function create_default_slot_9(ctx) {
	let t_value = Utils.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9.name,
		type: "slot",
		source: "(960:22) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (967:16) {#if !(swipeout || accordionItem)}
function create_if_block_99(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_99.name,
		type: "if",
		source: "(967:16) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (881:16) {#if hasHeader}
function create_if_block_98(ctx) {
	let div;
	let t0_value = Utils.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_8);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$F, 881, 18, 32102);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_8, get_header_slot_context_8);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_98.name,
		type: "if",
		source: "(881:16) {#if hasHeader}",
		ctx
	});

	return block;
}

// (889:18) {#if (hasTitle)}
function create_if_block_97(ctx) {
	let div;
	let t0_value = Utils.text(/*title*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*#slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_8);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$F, 889, 20, 32406);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = Utils.text(/*title*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_8, get_title_slot_context_8);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (title_slot) title_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_97.name,
		type: "if",
		source: "(889:18) {#if (hasTitle)}",
		ctx
	});

	return block;
}

// (896:18) {#if hasAfter}
function create_if_block_94(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_8);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_96(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_95(ctx);
	const after_slot_template = /*#slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_8);
	const after_end_slot_template = /*#slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_8);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$F, 896, 20, 32667);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_8, get_after_start_slot_context_8);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_96(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_95(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_8, get_after_slot_context_8);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_8, get_after_end_slot_context_8);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_94.name,
		type: "if",
		source: "(896:18) {#if hasAfter}",
		ctx
	});

	return block;
}

// (899:22) {#if typeof after !== 'undefined'}
function create_if_block_96(ctx) {
	let span;
	let t_value = Utils.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file$F, 899, 24, 32823);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_96.name,
		type: "if",
		source: "(899:22) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (902:22) {#if typeof badge !== 'undefined'}
function create_if_block_95(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_95.name,
		type: "if",
		source: "(902:22) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (903:24) <Badge color={badgeColor}>
function create_default_slot_8(ctx) {
	let t_value = Utils.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(903:24) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (910:16) {#if hasSubtitle}
function create_if_block_93(ctx) {
	let div;
	let t0_value = Utils.text(/*subtitle*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*#slots*/ ctx[66].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[80], get_subtitle_slot_context_4);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			attr_dev(div, "class", "item-subtitle");
			add_location(div, file$F, 910, 18, 33265);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 8) && t0_value !== (t0_value = Utils.text(/*subtitle*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(subtitle_slot, subtitle_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_subtitle_slot_changes_4, get_subtitle_slot_context_4);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_93.name,
		type: "if",
		source: "(910:16) {#if hasSubtitle}",
		ctx
	});

	return block;
}

// (916:16) {#if hasText}
function create_if_block_92(ctx) {
	let div;
	let t0_value = Utils.text(/*text*/ ctx[1]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*#slots*/ ctx[66].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[80], get_text_slot_context_4);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			attr_dev(div, "class", "item-text");
			add_location(div, file$F, 916, 18, 33476);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 2) && t0_value !== (t0_value = Utils.text(/*text*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_text_slot_changes_4, get_text_slot_context_4);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (text_slot) text_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_92.name,
		type: "if",
		source: "(916:16) {#if hasText}",
		ctx
	});

	return block;
}

// (923:16) {#if !(swipeout || accordionItem)}
function create_if_block_91(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_91.name,
		type: "if",
		source: "(923:16) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (926:16) {#if hasFooter}
function create_if_block_90(ctx) {
	let div;
	let t0_value = Utils.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_8);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$F, 926, 18, 33815);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_8, get_footer_slot_context_8);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_90.name,
		type: "if",
		source: "(926:16) {#if hasFooter}",
		ctx
	});

	return block;
}

// (739:12) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_87(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$F, 739, 14, 26837);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_87.name,
		type: "if",
		source: "(739:12) {#if isSortable && sortable !== false && isSortableOpposite}",
		ctx
	});

	return block;
}

// (742:12) {#if hasMedia}
function create_if_block_85(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[2] !== "undefined" && create_if_block_86(ctx);
	const media_slot_template = /*#slots*/ ctx[66].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[80], get_media_slot_context_3);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "item-media");
			add_location(div, file$F, 742, 14, 26929);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*media*/ ctx[2] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_86(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_media_slot_changes_3, get_media_slot_context_3);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_85.name,
		type: "if",
		source: "(742:12) {#if hasMedia}",
		ctx
	});

	return block;
}

// (744:16) {#if typeof media !== 'undefined'}
function create_if_block_86(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*media*/ ctx[2])) attr_dev(img, "src", img_src_value);
			add_location(img, file$F, 744, 18, 27023);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 4 && img.src !== (img_src_value = /*media*/ ctx[2])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_86.name,
		type: "if",
		source: "(744:16) {#if typeof media !== 'undefined'}",
		ctx
	});

	return block;
}

// (804:14) {:else}
function create_else_block_6(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*#slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_7);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) && create_if_block_82(ctx);
	const after_title_slot_template = /*#slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_7);
	let if_block1 = /*hasAfter*/ ctx[42] && create_if_block_79(ctx);
	const inner_slot_template = /*#slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_7);
	let if_block2 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_78(ctx);

	const block = {
		c: function create() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_dev(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, if_block2_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_7, get_before_title_slot_context_7);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 448) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_82(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_7, get_after_title_slot_context_7);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_79(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_7, get_inner_slot_context_7);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_78(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach_dev(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_6.name,
		type: "else",
		source: "(804:14) {:else}",
		ctx
	});

	return block;
}

// (752:14) {#if isMedia}
function create_if_block_68(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_77(ctx);
	const before_title_slot_template = /*#slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_6);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_76(ctx);
	const after_title_slot_template = /*#slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_6);
	let if_block2 = /*hasAfter*/ ctx[42] && create_if_block_73(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[40] && create_if_block_72(ctx);
	let if_block4 = /*hasText*/ ctx[41] && create_if_block_71(ctx);
	const inner_slot_template = /*#slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_6);
	let if_block5 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_70(ctx);
	let if_block6 = /*hasFooter*/ ctx[39] && create_if_block_69(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty();
			attr_dev(div, "class", "item-title-row");
			add_location(div, file$F, 758, 16, 27492);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_dev(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_dev(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_dev(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_dev(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_dev(target, if_block6_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_77(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_6, get_before_title_slot_context_6);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_76(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_6, get_after_title_slot_context_6);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_73(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[40]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 512) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_72(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[41]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 1024) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_71(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_6, get_inner_slot_context_6);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_70(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_69(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach_dev(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach_dev(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach_dev(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach_dev(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach_dev(if_block6_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_68.name,
		type: "if",
		source: "(752:14) {#if isMedia}",
		ctx
	});

	return block;
}

// (806:16) {#if (hasTitle || hasHeader || hasFooter)}
function create_if_block_82(ctx) {
	let div;
	let t0;
	let t1_value = Utils.text(/*title*/ ctx[0]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_84(ctx);
	const title_slot_template = /*#slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_7);
	let if_block1 = /*hasFooter*/ ctx[39] && create_if_block_83(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$F, 806, 18, 29333);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_84(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 1) && t1_value !== (t1_value = Utils.text(/*title*/ ctx[0]) + "")) set_data_dev(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_7, get_title_slot_context_7);
				}
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_83(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_82.name,
		type: "if",
		source: "(806:16) {#if (hasTitle || hasHeader || hasFooter)}",
		ctx
	});

	return block;
}

// (808:20) {#if hasHeader}
function create_if_block_84(ctx) {
	let div;
	let t0_value = Utils.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_7);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$F, 808, 22, 29416);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_7, get_header_slot_context_7);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_84.name,
		type: "if",
		source: "(808:20) {#if hasHeader}",
		ctx
	});

	return block;
}

// (816:20) {#if hasFooter}
function create_if_block_83(ctx) {
	let div;
	let t0_value = Utils.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_7);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$F, 816, 22, 29729);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_7, get_footer_slot_context_7);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_83.name,
		type: "if",
		source: "(816:20) {#if hasFooter}",
		ctx
	});

	return block;
}

// (825:16) {#if hasAfter}
function create_if_block_79(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_7);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_81(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_80(ctx);
	const after_slot_template = /*#slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_7);
	const after_end_slot_template = /*#slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_7);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$F, 825, 18, 30042);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_7, get_after_start_slot_context_7);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_81(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_80(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_7, get_after_slot_context_7);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_7, get_after_end_slot_context_7);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_79.name,
		type: "if",
		source: "(825:16) {#if hasAfter}",
		ctx
	});

	return block;
}

// (828:20) {#if typeof after !== 'undefined'}
function create_if_block_81(ctx) {
	let span;
	let t_value = Utils.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file$F, 828, 22, 30192);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_81.name,
		type: "if",
		source: "(828:20) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (831:20) {#if typeof badge !== 'undefined'}
function create_if_block_80(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_7] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_80.name,
		type: "if",
		source: "(831:20) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (832:22) <Badge color={badgeColor}>
function create_default_slot_7(ctx) {
	let t_value = Utils.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(832:22) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (839:16) {#if !(swipeout || accordionItem)}
function create_if_block_78(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_78.name,
		type: "if",
		source: "(839:16) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (753:16) {#if hasHeader}
function create_if_block_77(ctx) {
	let div;
	let t0_value = Utils.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_6);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$F, 753, 18, 27319);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_6, get_header_slot_context_6);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_77.name,
		type: "if",
		source: "(753:16) {#if hasHeader}",
		ctx
	});

	return block;
}

// (761:18) {#if (hasTitle)}
function create_if_block_76(ctx) {
	let div;
	let t0_value = Utils.text(/*title*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*#slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_6);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$F, 761, 20, 27623);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = Utils.text(/*title*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_6, get_title_slot_context_6);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (title_slot) title_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_76.name,
		type: "if",
		source: "(761:18) {#if (hasTitle)}",
		ctx
	});

	return block;
}

// (768:18) {#if hasAfter}
function create_if_block_73(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_6);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_75(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_74(ctx);
	const after_slot_template = /*#slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_6);
	const after_end_slot_template = /*#slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_6);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$F, 768, 20, 27884);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_6, get_after_start_slot_context_6);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_75(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_74(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_6, get_after_slot_context_6);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_6, get_after_end_slot_context_6);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_73.name,
		type: "if",
		source: "(768:18) {#if hasAfter}",
		ctx
	});

	return block;
}

// (771:22) {#if typeof after !== 'undefined'}
function create_if_block_75(ctx) {
	let span;
	let t_value = Utils.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file$F, 771, 24, 28040);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_75.name,
		type: "if",
		source: "(771:22) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (774:22) {#if typeof badge !== 'undefined'}
function create_if_block_74(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_74.name,
		type: "if",
		source: "(774:22) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (775:24) <Badge color={badgeColor}>
function create_default_slot_6(ctx) {
	let t_value = Utils.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(775:24) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (782:16) {#if hasSubtitle}
function create_if_block_72(ctx) {
	let div;
	let t0_value = Utils.text(/*subtitle*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*#slots*/ ctx[66].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[80], get_subtitle_slot_context_3);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			attr_dev(div, "class", "item-subtitle");
			add_location(div, file$F, 782, 18, 28482);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 8) && t0_value !== (t0_value = Utils.text(/*subtitle*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(subtitle_slot, subtitle_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_subtitle_slot_changes_3, get_subtitle_slot_context_3);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_72.name,
		type: "if",
		source: "(782:16) {#if hasSubtitle}",
		ctx
	});

	return block;
}

// (788:16) {#if hasText}
function create_if_block_71(ctx) {
	let div;
	let t0_value = Utils.text(/*text*/ ctx[1]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*#slots*/ ctx[66].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[80], get_text_slot_context_3);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			attr_dev(div, "class", "item-text");
			add_location(div, file$F, 788, 18, 28693);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 2) && t0_value !== (t0_value = Utils.text(/*text*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_text_slot_changes_3, get_text_slot_context_3);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (text_slot) text_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_71.name,
		type: "if",
		source: "(788:16) {#if hasText}",
		ctx
	});

	return block;
}

// (795:16) {#if !(swipeout || accordionItem)}
function create_if_block_70(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_70.name,
		type: "if",
		source: "(795:16) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (798:16) {#if hasFooter}
function create_if_block_69(ctx) {
	let div;
	let t0_value = Utils.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_6);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$F, 798, 18, 29032);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_6, get_footer_slot_context_6);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_69.name,
		type: "if",
		source: "(798:16) {#if hasFooter}",
		ctx
	});

	return block;
}

// (491:8) {:else}
function create_else_block_2$1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_26, create_else_block_4];
	const if_blocks = [];

	function select_block_type_4(ctx, dirty) {
		if (/*checkbox*/ ctx[14] || /*radio*/ ctx[15]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_4(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_4(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2$1.name,
		type: "else",
		source: "(491:8) {:else}",
		ctx
	});

	return block;
}

// (375:8) {#if isLink}
function create_if_block_5$2(ctx) {
	let a;
	let div1;
	let t0;
	let t1;
	let t2;
	let div0;
	let t3;
	let current_block_type_index;
	let if_block2;
	let t4;
	let t5;
	let t6;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*#slots*/ ctx[66]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[80], get_content_start_slot_context$1);
	let if_block0 = /*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29] && create_if_block_25(ctx);
	let if_block1 = /*hasMedia*/ ctx[36] && create_if_block_23$1(ctx);
	const inner_start_slot_template = /*#slots*/ ctx[66]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_start_slot_context$1);
	const if_block_creators = [create_if_block_6$2, create_else_block_1$2];
	const if_blocks = [];

	function select_block_type_3(ctx, dirty) {
		if (/*isMedia*/ ctx[23]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_3(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*#slots*/ ctx[66]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_end_slot_context$1);
	const content_slot_template = /*#slots*/ ctx[66].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[80], get_content_slot_context$2);
	const content_end_slot_template = /*#slots*/ ctx[66]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[80], get_content_end_slot_context$1);
	let a_levels = [{ class: /*linkClasses*/ ctx[33] }, /*linkAttrs*/ ctx[34]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div0 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t3 = space();
			if_block2.c();
			t4 = space();
			if (inner_end_slot) inner_end_slot.c();
			t5 = space();
			if (content_slot) content_slot.c();
			t6 = space();
			if (content_end_slot) content_end_slot.c();
			attr_dev(div0, "class", "item-inner");
			add_location(div0, file$F, 390, 14, 13059);
			attr_dev(div1, "class", /*contentClasses*/ ctx[32]);
			add_location(div1, file$F, 377, 12, 12558);
			set_attributes(a, a_data);
			add_location(a, file$F, 375, 10, 12429);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, div1);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_dev(div1, t0);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t2);
			append_dev(div1, div0);

			if (inner_start_slot) {
				inner_start_slot.m(div0, null);
			}

			append_dev(div0, t3);
			if_blocks[current_block_type_index].m(div0, null);
			append_dev(div0, t4);

			if (inner_end_slot) {
				inner_end_slot.m(div0, null);
			}

			/*div0_binding*/ ctx[69](div0);
			append_dev(div1, t5);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			append_dev(div1, t6);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			/*a_binding*/ ctx[70](a);
			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[43], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_start_slot_changes$1, get_content_start_slot_context$1);
				}
			}

			if (/*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_25(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*hasMedia*/ ctx[36]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_23$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_start_slot_changes$1, get_inner_start_slot_context$1);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_3(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(div0, t4);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_end_slot_changes$1, get_inner_end_slot_context$1);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_slot_changes$2, get_content_slot_context$2);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_end_slot_changes$1, get_content_end_slot_context$1);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2) {
				attr_dev(div1, "class", /*contentClasses*/ ctx[32]);
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty[1] & /*linkClasses*/ 4) && { class: /*linkClasses*/ ctx[33] },
				dirty[1] & /*linkAttrs*/ 8 && /*linkAttrs*/ ctx[34]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div0_binding*/ ctx[69](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			/*a_binding*/ ctx[70](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5$2.name,
		type: "if",
		source: "(375:8) {#if isLink}",
		ctx
	});

	return block;
}

// (617:10) {:else}
function create_else_block_4(ctx) {
	let div1;
	let t0;
	let t1;
	let t2;
	let div0;
	let t3;
	let current_block_type_index;
	let if_block2;
	let t4;
	let t5;
	let t6;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*#slots*/ ctx[66]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[80], get_content_start_slot_context_2);
	let if_block0 = /*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29] && create_if_block_66(ctx);
	let if_block1 = /*hasMedia*/ ctx[36] && create_if_block_64(ctx);
	const inner_start_slot_template = /*#slots*/ ctx[66]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_start_slot_context_2);
	const if_block_creators = [create_if_block_47, create_else_block_5];
	const if_blocks = [];

	function select_block_type_6(ctx, dirty) {
		if (/*isMedia*/ ctx[23]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_6(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*#slots*/ ctx[66]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_end_slot_context_2);
	const content_slot_template = /*#slots*/ ctx[66].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[80], get_content_slot_context_2);
	const content_end_slot_template = /*#slots*/ ctx[66]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[80], get_content_end_slot_context_2);

	const block = {
		c: function create() {
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div0 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t3 = space();
			if_block2.c();
			t4 = space();
			if (inner_end_slot) inner_end_slot.c();
			t5 = space();
			if (content_slot) content_slot.c();
			t6 = space();
			if (content_end_slot) content_end_slot.c();
			attr_dev(div0, "class", "item-inner");
			add_location(div0, file$F, 630, 14, 22543);
			attr_dev(div1, "class", /*contentClasses*/ ctx[32]);
			add_location(div1, file$F, 617, 12, 22023);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_dev(div1, t0);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t1);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t2);
			append_dev(div1, div0);

			if (inner_start_slot) {
				inner_start_slot.m(div0, null);
			}

			append_dev(div0, t3);
			if_blocks[current_block_type_index].m(div0, null);
			append_dev(div0, t4);

			if (inner_end_slot) {
				inner_end_slot.m(div0, null);
			}

			/*div0_binding_1*/ ctx[73](div0);
			append_dev(div1, t5);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			append_dev(div1, t6);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div1, "click", /*onClick*/ ctx[43], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_start_slot_changes_2, get_content_start_slot_context_2);
				}
			}

			if (/*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_66(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*hasMedia*/ ctx[36]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_64(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_start_slot_changes_2, get_inner_start_slot_context_2);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_6(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(div0, t4);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_end_slot_changes_2, get_inner_end_slot_context_2);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_slot_changes_2, get_content_slot_context_2);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_end_slot_changes_2, get_content_end_slot_context_2);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2) {
				attr_dev(div1, "class", /*contentClasses*/ ctx[32]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div0_binding_1*/ ctx[73](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_4.name,
		type: "else",
		source: "(617:10) {:else}",
		ctx
	});

	return block;
}

// (493:10) {#if checkbox || radio}
function create_if_block_26(ctx) {
	let label;
	let t0;
	let t1;
	let input;
	let input_value_value;
	let input_type_value;
	let t2;
	let i;
	let i_class_value;
	let t3;
	let t4;
	let div;
	let t5;
	let current_block_type_index;
	let if_block2;
	let t6;
	let t7;
	let t8;
	let current;
	let mounted;
	let dispose;
	const content_start_slot_template = /*#slots*/ ctx[66]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[80], get_content_start_slot_context_1$1);
	let if_block0 = /*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29] && create_if_block_46(ctx);
	let if_block1 = /*hasMedia*/ ctx[36] && create_if_block_44(ctx);
	const inner_start_slot_template = /*#slots*/ ctx[66]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_start_slot_context_1$1);
	const if_block_creators = [create_if_block_27, create_else_block_3];
	const if_blocks = [];

	function select_block_type_5(ctx, dirty) {
		if (/*isMedia*/ ctx[23]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_5(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const inner_end_slot_template = /*#slots*/ ctx[66]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_end_slot_context_1$1);
	const content_slot_template = /*#slots*/ ctx[66].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[80], get_content_slot_context_1$1);
	const content_end_slot_template = /*#slots*/ ctx[66]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[80], get_content_end_slot_context_1$1);

	const block = {
		c: function create() {
			label = element("label");
			if (content_start_slot) content_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			input = element("input");
			t2 = space();
			i = element("i");
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			div = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t5 = space();
			if_block2.c();
			t6 = space();
			if (inner_end_slot) inner_end_slot.c();
			t7 = space();
			if (content_slot) content_slot.c();
			t8 = space();
			if (content_end_slot) content_end_slot.c();

			input.value = input_value_value = typeof /*value*/ ctx[18] === "undefined"
			? ""
			: /*value*/ ctx[18];

			attr_dev(input, "name", /*name*/ ctx[17]);
			input.checked = /*checked*/ ctx[16];
			input.readOnly = /*readonly*/ ctx[19];
			input.disabled = /*disabled*/ ctx[21];
			input.required = /*required*/ ctx[20];
			attr_dev(input, "type", input_type_value = /*radio*/ ctx[15] ? "radio" : "checkbox");
			add_location(input, file$F, 498, 14, 17357);
			attr_dev(i, "class", i_class_value = `icon icon-${/*radio*/ ctx[15] ? "radio" : "checkbox"}`);
			add_location(i, file$F, 509, 14, 17756);
			attr_dev(div, "class", "item-inner");
			add_location(div, file$F, 518, 14, 18098);
			attr_dev(label, "class", /*contentClasses*/ ctx[32]);
			add_location(label, file$F, 493, 12, 17105);
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);

			if (content_start_slot) {
				content_start_slot.m(label, null);
			}

			append_dev(label, t0);
			if (if_block0) if_block0.m(label, null);
			append_dev(label, t1);
			append_dev(label, input);
			/*input_binding*/ ctx[71](input);
			append_dev(label, t2);
			append_dev(label, i);
			append_dev(label, t3);
			if (if_block1) if_block1.m(label, null);
			append_dev(label, t4);
			append_dev(label, div);

			if (inner_start_slot) {
				inner_start_slot.m(div, null);
			}

			append_dev(div, t5);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t6);

			if (inner_end_slot) {
				inner_end_slot.m(div, null);
			}

			/*div_binding*/ ctx[72](div);
			append_dev(label, t7);

			if (content_slot) {
				content_slot.m(label, null);
			}

			append_dev(label, t8);

			if (content_end_slot) {
				content_end_slot.m(label, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "change", /*onChange*/ ctx[44], false, false, false),
					listen_dev(label, "click", /*onClick*/ ctx[43], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (content_start_slot) {
				if (content_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_start_slot_changes_1$1, get_content_start_slot_context_1$1);
				}
			}

			if (/*isSortable*/ ctx[28] && /*sortable*/ ctx[12] !== false && /*isSortableOpposite*/ ctx[29]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_46(ctx);
					if_block0.c();
					if_block0.m(label, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!current || dirty[0] & /*value*/ 262144 && input_value_value !== (input_value_value = typeof /*value*/ ctx[18] === "undefined"
			? ""
			: /*value*/ ctx[18]) && input.value !== input_value_value) {
				prop_dev(input, "value", input_value_value);
			}

			if (!current || dirty[0] & /*name*/ 131072) {
				attr_dev(input, "name", /*name*/ ctx[17]);
			}

			if (!current || dirty[0] & /*checked*/ 65536) {
				prop_dev(input, "checked", /*checked*/ ctx[16]);
			}

			if (!current || dirty[0] & /*readonly*/ 524288) {
				prop_dev(input, "readOnly", /*readonly*/ ctx[19]);
			}

			if (!current || dirty[0] & /*disabled*/ 2097152) {
				prop_dev(input, "disabled", /*disabled*/ ctx[21]);
			}

			if (!current || dirty[0] & /*required*/ 1048576) {
				prop_dev(input, "required", /*required*/ ctx[20]);
			}

			if (!current || dirty[0] & /*radio*/ 32768 && input_type_value !== (input_type_value = /*radio*/ ctx[15] ? "radio" : "checkbox")) {
				attr_dev(input, "type", input_type_value);
			}

			if (!current || dirty[0] & /*radio*/ 32768 && i_class_value !== (i_class_value = `icon icon-${/*radio*/ ctx[15] ? "radio" : "checkbox"}`)) {
				attr_dev(i, "class", i_class_value);
			}

			if (/*hasMedia*/ ctx[36]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasMedia*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_44(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(label, t4);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_start_slot_changes_1$1, get_inner_start_slot_context_1$1);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_5(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(div, t6);
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_end_slot_changes_1$1, get_inner_end_slot_context_1$1);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_slot_changes_1$1, get_content_slot_context_1$1);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_content_end_slot_changes_1$1, get_content_end_slot_context_1$1);
				}
			}

			if (!current || dirty[1] & /*contentClasses*/ 2) {
				attr_dev(label, "class", /*contentClasses*/ ctx[32]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(inner_start_slot, local);
			transition_in(if_block2);
			transition_in(inner_end_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(inner_start_slot, local);
			transition_out(if_block2);
			transition_out(inner_end_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			/*input_binding*/ ctx[71](null);
			if (if_block1) if_block1.d();
			if (inner_start_slot) inner_start_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			/*div_binding*/ ctx[72](null);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_26.name,
		type: "if",
		source: "(493:10) {#if checkbox || radio}",
		ctx
	});

	return block;
}

// (620:14) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_66(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$F, 620, 16, 22206);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_66.name,
		type: "if",
		source: "(620:14) {#if isSortable && sortable !== false && isSortableOpposite}",
		ctx
	});

	return block;
}

// (623:14) {#if hasMedia}
function create_if_block_64(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[2] !== "undefined" && create_if_block_65(ctx);
	const media_slot_template = /*#slots*/ ctx[66].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[80], get_media_slot_context_2);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "item-media");
			add_location(div, file$F, 623, 16, 22304);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*media*/ ctx[2] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_65(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_media_slot_changes_2, get_media_slot_context_2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_64.name,
		type: "if",
		source: "(623:14) {#if hasMedia}",
		ctx
	});

	return block;
}

// (625:18) {#if typeof media !== 'undefined'}
function create_if_block_65(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*media*/ ctx[2])) attr_dev(img, "src", img_src_value);
			add_location(img, file$F, 625, 20, 22402);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 4 && img.src !== (img_src_value = /*media*/ ctx[2])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_65.name,
		type: "if",
		source: "(625:18) {#if typeof media !== 'undefined'}",
		ctx
	});

	return block;
}

// (685:16) {:else}
function create_else_block_5(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*#slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_5);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) && create_if_block_61(ctx);
	const after_title_slot_template = /*#slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_5);
	let if_block1 = /*hasAfter*/ ctx[42] && create_if_block_58(ctx);
	const inner_slot_template = /*#slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_5);
	let if_block2 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_57(ctx);

	const block = {
		c: function create() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_dev(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, if_block2_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_5, get_before_title_slot_context_5);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 448) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_61(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_5, get_after_title_slot_context_5);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_58(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_5, get_inner_slot_context_5);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_57(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach_dev(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_5.name,
		type: "else",
		source: "(685:16) {:else}",
		ctx
	});

	return block;
}

// (633:16) {#if isMedia}
function create_if_block_47(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_56(ctx);
	const before_title_slot_template = /*#slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_4);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_55(ctx);
	const after_title_slot_template = /*#slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_4);
	let if_block2 = /*hasAfter*/ ctx[42] && create_if_block_52(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[40] && create_if_block_51(ctx);
	let if_block4 = /*hasText*/ ctx[41] && create_if_block_50(ctx);
	const inner_slot_template = /*#slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_4);
	let if_block5 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_49(ctx);
	let if_block6 = /*hasFooter*/ ctx[39] && create_if_block_48(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty();
			attr_dev(div, "class", "item-title-row");
			add_location(div, file$F, 639, 18, 22899);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_dev(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_dev(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_dev(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_dev(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_dev(target, if_block6_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_56(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_4, get_before_title_slot_context_4);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_55(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_4, get_after_title_slot_context_4);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_52(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[40]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 512) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_51(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[41]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 1024) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_50(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_4, get_inner_slot_context_4);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_49(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_48(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach_dev(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach_dev(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach_dev(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach_dev(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach_dev(if_block6_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_47.name,
		type: "if",
		source: "(633:16) {#if isMedia}",
		ctx
	});

	return block;
}

// (687:18) {#if (hasTitle || hasHeader || hasFooter)}
function create_if_block_61(ctx) {
	let div;
	let t0;
	let t1_value = Utils.text(/*title*/ ctx[0]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_63(ctx);
	const title_slot_template = /*#slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_5);
	let if_block1 = /*hasFooter*/ ctx[39] && create_if_block_62(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$F, 687, 20, 24836);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_63(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 1) && t1_value !== (t1_value = Utils.text(/*title*/ ctx[0]) + "")) set_data_dev(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_5, get_title_slot_context_5);
				}
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_62(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_61.name,
		type: "if",
		source: "(687:18) {#if (hasTitle || hasHeader || hasFooter)}",
		ctx
	});

	return block;
}

// (689:22) {#if hasHeader}
function create_if_block_63(ctx) {
	let div;
	let t0_value = Utils.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_5);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$F, 689, 24, 24923);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_5, get_header_slot_context_5);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_63.name,
		type: "if",
		source: "(689:22) {#if hasHeader}",
		ctx
	});

	return block;
}

// (697:22) {#if hasFooter}
function create_if_block_62(ctx) {
	let div;
	let t0_value = Utils.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_5);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$F, 697, 24, 25252);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_5, get_footer_slot_context_5);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_62.name,
		type: "if",
		source: "(697:22) {#if hasFooter}",
		ctx
	});

	return block;
}

// (706:18) {#if hasAfter}
function create_if_block_58(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_5);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_60(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_59(ctx);
	const after_slot_template = /*#slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_5);
	const after_end_slot_template = /*#slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_5);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$F, 706, 20, 25583);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_5, get_after_start_slot_context_5);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_60(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_59(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_5, get_after_slot_context_5);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_5, get_after_end_slot_context_5);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_58.name,
		type: "if",
		source: "(706:18) {#if hasAfter}",
		ctx
	});

	return block;
}

// (709:22) {#if typeof after !== 'undefined'}
function create_if_block_60(ctx) {
	let span;
	let t_value = Utils.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file$F, 709, 24, 25739);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_60.name,
		type: "if",
		source: "(709:22) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (712:22) {#if typeof badge !== 'undefined'}
function create_if_block_59(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_59.name,
		type: "if",
		source: "(712:22) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (713:24) <Badge color={badgeColor}>
function create_default_slot_5(ctx) {
	let t_value = Utils.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(713:24) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (720:18) {#if !(swipeout || accordionItem)}
function create_if_block_57(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_57.name,
		type: "if",
		source: "(720:18) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (634:18) {#if hasHeader}
function create_if_block_56(ctx) {
	let div;
	let t0_value = Utils.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_4);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$F, 634, 20, 22716);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_4, get_header_slot_context_4);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_56.name,
		type: "if",
		source: "(634:18) {#if hasHeader}",
		ctx
	});

	return block;
}

// (642:20) {#if (hasTitle)}
function create_if_block_55(ctx) {
	let div;
	let t0_value = Utils.text(/*title*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*#slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_4);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$F, 642, 22, 23036);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = Utils.text(/*title*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_4, get_title_slot_context_4);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (title_slot) title_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_55.name,
		type: "if",
		source: "(642:20) {#if (hasTitle)}",
		ctx
	});

	return block;
}

// (649:20) {#if hasAfter}
function create_if_block_52(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_4);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_54(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_53(ctx);
	const after_slot_template = /*#slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_4);
	const after_end_slot_template = /*#slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_4);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$F, 649, 22, 23311);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_4, get_after_start_slot_context_4);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_54(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_53(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_4, get_after_slot_context_4);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_4, get_after_end_slot_context_4);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_52.name,
		type: "if",
		source: "(649:20) {#if hasAfter}",
		ctx
	});

	return block;
}

// (652:24) {#if typeof after !== 'undefined'}
function create_if_block_54(ctx) {
	let span;
	let t_value = Utils.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file$F, 652, 26, 23473);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_54.name,
		type: "if",
		source: "(652:24) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (655:24) {#if typeof badge !== 'undefined'}
function create_if_block_53(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_53.name,
		type: "if",
		source: "(655:24) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (656:26) <Badge color={badgeColor}>
function create_default_slot_4(ctx) {
	let t_value = Utils.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(656:26) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (663:18) {#if hasSubtitle}
function create_if_block_51(ctx) {
	let div;
	let t0_value = Utils.text(/*subtitle*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*#slots*/ ctx[66].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[80], get_subtitle_slot_context_2);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			attr_dev(div, "class", "item-subtitle");
			add_location(div, file$F, 663, 20, 23937);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 8) && t0_value !== (t0_value = Utils.text(/*subtitle*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(subtitle_slot, subtitle_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_subtitle_slot_changes_2, get_subtitle_slot_context_2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_51.name,
		type: "if",
		source: "(663:18) {#if hasSubtitle}",
		ctx
	});

	return block;
}

// (669:18) {#if hasText}
function create_if_block_50(ctx) {
	let div;
	let t0_value = Utils.text(/*text*/ ctx[1]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*#slots*/ ctx[66].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[80], get_text_slot_context_2);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			attr_dev(div, "class", "item-text");
			add_location(div, file$F, 669, 20, 24160);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 2) && t0_value !== (t0_value = Utils.text(/*text*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_text_slot_changes_2, get_text_slot_context_2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (text_slot) text_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_50.name,
		type: "if",
		source: "(669:18) {#if hasText}",
		ctx
	});

	return block;
}

// (676:18) {#if !(swipeout || accordionItem)}
function create_if_block_49(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_49.name,
		type: "if",
		source: "(676:18) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (679:18) {#if hasFooter}
function create_if_block_48(ctx) {
	let div;
	let t0_value = Utils.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_4);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$F, 679, 20, 24519);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_4, get_footer_slot_context_4);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_48.name,
		type: "if",
		source: "(679:18) {#if hasFooter}",
		ctx
	});

	return block;
}

// (496:14) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_46(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$F, 496, 16, 17290);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_46.name,
		type: "if",
		source: "(496:14) {#if isSortable && sortable !== false && isSortableOpposite}",
		ctx
	});

	return block;
}

// (511:14) {#if hasMedia}
function create_if_block_44(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[2] !== "undefined" && create_if_block_45(ctx);
	const media_slot_template = /*#slots*/ ctx[66].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[80], get_media_slot_context_1$1);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "item-media");
			add_location(div, file$F, 511, 16, 17859);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*media*/ ctx[2] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_45(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_media_slot_changes_1$1, get_media_slot_context_1$1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_44.name,
		type: "if",
		source: "(511:14) {#if hasMedia}",
		ctx
	});

	return block;
}

// (513:18) {#if typeof media !== 'undefined'}
function create_if_block_45(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*media*/ ctx[2])) attr_dev(img, "src", img_src_value);
			add_location(img, file$F, 513, 20, 17957);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 4 && img.src !== (img_src_value = /*media*/ ctx[2])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_45.name,
		type: "if",
		source: "(513:18) {#if typeof media !== 'undefined'}",
		ctx
	});

	return block;
}

// (573:16) {:else}
function create_else_block_3(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*#slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_3);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) && create_if_block_41(ctx);
	const after_title_slot_template = /*#slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_3);
	let if_block1 = /*hasAfter*/ ctx[42] && create_if_block_38(ctx);
	const inner_slot_template = /*#slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_3);
	let if_block2 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_37(ctx);

	const block = {
		c: function create() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_dev(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, if_block2_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_3, get_before_title_slot_context_3);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 448) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_41(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_3, get_after_title_slot_context_3);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_38(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_3, get_inner_slot_context_3);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_37(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach_dev(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_3.name,
		type: "else",
		source: "(573:16) {:else}",
		ctx
	});

	return block;
}

// (521:16) {#if isMedia}
function create_if_block_27(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_36(ctx);
	const before_title_slot_template = /*#slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_2);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_35(ctx);
	const after_title_slot_template = /*#slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_2);
	let if_block2 = /*hasAfter*/ ctx[42] && create_if_block_32(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[40] && create_if_block_31(ctx);
	let if_block4 = /*hasText*/ ctx[41] && create_if_block_30(ctx);
	const inner_slot_template = /*#slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_2);
	let if_block5 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_29(ctx);
	let if_block6 = /*hasFooter*/ ctx[39] && create_if_block_28(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty();
			attr_dev(div, "class", "item-title-row");
			add_location(div, file$F, 527, 18, 18454);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_dev(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_dev(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_dev(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_dev(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_dev(target, if_block6_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_36(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_2, get_before_title_slot_context_2);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_35(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_2, get_after_title_slot_context_2);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_32(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[40]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 512) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_31(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[41]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 1024) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_30(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_2, get_inner_slot_context_2);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_29(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_28(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach_dev(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach_dev(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach_dev(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach_dev(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach_dev(if_block6_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_27.name,
		type: "if",
		source: "(521:16) {#if isMedia}",
		ctx
	});

	return block;
}

// (575:18) {#if (hasTitle || hasHeader || hasFooter)}
function create_if_block_41(ctx) {
	let div;
	let t0;
	let t1_value = Utils.text(/*title*/ ctx[0]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_43(ctx);
	const title_slot_template = /*#slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_3);
	let if_block1 = /*hasFooter*/ ctx[39] && create_if_block_42(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$F, 575, 20, 20391);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_43(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 1) && t1_value !== (t1_value = Utils.text(/*title*/ ctx[0]) + "")) set_data_dev(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_3, get_title_slot_context_3);
				}
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_42(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_41.name,
		type: "if",
		source: "(575:18) {#if (hasTitle || hasHeader || hasFooter)}",
		ctx
	});

	return block;
}

// (577:22) {#if hasHeader}
function create_if_block_43(ctx) {
	let div;
	let t0_value = Utils.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_3);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$F, 577, 24, 20478);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_3, get_header_slot_context_3);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_43.name,
		type: "if",
		source: "(577:22) {#if hasHeader}",
		ctx
	});

	return block;
}

// (585:22) {#if hasFooter}
function create_if_block_42(ctx) {
	let div;
	let t0_value = Utils.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_3);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$F, 585, 24, 20807);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_3, get_footer_slot_context_3);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_42.name,
		type: "if",
		source: "(585:22) {#if hasFooter}",
		ctx
	});

	return block;
}

// (594:18) {#if hasAfter}
function create_if_block_38(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_3);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_40(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_39(ctx);
	const after_slot_template = /*#slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_3);
	const after_end_slot_template = /*#slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_3);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$F, 594, 20, 21138);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_3, get_after_start_slot_context_3);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_40(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_39(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_3, get_after_slot_context_3);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_3, get_after_end_slot_context_3);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_38.name,
		type: "if",
		source: "(594:18) {#if hasAfter}",
		ctx
	});

	return block;
}

// (597:22) {#if typeof after !== 'undefined'}
function create_if_block_40(ctx) {
	let span;
	let t_value = Utils.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file$F, 597, 24, 21294);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_40.name,
		type: "if",
		source: "(597:22) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (600:22) {#if typeof badge !== 'undefined'}
function create_if_block_39(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_39.name,
		type: "if",
		source: "(600:22) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (601:24) <Badge color={badgeColor}>
function create_default_slot_3(ctx) {
	let t_value = Utils.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(601:24) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (608:18) {#if !(swipeout || accordionItem)}
function create_if_block_37(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_37.name,
		type: "if",
		source: "(608:18) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (522:18) {#if hasHeader}
function create_if_block_36(ctx) {
	let div;
	let t0_value = Utils.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_2);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$F, 522, 20, 18271);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_2, get_header_slot_context_2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_36.name,
		type: "if",
		source: "(522:18) {#if hasHeader}",
		ctx
	});

	return block;
}

// (530:20) {#if (hasTitle)}
function create_if_block_35(ctx) {
	let div;
	let t0_value = Utils.text(/*title*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*#slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_2);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$F, 530, 22, 18591);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = Utils.text(/*title*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_2, get_title_slot_context_2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (title_slot) title_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_35.name,
		type: "if",
		source: "(530:20) {#if (hasTitle)}",
		ctx
	});

	return block;
}

// (537:20) {#if hasAfter}
function create_if_block_32(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_2);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_34(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_33(ctx);
	const after_slot_template = /*#slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_2);
	const after_end_slot_template = /*#slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_2);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$F, 537, 22, 18866);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_2, get_after_start_slot_context_2);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_34(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_33(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_2, get_after_slot_context_2);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_2, get_after_end_slot_context_2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_32.name,
		type: "if",
		source: "(537:20) {#if hasAfter}",
		ctx
	});

	return block;
}

// (540:24) {#if typeof after !== 'undefined'}
function create_if_block_34(ctx) {
	let span;
	let t_value = Utils.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file$F, 540, 26, 19028);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_34.name,
		type: "if",
		source: "(540:24) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (543:24) {#if typeof badge !== 'undefined'}
function create_if_block_33(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_33.name,
		type: "if",
		source: "(543:24) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (544:26) <Badge color={badgeColor}>
function create_default_slot_2$2(ctx) {
	let t_value = Utils.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$2.name,
		type: "slot",
		source: "(544:26) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (551:18) {#if hasSubtitle}
function create_if_block_31(ctx) {
	let div;
	let t0_value = Utils.text(/*subtitle*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*#slots*/ ctx[66].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[80], get_subtitle_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			attr_dev(div, "class", "item-subtitle");
			add_location(div, file$F, 551, 20, 19492);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 8) && t0_value !== (t0_value = Utils.text(/*subtitle*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(subtitle_slot, subtitle_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_subtitle_slot_changes_1, get_subtitle_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_31.name,
		type: "if",
		source: "(551:18) {#if hasSubtitle}",
		ctx
	});

	return block;
}

// (557:18) {#if hasText}
function create_if_block_30(ctx) {
	let div;
	let t0_value = Utils.text(/*text*/ ctx[1]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*#slots*/ ctx[66].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[80], get_text_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			attr_dev(div, "class", "item-text");
			add_location(div, file$F, 557, 20, 19715);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 2) && t0_value !== (t0_value = Utils.text(/*text*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_text_slot_changes_1, get_text_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (text_slot) text_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_30.name,
		type: "if",
		source: "(557:18) {#if hasText}",
		ctx
	});

	return block;
}

// (564:18) {#if !(swipeout || accordionItem)}
function create_if_block_29(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_29.name,
		type: "if",
		source: "(564:18) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (567:18) {#if hasFooter}
function create_if_block_28(ctx) {
	let div;
	let t0_value = Utils.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_2);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$F, 567, 20, 20074);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_2, get_footer_slot_context_2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_28.name,
		type: "if",
		source: "(567:18) {#if hasFooter}",
		ctx
	});

	return block;
}

// (380:14) {#if isSortable && sortable !== false && isSortableOpposite}
function create_if_block_25(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$F, 380, 16, 12722);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_25.name,
		type: "if",
		source: "(380:14) {#if isSortable && sortable !== false && isSortableOpposite}",
		ctx
	});

	return block;
}

// (383:14) {#if hasMedia}
function create_if_block_23$1(ctx) {
	let div;
	let t;
	let current;
	let if_block = typeof /*media*/ ctx[2] !== "undefined" && create_if_block_24(ctx);
	const media_slot_template = /*#slots*/ ctx[66].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[80], get_media_slot_context$3);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (media_slot) media_slot.c();
			attr_dev(div, "class", "item-media");
			add_location(div, file$F, 383, 16, 12820);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (media_slot) {
				media_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (typeof /*media*/ ctx[2] !== "undefined") {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_24(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (media_slot) {
				if (media_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_media_slot_changes$3, get_media_slot_context$3);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(media_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(media_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (media_slot) media_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_23$1.name,
		type: "if",
		source: "(383:14) {#if hasMedia}",
		ctx
	});

	return block;
}

// (385:18) {#if typeof media !== 'undefined'}
function create_if_block_24(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*media*/ ctx[2])) attr_dev(img, "src", img_src_value);
			add_location(img, file$F, 385, 20, 12918);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*media*/ 4 && img.src !== (img_src_value = /*media*/ ctx[2])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_24.name,
		type: "if",
		source: "(385:18) {#if typeof media !== 'undefined'}",
		ctx
	});

	return block;
}

// (445:16) {:else}
function create_else_block_1$2(ctx) {
	let t0;
	let t1;
	let t2;
	let t3;
	let t4;
	let if_block2_anchor;
	let current;
	const before_title_slot_template = /*#slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context_1);
	let if_block0 = (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) && create_if_block_20$1(ctx);
	const after_title_slot_template = /*#slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context_1);
	let if_block1 = /*hasAfter*/ ctx[42] && create_if_block_17$1(ctx);
	const inner_slot_template = /*#slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context_1$1);
	let if_block2 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_16$1(ctx);

	const block = {
		c: function create() {
			if (before_title_slot) before_title_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (after_title_slot) after_title_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (inner_slot) inner_slot.c();
			t4 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (before_title_slot) {
				before_title_slot.m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);

			if (after_title_slot) {
				after_title_slot.m(target, anchor);
			}

			insert_dev(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t3, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t4, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_dev(target, if_block2_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes_1, get_before_title_slot_context_1);
				}
			}

			if (/*hasTitle*/ ctx[37] || /*hasHeader*/ ctx[38] || /*hasFooter*/ ctx[39]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 448) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_20$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes_1, get_after_title_slot_context_1);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_17$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes_1$1, get_inner_slot_context_1$1);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_16$1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_title_slot, local);
			transition_in(if_block0);
			transition_in(after_title_slot, local);
			transition_in(if_block1);
			transition_in(inner_slot, local);
			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_title_slot, local);
			transition_out(if_block0);
			transition_out(after_title_slot, local);
			transition_out(if_block1);
			transition_out(inner_slot, local);
			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (before_title_slot) before_title_slot.d(detaching);
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (after_title_slot) after_title_slot.d(detaching);
			if (detaching) detach_dev(t2);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t3);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t4);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$2.name,
		type: "else",
		source: "(445:16) {:else}",
		ctx
	});

	return block;
}

// (393:16) {#if isMedia}
function create_if_block_6$2(ctx) {
	let t0;
	let div;
	let t1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let if_block6_anchor;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_15$1(ctx);
	const before_title_slot_template = /*#slots*/ ctx[66]["before-title"];
	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[80], get_before_title_slot_context);
	let if_block1 = /*hasTitle*/ ctx[37] && create_if_block_14$1(ctx);
	const after_title_slot_template = /*#slots*/ ctx[66]["after-title"];
	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[80], get_after_title_slot_context);
	let if_block2 = /*hasAfter*/ ctx[42] && create_if_block_11$2(ctx);
	let if_block3 = /*hasSubtitle*/ ctx[40] && create_if_block_10$2(ctx);
	let if_block4 = /*hasText*/ ctx[41] && create_if_block_9$2(ctx);
	const inner_slot_template = /*#slots*/ ctx[66].inner;
	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[80], get_inner_slot_context$1);
	let if_block5 = !(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13]) && create_if_block_8$2(ctx);
	let if_block6 = /*hasFooter*/ ctx[39] && create_if_block_7$2(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();
			div = element("div");
			if (before_title_slot) before_title_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_title_slot) after_title_slot.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (if_block4) if_block4.c();
			t6 = space();
			if (inner_slot) inner_slot.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			if_block6_anchor = empty();
			attr_dev(div, "class", "item-title-row");
			add_location(div, file$F, 399, 18, 13415);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);

			if (before_title_slot) {
				before_title_slot.m(div, null);
			}

			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_title_slot) {
				after_title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block2) if_block2.m(div, null);
			insert_dev(target, t4, anchor);
			if (if_block3) if_block3.m(target, anchor);
			insert_dev(target, t5, anchor);
			if (if_block4) if_block4.m(target, anchor);
			insert_dev(target, t6, anchor);

			if (inner_slot) {
				inner_slot.m(target, anchor);
			}

			insert_dev(target, t7, anchor);
			if (if_block5) if_block5.m(target, anchor);
			insert_dev(target, t8, anchor);
			if (if_block6) if_block6.m(target, anchor);
			insert_dev(target, if_block6_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_15$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (before_title_slot) {
				if (before_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(before_title_slot, before_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_before_title_slot_changes, get_before_title_slot_context);
				}
			}

			if (/*hasTitle*/ ctx[37]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasTitle*/ 64) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_14$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_title_slot) {
				if (after_title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_title_slot, after_title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_title_slot_changes, get_after_title_slot_context);
				}
			}

			if (/*hasAfter*/ ctx[42]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[1] & /*hasAfter*/ 2048) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_11$2(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasSubtitle*/ ctx[40]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[1] & /*hasSubtitle*/ 512) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_10$2(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(t5.parentNode, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasText*/ ctx[41]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[1] & /*hasText*/ 1024) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_9$2(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(t6.parentNode, t6);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (inner_slot) {
				if (inner_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(inner_slot, inner_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_inner_slot_changes$1, get_inner_slot_context$1);
				}
			}

			if (!(/*swipeout*/ ctx[11] || /*accordionItem*/ ctx[13])) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*swipeout, accordionItem*/ 10240) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_8$2(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(t8.parentNode, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_7$2(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(before_title_slot, local);
			transition_in(if_block1);
			transition_in(after_title_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(inner_slot, local);
			transition_in(if_block5);
			transition_in(if_block6);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(before_title_slot, local);
			transition_out(if_block1);
			transition_out(after_title_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(inner_slot, local);
			transition_out(if_block5);
			transition_out(if_block6);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div);
			if (before_title_slot) before_title_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (after_title_slot) after_title_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (detaching) detach_dev(t4);
			if (if_block3) if_block3.d(detaching);
			if (detaching) detach_dev(t5);
			if (if_block4) if_block4.d(detaching);
			if (detaching) detach_dev(t6);
			if (inner_slot) inner_slot.d(detaching);
			if (detaching) detach_dev(t7);
			if (if_block5) if_block5.d(detaching);
			if (detaching) detach_dev(t8);
			if (if_block6) if_block6.d(detaching);
			if (detaching) detach_dev(if_block6_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6$2.name,
		type: "if",
		source: "(393:16) {#if isMedia}",
		ctx
	});

	return block;
}

// (447:18) {#if (hasTitle || hasHeader || hasFooter)}
function create_if_block_20$1(ctx) {
	let div;
	let t0;
	let t1_value = Utils.text(/*title*/ ctx[0]) + "";
	let t1;
	let t2;
	let t3;
	let current;
	let if_block0 = /*hasHeader*/ ctx[38] && create_if_block_22$1(ctx);
	const title_slot_template = /*#slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context_1);
	let if_block1 = /*hasFooter*/ ctx[39] && create_if_block_21$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			t1 = text(t1_value);
			t2 = space();
			if (title_slot) title_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$F, 447, 20, 15352);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, t2);

			if (title_slot) {
				title_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*hasHeader*/ ctx[38]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[1] & /*hasHeader*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_22$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if ((!current || dirty[0] & /*title*/ 1) && t1_value !== (t1_value = Utils.text(/*title*/ ctx[0]) + "")) set_data_dev(t1, t1_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes_1, get_title_slot_context_1);
				}
			}

			if (/*hasFooter*/ ctx[39]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[1] & /*hasFooter*/ 256) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_21$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(title_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(title_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (title_slot) title_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_20$1.name,
		type: "if",
		source: "(447:18) {#if (hasTitle || hasHeader || hasFooter)}",
		ctx
	});

	return block;
}

// (449:22) {#if hasHeader}
function create_if_block_22$1(ctx) {
	let div;
	let t0_value = Utils.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$F, 449, 24, 15439);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes_1, get_header_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_22$1.name,
		type: "if",
		source: "(449:22) {#if hasHeader}",
		ctx
	});

	return block;
}

// (457:22) {#if hasFooter}
function create_if_block_21$1(ctx) {
	let div;
	let t0_value = Utils.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$F, 457, 24, 15768);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes_1, get_footer_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_21$1.name,
		type: "if",
		source: "(457:22) {#if hasFooter}",
		ctx
	});

	return block;
}

// (466:18) {#if hasAfter}
function create_if_block_17$1(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context_1);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_19$1(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_18$1(ctx);
	const after_slot_template = /*#slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context_1);
	const after_end_slot_template = /*#slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context_1);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$F, 466, 20, 16099);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes_1, get_after_start_slot_context_1);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_19$1(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_18$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes_1, get_after_slot_context_1);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes_1, get_after_end_slot_context_1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_17$1.name,
		type: "if",
		source: "(466:18) {#if hasAfter}",
		ctx
	});

	return block;
}

// (469:22) {#if typeof after !== 'undefined'}
function create_if_block_19$1(ctx) {
	let span;
	let t_value = Utils.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file$F, 469, 24, 16255);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_19$1.name,
		type: "if",
		source: "(469:22) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (472:22) {#if typeof badge !== 'undefined'}
function create_if_block_18$1(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_18$1.name,
		type: "if",
		source: "(472:22) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (473:24) <Badge color={badgeColor}>
function create_default_slot_1$2(ctx) {
	let t_value = Utils.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(473:24) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (480:18) {#if !(swipeout || accordionItem)}
function create_if_block_16$1(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_16$1.name,
		type: "if",
		source: "(480:18) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (394:18) {#if hasHeader}
function create_if_block_15$1(ctx) {
	let div;
	let t0_value = Utils.text(/*header*/ ctx[4]) + "";
	let t0;
	let t1;
	let current;
	const header_slot_template = /*#slots*/ ctx[66].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[80], get_header_slot_context$1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "item-header");
			add_location(div, file$F, 394, 20, 13232);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 16) && t0_value !== (t0_value = Utils.text(/*header*/ ctx[4]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_header_slot_changes$1, get_header_slot_context$1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_15$1.name,
		type: "if",
		source: "(394:18) {#if hasHeader}",
		ctx
	});

	return block;
}

// (402:20) {#if (hasTitle)}
function create_if_block_14$1(ctx) {
	let div;
	let t0_value = Utils.text(/*title*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	const title_slot_template = /*#slots*/ ctx[66].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[80], get_title_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (title_slot) title_slot.c();
			attr_dev(div, "class", "item-title");
			add_location(div, file$F, 402, 22, 13552);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*title*/ 1) && t0_value !== (t0_value = Utils.text(/*title*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (title_slot) {
				if (title_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_title_slot_changes, get_title_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (title_slot) title_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_14$1.name,
		type: "if",
		source: "(402:20) {#if (hasTitle)}",
		ctx
	});

	return block;
}

// (409:20) {#if hasAfter}
function create_if_block_11$2(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const after_start_slot_template = /*#slots*/ ctx[66]["after-start"];
	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[80], get_after_start_slot_context);
	let if_block0 = typeof /*after*/ ctx[6] !== "undefined" && create_if_block_13$2(ctx);
	let if_block1 = typeof /*badge*/ ctx[7] !== "undefined" && create_if_block_12$2(ctx);
	const after_slot_template = /*#slots*/ ctx[66].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[80], get_after_slot_context);
	const after_end_slot_template = /*#slots*/ ctx[66]["after-end"];
	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[80], get_after_end_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			if (after_start_slot) after_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (after_slot) after_slot.c();
			t3 = space();
			if (after_end_slot) after_end_slot.c();
			attr_dev(div, "class", "item-after");
			add_location(div, file$F, 409, 22, 13827);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (after_start_slot) {
				after_start_slot.m(div, null);
			}

			append_dev(div, t0);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t1);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t2);

			if (after_slot) {
				after_slot.m(div, null);
			}

			append_dev(div, t3);

			if (after_end_slot) {
				after_end_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (after_start_slot) {
				if (after_start_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_start_slot, after_start_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_start_slot_changes, get_after_start_slot_context);
				}
			}

			if (typeof /*after*/ ctx[6] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_13$2(ctx);
					if_block0.c();
					if_block0.m(div, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*badge*/ ctx[7] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*badge*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_12$2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t2);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (after_slot) {
				if (after_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_slot, after_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_slot_changes, get_after_slot_context);
				}
			}

			if (after_end_slot) {
				if (after_end_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(after_end_slot, after_end_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_after_end_slot_changes, get_after_end_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(after_start_slot, local);
			transition_in(if_block1);
			transition_in(after_slot, local);
			transition_in(after_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(after_start_slot, local);
			transition_out(if_block1);
			transition_out(after_slot, local);
			transition_out(after_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (after_start_slot) after_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (after_slot) after_slot.d(detaching);
			if (after_end_slot) after_end_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_11$2.name,
		type: "if",
		source: "(409:20) {#if hasAfter}",
		ctx
	});

	return block;
}

// (412:24) {#if typeof after !== 'undefined'}
function create_if_block_13$2(ctx) {
	let span;
	let t_value = Utils.text(/*after*/ ctx[6]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			add_location(span, file$F, 412, 26, 13989);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*after*/ 64 && t_value !== (t_value = Utils.text(/*after*/ ctx[6]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_13$2.name,
		type: "if",
		source: "(412:24) {#if typeof after !== 'undefined'}",
		ctx
	});

	return block;
}

// (415:24) {#if typeof badge !== 'undefined'}
function create_if_block_12$2(ctx) {
	let badge_1;
	let current;

	badge_1 = new Badge({
			props: {
				color: /*badgeColor*/ ctx[8],
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(badge_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(badge_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const badge_1_changes = {};
			if (dirty[0] & /*badgeColor*/ 256) badge_1_changes.color = /*badgeColor*/ ctx[8];

			if (dirty[0] & /*badge*/ 128 | dirty[2] & /*$$scope*/ 262144) {
				badge_1_changes.$$scope = { dirty, ctx };
			}

			badge_1.$set(badge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(badge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(badge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(badge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_12$2.name,
		type: "if",
		source: "(415:24) {#if typeof badge !== 'undefined'}",
		ctx
	});

	return block;
}

// (416:26) <Badge color={badgeColor}>
function create_default_slot$2(ctx) {
	let t_value = Utils.text(/*badge*/ ctx[7]) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*badge*/ 128 && t_value !== (t_value = Utils.text(/*badge*/ ctx[7]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(416:26) <Badge color={badgeColor}>",
		ctx
	});

	return block;
}

// (423:18) {#if hasSubtitle}
function create_if_block_10$2(ctx) {
	let div;
	let t0_value = Utils.text(/*subtitle*/ ctx[3]) + "";
	let t0;
	let t1;
	let current;
	const subtitle_slot_template = /*#slots*/ ctx[66].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[80], get_subtitle_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (subtitle_slot) subtitle_slot.c();
			attr_dev(div, "class", "item-subtitle");
			add_location(div, file$F, 423, 20, 14453);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*subtitle*/ 8) && t0_value !== (t0_value = Utils.text(/*subtitle*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

			if (subtitle_slot) {
				if (subtitle_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(subtitle_slot, subtitle_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_subtitle_slot_changes, get_subtitle_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10$2.name,
		type: "if",
		source: "(423:18) {#if hasSubtitle}",
		ctx
	});

	return block;
}

// (429:18) {#if hasText}
function create_if_block_9$2(ctx) {
	let div;
	let t0_value = Utils.text(/*text*/ ctx[1]) + "";
	let t0;
	let t1;
	let current;
	const text_slot_template = /*#slots*/ ctx[66].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[80], get_text_slot_context$2);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_slot) text_slot.c();
			attr_dev(div, "class", "item-text");
			add_location(div, file$F, 429, 20, 14676);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 2) && t0_value !== (t0_value = Utils.text(/*text*/ ctx[1]) + "")) set_data_dev(t0, t0_value);

			if (text_slot) {
				if (text_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_text_slot_changes$2, get_text_slot_context$2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (text_slot) text_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9$2.name,
		type: "if",
		source: "(429:18) {#if hasText}",
		ctx
	});

	return block;
}

// (436:18) {#if !(swipeout || accordionItem)}
function create_if_block_8$2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8$2.name,
		type: "if",
		source: "(436:18) {#if !(swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (439:18) {#if hasFooter}
function create_if_block_7$2(ctx) {
	let div;
	let t0_value = Utils.text(/*footer*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	const footer_slot_template = /*#slots*/ ctx[66].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[80], get_footer_slot_context$1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "item-footer");
			add_location(div, file$F, 439, 20, 15035);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 32) && t0_value !== (t0_value = Utils.text(/*footer*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[80], dirty, get_footer_slot_changes$1, get_footer_slot_context$1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7$2.name,
		type: "if",
		source: "(439:18) {#if hasFooter}",
		ctx
	});

	return block;
}

// (1092:4) {#if (isSortable && sortable !== false && !isSortableOpposite)}
function create_if_block_3$7(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "sortable-handler");
			add_location(div, file$F, 1092, 6, 40001);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$7.name,
		type: "if",
		source: "(1092:4) {#if (isSortable && sortable !== false && !isSortableOpposite)}",
		ctx
	});

	return block;
}

// (1095:4) {#if (swipeout || accordionItem)}
function create_if_block_2$8(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[66].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[80], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[2] & /*$$scope*/ 262144) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[80], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$8.name,
		type: "if",
		source: "(1095:4) {#if (swipeout || accordionItem)}",
		ctx
	});

	return block;
}

// (363:16) {Utils.text(title)}
function fallback_block$1(ctx) {
	let t_value = Utils.text(/*title*/ ctx[0]) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*title*/ 1 && t_value !== (t_value = Utils.text(/*title*/ ctx[0]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$1.name,
		type: "fallback",
		source: "(363:16) {Utils.text(title)}",
		ctx
	});

	return block;
}

function create_fragment$F(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$d, create_if_block_1$8, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*divider*/ ctx[9] || /*groupTitle*/ ctx[10]) return 0;
		if (/*isSimple*/ ctx[30]) return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$F.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$A($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","title","text","media","subtitle","header","footer","tooltip","tooltipTrigger","link","tabLink","tabLinkActive","href","target","after","badge","badgeColor","mediaItem","mediaList","divider","groupTitle","swipeout","swipeoutOpened","sortable","sortableOpposite","accordionItem","accordionItemOpened","smartSelect","smartSelectParams","noChevron","chevronCenter","checkbox","radio","radioIcon","checked","indeterminate","name","value","readonly","required","disabled","virtualListIndex","smartSelectInstance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;

	validate_slots("List_item", slots, [
		'default','root-start','content-start','media','inner-start','header','before-title','title','after-title','after-start','after','after-end','subtitle','text','inner','footer','inner-end','content','content-end','root','root-end'
	]);

	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { title = undefined } = $$props;
	let { text = undefined } = $$props;
	let { media = undefined } = $$props;
	let { subtitle = undefined } = $$props;
	let { header = undefined } = $$props;
	let { footer = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { tooltipTrigger = undefined } = $$props;
	let { link = undefined } = $$props;
	let { tabLink = undefined } = $$props;
	let { tabLinkActive = false } = $$props;
	let { href = undefined } = $$props;
	let { target = undefined } = $$props;
	let { after = undefined } = $$props;
	let { badge = undefined } = $$props;
	let { badgeColor = undefined } = $$props;
	let { mediaItem = false } = $$props;
	let { mediaList = false } = $$props;
	let { divider = false } = $$props;
	let { groupTitle = false } = $$props;
	let { swipeout = false } = $$props;
	let { swipeoutOpened = false } = $$props;
	let { sortable = undefined } = $$props;
	let { sortableOpposite = undefined } = $$props;
	let { accordionItem = false } = $$props;
	let { accordionItemOpened = false } = $$props;
	let { smartSelect = false } = $$props;
	let { smartSelectParams = undefined } = $$props;
	let { noChevron = undefined } = $$props;
	let { chevronCenter = undefined } = $$props;
	let { checkbox = undefined } = $$props;
	let { radio = undefined } = $$props;
	let { radioIcon = undefined } = $$props;
	let { checked = undefined } = $$props;
	let { indeterminate = undefined } = $$props;
	let { name = undefined } = $$props;
	let { value = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let { required = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { virtualListIndex = undefined } = $$props;
	let el;
	let linkEl;
	let innerEl;
	let inputEl;
	let f7SmartSelect;
	let f7Tooltip;

	function smartSelectInstance() {
		return f7SmartSelect;
	}

	/* eslint-enable no-undef */
	let tooltipText = tooltip;

	function watchTooltip(newText) {
		const oldText = tooltipText;
		if (oldText === newText) return;
		tooltipText = newText;

		if (!newText && f7Tooltip) {
			f7Tooltip.destroy();
			f7Tooltip = null;
			return;
		}

		if (newText && !f7Tooltip && f7.instance) {
			f7Tooltip = f7.instance.tooltip.create({
				targetEl: el,
				text: newText,
				trigger: tooltipTrigger
			});

			return;
		}

		if (!newText || !f7Tooltip) return;
		f7Tooltip.setText(newText);
	}

	let initialWatchedOpened = false;

	function watchSwipeoutOpened(opened) {
		if (!initialWatchedOpened) {
			initialWatchedOpened = true;
			return;
		}

		if (!swipeout) return;

		if (opened) {
			f7.instance.swipeout.open(el);
		} else {
			f7.instance.swipeout.close(el);
		}
	}

	function onClick(event) {
		if (event.target.tagName.toLowerCase() !== "input") {
			dispatch("click", event);
			if (typeof $$props.onClick === "function") $$props.onClick(event);
		}
	}

	function onSwipeoutOverswipeEnter(eventEl) {
		if (eventEl !== el) return;
		dispatch("swipeoutOverswipeEnter");
		if (typeof $$props.onSwipeoutOverswipeEnter === "function") $$props.onSwipeoutOverswipeEnter();
	}

	function onSwipeoutOverswipeExit(eventEl) {
		if (eventEl !== el) return;
		dispatch("swipeoutOverswipeExit");
		if (typeof $$props.onSwipeoutOverswipeExit === "function") $$props.onSwipeoutOverswipeExit();
	}

	function onSwipeoutDeleted(eventEl) {
		if (eventEl !== el) return;
		dispatch("swipeoutDeleted");
		if (typeof $$props.onSwipeoutDeleted === "function") $$props.onSwipeoutDeleted();
	}

	function onSwipeoutDelete(eventEl) {
		if (eventEl !== el) return;
		dispatch("swipeoutDelete");
		if (typeof $$props.onSwipeoutDelete === "function") $$props.onSwipeoutDelete();
	}

	function onSwipeoutClose(eventEl) {
		if (eventEl !== el) return;
		dispatch("swipeoutClose");
		if (typeof $$props.onSwipeoutClose === "function") $$props.onSwipeoutClose();
	}

	function onSwipeoutClosed(eventEl) {
		if (eventEl !== el) return;
		dispatch("swipeoutClosed");
		if (typeof $$props.onSwipeoutClosed === "function") $$props.onSwipeoutClosed();
	}

	function onSwipeoutOpen(eventEl) {
		if (eventEl !== el) return;
		dispatch("swipeoutOpen");
		if (typeof $$props.onSwipeoutOpen === "function") $$props.onSwipeoutOpen();
	}

	function onSwipeoutOpened(eventEl) {
		if (eventEl !== el) return;
		dispatch("swipeoutOpened");
		if (typeof $$props.onSwipeoutOpened === "function") $$props.onSwipeoutOpened();
	}

	function onSwipeout(eventEl, progress) {
		if (eventEl !== el) return;
		dispatch("swipeout", progress);
	}

	function onAccBeforeClose(eventEl, prevent) {
		if (eventEl !== el) return;
		dispatch("accordionBeforeClose", [prevent]);
		if (typeof $$props.onAccordionBeforeClose === "function") $$props.onAccordionBeforeClose(prevent);
	}

	function onAccClose(eventEl) {
		if (eventEl !== el) return;
		dispatch("accordionClose");
		if (typeof $$props.onAccordionClose === "function") $$props.onAccordionClose();
	}

	function onAccClosed(eventEl) {
		if (eventEl !== el) return;
		dispatch("accordionClosed");
		if (typeof $$props.onAccordionClosed === "function") $$props.onAccordionClosed();
	}

	function onAccBeforeOpen(eventEl, prevent) {
		if (eventEl !== el) return;
		dispatch("accordionBeforeOpen", [prevent]);
		if (typeof $$props.onAccordionBeforeOpen === "function") $$props.onAccordionBeforeOpen(prevent);
	}

	function onAccOpen(eventEl) {
		if (eventEl !== el) return;
		dispatch("accordionOpen");
		if (typeof $$props.onAccordionOpen === "function") $$props.onAccordionOpen();
	}

	function onAccOpened(eventEl) {
		if (eventEl !== el) return;
		dispatch("accordionOpened");
		if (typeof $$props.onAccordionOpened === "function") $$props.onAccordionOpened();
	}

	function onChange(event) {
		dispatch("change", [event]);
		if (typeof $$props.onChange === "function") $$props.onChange(event);
	}

	onMount(() => {
		if (linkEl && $$props.routeProps) {
			$$invalidate(25, linkEl.f7RouteProps = $$props.routeProps, linkEl);
		}

		if (indeterminate && inputEl) {
			$$invalidate(27, inputEl.indeterminate = true, inputEl);
		}

		f7.ready(() => {
			if (swipeout) {
				f7.instance.on("swipeoutOpen", onSwipeoutOpen);
				f7.instance.on("swipeoutOpened", onSwipeoutOpened);
				f7.instance.on("swipeoutClose", onSwipeoutClose);
				f7.instance.on("swipeoutClosed", onSwipeoutClosed);
				f7.instance.on("swipeoutDelete", onSwipeoutDelete);
				f7.instance.on("swipeoutDeleted", onSwipeoutDeleted);
				f7.instance.on("swipeoutOverswipeEnter", onSwipeoutOverswipeEnter);
				f7.instance.on("swipeoutOverswipeExit", onSwipeoutOverswipeExit);
				f7.instance.on("swipeout", onSwipeout);
			}

			if (accordionItem) {
				f7.instance.on("accordionBeforeOpen", onAccBeforeOpen);
				f7.instance.on("accordionOpen", onAccOpen);
				f7.instance.on("accordionOpened", onAccOpened);
				f7.instance.on("accordionBeforeClose", onAccBeforeClose);
				f7.instance.on("accordionClose", onAccClose);
				f7.instance.on("accordionClosed", onAccClosed);
			}

			if (linkEl && smartSelect) {
				const ssParams = Utils.extend({ el: linkEl }, smartSelectParams || {});
				f7SmartSelect = f7.instance.smartSelect.create(ssParams);
			}

			if (swipeoutOpened) {
				f7.instance.swipeout.open(el);
			}

			if (tooltip) {
				f7Tooltip = f7.instance.tooltip.create({
					targetEl: el,
					text: tooltip,
					trigger: tooltipTrigger
				});
			}
		});
	});

	afterUpdate(() => {
		if (linkEl && $$props.routeProps) {
			$$invalidate(25, linkEl.f7RouteProps = $$props.routeProps, linkEl);
		}

		if (inputEl) {
			$$invalidate(27, inputEl.indeterminate = indeterminate, inputEl);
		}
	});

	onDestroy(() => {
		if (linkEl) {
			delete linkEl.f7RouteProps;
		}

		if (!f7.instance) return;

		if (swipeout) {
			f7.instance.off("swipeoutOpen", onSwipeoutOpen);
			f7.instance.off("swipeoutOpened", onSwipeoutOpened);
			f7.instance.off("swipeoutClose", onSwipeoutClose);
			f7.instance.off("swipeoutClosed", onSwipeoutClosed);
			f7.instance.off("swipeoutDelete", onSwipeoutDelete);
			f7.instance.off("swipeoutDeleted", onSwipeoutDeleted);
			f7.instance.off("swipeoutOverswipeEnter", onSwipeoutOverswipeEnter);
			f7.instance.off("swipeoutOverswipeExit", onSwipeoutOverswipeExit);
			f7.instance.off("swipeout", onSwipeout);
		}

		if (accordionItem) {
			f7.instance.off("accordionBeforeOpen", onAccBeforeOpen);
			f7.instance.off("accordionOpen", onAccOpen);
			f7.instance.off("accordionOpened", onAccOpened);
			f7.instance.off("accordionBeforeClose", onAccBeforeClose);
			f7.instance.off("accordionClose", onAccClose);
			f7.instance.off("accordionClosed", onAccClosed);
		}

		if (f7SmartSelect && f7SmartSelect.destroy) {
			f7SmartSelect.destroy();
			f7SmartSelect = null;
		}

		if (f7Tooltip && f7Tooltip.destroy) {
			f7Tooltip.destroy();
			f7Tooltip = null;
		}
	});

	function li_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(24, el);
		});
	}

	function li_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(24, el);
		});
	}

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			innerEl = $$value;
			$$invalidate(26, innerEl);
		});
	}

	function a_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			linkEl = $$value;
			$$invalidate(25, linkEl);
		});
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(27, inputEl);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			innerEl = $$value;
			$$invalidate(26, innerEl);
		});
	}

	function div0_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			innerEl = $$value;
			$$invalidate(26, innerEl);
		});
	}

	function div0_binding_2($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			innerEl = $$value;
			$$invalidate(26, innerEl);
		});
	}

	function a_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			linkEl = $$value;
			$$invalidate(25, linkEl);
		});
	}

	function input_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(27, inputEl);
		});
	}

	function div_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			innerEl = $$value;
			$$invalidate(26, innerEl);
		});
	}

	function div0_binding_3($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			innerEl = $$value;
			$$invalidate(26, innerEl);
		});
	}

	function li_binding_2($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(24, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(103, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(45, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(46, className = $$new_props.class);
		if ("title" in $$new_props) $$invalidate(0, title = $$new_props.title);
		if ("text" in $$new_props) $$invalidate(1, text = $$new_props.text);
		if ("media" in $$new_props) $$invalidate(2, media = $$new_props.media);
		if ("subtitle" in $$new_props) $$invalidate(3, subtitle = $$new_props.subtitle);
		if ("header" in $$new_props) $$invalidate(4, header = $$new_props.header);
		if ("footer" in $$new_props) $$invalidate(5, footer = $$new_props.footer);
		if ("tooltip" in $$new_props) $$invalidate(47, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$new_props) $$invalidate(48, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("link" in $$new_props) $$invalidate(49, link = $$new_props.link);
		if ("tabLink" in $$new_props) $$invalidate(50, tabLink = $$new_props.tabLink);
		if ("tabLinkActive" in $$new_props) $$invalidate(51, tabLinkActive = $$new_props.tabLinkActive);
		if ("href" in $$new_props) $$invalidate(52, href = $$new_props.href);
		if ("target" in $$new_props) $$invalidate(53, target = $$new_props.target);
		if ("after" in $$new_props) $$invalidate(6, after = $$new_props.after);
		if ("badge" in $$new_props) $$invalidate(7, badge = $$new_props.badge);
		if ("badgeColor" in $$new_props) $$invalidate(8, badgeColor = $$new_props.badgeColor);
		if ("mediaItem" in $$new_props) $$invalidate(54, mediaItem = $$new_props.mediaItem);
		if ("mediaList" in $$new_props) $$invalidate(55, mediaList = $$new_props.mediaList);
		if ("divider" in $$new_props) $$invalidate(9, divider = $$new_props.divider);
		if ("groupTitle" in $$new_props) $$invalidate(10, groupTitle = $$new_props.groupTitle);
		if ("swipeout" in $$new_props) $$invalidate(11, swipeout = $$new_props.swipeout);
		if ("swipeoutOpened" in $$new_props) $$invalidate(56, swipeoutOpened = $$new_props.swipeoutOpened);
		if ("sortable" in $$new_props) $$invalidate(12, sortable = $$new_props.sortable);
		if ("sortableOpposite" in $$new_props) $$invalidate(57, sortableOpposite = $$new_props.sortableOpposite);
		if ("accordionItem" in $$new_props) $$invalidate(13, accordionItem = $$new_props.accordionItem);
		if ("accordionItemOpened" in $$new_props) $$invalidate(58, accordionItemOpened = $$new_props.accordionItemOpened);
		if ("smartSelect" in $$new_props) $$invalidate(59, smartSelect = $$new_props.smartSelect);
		if ("smartSelectParams" in $$new_props) $$invalidate(60, smartSelectParams = $$new_props.smartSelectParams);
		if ("noChevron" in $$new_props) $$invalidate(61, noChevron = $$new_props.noChevron);
		if ("chevronCenter" in $$new_props) $$invalidate(62, chevronCenter = $$new_props.chevronCenter);
		if ("checkbox" in $$new_props) $$invalidate(14, checkbox = $$new_props.checkbox);
		if ("radio" in $$new_props) $$invalidate(15, radio = $$new_props.radio);
		if ("radioIcon" in $$new_props) $$invalidate(63, radioIcon = $$new_props.radioIcon);
		if ("checked" in $$new_props) $$invalidate(16, checked = $$new_props.checked);
		if ("indeterminate" in $$new_props) $$invalidate(64, indeterminate = $$new_props.indeterminate);
		if ("name" in $$new_props) $$invalidate(17, name = $$new_props.name);
		if ("value" in $$new_props) $$invalidate(18, value = $$new_props.value);
		if ("readonly" in $$new_props) $$invalidate(19, readonly = $$new_props.readonly);
		if ("required" in $$new_props) $$invalidate(20, required = $$new_props.required);
		if ("disabled" in $$new_props) $$invalidate(21, disabled = $$new_props.disabled);
		if ("virtualListIndex" in $$new_props) $$invalidate(22, virtualListIndex = $$new_props.virtualListIndex);
		if ("$$scope" in $$new_props) $$invalidate(80, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		afterUpdate,
		getContext,
		Mixins,
		Utils,
		restProps,
		f7,
		hasSlots,
		Badge,
		dispatch,
		className,
		title,
		text,
		media,
		subtitle,
		header,
		footer,
		tooltip,
		tooltipTrigger,
		link,
		tabLink,
		tabLinkActive,
		href,
		target,
		after,
		badge,
		badgeColor,
		mediaItem,
		mediaList,
		divider,
		groupTitle,
		swipeout,
		swipeoutOpened,
		sortable,
		sortableOpposite,
		accordionItem,
		accordionItemOpened,
		smartSelect,
		smartSelectParams,
		noChevron,
		chevronCenter,
		checkbox,
		radio,
		radioIcon,
		checked,
		indeterminate,
		name,
		value,
		readonly,
		required,
		disabled,
		virtualListIndex,
		el,
		linkEl,
		innerEl,
		inputEl,
		f7SmartSelect,
		f7Tooltip,
		smartSelectInstance,
		tooltipText,
		watchTooltip,
		initialWatchedOpened,
		watchSwipeoutOpened,
		onClick,
		onSwipeoutOverswipeEnter,
		onSwipeoutOverswipeExit,
		onSwipeoutDeleted,
		onSwipeoutDelete,
		onSwipeoutClose,
		onSwipeoutClosed,
		onSwipeoutOpen,
		onSwipeoutOpened,
		onSwipeout,
		onAccBeforeClose,
		onAccClose,
		onAccClosed,
		onAccBeforeOpen,
		onAccOpen,
		onAccOpened,
		onChange,
		isMedia,
		isSortable,
		isSortableOpposite,
		isSimple,
		liClasses,
		contentClasses,
		linkClasses,
		linkAttrs,
		isLink,
		hasMedia,
		hasTitle,
		hasHeader,
		hasFooter,
		hasSubtitle,
		hasText,
		hasAfter
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(103, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(46, className = $$new_props.className);
		if ("title" in $$props) $$invalidate(0, title = $$new_props.title);
		if ("text" in $$props) $$invalidate(1, text = $$new_props.text);
		if ("media" in $$props) $$invalidate(2, media = $$new_props.media);
		if ("subtitle" in $$props) $$invalidate(3, subtitle = $$new_props.subtitle);
		if ("header" in $$props) $$invalidate(4, header = $$new_props.header);
		if ("footer" in $$props) $$invalidate(5, footer = $$new_props.footer);
		if ("tooltip" in $$props) $$invalidate(47, tooltip = $$new_props.tooltip);
		if ("tooltipTrigger" in $$props) $$invalidate(48, tooltipTrigger = $$new_props.tooltipTrigger);
		if ("link" in $$props) $$invalidate(49, link = $$new_props.link);
		if ("tabLink" in $$props) $$invalidate(50, tabLink = $$new_props.tabLink);
		if ("tabLinkActive" in $$props) $$invalidate(51, tabLinkActive = $$new_props.tabLinkActive);
		if ("href" in $$props) $$invalidate(52, href = $$new_props.href);
		if ("target" in $$props) $$invalidate(53, target = $$new_props.target);
		if ("after" in $$props) $$invalidate(6, after = $$new_props.after);
		if ("badge" in $$props) $$invalidate(7, badge = $$new_props.badge);
		if ("badgeColor" in $$props) $$invalidate(8, badgeColor = $$new_props.badgeColor);
		if ("mediaItem" in $$props) $$invalidate(54, mediaItem = $$new_props.mediaItem);
		if ("mediaList" in $$props) $$invalidate(55, mediaList = $$new_props.mediaList);
		if ("divider" in $$props) $$invalidate(9, divider = $$new_props.divider);
		if ("groupTitle" in $$props) $$invalidate(10, groupTitle = $$new_props.groupTitle);
		if ("swipeout" in $$props) $$invalidate(11, swipeout = $$new_props.swipeout);
		if ("swipeoutOpened" in $$props) $$invalidate(56, swipeoutOpened = $$new_props.swipeoutOpened);
		if ("sortable" in $$props) $$invalidate(12, sortable = $$new_props.sortable);
		if ("sortableOpposite" in $$props) $$invalidate(57, sortableOpposite = $$new_props.sortableOpposite);
		if ("accordionItem" in $$props) $$invalidate(13, accordionItem = $$new_props.accordionItem);
		if ("accordionItemOpened" in $$props) $$invalidate(58, accordionItemOpened = $$new_props.accordionItemOpened);
		if ("smartSelect" in $$props) $$invalidate(59, smartSelect = $$new_props.smartSelect);
		if ("smartSelectParams" in $$props) $$invalidate(60, smartSelectParams = $$new_props.smartSelectParams);
		if ("noChevron" in $$props) $$invalidate(61, noChevron = $$new_props.noChevron);
		if ("chevronCenter" in $$props) $$invalidate(62, chevronCenter = $$new_props.chevronCenter);
		if ("checkbox" in $$props) $$invalidate(14, checkbox = $$new_props.checkbox);
		if ("radio" in $$props) $$invalidate(15, radio = $$new_props.radio);
		if ("radioIcon" in $$props) $$invalidate(63, radioIcon = $$new_props.radioIcon);
		if ("checked" in $$props) $$invalidate(16, checked = $$new_props.checked);
		if ("indeterminate" in $$props) $$invalidate(64, indeterminate = $$new_props.indeterminate);
		if ("name" in $$props) $$invalidate(17, name = $$new_props.name);
		if ("value" in $$props) $$invalidate(18, value = $$new_props.value);
		if ("readonly" in $$props) $$invalidate(19, readonly = $$new_props.readonly);
		if ("required" in $$props) $$invalidate(20, required = $$new_props.required);
		if ("disabled" in $$props) $$invalidate(21, disabled = $$new_props.disabled);
		if ("virtualListIndex" in $$props) $$invalidate(22, virtualListIndex = $$new_props.virtualListIndex);
		if ("el" in $$props) $$invalidate(24, el = $$new_props.el);
		if ("linkEl" in $$props) $$invalidate(25, linkEl = $$new_props.linkEl);
		if ("innerEl" in $$props) $$invalidate(26, innerEl = $$new_props.innerEl);
		if ("inputEl" in $$props) $$invalidate(27, inputEl = $$new_props.inputEl);
		if ("f7SmartSelect" in $$props) f7SmartSelect = $$new_props.f7SmartSelect;
		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
		if ("initialWatchedOpened" in $$props) initialWatchedOpened = $$new_props.initialWatchedOpened;
		if ("isMedia" in $$props) $$invalidate(23, isMedia = $$new_props.isMedia);
		if ("isSortable" in $$props) $$invalidate(28, isSortable = $$new_props.isSortable);
		if ("isSortableOpposite" in $$props) $$invalidate(29, isSortableOpposite = $$new_props.isSortableOpposite);
		if ("isSimple" in $$props) $$invalidate(30, isSimple = $$new_props.isSimple);
		if ("liClasses" in $$props) $$invalidate(31, liClasses = $$new_props.liClasses);
		if ("contentClasses" in $$props) $$invalidate(32, contentClasses = $$new_props.contentClasses);
		if ("linkClasses" in $$props) $$invalidate(33, linkClasses = $$new_props.linkClasses);
		if ("linkAttrs" in $$props) $$invalidate(34, linkAttrs = $$new_props.linkAttrs);
		if ("isLink" in $$props) $$invalidate(35, isLink = $$new_props.isLink);
		if ("hasMedia" in $$props) $$invalidate(36, hasMedia = $$new_props.hasMedia);
		if ("hasTitle" in $$props) $$invalidate(37, hasTitle = $$new_props.hasTitle);
		if ("hasHeader" in $$props) $$invalidate(38, hasHeader = $$new_props.hasHeader);
		if ("hasFooter" in $$props) $$invalidate(39, hasFooter = $$new_props.hasFooter);
		if ("hasSubtitle" in $$props) $$invalidate(40, hasSubtitle = $$new_props.hasSubtitle);
		if ("hasText" in $$props) $$invalidate(41, hasText = $$new_props.hasText);
		if ("hasAfter" in $$props) $$invalidate(42, hasAfter = $$new_props.hasAfter);
	};

	let isMedia;
	let isSortable;
	let isSortableOpposite;
	let isSimple;
	let liClasses;
	let contentClasses;
	let linkClasses;
	let linkAttrs;
	let isLink;
	let hasMedia;
	let hasTitle;
	let hasHeader;
	let hasFooter;
	let hasSubtitle;
	let hasText;
	let hasAfter;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[1] & /*mediaList, mediaItem*/ 25165824) {
			 $$invalidate(23, isMedia = mediaList || mediaItem || getContext("f7ListMedia"));
		}

		if ($$self.$$.dirty[0] & /*sortable*/ 4096) {
			 $$invalidate(28, isSortable = sortable || getContext("f7ListSortable"));
		}

		if ($$self.$$.dirty[1] & /*sortableOpposite*/ 67108864) {
			 $$invalidate(29, isSortableOpposite = sortableOpposite || getContext("f7ListSortableOpposite"));
		}

		 $$invalidate(31, liClasses = Utils.classNames(
			className,
			{
				"item-divider": divider,
				"list-group-title": groupTitle,
				"media-item": isMedia,
				swipeout,
				"accordion-item": accordionItem,
				"accordion-item-opened": accordionItemOpened,
				disabled: disabled && !(radio || checkbox),
				"no-chevron": noChevron,
				"chevron-center": chevronCenter,
				"disallow-sorting": sortable === false
			},
			Mixins.colorClasses($$props)
		));

		 $$invalidate(32, contentClasses = Utils.classNames(
			className,
			"item-content",
			{
				"item-checkbox": checkbox,
				"item-radio": radio,
				"item-radio-icon-start": radio && radioIcon === "start",
				"item-radio-icon-end": radio && radioIcon === "end"
			},
			Mixins.colorClasses($$props)
		));

		 $$invalidate(33, linkClasses = Utils.classNames(
			{
				"item-link": true,
				"smart-select": smartSelect,
				"tab-link": tabLink || tabLink === "",
				"tab-link-active": tabLinkActive
			},
			Mixins.linkRouterClasses($$props),
			Mixins.linkActionsClasses($$props)
		));

		 $$invalidate(34, linkAttrs = {
			href: link === true ? "" : link || href,
			target,
			"data-tab": Utils.isStringProp(tabLink) && tabLink || undefined,
			...Mixins.linkRouterAttrs($$props),
			...Mixins.linkActionsAttrs($$props)
		});

		if ($$self.$$.dirty[0] & /*accordionItem*/ 8192 | $$self.$$.dirty[1] & /*link, href, smartSelect*/ 270794752) {
			 $$invalidate(35, isLink = link || href || smartSelect || accordionItem);
		}

		if ($$self.$$.dirty[0] & /*media*/ 4) {
			/* eslint-disable no-undef */
			 $$invalidate(36, hasMedia = typeof media !== "undefined" || hasSlots(arguments, "media"));
		}

		if ($$self.$$.dirty[0] & /*title*/ 1) {
			 $$invalidate(37, hasTitle = typeof title !== "undefined" || hasSlots(arguments, "title"));
		}

		if ($$self.$$.dirty[0] & /*header*/ 16) {
			 $$invalidate(38, hasHeader = typeof header !== "undefined" || hasSlots(arguments, "header"));
		}

		if ($$self.$$.dirty[0] & /*footer*/ 32) {
			 $$invalidate(39, hasFooter = typeof footer !== "undefined" || hasSlots(arguments, "footer"));
		}

		if ($$self.$$.dirty[0] & /*subtitle*/ 8) {
			 $$invalidate(40, hasSubtitle = typeof subtitle !== "undefined" || hasSlots(arguments, "subtitle"));
		}

		if ($$self.$$.dirty[0] & /*text*/ 2) {
			 $$invalidate(41, hasText = typeof text !== "undefined" || hasSlots(arguments, "text"));
		}

		if ($$self.$$.dirty[0] & /*after, badge*/ 192) {
			 $$invalidate(42, hasAfter = typeof after !== "undefined" || typeof badge !== "undefined" || hasSlots(arguments, "after"));
		}

		if ($$self.$$.dirty[1] & /*tooltip*/ 65536) {
			 watchTooltip(tooltip);
		}

		if ($$self.$$.dirty[1] & /*swipeoutOpened*/ 33554432) {
			 watchSwipeoutOpened(swipeoutOpened);
		}
	};

	 $$invalidate(30, isSimple = getContext("f7ListSimple"));
	$$props = exclude_internal_props($$props);

	return [
		title,
		text,
		media,
		subtitle,
		header,
		footer,
		after,
		badge,
		badgeColor,
		divider,
		groupTitle,
		swipeout,
		sortable,
		accordionItem,
		checkbox,
		radio,
		checked,
		name,
		value,
		readonly,
		required,
		disabled,
		virtualListIndex,
		isMedia,
		el,
		linkEl,
		innerEl,
		inputEl,
		isSortable,
		isSortableOpposite,
		isSimple,
		liClasses,
		contentClasses,
		linkClasses,
		linkAttrs,
		isLink,
		hasMedia,
		hasTitle,
		hasHeader,
		hasFooter,
		hasSubtitle,
		hasText,
		hasAfter,
		onClick,
		onChange,
		$$restProps,
		className,
		tooltip,
		tooltipTrigger,
		link,
		tabLink,
		tabLinkActive,
		href,
		target,
		mediaItem,
		mediaList,
		swipeoutOpened,
		sortableOpposite,
		accordionItemOpened,
		smartSelect,
		smartSelectParams,
		noChevron,
		chevronCenter,
		radioIcon,
		indeterminate,
		smartSelectInstance,
		slots,
		li_binding,
		li_binding_1,
		div0_binding,
		a_binding,
		input_binding,
		div_binding,
		div0_binding_1,
		div0_binding_2,
		a_binding_1,
		input_binding_1,
		div_binding_1,
		div0_binding_3,
		li_binding_2,
		$$scope
	];
}

class List_item extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$A,
			create_fragment$F,
			safe_not_equal,
			{
				class: 46,
				title: 0,
				text: 1,
				media: 2,
				subtitle: 3,
				header: 4,
				footer: 5,
				tooltip: 47,
				tooltipTrigger: 48,
				link: 49,
				tabLink: 50,
				tabLinkActive: 51,
				href: 52,
				target: 53,
				after: 6,
				badge: 7,
				badgeColor: 8,
				mediaItem: 54,
				mediaList: 55,
				divider: 9,
				groupTitle: 10,
				swipeout: 11,
				swipeoutOpened: 56,
				sortable: 12,
				sortableOpposite: 57,
				accordionItem: 13,
				accordionItemOpened: 58,
				smartSelect: 59,
				smartSelectParams: 60,
				noChevron: 61,
				chevronCenter: 62,
				checkbox: 14,
				radio: 15,
				radioIcon: 63,
				checked: 16,
				indeterminate: 64,
				name: 17,
				value: 18,
				readonly: 19,
				required: 20,
				disabled: 21,
				virtualListIndex: 22,
				smartSelectInstance: 65
			},
			[-1, -1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "List_item",
			options,
			id: create_fragment$F.name
		});
	}

	get class() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get media() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set media(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtitle() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtitle(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get header() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set header(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get footer() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set footer(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltip() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltip(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tooltipTrigger() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tooltipTrigger(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get link() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set link(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabLink() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabLink(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabLinkActive() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabLinkActive(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get target() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set target(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get after() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set after(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get badge() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set badge(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get badgeColor() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set badgeColor(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mediaItem() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mediaItem(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mediaList() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mediaList(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get divider() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set divider(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get groupTitle() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set groupTitle(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeout() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeout(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeoutOpened() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeoutOpened(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortable() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortable(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortableOpposite() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortableOpposite(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accordionItem() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accordionItem(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accordionItemOpened() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accordionItemOpened(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smartSelect() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smartSelect(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smartSelectParams() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smartSelectParams(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noChevron() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noChevron(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get chevronCenter() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set chevronCenter(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checkbox() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checkbox(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get radio() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set radio(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get radioIcon() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set radioIcon(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get indeterminate() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set indeterminate(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get required() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set required(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get virtualListIndex() {
		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set virtualListIndex(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smartSelectInstance() {
		return this.$$.ctx[65];
	}

	set smartSelectInstance(value) {
		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/list.svelte generated by Svelte v3.31.0 */
const file$G = "node_modules/framework7-svelte/components/list.svelte";
const get_after_list_slot_changes_1 = dirty => ({});
const get_after_list_slot_context_1 = ctx => ({});
const get_list_slot_changes_1 = dirty => ({});
const get_list_slot_context_1 = ctx => ({});
const get_before_list_slot_changes_1 = dirty => ({});
const get_before_list_slot_context_1 = ctx => ({});
const get_after_list_slot_changes = dirty => ({});
const get_after_list_slot_context = ctx => ({});
const get_list_slot_changes = dirty => ({});
const get_list_slot_context = ctx => ({});
const get_before_list_slot_changes = dirty => ({});
const get_before_list_slot_context = ctx => ({});

// (219:0) {:else}
function create_else_block_1$3(ctx) {
	let div;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let div_data_sortable_move_elements_value;
	let current;
	const before_list_slot_template = /*#slots*/ ctx[43]["before-list"];
	const before_list_slot = create_slot(before_list_slot_template, ctx, /*$$scope*/ ctx[42], get_before_list_slot_context_1);
	const if_block_creators = [create_if_block_2$9, create_else_block_2$2];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*hasUlSlots*/ ctx[4] && /*ul*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const after_list_slot_template = /*#slots*/ ctx[43]["after-list"];
	const after_list_slot = create_slot(after_list_slot_template, ctx, /*$$scope*/ ctx[42], get_after_list_slot_context_1);

	let div_levels = [
		{ class: /*classes*/ ctx[5] },
		{
			"data-sortable-move-elements": div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== "undefined"
			? /*sortableMoveElements*/ ctx[1].toString()
			: undefined
		},
		restProps(/*$$restProps*/ ctx[7])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (before_list_slot) before_list_slot.c();
			t0 = space();
			if_block.c();
			t1 = space();
			if (after_list_slot) after_list_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$G, 219, 2, 7137);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (before_list_slot) {
				before_list_slot.m(div, null);
			}

			append_dev(div, t0);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t1);

			if (after_list_slot) {
				after_list_slot.m(div, null);
			}

			/*div_binding*/ ctx[45](div);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_list_slot) {
				if (before_list_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(before_list_slot, before_list_slot_template, ctx, /*$$scope*/ ctx[42], dirty, get_before_list_slot_changes_1, get_before_list_slot_context_1);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, t1);
			}

			if (after_list_slot) {
				if (after_list_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(after_list_slot, after_list_slot_template, ctx, /*$$scope*/ ctx[42], dirty, get_after_list_slot_changes_1, get_after_list_slot_context_1);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 32) && { class: /*classes*/ ctx[5] },
				(!current || dirty[0] & /*sortableMoveElements*/ 2 && div_data_sortable_move_elements_value !== (div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== "undefined"
				? /*sortableMoveElements*/ ctx[1].toString()
				: undefined)) && {
					"data-sortable-move-elements": div_data_sortable_move_elements_value
				},
				dirty[0] & /*$$restProps*/ 128 && restProps(/*$$restProps*/ ctx[7])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_list_slot, local);
			transition_in(if_block);
			transition_in(after_list_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_list_slot, local);
			transition_out(if_block);
			transition_out(after_list_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (before_list_slot) before_list_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (after_list_slot) after_list_slot.d(detaching);
			/*div_binding*/ ctx[45](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1$3.name,
		type: "else",
		source: "(219:0) {:else}",
		ctx
	});

	return block;
}

// (200:0) {#if form}
function create_if_block$e(ctx) {
	let form_1;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let form_1_data_sortable_move_elements_value;
	let current;
	let mounted;
	let dispose;
	const before_list_slot_template = /*#slots*/ ctx[43]["before-list"];
	const before_list_slot = create_slot(before_list_slot_template, ctx, /*$$scope*/ ctx[42], get_before_list_slot_context);
	const if_block_creators = [create_if_block_1$9, create_else_block$5];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*hasUlSlots*/ ctx[4] && /*ul*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const after_list_slot_template = /*#slots*/ ctx[43]["after-list"];
	const after_list_slot = create_slot(after_list_slot_template, ctx, /*$$scope*/ ctx[42], get_after_list_slot_context);

	let form_1_levels = [
		{ class: /*classes*/ ctx[5] },
		{
			"data-sortable-move-elements": form_1_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== "undefined"
			? /*sortableMoveElements*/ ctx[1].toString()
			: undefined
		},
		restProps(/*$$restProps*/ ctx[7])
	];

	let form_1_data = {};

	for (let i = 0; i < form_1_levels.length; i += 1) {
		form_1_data = assign(form_1_data, form_1_levels[i]);
	}

	const block = {
		c: function create() {
			form_1 = element("form");
			if (before_list_slot) before_list_slot.c();
			t0 = space();
			if_block.c();
			t1 = space();
			if (after_list_slot) after_list_slot.c();
			set_attributes(form_1, form_1_data);
			add_location(form_1, file$G, 200, 2, 6701);
		},
		m: function mount(target, anchor) {
			insert_dev(target, form_1, anchor);

			if (before_list_slot) {
				before_list_slot.m(form_1, null);
			}

			append_dev(form_1, t0);
			if_blocks[current_block_type_index].m(form_1, null);
			append_dev(form_1, t1);

			if (after_list_slot) {
				after_list_slot.m(form_1, null);
			}

			/*form_1_binding*/ ctx[44](form_1);
			current = true;

			if (!mounted) {
				dispose = listen_dev(form_1, "submit", /*onSubmit*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (before_list_slot) {
				if (before_list_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(before_list_slot, before_list_slot_template, ctx, /*$$scope*/ ctx[42], dirty, get_before_list_slot_changes, get_before_list_slot_context);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(form_1, t1);
			}

			if (after_list_slot) {
				if (after_list_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(after_list_slot, after_list_slot_template, ctx, /*$$scope*/ ctx[42], dirty, get_after_list_slot_changes, get_after_list_slot_context);
				}
			}

			set_attributes(form_1, form_1_data = get_spread_update(form_1_levels, [
				(!current || dirty[0] & /*classes*/ 32) && { class: /*classes*/ ctx[5] },
				(!current || dirty[0] & /*sortableMoveElements*/ 2 && form_1_data_sortable_move_elements_value !== (form_1_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[1] !== "undefined"
				? /*sortableMoveElements*/ ctx[1].toString()
				: undefined)) && {
					"data-sortable-move-elements": form_1_data_sortable_move_elements_value
				},
				dirty[0] & /*$$restProps*/ 128 && restProps(/*$$restProps*/ ctx[7])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_list_slot, local);
			transition_in(if_block);
			transition_in(after_list_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_list_slot, local);
			transition_out(if_block);
			transition_out(after_list_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form_1);
			if (before_list_slot) before_list_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (after_list_slot) after_list_slot.d(detaching);
			/*form_1_binding*/ ctx[44](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$e.name,
		type: "if",
		source: "(200:0) {#if form}",
		ctx
	});

	return block;
}

// (232:4) {:else}
function create_else_block_2$2(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[43].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[42], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[42], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2$2.name,
		type: "else",
		source: "(232:4) {:else}",
		ctx
	});

	return block;
}

// (227:4) {#if hasUlSlots && ul}
function create_if_block_2$9(ctx) {
	let ul_1;
	let t;
	let current;
	const list_slot_template = /*#slots*/ ctx[43].list;
	const list_slot = create_slot(list_slot_template, ctx, /*$$scope*/ ctx[42], get_list_slot_context_1);
	const default_slot_template = /*#slots*/ ctx[43].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[42], null);

	const block = {
		c: function create() {
			ul_1 = element("ul");
			if (list_slot) list_slot.c();
			t = space();
			if (default_slot) default_slot.c();
			add_location(ul_1, file$G, 227, 4, 7404);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul_1, anchor);

			if (list_slot) {
				list_slot.m(ul_1, null);
			}

			append_dev(ul_1, t);

			if (default_slot) {
				default_slot.m(ul_1, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (list_slot) {
				if (list_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(list_slot, list_slot_template, ctx, /*$$scope*/ ctx[42], dirty, get_list_slot_changes_1, get_list_slot_context_1);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[42], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul_1);
			if (list_slot) list_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$9.name,
		type: "if",
		source: "(227:4) {#if hasUlSlots && ul}",
		ctx
	});

	return block;
}

// (214:4) {:else}
function create_else_block$5(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[43].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[42], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[42], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$5.name,
		type: "else",
		source: "(214:4) {:else}",
		ctx
	});

	return block;
}

// (209:4) {#if hasUlSlots && ul}
function create_if_block_1$9(ctx) {
	let ul_1;
	let t;
	let current;
	const list_slot_template = /*#slots*/ ctx[43].list;
	const list_slot = create_slot(list_slot_template, ctx, /*$$scope*/ ctx[42], get_list_slot_context);
	const default_slot_template = /*#slots*/ ctx[43].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[42], null);

	const block = {
		c: function create() {
			ul_1 = element("ul");
			if (list_slot) list_slot.c();
			t = space();
			if (default_slot) default_slot.c();
			add_location(ul_1, file$G, 209, 4, 6994);
		},
		m: function mount(target, anchor) {
			insert_dev(target, ul_1, anchor);

			if (list_slot) {
				list_slot.m(ul_1, null);
			}

			append_dev(ul_1, t);

			if (default_slot) {
				default_slot.m(ul_1, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (list_slot) {
				if (list_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(list_slot, list_slot_template, ctx, /*$$scope*/ ctx[42], dirty, get_list_slot_changes, get_list_slot_context);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[42], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(list_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(list_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul_1);
			if (list_slot) list_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$9.name,
		type: "if",
		source: "(209:4) {#if hasUlSlots && ul}",
		ctx
	});

	return block;
}

function create_fragment$G(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$e, create_else_block_1$3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*form*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$G.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$B($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","ul","inset","xsmallInset","smallInset","mediumInset","largeInset","xlargeInset","mediaList","sortable","sortableTapHold","sortableEnabled","sortableMoveElements","sortableOpposite","accordionList","accordionOpposite","contactsList","simpleList","linksList","noHairlines","noHairlinesBetween","noHairlinesMd","noHairlinesBetweenMd","noHairlinesIos","noHairlinesBetweenIos","noHairlinesAurora","noHairlinesBetweenAurora","noChevron","chevronCenter","tab","tabActive","form","formStoreData","inlineLabels","virtualList","virtualListParams","virtualListInstance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("List", slots, ['before-list','list','default','after-list']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { ul = true } = $$props;
	let { inset = false } = $$props;
	let { xsmallInset = false } = $$props;
	let { smallInset = false } = $$props;
	let { mediumInset = false } = $$props;
	let { largeInset = false } = $$props;
	let { xlargeInset = false } = $$props;
	let { mediaList = false } = $$props;
	let { sortable = false } = $$props;
	let { sortableTapHold = false } = $$props;
	let { sortableEnabled = false } = $$props;
	let { sortableMoveElements = undefined } = $$props;
	let { sortableOpposite = false } = $$props;
	let { accordionList = false } = $$props;
	let { accordionOpposite = false } = $$props;
	let { contactsList = false } = $$props;
	let { simpleList = false } = $$props;
	let { linksList = false } = $$props;
	let { noHairlines = false } = $$props;
	let { noHairlinesBetween = false } = $$props;
	let { noHairlinesMd = false } = $$props;
	let { noHairlinesBetweenMd = false } = $$props;
	let { noHairlinesIos = false } = $$props;
	let { noHairlinesBetweenIos = false } = $$props;
	let { noHairlinesAurora = false } = $$props;
	let { noHairlinesBetweenAurora = false } = $$props;
	let { noChevron = false } = $$props;
	let { chevronCenter = false } = $$props;
	let { tab = false } = $$props;
	let { tabActive = false } = $$props;
	let { form = false } = $$props;
	let { formStoreData = false } = $$props;
	let { inlineLabels = false } = $$props;
	let { virtualList = false } = $$props;
	let { virtualListParams = undefined } = $$props;
	let el;
	let f7VirtualList;

	function virtualListInstance() {
		return f7VirtualList;
	}

	setContext("f7ListMedia", mediaList);
	setContext("f7ListSortable", sortable);
	setContext("f7ListSortableOpposite", sortableOpposite);
	setContext("f7ListSimple", simpleList);

	function onSubmit(event) {
		dispatch("submit", [event]);
		if (typeof $$props.onSubmit === "function") $$props.onSubmit(event);
	}

	function onSortableEnable(sortableEl) {
		if (sortableEl !== el) return;
		dispatch("sortableEnable");
		if (typeof $$props.onSortableEnable === "function") $$props.onSortableEnable();
	}

	function onSortableDisable(sortableEl) {
		if (sortableEl !== el) return;
		dispatch("sortableDisable");
		if (typeof $$props.onSortableDisable === "function") $$props.onSortableDisable();
	}

	function onSortableSort(listItemEl, sortData, listEl) {
		if (listEl !== el) return;
		dispatch("sortableSort", [sortData]);
		if (typeof $$props.onSortableSort === "function") $$props.onSortableSort(sortData);
	}

	function onTabShow(tabEl) {
		if (tabEl !== el) return;
		dispatch("tabShow");
		if (typeof $$props.onTabShow === "function") $$props.onTabShow(tabEl);
	}

	function onTabHide(tabEl) {
		if (tabEl !== el) return;
		dispatch("tabHide");
		if (typeof $$props.onTabHide === "function") $$props.onTabHide(tabEl);
	}

	onMount(() => {
		f7.ready(() => {
			f7.instance.on("sortableEnable", onSortableEnable);
			f7.instance.on("sortableDisable", onSortableDisable);
			f7.instance.on("sortableSort", onSortableSort);
			f7.instance.on("tabShow", onTabShow);
			f7.instance.on("tabHide", onTabHide);
			if (!virtualList) return;
			const vlParams = virtualListParams || {};
			if (!vlParams.renderItem && !vlParams.itemTemplate && !vlParams.renderExternal) return;

			f7VirtualList = f7.instance.virtualList.create(Utils.extend(
				{
					el,
					on: {
						itemBeforeInsert(itemEl, item) {
							const vl = this;
							dispatch("virtualItemBeforeInsert", [vl, itemEl, item]);
							if (typeof $$props.onVirtualItemBeforeInsert === "function") $$props.onVirtualItemBeforeInsert(vl, itemEl, item);
						},
						beforeClear(fragment) {
							const vl = this;
							dispatch("virtualBeforeClear", [vl, fragment]);
							if (typeof $$props.onVirtualBeforeClear === "function") $$props.onVirtualBeforeClear(vl, fragment);
						},
						itemsBeforeInsert(fragment) {
							const vl = this;
							dispatch("virtualItemsBeforeInsert", [vl, fragment]);
							if (typeof $$props.onVirtualItemsBeforeInsert === "function") $$props.onVirtualItemsBeforeInsert(vl, fragment);
						},
						itemsAfterInsert(fragment) {
							const vl = this;
							dispatch("virtualItemsAfterInsert", [vl, fragment]);
							if (typeof $$props.onVirtualItemsAfterInsert === "function") $$props.onVirtualItemsAfterInsert(vl, fragment);
						}
					}
				},
				vlParams
			));
		});
	});

	onDestroy(() => {
		if (!f7.instance) return;
		f7.instance.off("sortableEnable", onSortableEnable);
		f7.instance.off("sortableDisable", onSortableDisable);
		f7.instance.off("sortableSort", onSortableSort);
		f7.instance.off("tabShow", onTabShow);
		f7.instance.off("tabHide", onTabHide);
		if (f7VirtualList && f7VirtualList.destroy) f7VirtualList.destroy();
	});

	function form_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(53, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(8, className = $$new_props.class);
		if ("ul" in $$new_props) $$invalidate(0, ul = $$new_props.ul);
		if ("inset" in $$new_props) $$invalidate(9, inset = $$new_props.inset);
		if ("xsmallInset" in $$new_props) $$invalidate(10, xsmallInset = $$new_props.xsmallInset);
		if ("smallInset" in $$new_props) $$invalidate(11, smallInset = $$new_props.smallInset);
		if ("mediumInset" in $$new_props) $$invalidate(12, mediumInset = $$new_props.mediumInset);
		if ("largeInset" in $$new_props) $$invalidate(13, largeInset = $$new_props.largeInset);
		if ("xlargeInset" in $$new_props) $$invalidate(14, xlargeInset = $$new_props.xlargeInset);
		if ("mediaList" in $$new_props) $$invalidate(15, mediaList = $$new_props.mediaList);
		if ("sortable" in $$new_props) $$invalidate(16, sortable = $$new_props.sortable);
		if ("sortableTapHold" in $$new_props) $$invalidate(17, sortableTapHold = $$new_props.sortableTapHold);
		if ("sortableEnabled" in $$new_props) $$invalidate(18, sortableEnabled = $$new_props.sortableEnabled);
		if ("sortableMoveElements" in $$new_props) $$invalidate(1, sortableMoveElements = $$new_props.sortableMoveElements);
		if ("sortableOpposite" in $$new_props) $$invalidate(19, sortableOpposite = $$new_props.sortableOpposite);
		if ("accordionList" in $$new_props) $$invalidate(20, accordionList = $$new_props.accordionList);
		if ("accordionOpposite" in $$new_props) $$invalidate(21, accordionOpposite = $$new_props.accordionOpposite);
		if ("contactsList" in $$new_props) $$invalidate(22, contactsList = $$new_props.contactsList);
		if ("simpleList" in $$new_props) $$invalidate(23, simpleList = $$new_props.simpleList);
		if ("linksList" in $$new_props) $$invalidate(24, linksList = $$new_props.linksList);
		if ("noHairlines" in $$new_props) $$invalidate(25, noHairlines = $$new_props.noHairlines);
		if ("noHairlinesBetween" in $$new_props) $$invalidate(26, noHairlinesBetween = $$new_props.noHairlinesBetween);
		if ("noHairlinesMd" in $$new_props) $$invalidate(27, noHairlinesMd = $$new_props.noHairlinesMd);
		if ("noHairlinesBetweenMd" in $$new_props) $$invalidate(28, noHairlinesBetweenMd = $$new_props.noHairlinesBetweenMd);
		if ("noHairlinesIos" in $$new_props) $$invalidate(29, noHairlinesIos = $$new_props.noHairlinesIos);
		if ("noHairlinesBetweenIos" in $$new_props) $$invalidate(30, noHairlinesBetweenIos = $$new_props.noHairlinesBetweenIos);
		if ("noHairlinesAurora" in $$new_props) $$invalidate(31, noHairlinesAurora = $$new_props.noHairlinesAurora);
		if ("noHairlinesBetweenAurora" in $$new_props) $$invalidate(32, noHairlinesBetweenAurora = $$new_props.noHairlinesBetweenAurora);
		if ("noChevron" in $$new_props) $$invalidate(33, noChevron = $$new_props.noChevron);
		if ("chevronCenter" in $$new_props) $$invalidate(34, chevronCenter = $$new_props.chevronCenter);
		if ("tab" in $$new_props) $$invalidate(35, tab = $$new_props.tab);
		if ("tabActive" in $$new_props) $$invalidate(36, tabActive = $$new_props.tabActive);
		if ("form" in $$new_props) $$invalidate(2, form = $$new_props.form);
		if ("formStoreData" in $$new_props) $$invalidate(37, formStoreData = $$new_props.formStoreData);
		if ("inlineLabels" in $$new_props) $$invalidate(38, inlineLabels = $$new_props.inlineLabels);
		if ("virtualList" in $$new_props) $$invalidate(39, virtualList = $$new_props.virtualList);
		if ("virtualListParams" in $$new_props) $$invalidate(40, virtualListParams = $$new_props.virtualListParams);
		if ("$$scope" in $$new_props) $$invalidate(42, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		setContext,
		Mixins,
		Utils,
		restProps,
		f7,
		hasSlots,
		dispatch,
		className,
		ul,
		inset,
		xsmallInset,
		smallInset,
		mediumInset,
		largeInset,
		xlargeInset,
		mediaList,
		sortable,
		sortableTapHold,
		sortableEnabled,
		sortableMoveElements,
		sortableOpposite,
		accordionList,
		accordionOpposite,
		contactsList,
		simpleList,
		linksList,
		noHairlines,
		noHairlinesBetween,
		noHairlinesMd,
		noHairlinesBetweenMd,
		noHairlinesIos,
		noHairlinesBetweenIos,
		noHairlinesAurora,
		noHairlinesBetweenAurora,
		noChevron,
		chevronCenter,
		tab,
		tabActive,
		form,
		formStoreData,
		inlineLabels,
		virtualList,
		virtualListParams,
		el,
		f7VirtualList,
		virtualListInstance,
		onSubmit,
		onSortableEnable,
		onSortableDisable,
		onSortableSort,
		onTabShow,
		onTabHide,
		hasUlSlots,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(53, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(8, className = $$new_props.className);
		if ("ul" in $$props) $$invalidate(0, ul = $$new_props.ul);
		if ("inset" in $$props) $$invalidate(9, inset = $$new_props.inset);
		if ("xsmallInset" in $$props) $$invalidate(10, xsmallInset = $$new_props.xsmallInset);
		if ("smallInset" in $$props) $$invalidate(11, smallInset = $$new_props.smallInset);
		if ("mediumInset" in $$props) $$invalidate(12, mediumInset = $$new_props.mediumInset);
		if ("largeInset" in $$props) $$invalidate(13, largeInset = $$new_props.largeInset);
		if ("xlargeInset" in $$props) $$invalidate(14, xlargeInset = $$new_props.xlargeInset);
		if ("mediaList" in $$props) $$invalidate(15, mediaList = $$new_props.mediaList);
		if ("sortable" in $$props) $$invalidate(16, sortable = $$new_props.sortable);
		if ("sortableTapHold" in $$props) $$invalidate(17, sortableTapHold = $$new_props.sortableTapHold);
		if ("sortableEnabled" in $$props) $$invalidate(18, sortableEnabled = $$new_props.sortableEnabled);
		if ("sortableMoveElements" in $$props) $$invalidate(1, sortableMoveElements = $$new_props.sortableMoveElements);
		if ("sortableOpposite" in $$props) $$invalidate(19, sortableOpposite = $$new_props.sortableOpposite);
		if ("accordionList" in $$props) $$invalidate(20, accordionList = $$new_props.accordionList);
		if ("accordionOpposite" in $$props) $$invalidate(21, accordionOpposite = $$new_props.accordionOpposite);
		if ("contactsList" in $$props) $$invalidate(22, contactsList = $$new_props.contactsList);
		if ("simpleList" in $$props) $$invalidate(23, simpleList = $$new_props.simpleList);
		if ("linksList" in $$props) $$invalidate(24, linksList = $$new_props.linksList);
		if ("noHairlines" in $$props) $$invalidate(25, noHairlines = $$new_props.noHairlines);
		if ("noHairlinesBetween" in $$props) $$invalidate(26, noHairlinesBetween = $$new_props.noHairlinesBetween);
		if ("noHairlinesMd" in $$props) $$invalidate(27, noHairlinesMd = $$new_props.noHairlinesMd);
		if ("noHairlinesBetweenMd" in $$props) $$invalidate(28, noHairlinesBetweenMd = $$new_props.noHairlinesBetweenMd);
		if ("noHairlinesIos" in $$props) $$invalidate(29, noHairlinesIos = $$new_props.noHairlinesIos);
		if ("noHairlinesBetweenIos" in $$props) $$invalidate(30, noHairlinesBetweenIos = $$new_props.noHairlinesBetweenIos);
		if ("noHairlinesAurora" in $$props) $$invalidate(31, noHairlinesAurora = $$new_props.noHairlinesAurora);
		if ("noHairlinesBetweenAurora" in $$props) $$invalidate(32, noHairlinesBetweenAurora = $$new_props.noHairlinesBetweenAurora);
		if ("noChevron" in $$props) $$invalidate(33, noChevron = $$new_props.noChevron);
		if ("chevronCenter" in $$props) $$invalidate(34, chevronCenter = $$new_props.chevronCenter);
		if ("tab" in $$props) $$invalidate(35, tab = $$new_props.tab);
		if ("tabActive" in $$props) $$invalidate(36, tabActive = $$new_props.tabActive);
		if ("form" in $$props) $$invalidate(2, form = $$new_props.form);
		if ("formStoreData" in $$props) $$invalidate(37, formStoreData = $$new_props.formStoreData);
		if ("inlineLabels" in $$props) $$invalidate(38, inlineLabels = $$new_props.inlineLabels);
		if ("virtualList" in $$props) $$invalidate(39, virtualList = $$new_props.virtualList);
		if ("virtualListParams" in $$props) $$invalidate(40, virtualListParams = $$new_props.virtualListParams);
		if ("el" in $$props) $$invalidate(3, el = $$new_props.el);
		if ("f7VirtualList" in $$props) f7VirtualList = $$new_props.f7VirtualList;
		if ("hasUlSlots" in $$props) $$invalidate(4, hasUlSlots = $$new_props.hasUlSlots);
		if ("classes" in $$props) $$invalidate(5, classes = $$new_props.classes);
	};

	let hasUlSlots;
	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(5, classes = Utils.classNames(
			className,
			"list",
			{
				inset,
				"xsmall-inset": xsmallInset,
				"small-inset": smallInset,
				"medium-inset": mediumInset,
				"large-inset": largeInset,
				"xlarge-inset": xlargeInset,
				"media-list": mediaList,
				"simple-list": simpleList,
				"links-list": linksList,
				sortable,
				"sortable-tap-hold": sortableTapHold,
				"sortable-enabled": sortableEnabled,
				"sortable-opposite": sortableOpposite,
				"accordion-list": accordionList,
				"accordion-opposite": accordionOpposite,
				"contacts-list": contactsList,
				"virtual-list": virtualList,
				tab,
				"tab-active": tabActive,
				"no-hairlines": noHairlines,
				"no-hairlines-md": noHairlinesMd,
				"no-hairlines-ios": noHairlinesIos,
				"no-hairlines-aurora": noHairlinesAurora,
				"no-hairlines-between": noHairlinesBetween,
				"no-hairlines-between-md": noHairlinesBetweenMd,
				"no-hairlines-between-ios": noHairlinesBetweenIos,
				"no-hairlines-between-aurora": noHairlinesBetweenAurora,
				"form-store-data": formStoreData,
				"inline-labels": inlineLabels,
				"no-chevron": noChevron,
				"chevron-center": chevronCenter
			},
			Mixins.colorClasses($$props)
		));
	};

	 $$invalidate(4, hasUlSlots = hasSlots(arguments, "default") || hasSlots(arguments, "list"));
	$$props = exclude_internal_props($$props);

	return [
		ul,
		sortableMoveElements,
		form,
		el,
		hasUlSlots,
		classes,
		onSubmit,
		$$restProps,
		className,
		inset,
		xsmallInset,
		smallInset,
		mediumInset,
		largeInset,
		xlargeInset,
		mediaList,
		sortable,
		sortableTapHold,
		sortableEnabled,
		sortableOpposite,
		accordionList,
		accordionOpposite,
		contactsList,
		simpleList,
		linksList,
		noHairlines,
		noHairlinesBetween,
		noHairlinesMd,
		noHairlinesBetweenMd,
		noHairlinesIos,
		noHairlinesBetweenIos,
		noHairlinesAurora,
		noHairlinesBetweenAurora,
		noChevron,
		chevronCenter,
		tab,
		tabActive,
		formStoreData,
		inlineLabels,
		virtualList,
		virtualListParams,
		virtualListInstance,
		$$scope,
		slots,
		form_1_binding,
		div_binding
	];
}

class List extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$B,
			create_fragment$G,
			safe_not_equal,
			{
				class: 8,
				ul: 0,
				inset: 9,
				xsmallInset: 10,
				smallInset: 11,
				mediumInset: 12,
				largeInset: 13,
				xlargeInset: 14,
				mediaList: 15,
				sortable: 16,
				sortableTapHold: 17,
				sortableEnabled: 18,
				sortableMoveElements: 1,
				sortableOpposite: 19,
				accordionList: 20,
				accordionOpposite: 21,
				contactsList: 22,
				simpleList: 23,
				linksList: 24,
				noHairlines: 25,
				noHairlinesBetween: 26,
				noHairlinesMd: 27,
				noHairlinesBetweenMd: 28,
				noHairlinesIos: 29,
				noHairlinesBetweenIos: 30,
				noHairlinesAurora: 31,
				noHairlinesBetweenAurora: 32,
				noChevron: 33,
				chevronCenter: 34,
				tab: 35,
				tabActive: 36,
				form: 2,
				formStoreData: 37,
				inlineLabels: 38,
				virtualList: 39,
				virtualListParams: 40,
				virtualListInstance: 41
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "List",
			options,
			id: create_fragment$G.name
		});
	}

	get class() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ul() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ul(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inset() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inset(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xsmallInset() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xsmallInset(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smallInset() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smallInset(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mediumInset() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mediumInset(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get largeInset() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set largeInset(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get xlargeInset() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set xlargeInset(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get mediaList() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set mediaList(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortable() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortable(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortableTapHold() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortableTapHold(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortableEnabled() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortableEnabled(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortableMoveElements() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortableMoveElements(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sortableOpposite() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sortableOpposite(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accordionList() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accordionList(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get accordionOpposite() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set accordionOpposite(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get contactsList() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set contactsList(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get simpleList() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set simpleList(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get linksList() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set linksList(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlines() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlines(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesBetween() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesBetween(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesMd() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesMd(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesBetweenMd() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesBetweenMd(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesIos() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesIos(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesBetweenIos() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesBetweenIos(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesAurora() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesAurora(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairlinesBetweenAurora() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairlinesBetweenAurora(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noChevron() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noChevron(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get chevronCenter() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set chevronCenter(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tab() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tab(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabActive() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabActive(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get form() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set form(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get formStoreData() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set formStoreData(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inlineLabels() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inlineLabels(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get virtualList() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set virtualList(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get virtualListParams() {
		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set virtualListParams(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get virtualListInstance() {
		return this.$$.ctx[41];
	}

	set virtualListInstance(value) {
		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/login-screen-title.svelte generated by Svelte v3.31.0 */
const file$H = "node_modules/framework7-svelte/components/login-screen-title.svelte";

function create_fragment$H(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$H, 14, 0, 321);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$H.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$C($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Login_screen_title", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "login-screen-title", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class Login_screen_title extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$C, create_fragment$H, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Login_screen_title",
			options,
			id: create_fragment$H.name
		});
	}

	get class() {
		throw new Error("<Login_screen_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Login_screen_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/login-screen.svelte generated by Svelte v3.31.0 */
const file$I = "node_modules/framework7-svelte/components/login-screen.svelte";

function create_fragment$I(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	let div_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$I, 89, 0, 2261);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[10](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[10](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$I.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$5($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","opened","instance","open","close"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Login_screen", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { opened = undefined } = $$props;
	let el;
	let f7LoginScreen;

	function instance() {
		return f7LoginScreen;
	}

	function open(anim) {
		if (!f7LoginScreen) return undefined;
		return f7LoginScreen.open(anim);
	}

	function close(anim) {
		if (!f7LoginScreen) return undefined;
		return f7LoginScreen.close(anim);
	}

	function onOpen(instance) {
		dispatch("loginscreenOpen", [instance]);
		if (typeof $$props.onLoginScreenOpen === "function") $$props.onLoginScreenOpen(instance);
	}

	function onOpened(instance) {
		dispatch("loginscreenOpened", [instance]);
		if (typeof $$props.onLoginScreenOpened === "function") $$props.onLoginScreenOpened(instance);
	}

	function onClose(instance) {
		dispatch("loginscreenClose", [instance]);
		if (typeof $$props.onLoginScreenClose === "function") $$props.onLoginScreenClose(instance);
	}

	function onClosed(instance) {
		dispatch("loginscreenClosed", [instance]);
		if (typeof $$props.onLoginScreenClosed === "function") $$props.onLoginScreenClosed(instance);
	}

	let initialWatched = false;

	function watchOpened(openedPassed) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7LoginScreen) return;
		if (openedPassed) f7LoginScreen.open(); else f7LoginScreen.close();
	}

	onMount(() => {
		const params = {
			el,
			on: {
				open: onOpen,
				opened: onOpened,
				close: onClose,
				closed: onClosed
			}
		};

		f7.ready(() => {
			f7LoginScreen = f7.instance.loginScreen.create(params);

			if (opened) {
				f7LoginScreen.open(false);
			}
		});
	});

	onDestroy(() => {
		if (f7LoginScreen) f7LoginScreen.destroy();
		f7LoginScreen = undefined;
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(19, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("opened" in $$new_props) $$invalidate(4, opened = $$new_props.opened);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		opened,
		el,
		f7LoginScreen,
		instance,
		open,
		close,
		onOpen,
		onOpened,
		onClose,
		onClosed,
		initialWatched,
		watchOpened,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(19, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("opened" in $$props) $$invalidate(4, opened = $$new_props.opened);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("f7LoginScreen" in $$props) f7LoginScreen = $$new_props.f7LoginScreen;
		if ("initialWatched" in $$props) initialWatched = $$new_props.initialWatched;
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classes = Utils.classNames(className, "login-screen", Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*opened*/ 16) {
			 watchOpened(opened);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		classes,
		$$restProps,
		className,
		opened,
		instance,
		open,
		close,
		$$scope,
		slots,
		div_binding
	];
}

class Login_screen extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance_1$5, create_fragment$I, safe_not_equal, {
			class: 3,
			opened: 4,
			instance: 5,
			open: 6,
			close: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Login_screen",
			options,
			id: create_fragment$I.name
		});
	}

	get class() {
		throw new Error("<Login_screen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Login_screen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get opened() {
		throw new Error("<Login_screen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set opened(value) {
		throw new Error("<Login_screen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[5];
	}

	set instance(value) {
		throw new Error("<Login_screen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		return this.$$.ctx[6];
	}

	set open(value) {
		throw new Error("<Login_screen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get close() {
		return this.$$.ctx[7];
	}

	set close(value) {
		throw new Error("<Login_screen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/menu-dropdown-item.svelte generated by Svelte v3.31.0 */
const file$J = "node_modules/framework7-svelte/components/menu-dropdown-item.svelte";

// (77:0) {:else}
function create_else_block$6(ctx) {
	let div;
	let t0_value = Utils.text(/*text*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
	let div_levels = [{ class: /*classes*/ ctx[4] }, /*attrs*/ ctx[3]];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$J, 77, 2, 1847);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[15](div);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*onClick*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*text*/ 1) && t0_value !== (t0_value = Utils.text(/*text*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4096) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*attrs*/ 8 && /*attrs*/ ctx[3]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[15](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$6.name,
		type: "else",
		source: "(77:0) {:else}",
		ctx
	});

	return block;
}

// (72:0) {#if isLink}
function create_if_block$f(ctx) {
	let a;
	let t0_value = Utils.text(/*text*/ ctx[0]) + "";
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
	let a_levels = [{ class: /*classes*/ ctx[4] }, /*attrs*/ ctx[3]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			add_location(a, file$J, 72, 2, 1729);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, t0);
			append_dev(a, t1);

			if (default_slot) {
				default_slot.m(a, null);
			}

			/*a_binding*/ ctx[14](a);
			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*text*/ 1) && t0_value !== (t0_value = Utils.text(/*text*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4096) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*attrs*/ 8 && /*attrs*/ ctx[3]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
			/*a_binding*/ ctx[14](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$f.name,
		type: "if",
		source: "(72:0) {#if isLink}",
		ctx
	});

	return block;
}

function create_fragment$J(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$f, create_else_block$6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isLink*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$J.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$D($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","text","href","link","target","divider"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Menu_dropdown_item", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { text = undefined } = $$props;
	let { href = undefined } = $$props;
	let { link = undefined } = $$props;
	let { target = undefined } = $$props;
	let { divider = undefined } = $$props;
	let el;

	function onClick(e) {
		dispatch("click", [e]);
		if (typeof $$props.onClick === "function") $$props.onClick(e);
	}

	onMount(() => {
		if ($$props.routeProps) {
			$$invalidate(2, el.f7RouteProps = $$props.routeProps, el);
		}
	});

	afterUpdate(() => {
		if ($$props.routeProps && el) {
			$$invalidate(2, el.f7RouteProps = $$props.routeProps, el);
		}
	});

	onDestroy(() => {
		if (!el || !f7.instance) return;
		delete el.f7RouteProps;
	});

	function a_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ("text" in $$new_props) $$invalidate(0, text = $$new_props.text);
		if ("href" in $$new_props) $$invalidate(7, href = $$new_props.href);
		if ("link" in $$new_props) $$invalidate(8, link = $$new_props.link);
		if ("target" in $$new_props) $$invalidate(9, target = $$new_props.target);
		if ("divider" in $$new_props) $$invalidate(10, divider = $$new_props.divider);
		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		afterUpdate,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		text,
		href,
		link,
		target,
		divider,
		el,
		onClick,
		hrefComputed,
		attrs,
		isLink,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
		if ("text" in $$props) $$invalidate(0, text = $$new_props.text);
		if ("href" in $$props) $$invalidate(7, href = $$new_props.href);
		if ("link" in $$props) $$invalidate(8, link = $$new_props.link);
		if ("target" in $$props) $$invalidate(9, target = $$new_props.target);
		if ("divider" in $$props) $$invalidate(10, divider = $$new_props.divider);
		if ("el" in $$props) $$invalidate(2, el = $$new_props.el);
		if ("hrefComputed" in $$props) $$invalidate(11, hrefComputed = $$new_props.hrefComputed);
		if ("attrs" in $$props) $$invalidate(3, attrs = $$new_props.attrs);
		if ("isLink" in $$props) $$invalidate(1, isLink = $$new_props.isLink);
		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
	};

	let hrefComputed;
	let attrs;
	let isLink;
	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*href, link*/ 384) {
			 $$invalidate(11, hrefComputed = typeof href === "undefined" && link ? "#" : href);
		}

		 $$invalidate(3, attrs = Utils.extend(
			{
				href: hrefComputed,
				target,
				...restProps($$restProps)
			},
			Mixins.linkRouterAttrs($$props),
			Mixins.linkActionsAttrs($$props)
		));

		if ($$self.$$.dirty & /*link, href*/ 384) {
			 $$invalidate(1, isLink = link || href || href === "");
		}

		 $$invalidate(4, classes = Utils.classNames(
			{
				"menu-dropdown-link": isLink && !divider,
				"menu-dropdown-item": !isLink && !divider,
				"menu-dropdown-divider": divider
			},
			className,
			Mixins.colorClasses($$props),
			Mixins.linkRouterClasses($$props),
			Mixins.linkActionsClasses($$props),
			{
				"menu-close": typeof menuClose === "undefined"
			}
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		text,
		isLink,
		el,
		attrs,
		classes,
		onClick,
		className,
		href,
		link,
		target,
		divider,
		hrefComputed,
		$$scope,
		slots,
		a_binding,
		div_binding
	];
}

class Menu_dropdown_item extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$D, create_fragment$J, safe_not_equal, {
			class: 6,
			text: 0,
			href: 7,
			link: 8,
			target: 9,
			divider: 10
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Menu_dropdown_item",
			options,
			id: create_fragment$J.name
		});
	}

	get class() {
		throw new Error("<Menu_dropdown_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Menu_dropdown_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<Menu_dropdown_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Menu_dropdown_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Menu_dropdown_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Menu_dropdown_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get link() {
		throw new Error("<Menu_dropdown_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set link(value) {
		throw new Error("<Menu_dropdown_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get target() {
		throw new Error("<Menu_dropdown_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set target(value) {
		throw new Error("<Menu_dropdown_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get divider() {
		throw new Error("<Menu_dropdown_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set divider(value) {
		throw new Error("<Menu_dropdown_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/menu-dropdown.svelte generated by Svelte v3.31.0 */
const file$K = "node_modules/framework7-svelte/components/menu-dropdown.svelte";

function create_fragment$K(ctx) {
	let div1;
	let div0;
	let div0_style_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	let div1_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div0, "class", "menu-dropdown-content");
			attr_dev(div0, "style", div0_style_value = /*contentHeight*/ ctx[0] && `height: ${/*contentHeight*/ ctx[0]}`);
			add_location(div0, file$K, 32, 2, 764);
			set_attributes(div1, div1_data);
			add_location(div1, file$K, 31, 0, 712);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 512) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
				}
			}

			if (!current || dirty & /*contentHeight*/ 1 && div0_style_value !== (div0_style_value = /*contentHeight*/ ctx[0] && `height: ${/*contentHeight*/ ctx[0]}`)) {
				attr_dev(div0, "style", div0_style_value);
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$K.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$E($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","contentHeight","position","left","center","right"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Menu_dropdown", slots, ['default']);
	let { class: className = undefined } = $$props;
	let { contentHeight = undefined } = $$props;
	let { position = undefined } = $$props;
	let { left = undefined } = $$props;
	let { center = undefined } = $$props;
	let { right = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("contentHeight" in $$new_props) $$invalidate(0, contentHeight = $$new_props.contentHeight);
		if ("position" in $$new_props) $$invalidate(4, position = $$new_props.position);
		if ("left" in $$new_props) $$invalidate(5, left = $$new_props.left);
		if ("center" in $$new_props) $$invalidate(6, center = $$new_props.center);
		if ("right" in $$new_props) $$invalidate(7, right = $$new_props.right);
		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		contentHeight,
		position,
		left,
		center,
		right,
		positionComputed,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("contentHeight" in $$props) $$invalidate(0, contentHeight = $$new_props.contentHeight);
		if ("position" in $$props) $$invalidate(4, position = $$new_props.position);
		if ("left" in $$props) $$invalidate(5, left = $$new_props.left);
		if ("center" in $$props) $$invalidate(6, center = $$new_props.center);
		if ("right" in $$props) $$invalidate(7, right = $$new_props.right);
		if ("positionComputed" in $$props) $$invalidate(8, positionComputed = $$new_props.positionComputed);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	let positionComputed;
	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*position, left, center, right*/ 240) {
			 $$invalidate(8, positionComputed = (() => {
				let pos = position || "left";
				if (left) pos = "left";
				if (center) pos = "center";
				if (right) pos = "right";
				return pos;
			})());
		}

		 $$invalidate(1, classes = Utils.classNames("menu-dropdown", `menu-dropdown-${positionComputed}`, Mixins.colorClasses($$props), className));
	};

	$$props = exclude_internal_props($$props);

	return [
		contentHeight,
		classes,
		$$restProps,
		className,
		position,
		left,
		center,
		right,
		positionComputed,
		$$scope,
		slots
	];
}

class Menu_dropdown extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$E, create_fragment$K, safe_not_equal, {
			class: 3,
			contentHeight: 0,
			position: 4,
			left: 5,
			center: 6,
			right: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Menu_dropdown",
			options,
			id: create_fragment$K.name
		});
	}

	get class() {
		throw new Error("<Menu_dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Menu_dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get contentHeight() {
		throw new Error("<Menu_dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set contentHeight(value) {
		throw new Error("<Menu_dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get position() {
		throw new Error("<Menu_dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set position(value) {
		throw new Error("<Menu_dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get left() {
		throw new Error("<Menu_dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set left(value) {
		throw new Error("<Menu_dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get center() {
		throw new Error("<Menu_dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set center(value) {
		throw new Error("<Menu_dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get right() {
		throw new Error("<Menu_dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set right(value) {
		throw new Error("<Menu_dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/menu-item.svelte generated by Svelte v3.31.0 */
const file$L = "node_modules/framework7-svelte/components/menu-item.svelte";
const get_text_slot_changes_1$1 = dirty => ({});
const get_text_slot_context_1$1 = ctx => ({});
const get_text_slot_changes$3 = dirty => ({});
const get_text_slot_context$3 = ctx => ({});

// (121:0) {:else}
function create_else_block$7(ctx) {
	let div;
	let t;
	let current;
	let mounted;
	let dispose;
	let if_block = (typeof /*text*/ ctx[0] !== "undefined" || /*hasTextSlots*/ ctx[1] || /*hasIcon*/ ctx[5]) && create_if_block_3$8(ctx);
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);
	let div_levels = [{ class: /*classes*/ ctx[4] }, /*attrs*/ ctx[3]];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$L, 121, 2, 3292);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[20](div);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*onClick*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (typeof /*text*/ ctx[0] !== "undefined" || /*hasTextSlots*/ ctx[1] || /*hasIcon*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*text, hasTextSlots, hasIcon*/ 35) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_3$8(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 131072) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[17], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*attrs*/ 8 && /*attrs*/ ctx[3]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[20](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$7.name,
		type: "else",
		source: "(121:0) {:else}",
		ctx
	});

	return block;
}

// (99:0) {#if isLink}
function create_if_block$g(ctx) {
	let a;
	let t;
	let current;
	let mounted;
	let dispose;
	let if_block = (typeof /*text*/ ctx[0] !== "undefined" || /*hasTextSlots*/ ctx[1] || /*hasIcon*/ ctx[5]) && create_if_block_1$a(ctx);
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);
	let a_levels = [{ class: /*classes*/ ctx[4] }, /*attrs*/ ctx[3]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			add_location(a, file$L, 99, 2, 2682);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			if (if_block) if_block.m(a, null);
			append_dev(a, t);

			if (default_slot) {
				default_slot.m(a, null);
			}

			/*a_binding*/ ctx[19](a);
			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (typeof /*text*/ ctx[0] !== "undefined" || /*hasTextSlots*/ ctx[1] || /*hasIcon*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*text, hasTextSlots, hasIcon*/ 35) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1$a(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(a, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 131072) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[17], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*attrs*/ 8 && /*attrs*/ ctx[3]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			/*a_binding*/ ctx[19](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$g.name,
		type: "if",
		source: "(99:0) {#if isLink}",
		ctx
	});

	return block;
}

// (123:4) {#if typeof text !== 'undefined' || hasTextSlots || hasIcon}
function create_if_block_3$8(ctx) {
	let div;
	let t0_value = Utils.text(/*text*/ ctx[0]) + "";
	let t0;
	let t1;
	let t2;
	let current;
	let if_block = /*hasIcon*/ ctx[5] && create_if_block_4$5(ctx);
	const text_slot_template = /*#slots*/ ctx[18].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[17], get_text_slot_context_1$1);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			if (text_slot) text_slot.c();
			attr_dev(div, "class", "menu-item-content");
			add_location(div, file$L, 123, 6, 3430);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);
			if (if_block) if_block.m(div, null);
			append_dev(div, t2);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*text*/ 1) && t0_value !== (t0_value = Utils.text(/*text*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (/*hasIcon*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*hasIcon*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_4$5(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t2);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (text_slot) {
				if (text_slot.p && dirty & /*$$scope*/ 131072) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[17], dirty, get_text_slot_changes_1$1, get_text_slot_context_1$1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(text_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(text_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (text_slot) text_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$8.name,
		type: "if",
		source: "(123:4) {#if typeof text !== 'undefined' || hasTextSlots || hasIcon}",
		ctx
	});

	return block;
}

// (126:8) {#if hasIcon}
function create_if_block_4$5(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				material: /*$$props*/ ctx[8].iconMaterial,
				f7: /*$$props*/ ctx[8].iconF7,
				icon: /*$$props*/ ctx[8].icon,
				md: /*$$props*/ ctx[8].iconMd,
				ios: /*$$props*/ ctx[8].iconIos,
				aurora: /*$$props*/ ctx[8].iconAurora,
				color: /*$$props*/ ctx[8].iconColor,
				size: /*$$props*/ ctx[8].iconSize
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*$$props*/ 256) icon_changes.material = /*$$props*/ ctx[8].iconMaterial;
			if (dirty & /*$$props*/ 256) icon_changes.f7 = /*$$props*/ ctx[8].iconF7;
			if (dirty & /*$$props*/ 256) icon_changes.icon = /*$$props*/ ctx[8].icon;
			if (dirty & /*$$props*/ 256) icon_changes.md = /*$$props*/ ctx[8].iconMd;
			if (dirty & /*$$props*/ 256) icon_changes.ios = /*$$props*/ ctx[8].iconIos;
			if (dirty & /*$$props*/ 256) icon_changes.aurora = /*$$props*/ ctx[8].iconAurora;
			if (dirty & /*$$props*/ 256) icon_changes.color = /*$$props*/ ctx[8].iconColor;
			if (dirty & /*$$props*/ 256) icon_changes.size = /*$$props*/ ctx[8].iconSize;
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$5.name,
		type: "if",
		source: "(126:8) {#if hasIcon}",
		ctx
	});

	return block;
}

// (101:4) {#if typeof text !== 'undefined' || hasTextSlots || hasIcon}
function create_if_block_1$a(ctx) {
	let div;
	let t0_value = Utils.text(/*text*/ ctx[0]) + "";
	let t0;
	let t1;
	let t2;
	let current;
	let if_block = /*hasIcon*/ ctx[5] && create_if_block_2$a(ctx);
	const text_slot_template = /*#slots*/ ctx[18].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[17], get_text_slot_context$3);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			if (text_slot) text_slot.c();
			attr_dev(div, "class", "menu-item-content");
			add_location(div, file$L, 101, 6, 2818);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);
			if (if_block) if_block.m(div, null);
			append_dev(div, t2);

			if (text_slot) {
				text_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*text*/ 1) && t0_value !== (t0_value = Utils.text(/*text*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (/*hasIcon*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*hasIcon*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_2$a(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t2);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (text_slot) {
				if (text_slot.p && dirty & /*$$scope*/ 131072) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[17], dirty, get_text_slot_changes$3, get_text_slot_context$3);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(text_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(text_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (text_slot) text_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$a.name,
		type: "if",
		source: "(101:4) {#if typeof text !== 'undefined' || hasTextSlots || hasIcon}",
		ctx
	});

	return block;
}

// (104:8) {#if hasIcon}
function create_if_block_2$a(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				material: /*$$props*/ ctx[8].iconMaterial,
				f7: /*$$props*/ ctx[8].iconF7,
				icon: /*$$props*/ ctx[8].icon,
				md: /*$$props*/ ctx[8].iconMd,
				ios: /*$$props*/ ctx[8].iconIos,
				aurora: /*$$props*/ ctx[8].iconAurora,
				color: /*$$props*/ ctx[8].iconColor,
				size: /*$$props*/ ctx[8].iconSize
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*$$props*/ 256) icon_changes.material = /*$$props*/ ctx[8].iconMaterial;
			if (dirty & /*$$props*/ 256) icon_changes.f7 = /*$$props*/ ctx[8].iconF7;
			if (dirty & /*$$props*/ 256) icon_changes.icon = /*$$props*/ ctx[8].icon;
			if (dirty & /*$$props*/ 256) icon_changes.md = /*$$props*/ ctx[8].iconMd;
			if (dirty & /*$$props*/ 256) icon_changes.ios = /*$$props*/ ctx[8].iconIos;
			if (dirty & /*$$props*/ 256) icon_changes.aurora = /*$$props*/ ctx[8].iconAurora;
			if (dirty & /*$$props*/ 256) icon_changes.color = /*$$props*/ ctx[8].iconColor;
			if (dirty & /*$$props*/ 256) icon_changes.size = /*$$props*/ ctx[8].iconSize;
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$a.name,
		type: "if",
		source: "(104:8) {#if hasIcon}",
		ctx
	});

	return block;
}

function create_fragment$L(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$g, create_else_block$7];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isLink*/ ctx[6]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$L.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$F($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","text","iconOnly","href","link","target","dropdown"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Menu_item", slots, ['text','default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { text = undefined } = $$props;
	let { iconOnly = undefined } = $$props;
	let { href = undefined } = $$props;
	let { link = undefined } = $$props;
	let { target = undefined } = $$props;
	let { dropdown = undefined } = $$props;
	let el;

	function onClick(e) {
		dispatch("click", [e]);
		if (typeof $$props.onClick === "function") $$props.onClick(e);
	}

	function onOpened(itemEl) {
		if (itemEl !== el) return;
		dispatch("menuOpened", [el]);
		if (typeof $$props.onMenuOpened === "function") $$props.onMenuOpened(el);
	}

	function onClosed(itemEl) {
		if (itemEl !== el) return;
		dispatch("menuClosed", [el]);
		if (typeof $$props.onMenuClosed === "function") $$props.onMenuClosed(el);
	}

	onMount(() => {
		if ($$props.routeProps) {
			$$invalidate(2, el.f7RouteProps = $$props.routeProps, el);
		}

		f7.ready(() => {
			f7.instance.on("menuOpened", onOpened);
			f7.instance.on("menuClosed", onClosed);
		});
	});

	afterUpdate(() => {
		if ($$props.routeProps) {
			$$invalidate(2, el.f7RouteProps = $$props.routeProps, el);
		}
	});

	onDestroy(() => {
		if (!el || !f7.instance) return;
		delete el.f7RouteProps;
		f7.instance.off("menuOpened", onOpened);
		f7.instance.off("menuClosed", onClosed);
	});

	function a_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(9, className = $$new_props.class);
		if ("text" in $$new_props) $$invalidate(0, text = $$new_props.text);
		if ("iconOnly" in $$new_props) $$invalidate(10, iconOnly = $$new_props.iconOnly);
		if ("href" in $$new_props) $$invalidate(11, href = $$new_props.href);
		if ("link" in $$new_props) $$invalidate(12, link = $$new_props.link);
		if ("target" in $$new_props) $$invalidate(13, target = $$new_props.target);
		if ("dropdown" in $$new_props) $$invalidate(14, dropdown = $$new_props.dropdown);
		if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		afterUpdate,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		hasSlots,
		Icon,
		dispatch,
		className,
		text,
		iconOnly,
		href,
		link,
		target,
		dropdown,
		el,
		onClick,
		onOpened,
		onClosed,
		hrefComputed,
		attrs,
		hasDefaultSlots,
		hasTextSlots,
		iconOnlyComputed,
		classes,
		hasIcon,
		isLink
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(9, className = $$new_props.className);
		if ("text" in $$props) $$invalidate(0, text = $$new_props.text);
		if ("iconOnly" in $$props) $$invalidate(10, iconOnly = $$new_props.iconOnly);
		if ("href" in $$props) $$invalidate(11, href = $$new_props.href);
		if ("link" in $$props) $$invalidate(12, link = $$new_props.link);
		if ("target" in $$props) $$invalidate(13, target = $$new_props.target);
		if ("dropdown" in $$props) $$invalidate(14, dropdown = $$new_props.dropdown);
		if ("el" in $$props) $$invalidate(2, el = $$new_props.el);
		if ("hrefComputed" in $$props) $$invalidate(15, hrefComputed = $$new_props.hrefComputed);
		if ("attrs" in $$props) $$invalidate(3, attrs = $$new_props.attrs);
		if ("hasDefaultSlots" in $$props) hasDefaultSlots = $$new_props.hasDefaultSlots;
		if ("hasTextSlots" in $$props) $$invalidate(1, hasTextSlots = $$new_props.hasTextSlots);
		if ("iconOnlyComputed" in $$props) $$invalidate(16, iconOnlyComputed = $$new_props.iconOnlyComputed);
		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
		if ("hasIcon" in $$props) $$invalidate(5, hasIcon = $$new_props.hasIcon);
		if ("isLink" in $$props) $$invalidate(6, isLink = $$new_props.isLink);
	};

	let hrefComputed;
	let attrs;
	let hasDefaultSlots;
	let hasTextSlots;
	let iconOnlyComputed;
	let classes;
	let hasIcon;
	let isLink;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*href, link*/ 6144) {
			 $$invalidate(15, hrefComputed = typeof href === "undefined" && link ? "#" : href);
		}

		 $$invalidate(3, attrs = Utils.extend(
			{
				href: hrefComputed,
				target,
				...restProps($$restProps)
			},
			Mixins.linkRouterAttrs($$props),
			Mixins.linkActionsAttrs($$props)
		));

		if ($$self.$$.dirty & /*iconOnly, text, hasTextSlots*/ 1027) {
			 $$invalidate(16, iconOnlyComputed = iconOnly || !text && !hasTextSlots);
		}

		 $$invalidate(4, classes = Utils.classNames(
			{
				"menu-item": true,
				"menu-item-dropdown": dropdown || dropdown === "",
				"icon-only": iconOnlyComputed
			},
			className,
			Mixins.colorClasses($$props),
			Mixins.linkRouterClasses($$props),
			Mixins.linkActionsClasses($$props)
		));

		 $$invalidate(5, hasIcon = $$props.icon || $$props.iconMaterial || $$props.iconF7 || $$props.iconMd || $$props.iconIos || $$props.iconAurora);

		if ($$self.$$.dirty & /*link, href*/ 6144) {
			 $$invalidate(6, isLink = link || href || href === "");
		}
	};

	 hasDefaultSlots = hasSlots(arguments, "default");

	// eslint-disable-next-line
	 $$invalidate(1, hasTextSlots = hasSlots(arguments, "text"));

	$$props = exclude_internal_props($$props);

	return [
		text,
		hasTextSlots,
		el,
		attrs,
		classes,
		hasIcon,
		isLink,
		onClick,
		$$props,
		className,
		iconOnly,
		href,
		link,
		target,
		dropdown,
		hrefComputed,
		iconOnlyComputed,
		$$scope,
		slots,
		a_binding,
		div_binding
	];
}

class Menu_item extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$F, create_fragment$L, safe_not_equal, {
			class: 9,
			text: 0,
			iconOnly: 10,
			href: 11,
			link: 12,
			target: 13,
			dropdown: 14
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Menu_item",
			options,
			id: create_fragment$L.name
		});
	}

	get class() {
		throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iconOnly() {
		throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconOnly(value) {
		throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get link() {
		throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set link(value) {
		throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get target() {
		throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set target(value) {
		throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dropdown() {
		throw new Error("<Menu_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dropdown(value) {
		throw new Error("<Menu_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/menu.svelte generated by Svelte v3.31.0 */
const file$M = "node_modules/framework7-svelte/components/menu.svelte";

function create_fragment$M(ctx) {
	let div1;
	let div0;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div1_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div0, "class", "menu-inner");
			add_location(div0, file$M, 17, 2, 361);
			set_attributes(div1, div1_data);
			add_location(div1, file$M, 16, 0, 309);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$M.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$G($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Menu", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "menu", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class Menu extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$G, create_fragment$M, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Menu",
			options,
			id: create_fragment$M.name
		});
	}

	get class() {
		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/message.svelte generated by Svelte v3.31.0 */
const file$N = "node_modules/framework7-svelte/components/message.svelte";
const get_end_slot_changes = dirty => ({});
const get_end_slot_context = ctx => ({});
const get_content_end_slot_changes$2 = dirty => ({});
const get_content_end_slot_context$2 = ctx => ({});
const get_footer_slot_changes$2 = dirty => ({});
const get_footer_slot_context$2 = ctx => ({});
const get_bubble_end_slot_changes = dirty => ({});
const get_bubble_end_slot_context = ctx => ({});
const get_text_footer_slot_changes = dirty => ({});
const get_text_footer_slot_context = ctx => ({});
const get_text_slot_changes$4 = dirty => ({});
const get_text_slot_context$4 = ctx => ({});
const get_text_header_slot_changes = dirty => ({});
const get_text_header_slot_context = ctx => ({});
const get_image_slot_changes = dirty => ({});
const get_image_slot_context = ctx => ({});
const get_bubble_start_slot_changes = dirty => ({});
const get_bubble_start_slot_context = ctx => ({});
const get_header_slot_changes$2 = dirty => ({});
const get_header_slot_context$2 = ctx => ({});
const get_name_slot_changes = dirty => ({});
const get_name_slot_context = ctx => ({});
const get_content_start_slot_changes$2 = dirty => ({});
const get_content_start_slot_context$2 = ctx => ({});
const get_avatar_slot_changes = dirty => ({});
const get_avatar_slot_context = ctx => ({});
const get_start_slot_changes = dirty => ({});
const get_start_slot_context = ctx => ({});

// (99:2) {#if (avatar || hasAvatarSlots)}
function create_if_block_10$3(ctx) {
	let div;
	let div_style_value;
	let current;
	let mounted;
	let dispose;
	const avatar_slot_template = /*#slots*/ ctx[37].avatar;
	const avatar_slot = create_slot(avatar_slot_template, ctx, /*$$scope*/ ctx[36], get_avatar_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			if (avatar_slot) avatar_slot.c();
			attr_dev(div, "class", "message-avatar");

			attr_dev(div, "style", div_style_value = /*avatar*/ ctx[3]
			? `background-image: url(${/*avatar*/ ctx[3]})`
			: undefined);

			add_location(div, file$N, 99, 4, 3030);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (avatar_slot) {
				avatar_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*onAvatarClick*/ ctx[22], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (avatar_slot) {
				if (avatar_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(avatar_slot, avatar_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_avatar_slot_changes, get_avatar_slot_context);
				}
			}

			if (!current || dirty[0] & /*avatar*/ 8 && div_style_value !== (div_style_value = /*avatar*/ ctx[3]
			? `background-image: url(${/*avatar*/ ctx[3]})`
			: undefined)) {
				attr_dev(div, "style", div_style_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(avatar_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(avatar_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (avatar_slot) avatar_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10$3.name,
		type: "if",
		source: "(99:2) {#if (avatar || hasAvatarSlots)}",
		ctx
	});

	return block;
}

// (110:4) {#if (hasNameSlots || name)}
function create_if_block_9$3(ctx) {
	let div;
	let t0_value = Utils.text(/*name*/ ctx[2]) + "";
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	const name_slot_template = /*#slots*/ ctx[37].name;
	const name_slot = create_slot(name_slot_template, ctx, /*$$scope*/ ctx[36], get_name_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (name_slot) name_slot.c();
			attr_dev(div, "class", "message-name");
			add_location(div, file$N, 110, 6, 3324);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (name_slot) {
				name_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*onNameClick*/ ctx[20], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*name*/ 4) && t0_value !== (t0_value = Utils.text(/*name*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

			if (name_slot) {
				if (name_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(name_slot, name_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_name_slot_changes, get_name_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(name_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(name_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (name_slot) name_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9$3.name,
		type: "if",
		source: "(110:4) {#if (hasNameSlots || name)}",
		ctx
	});

	return block;
}

// (116:4) {#if (hasHeaderSlots || header)}
function create_if_block_8$3(ctx) {
	let div;
	let t0_value = Utils.text(/*header*/ ctx[5]) + "";
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	const header_slot_template = /*#slots*/ ctx[37].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[36], get_header_slot_context$2);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (header_slot) header_slot.c();
			attr_dev(div, "class", "message-header");
			add_location(div, file$N, 116, 6, 3495);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (header_slot) {
				header_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*onHeaderClick*/ ctx[23], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*header*/ 32) && t0_value !== (t0_value = Utils.text(/*header*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

			if (header_slot) {
				if (header_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(header_slot, header_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_header_slot_changes$2, get_header_slot_context$2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8$3.name,
		type: "if",
		source: "(116:4) {#if (hasHeaderSlots || header)}",
		ctx
	});

	return block;
}

// (124:6) {#if (hasImageSlots || image)}
function create_if_block_6$3(ctx) {
	let div;
	let t;
	let current;
	let if_block = /*image*/ ctx[4] && create_if_block_7$3(ctx);
	const image_slot_template = /*#slots*/ ctx[37].image;
	const image_slot = create_slot(image_slot_template, ctx, /*$$scope*/ ctx[36], get_image_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (image_slot) image_slot.c();
			attr_dev(div, "class", "message-image");
			add_location(div, file$N, 124, 8, 3768);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (image_slot) {
				image_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*image*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_7$3(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (image_slot) {
				if (image_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(image_slot, image_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_image_slot_changes, get_image_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(image_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(image_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (image_slot) image_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6$3.name,
		type: "if",
		source: "(124:6) {#if (hasImageSlots || image)}",
		ctx
	});

	return block;
}

// (126:10) {#if image}
function create_if_block_7$3(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*image*/ ctx[4])) attr_dev(img, "src", img_src_value);
			add_location(img, file$N, 126, 12, 3830);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*image*/ 16 && img.src !== (img_src_value = /*image*/ ctx[4])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7$3.name,
		type: "if",
		source: "(126:10) {#if image}",
		ctx
	});

	return block;
}

// (132:6) {#if (hasTextHeaderSlots || textHeader)}
function create_if_block_5$3(ctx) {
	let div;
	let t0_value = Utils.text(/*textHeader*/ ctx[7]) + "";
	let t0;
	let t1;
	let current;
	const text_header_slot_template = /*#slots*/ ctx[37]["text-header"];
	const text_header_slot = create_slot(text_header_slot_template, ctx, /*$$scope*/ ctx[36], get_text_header_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_header_slot) text_header_slot.c();
			attr_dev(div, "class", "message-text-header");
			add_location(div, file$N, 132, 8, 3979);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (text_header_slot) {
				text_header_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*textHeader*/ 128) && t0_value !== (t0_value = Utils.text(/*textHeader*/ ctx[7]) + "")) set_data_dev(t0, t0_value);

			if (text_header_slot) {
				if (text_header_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(text_header_slot, text_header_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_text_header_slot_changes, get_text_header_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_header_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_header_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (text_header_slot) text_header_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5$3.name,
		type: "if",
		source: "(132:6) {#if (hasTextHeaderSlots || textHeader)}",
		ctx
	});

	return block;
}

// (138:6) {#if (hasTextSlots || text || htmlText || typing)}
function create_if_block_2$b(ctx) {
	let div;
	let t0_value = Utils.text(/*text*/ ctx[0]) + "";
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*htmlText*/ ctx[1] && create_if_block_4$6(ctx);
	const text_slot_template = /*#slots*/ ctx[37].text;
	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[36], get_text_slot_context$4);
	let if_block1 = /*typing*/ ctx[9] && create_if_block_3$9(ctx);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (text_slot) text_slot.c();
			t3 = space();
			if (if_block1) if_block1.c();
			attr_dev(div, "class", "message-text");
			add_location(div, file$N, 138, 8, 4177);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t2);

			if (text_slot) {
				text_slot.m(div, null);
			}

			append_dev(div, t3);
			if (if_block1) if_block1.m(div, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*onTextClick*/ ctx[21], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*text*/ 1) && t0_value !== (t0_value = Utils.text(/*text*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (/*htmlText*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4$6(ctx);
					if_block0.c();
					if_block0.m(div, t2);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (text_slot) {
				if (text_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(text_slot, text_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_text_slot_changes$4, get_text_slot_context$4);
				}
			}

			if (/*typing*/ ctx[9]) {
				if (if_block1) ; else {
					if_block1 = create_if_block_3$9(ctx);
					if_block1.c();
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (text_slot) text_slot.d(detaching);
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$b.name,
		type: "if",
		source: "(138:6) {#if (hasTextSlots || text || htmlText || typing)}",
		ctx
	});

	return block;
}

// (141:10) {#if htmlText}
function create_if_block_4$6(ctx) {
	let html_tag;
	let html_anchor;

	const block = {
		c: function create() {
			html_anchor = empty();
			html_tag = new HtmlTag(html_anchor);
		},
		m: function mount(target, anchor) {
			html_tag.m(/*htmlText*/ ctx[1], target, anchor);
			insert_dev(target, html_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*htmlText*/ 2) html_tag.p(/*htmlText*/ ctx[1]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(html_anchor);
			if (detaching) html_tag.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$6.name,
		type: "if",
		source: "(141:10) {#if htmlText}",
		ctx
	});

	return block;
}

// (143:10) {#if typing}
function create_if_block_3$9(ctx) {
	let div3;
	let div0;
	let t0;
	let div1;
	let t1;
	let div2;

	const block = {
		c: function create() {
			div3 = element("div");
			div0 = element("div");
			t0 = space();
			div1 = element("div");
			t1 = space();
			div2 = element("div");
			add_location(div0, file$N, 144, 14, 4420);
			add_location(div1, file$N, 145, 14, 4442);
			add_location(div2, file$N, 146, 14, 4464);
			attr_dev(div3, "class", "message-typing-indicator");
			add_location(div3, file$N, 143, 12, 4367);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div3, anchor);
			append_dev(div3, div0);
			append_dev(div3, t0);
			append_dev(div3, div1);
			append_dev(div3, t1);
			append_dev(div3, div2);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$9.name,
		type: "if",
		source: "(143:10) {#if typing}",
		ctx
	});

	return block;
}

// (152:6) {#if (hasTextFooterSlots || textFooter)}
function create_if_block_1$b(ctx) {
	let div;
	let t0_value = Utils.text(/*textFooter*/ ctx[8]) + "";
	let t0;
	let t1;
	let current;
	const text_footer_slot_template = /*#slots*/ ctx[37]["text-footer"];
	const text_footer_slot = create_slot(text_footer_slot_template, ctx, /*$$scope*/ ctx[36], get_text_footer_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (text_footer_slot) text_footer_slot.c();
			attr_dev(div, "class", "message-text-footer");
			add_location(div, file$N, 152, 8, 4589);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (text_footer_slot) {
				text_footer_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*textFooter*/ 256) && t0_value !== (t0_value = Utils.text(/*textFooter*/ ctx[8]) + "")) set_data_dev(t0, t0_value);

			if (text_footer_slot) {
				if (text_footer_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(text_footer_slot, text_footer_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_text_footer_slot_changes, get_text_footer_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(text_footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(text_footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (text_footer_slot) text_footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$b.name,
		type: "if",
		source: "(152:6) {#if (hasTextFooterSlots || textFooter)}",
		ctx
	});

	return block;
}

// (161:4) {#if (hasFooterSlots || footer)}
function create_if_block$h(ctx) {
	let div;
	let t0_value = Utils.text(/*footer*/ ctx[6]) + "";
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	const footer_slot_template = /*#slots*/ ctx[37].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[36], get_footer_slot_context$2);

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (footer_slot) footer_slot.c();
			attr_dev(div, "class", "message-footer");
			add_location(div, file$N, 161, 6, 4823);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);

			if (footer_slot) {
				footer_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*onFooterClick*/ ctx[24], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*footer*/ 64) && t0_value !== (t0_value = Utils.text(/*footer*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

			if (footer_slot) {
				if (footer_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(footer_slot, footer_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_footer_slot_changes$2, get_footer_slot_context$2);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (footer_slot) footer_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$h.name,
		type: "if",
		source: "(161:4) {#if (hasFooterSlots || footer)}",
		ctx
	});

	return block;
}

function create_fragment$N(ctx) {
	let div2;
	let t0;
	let t1;
	let div1;
	let t2;
	let t3;
	let t4;
	let div0;
	let t5;
	let t6;
	let t7;
	let t8;
	let t9;
	let t10;
	let t11;
	let t12;
	let t13;
	let current;
	let mounted;
	let dispose;
	const start_slot_template = /*#slots*/ ctx[37].start;
	const start_slot = create_slot(start_slot_template, ctx, /*$$scope*/ ctx[36], get_start_slot_context);
	let if_block0 = (/*avatar*/ ctx[3] || /*hasAvatarSlots*/ ctx[11]) && create_if_block_10$3(ctx);
	const content_start_slot_template = /*#slots*/ ctx[37]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[36], get_content_start_slot_context$2);
	let if_block1 = (/*hasNameSlots*/ ctx[12] || /*name*/ ctx[2]) && create_if_block_9$3(ctx);
	let if_block2 = (/*hasHeaderSlots*/ ctx[13] || /*header*/ ctx[5]) && create_if_block_8$3(ctx);
	const bubble_start_slot_template = /*#slots*/ ctx[37]["bubble-start"];
	const bubble_start_slot = create_slot(bubble_start_slot_template, ctx, /*$$scope*/ ctx[36], get_bubble_start_slot_context);
	let if_block3 = (/*hasImageSlots*/ ctx[14] || /*image*/ ctx[4]) && create_if_block_6$3(ctx);
	let if_block4 = (/*hasTextHeaderSlots*/ ctx[15] || /*textHeader*/ ctx[7]) && create_if_block_5$3(ctx);
	let if_block5 = (/*hasTextSlots*/ ctx[17] || /*text*/ ctx[0] || /*htmlText*/ ctx[1] || /*typing*/ ctx[9]) && create_if_block_2$b(ctx);
	let if_block6 = (/*hasTextFooterSlots*/ ctx[16] || /*textFooter*/ ctx[8]) && create_if_block_1$b(ctx);
	const bubble_end_slot_template = /*#slots*/ ctx[37]["bubble-end"];
	const bubble_end_slot = create_slot(bubble_end_slot_template, ctx, /*$$scope*/ ctx[36], get_bubble_end_slot_context);
	const default_slot_template = /*#slots*/ ctx[37].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[36], null);
	let if_block7 = (/*hasFooterSlots*/ ctx[18] || /*footer*/ ctx[6]) && create_if_block$h(ctx);
	const content_end_slot_template = /*#slots*/ ctx[37]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[36], get_content_end_slot_context$2);
	const end_slot_template = /*#slots*/ ctx[37].end;
	const end_slot = create_slot(end_slot_template, ctx, /*$$scope*/ ctx[36], get_end_slot_context);
	let div2_levels = [{ class: /*classes*/ ctx[10] }, restProps(/*$$restProps*/ ctx[26])];
	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			if (start_slot) start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			div0 = element("div");
			if (bubble_start_slot) bubble_start_slot.c();
			t5 = space();
			if (if_block3) if_block3.c();
			t6 = space();
			if (if_block4) if_block4.c();
			t7 = space();
			if (if_block5) if_block5.c();
			t8 = space();
			if (if_block6) if_block6.c();
			t9 = space();
			if (bubble_end_slot) bubble_end_slot.c();
			t10 = space();
			if (default_slot) default_slot.c();
			t11 = space();
			if (if_block7) if_block7.c();
			t12 = space();
			if (content_end_slot) content_end_slot.c();
			t13 = space();
			if (end_slot) end_slot.c();
			attr_dev(div0, "class", "message-bubble");
			add_location(div0, file$N, 121, 4, 3635);
			attr_dev(div1, "class", "message-content");
			add_location(div1, file$N, 107, 2, 3222);
			set_attributes(div2, div2_data);
			add_location(div2, file$N, 96, 0, 2899);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);

			if (start_slot) {
				start_slot.m(div2, null);
			}

			append_dev(div2, t0);
			if (if_block0) if_block0.m(div2, null);
			append_dev(div2, t1);
			append_dev(div2, div1);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_dev(div1, t2);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t3);
			if (if_block2) if_block2.m(div1, null);
			append_dev(div1, t4);
			append_dev(div1, div0);

			if (bubble_start_slot) {
				bubble_start_slot.m(div0, null);
			}

			append_dev(div0, t5);
			if (if_block3) if_block3.m(div0, null);
			append_dev(div0, t6);
			if (if_block4) if_block4.m(div0, null);
			append_dev(div0, t7);
			if (if_block5) if_block5.m(div0, null);
			append_dev(div0, t8);
			if (if_block6) if_block6.m(div0, null);
			append_dev(div0, t9);

			if (bubble_end_slot) {
				bubble_end_slot.m(div0, null);
			}

			append_dev(div0, t10);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			append_dev(div1, t11);
			if (if_block7) if_block7.m(div1, null);
			append_dev(div1, t12);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			append_dev(div2, t13);

			if (end_slot) {
				end_slot.m(div2, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(div0, "click", /*onBubbleClick*/ ctx[25], false, false, false),
					listen_dev(div2, "click", /*onClick*/ ctx[19], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (start_slot) {
				if (start_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(start_slot, start_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_start_slot_changes, get_start_slot_context);
				}
			}

			if (/*avatar*/ ctx[3] || /*hasAvatarSlots*/ ctx[11]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*avatar, hasAvatarSlots*/ 2056) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_10$3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div2, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (content_start_slot) {
				if (content_start_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_content_start_slot_changes$2, get_content_start_slot_context$2);
				}
			}

			if (/*hasNameSlots*/ ctx[12] || /*name*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*hasNameSlots, name*/ 4100) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_9$3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*hasHeaderSlots*/ ctx[13] || /*header*/ ctx[5]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*hasHeaderSlots, header*/ 8224) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_8$3(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, t4);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (bubble_start_slot) {
				if (bubble_start_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(bubble_start_slot, bubble_start_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_bubble_start_slot_changes, get_bubble_start_slot_context);
				}
			}

			if (/*hasImageSlots*/ ctx[14] || /*image*/ ctx[4]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*hasImageSlots, image*/ 16400) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block_6$3(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div0, t6);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (/*hasTextHeaderSlots*/ ctx[15] || /*textHeader*/ ctx[7]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);

					if (dirty[0] & /*hasTextHeaderSlots, textHeader*/ 32896) {
						transition_in(if_block4, 1);
					}
				} else {
					if_block4 = create_if_block_5$3(ctx);
					if_block4.c();
					transition_in(if_block4, 1);
					if_block4.m(div0, t7);
				}
			} else if (if_block4) {
				group_outros();

				transition_out(if_block4, 1, 1, () => {
					if_block4 = null;
				});

				check_outros();
			}

			if (/*hasTextSlots*/ ctx[17] || /*text*/ ctx[0] || /*htmlText*/ ctx[1] || /*typing*/ ctx[9]) {
				if (if_block5) {
					if_block5.p(ctx, dirty);

					if (dirty[0] & /*hasTextSlots, text, htmlText, typing*/ 131587) {
						transition_in(if_block5, 1);
					}
				} else {
					if_block5 = create_if_block_2$b(ctx);
					if_block5.c();
					transition_in(if_block5, 1);
					if_block5.m(div0, t8);
				}
			} else if (if_block5) {
				group_outros();

				transition_out(if_block5, 1, 1, () => {
					if_block5 = null;
				});

				check_outros();
			}

			if (/*hasTextFooterSlots*/ ctx[16] || /*textFooter*/ ctx[8]) {
				if (if_block6) {
					if_block6.p(ctx, dirty);

					if (dirty[0] & /*hasTextFooterSlots, textFooter*/ 65792) {
						transition_in(if_block6, 1);
					}
				} else {
					if_block6 = create_if_block_1$b(ctx);
					if_block6.c();
					transition_in(if_block6, 1);
					if_block6.m(div0, t9);
				}
			} else if (if_block6) {
				group_outros();

				transition_out(if_block6, 1, 1, () => {
					if_block6 = null;
				});

				check_outros();
			}

			if (bubble_end_slot) {
				if (bubble_end_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(bubble_end_slot, bubble_end_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_bubble_end_slot_changes, get_bubble_end_slot_context);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[36], dirty, null, null);
				}
			}

			if (/*hasFooterSlots*/ ctx[18] || /*footer*/ ctx[6]) {
				if (if_block7) {
					if_block7.p(ctx, dirty);

					if (dirty[0] & /*hasFooterSlots, footer*/ 262208) {
						transition_in(if_block7, 1);
					}
				} else {
					if_block7 = create_if_block$h(ctx);
					if_block7.c();
					transition_in(if_block7, 1);
					if_block7.m(div1, t12);
				}
			} else if (if_block7) {
				group_outros();

				transition_out(if_block7, 1, 1, () => {
					if_block7 = null;
				});

				check_outros();
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_content_end_slot_changes$2, get_content_end_slot_context$2);
				}
			}

			if (end_slot) {
				if (end_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(end_slot, end_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_end_slot_changes, get_end_slot_context);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty[0] & /*classes*/ 1024) && { class: /*classes*/ ctx[10] },
				dirty[0] & /*$$restProps*/ 67108864 && restProps(/*$$restProps*/ ctx[26])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(start_slot, local);
			transition_in(if_block0);
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(bubble_start_slot, local);
			transition_in(if_block3);
			transition_in(if_block4);
			transition_in(if_block5);
			transition_in(if_block6);
			transition_in(bubble_end_slot, local);
			transition_in(default_slot, local);
			transition_in(if_block7);
			transition_in(content_end_slot, local);
			transition_in(end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(start_slot, local);
			transition_out(if_block0);
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(bubble_start_slot, local);
			transition_out(if_block3);
			transition_out(if_block4);
			transition_out(if_block5);
			transition_out(if_block6);
			transition_out(bubble_end_slot, local);
			transition_out(default_slot, local);
			transition_out(if_block7);
			transition_out(content_end_slot, local);
			transition_out(end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (start_slot) start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (bubble_start_slot) bubble_start_slot.d(detaching);
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
			if (if_block5) if_block5.d();
			if (if_block6) if_block6.d();
			if (bubble_end_slot) bubble_end_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (if_block7) if_block7.d();
			if (content_end_slot) content_end_slot.d(detaching);
			if (end_slot) end_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$N.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$H($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","text","htmlText","name","avatar","type","image","header","footer","textHeader","textFooter","first","last","tail","sameName","sameHeader","sameFooter","sameAvatar","typing"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;

	validate_slots("Message", slots, [
		'start','avatar','content-start','name','header','bubble-start','image','text-header','text','text-footer','bubble-end','default','footer','content-end','end'
	]);

	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { text = undefined } = $$props;
	let { htmlText = undefined } = $$props;
	let { name = undefined } = $$props;
	let { avatar = undefined } = $$props;
	let { type = "sent" } = $$props;
	let { image = undefined } = $$props;
	let { header = undefined } = $$props;
	let { footer = undefined } = $$props;
	let { textHeader = undefined } = $$props;
	let { textFooter = undefined } = $$props;
	let { first = undefined } = $$props;
	let { last = undefined } = $$props;
	let { tail = undefined } = $$props;
	let { sameName = undefined } = $$props;
	let { sameHeader = undefined } = $$props;
	let { sameFooter = undefined } = $$props;
	let { sameAvatar = undefined } = $$props;
	let { typing = undefined } = $$props;

	function onClick() {
		dispatch("click");
		if (typeof $$props.onClick === "function") $$props.onClick();
	}

	function onNameClick() {
		dispatch("clickName");
		if (typeof $$props.onClickName === "function") $$props.onClickName();
	}

	function onTextClick() {
		dispatch("clickText");
		if (typeof $$props.onClickText === "function") $$props.onClickText();
	}

	function onAvatarClick() {
		dispatch("clickAvatar");
		if (typeof $$props.onClickAvatar === "function") $$props.onClickAvatar();
	}

	function onHeaderClick() {
		dispatch("clickHeader");
		if (typeof $$props.onClickHeader === "function") $$props.onClickHeader();
	}

	function onFooterClick() {
		dispatch("clickFooter");
		if (typeof $$props.onClickFooter === "function") $$props.onClickFooter();
	}

	function onBubbleClick() {
		dispatch("clickBubble");
		if (typeof $$props.onClickBubble === "function") $$props.onClickBubble();
	}

	$$self.$$set = $$new_props => {
		$$invalidate(39, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(26, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(27, className = $$new_props.class);
		if ("text" in $$new_props) $$invalidate(0, text = $$new_props.text);
		if ("htmlText" in $$new_props) $$invalidate(1, htmlText = $$new_props.htmlText);
		if ("name" in $$new_props) $$invalidate(2, name = $$new_props.name);
		if ("avatar" in $$new_props) $$invalidate(3, avatar = $$new_props.avatar);
		if ("type" in $$new_props) $$invalidate(28, type = $$new_props.type);
		if ("image" in $$new_props) $$invalidate(4, image = $$new_props.image);
		if ("header" in $$new_props) $$invalidate(5, header = $$new_props.header);
		if ("footer" in $$new_props) $$invalidate(6, footer = $$new_props.footer);
		if ("textHeader" in $$new_props) $$invalidate(7, textHeader = $$new_props.textHeader);
		if ("textFooter" in $$new_props) $$invalidate(8, textFooter = $$new_props.textFooter);
		if ("first" in $$new_props) $$invalidate(29, first = $$new_props.first);
		if ("last" in $$new_props) $$invalidate(30, last = $$new_props.last);
		if ("tail" in $$new_props) $$invalidate(31, tail = $$new_props.tail);
		if ("sameName" in $$new_props) $$invalidate(32, sameName = $$new_props.sameName);
		if ("sameHeader" in $$new_props) $$invalidate(33, sameHeader = $$new_props.sameHeader);
		if ("sameFooter" in $$new_props) $$invalidate(34, sameFooter = $$new_props.sameFooter);
		if ("sameAvatar" in $$new_props) $$invalidate(35, sameAvatar = $$new_props.sameAvatar);
		if ("typing" in $$new_props) $$invalidate(9, typing = $$new_props.typing);
		if ("$$scope" in $$new_props) $$invalidate(36, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		Mixins,
		Utils,
		restProps,
		hasSlots,
		dispatch,
		className,
		text,
		htmlText,
		name,
		avatar,
		type,
		image,
		header,
		footer,
		textHeader,
		textFooter,
		first,
		last,
		tail,
		sameName,
		sameHeader,
		sameFooter,
		sameAvatar,
		typing,
		onClick,
		onNameClick,
		onTextClick,
		onAvatarClick,
		onHeaderClick,
		onFooterClick,
		onBubbleClick,
		classes,
		hasAvatarSlots,
		hasNameSlots,
		hasHeaderSlots,
		hasImageSlots,
		hasTextHeaderSlots,
		hasTextFooterSlots,
		hasTextSlots,
		hasFooterSlots
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(39, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(27, className = $$new_props.className);
		if ("text" in $$props) $$invalidate(0, text = $$new_props.text);
		if ("htmlText" in $$props) $$invalidate(1, htmlText = $$new_props.htmlText);
		if ("name" in $$props) $$invalidate(2, name = $$new_props.name);
		if ("avatar" in $$props) $$invalidate(3, avatar = $$new_props.avatar);
		if ("type" in $$props) $$invalidate(28, type = $$new_props.type);
		if ("image" in $$props) $$invalidate(4, image = $$new_props.image);
		if ("header" in $$props) $$invalidate(5, header = $$new_props.header);
		if ("footer" in $$props) $$invalidate(6, footer = $$new_props.footer);
		if ("textHeader" in $$props) $$invalidate(7, textHeader = $$new_props.textHeader);
		if ("textFooter" in $$props) $$invalidate(8, textFooter = $$new_props.textFooter);
		if ("first" in $$props) $$invalidate(29, first = $$new_props.first);
		if ("last" in $$props) $$invalidate(30, last = $$new_props.last);
		if ("tail" in $$props) $$invalidate(31, tail = $$new_props.tail);
		if ("sameName" in $$props) $$invalidate(32, sameName = $$new_props.sameName);
		if ("sameHeader" in $$props) $$invalidate(33, sameHeader = $$new_props.sameHeader);
		if ("sameFooter" in $$props) $$invalidate(34, sameFooter = $$new_props.sameFooter);
		if ("sameAvatar" in $$props) $$invalidate(35, sameAvatar = $$new_props.sameAvatar);
		if ("typing" in $$props) $$invalidate(9, typing = $$new_props.typing);
		if ("classes" in $$props) $$invalidate(10, classes = $$new_props.classes);
		if ("hasAvatarSlots" in $$props) $$invalidate(11, hasAvatarSlots = $$new_props.hasAvatarSlots);
		if ("hasNameSlots" in $$props) $$invalidate(12, hasNameSlots = $$new_props.hasNameSlots);
		if ("hasHeaderSlots" in $$props) $$invalidate(13, hasHeaderSlots = $$new_props.hasHeaderSlots);
		if ("hasImageSlots" in $$props) $$invalidate(14, hasImageSlots = $$new_props.hasImageSlots);
		if ("hasTextHeaderSlots" in $$props) $$invalidate(15, hasTextHeaderSlots = $$new_props.hasTextHeaderSlots);
		if ("hasTextFooterSlots" in $$props) $$invalidate(16, hasTextFooterSlots = $$new_props.hasTextFooterSlots);
		if ("hasTextSlots" in $$props) $$invalidate(17, hasTextSlots = $$new_props.hasTextSlots);
		if ("hasFooterSlots" in $$props) $$invalidate(18, hasFooterSlots = $$new_props.hasFooterSlots);
	};

	let classes;
	let hasAvatarSlots;
	let hasNameSlots;
	let hasHeaderSlots;
	let hasImageSlots;
	let hasTextHeaderSlots;
	let hasTextFooterSlots;
	let hasTextSlots;
	let hasFooterSlots;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(10, classes = Utils.classNames(
			className,
			"message",
			{
				"message-sent": type === "sent" || !type,
				"message-received": type === "received",
				"message-typing": typing,
				"message-first": first,
				"message-last": last,
				"message-tail": tail,
				"message-same-name": sameName,
				"message-same-header": sameHeader,
				"message-same-footer": sameFooter,
				"message-same-avatar": sameAvatar
			},
			Mixins.colorClasses($$props)
		));
	};

	 $$invalidate(11, hasAvatarSlots = hasSlots(arguments, "avatar"));
	 $$invalidate(12, hasNameSlots = hasSlots(arguments, "name"));
	 $$invalidate(13, hasHeaderSlots = hasSlots(arguments, "header"));
	 $$invalidate(14, hasImageSlots = hasSlots(arguments, "image"));
	 $$invalidate(15, hasTextHeaderSlots = hasSlots(arguments, "text-header"));
	 $$invalidate(16, hasTextFooterSlots = hasSlots(arguments, "text-footer"));
	 $$invalidate(17, hasTextSlots = hasSlots(arguments, "text"));
	 $$invalidate(18, hasFooterSlots = hasSlots(arguments, "footer"));
	$$props = exclude_internal_props($$props);

	return [
		text,
		htmlText,
		name,
		avatar,
		image,
		header,
		footer,
		textHeader,
		textFooter,
		typing,
		classes,
		hasAvatarSlots,
		hasNameSlots,
		hasHeaderSlots,
		hasImageSlots,
		hasTextHeaderSlots,
		hasTextFooterSlots,
		hasTextSlots,
		hasFooterSlots,
		onClick,
		onNameClick,
		onTextClick,
		onAvatarClick,
		onHeaderClick,
		onFooterClick,
		onBubbleClick,
		$$restProps,
		className,
		type,
		first,
		last,
		tail,
		sameName,
		sameHeader,
		sameFooter,
		sameAvatar,
		$$scope,
		slots
	];
}

class Message extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$H,
			create_fragment$N,
			safe_not_equal,
			{
				class: 27,
				text: 0,
				htmlText: 1,
				name: 2,
				avatar: 3,
				type: 28,
				image: 4,
				header: 5,
				footer: 6,
				textHeader: 7,
				textFooter: 8,
				first: 29,
				last: 30,
				tail: 31,
				sameName: 32,
				sameHeader: 33,
				sameFooter: 34,
				sameAvatar: 35,
				typing: 9
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Message",
			options,
			id: create_fragment$N.name
		});
	}

	get class() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get htmlText() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set htmlText(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get avatar() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set avatar(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get image() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set image(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get header() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set header(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get footer() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set footer(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get textHeader() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set textHeader(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get textFooter() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set textFooter(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get first() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set first(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get last() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set last(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tail() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tail(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sameName() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sameName(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sameHeader() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sameHeader(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sameFooter() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sameFooter(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sameAvatar() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sameAvatar(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get typing() {
		throw new Error("<Message>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set typing(value) {
		throw new Error("<Message>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/messagebar-attachment.svelte generated by Svelte v3.31.0 */
const file$O = "node_modules/framework7-svelte/components/messagebar-attachment.svelte";

// (33:2) {#if image}
function create_if_block_1$c(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			if (img.src !== (img_src_value = /*image*/ ctx[0])) attr_dev(img, "src", img_src_value);
			add_location(img, file$O, 33, 4, 957);
		},
		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*image*/ 1 && img.src !== (img_src_value = /*image*/ ctx[0])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$c.name,
		type: "if",
		source: "(33:2) {#if image}",
		ctx
	});

	return block;
}

// (36:2) {#if deletable}
function create_if_block$i(ctx) {
	let span;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "messagebar-attachment-delete");
			add_location(span, file$O, 36, 4, 1007);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (!mounted) {
				dispose = listen_dev(span, "click", /*onDeleteClick*/ ctx[4], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$i.name,
		type: "if",
		source: "(36:2) {#if deletable}",
		ctx
	});

	return block;
}

function create_fragment$O(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*image*/ ctx[0] && create_if_block_1$c(ctx);
	let if_block1 = /*deletable*/ ctx[1] && create_if_block$i(ctx);
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
	let div_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[5])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$O, 31, 0, 870);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t1);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*onClick*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (/*image*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$c(ctx);
					if_block0.c();
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*deletable*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$i(ctx);
					if_block1.c();
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty & /*$$restProps*/ 32 && restProps(/*$$restProps*/ ctx[5])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$O.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$I($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","image","deletable"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Messagebar_attachment", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { image = undefined } = $$props;
	let { deletable = true } = $$props;

	function onClick(event) {
		dispatch("attachmentClick", [event]);
		if (typeof $$props.onAttachmentClick === "function") $$props.onAttachmentClick(event);
	}

	function onDeleteClick(event) {
		dispatch("attachmentDelete", [event]);
		if (typeof $$props.onAttachmentDelete === "function") $$props.onAttachmentDelete(event);
	}

	$$self.$$set = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ("image" in $$new_props) $$invalidate(0, image = $$new_props.image);
		if ("deletable" in $$new_props) $$invalidate(1, deletable = $$new_props.deletable);
		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		Mixins,
		Utils,
		restProps,
		dispatch,
		className,
		image,
		deletable,
		onClick,
		onDeleteClick,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
		if ("image" in $$props) $$invalidate(0, image = $$new_props.image);
		if ("deletable" in $$props) $$invalidate(1, deletable = $$new_props.deletable);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(2, classes = Utils.classNames(className, "messagebar-attachment", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);

	return [
		image,
		deletable,
		classes,
		onClick,
		onDeleteClick,
		$$restProps,
		className,
		$$scope,
		slots
	];
}

class Messagebar_attachment extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$I, create_fragment$O, safe_not_equal, { class: 6, image: 0, deletable: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Messagebar_attachment",
			options,
			id: create_fragment$O.name
		});
	}

	get class() {
		throw new Error("<Messagebar_attachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Messagebar_attachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get image() {
		throw new Error("<Messagebar_attachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set image(value) {
		throw new Error("<Messagebar_attachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get deletable() {
		throw new Error("<Messagebar_attachment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set deletable(value) {
		throw new Error("<Messagebar_attachment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/messagebar-attachments.svelte generated by Svelte v3.31.0 */
const file$P = "node_modules/framework7-svelte/components/messagebar-attachments.svelte";

function create_fragment$P(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$P, 16, 0, 327);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$P.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$J($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Messagebar_attachments", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "messagebar-attachments", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class Messagebar_attachments extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$J, create_fragment$P, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Messagebar_attachments",
			options,
			id: create_fragment$P.name
		});
	}

	get class() {
		throw new Error("<Messagebar_attachments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Messagebar_attachments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/messagebar-sheet-image.svelte generated by Svelte v3.31.0 */
const file$Q = "node_modules/framework7-svelte/components/messagebar-sheet-image.svelte";

function create_fragment$Q(ctx) {
	let label;
	let input;
	let t0;
	let i;
	let t1;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
	let label_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[3])];
	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	const block = {
		c: function create() {
			label = element("label");
			input = element("input");
			t0 = space();
			i = element("i");
			t1 = space();
			if (default_slot) default_slot.c();
			attr_dev(input, "type", "checkbox");
			input.checked = /*checked*/ ctx[0];
			add_location(input, file$Q, 37, 2, 1053);
			attr_dev(i, "class", "icon icon-checkbox");
			add_location(i, file$Q, 38, 2, 1120);
			set_attributes(label, label_data);
			add_location(label, file$Q, 36, 0, 999);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, input);
			append_dev(label, t0);
			append_dev(label, i);
			append_dev(label, t1);

			if (default_slot) {
				default_slot.m(label, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(input, "change", /*onChange*/ ctx[2], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*checked*/ 1) {
				prop_dev(input, "checked", /*checked*/ ctx[0]);
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$K($$self, $$props, $$invalidate) {
	const omit_props_names = ["style","class","image","checked"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Messagebar_sheet_image", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { style = undefined } = $$props;
	let { class: className = undefined } = $$props;
	let { image = undefined } = $$props;
	let { checked = false } = $$props;

	function onChange(event) {
		if (checked) dispatch("checked", [event]);
		if (typeof $$props.onChecked === "function") $$props.onChecked(event); else dispatch("unchecked", [event]);
		if (typeof $$props.onUnchecked === "function") $$props.onUnchecked(event);
		dispatch("change", [event]);
		if (typeof $$props.onChange === "function") $$props.onChange(event);
	}

	$$self.$$set = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("style" in $$new_props) $$invalidate(4, style = $$new_props.style);
		if ("class" in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ("image" in $$new_props) $$invalidate(6, image = $$new_props.image);
		if ("checked" in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		Mixins,
		Utils,
		restProps,
		dispatch,
		style,
		className,
		image,
		checked,
		onChange,
		classes,
		styles
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(11, $$props = assign(assign({}, $$props), $$new_props));
		if ("style" in $$props) $$invalidate(4, style = $$new_props.style);
		if ("className" in $$props) $$invalidate(5, className = $$new_props.className);
		if ("image" in $$props) $$invalidate(6, image = $$new_props.image);
		if ("checked" in $$props) $$invalidate(0, checked = $$new_props.checked);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
		if ("styles" in $$props) styles = $$new_props.styles;
	};

	let classes;
	let styles;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classes = Utils.classNames(className, "messagebar-sheet-image", "checkbox", Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*image, style*/ 80) {
			 styles = `${image ? `background-image: url(${image});` : ""}${style || ""}`;
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		checked,
		classes,
		onChange,
		$$restProps,
		style,
		className,
		image,
		$$scope,
		slots
	];
}

class Messagebar_sheet_image extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$K, create_fragment$Q, safe_not_equal, { style: 4, class: 5, image: 6, checked: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Messagebar_sheet_image",
			options,
			id: create_fragment$Q.name
		});
	}

	get style() {
		throw new Error("<Messagebar_sheet_image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Messagebar_sheet_image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Messagebar_sheet_image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Messagebar_sheet_image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get image() {
		throw new Error("<Messagebar_sheet_image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set image(value) {
		throw new Error("<Messagebar_sheet_image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<Messagebar_sheet_image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Messagebar_sheet_image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/messagebar-sheet-item.svelte generated by Svelte v3.31.0 */
const file$R = "node_modules/framework7-svelte/components/messagebar-sheet-item.svelte";

function create_fragment$R(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$R, 16, 0, 326);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$R.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$L($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Messagebar_sheet_item", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "messagebar-sheet-item", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class Messagebar_sheet_item extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$L, create_fragment$R, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Messagebar_sheet_item",
			options,
			id: create_fragment$R.name
		});
	}

	get class() {
		throw new Error("<Messagebar_sheet_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Messagebar_sheet_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/messagebar-sheet.svelte generated by Svelte v3.31.0 */
const file$S = "node_modules/framework7-svelte/components/messagebar-sheet.svelte";

function create_fragment$S(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$S, 16, 0, 321);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$S.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$M($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Messagebar_sheet", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "messagebar-sheet", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class Messagebar_sheet extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$M, create_fragment$S, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Messagebar_sheet",
			options,
			id: create_fragment$S.name
		});
	}

	get class() {
		throw new Error("<Messagebar_sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Messagebar_sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/messagebar.svelte generated by Svelte v3.31.0 */
const file$T = "node_modules/framework7-svelte/components/messagebar.svelte";
const get_after_inner_slot_changes_1 = dirty => ({});
const get_after_inner_slot_context_1 = ctx => ({});
const get_inner_end_slot_changes$2 = dirty => ({});
const get_inner_end_slot_context$2 = ctx => ({});
const get_send_link_slot_changes = dirty => ({});
const get_send_link_slot_context = ctx => ({});
const get_after_inner_slot_changes$1 = dirty => ({});
const get_after_inner_slot_context$1 = ctx => ({});
const get_before_area_slot_changes = dirty => ({});
const get_before_area_slot_context = ctx => ({});
const get_inner_start_slot_changes$2 = dirty => ({});
const get_inner_start_slot_context$2 = ctx => ({});
const get_before_inner_slot_changes$1 = dirty => ({});
const get_before_inner_slot_context$1 = ctx => ({});

// (234:4) {#if ((sendLink && sendLink.length > 0) || hasSendLinkSlots)}
function create_if_block$j(ctx) {
	let link;
	let current;

	link = new Link({
			props: {
				onClick: /*onClick*/ ctx[16],
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(link.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(link, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const link_changes = {};

			if (dirty[0] & /*sendLink*/ 2 | dirty[1] & /*$$scope*/ 32) {
				link_changes.$$scope = { dirty, ctx };
			}

			link.$set(link_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(link.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(link.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(link, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$j.name,
		type: "if",
		source: "(234:4) {#if ((sendLink && sendLink.length > 0) || hasSendLinkSlots)}",
		ctx
	});

	return block;
}

// (235:6) <Link onClick={onClick}>
function create_default_slot$3(ctx) {
	let t0;
	let t1;
	let current;
	const send_link_slot_template = /*#slots*/ ctx[34]["send-link"];
	const send_link_slot = create_slot(send_link_slot_template, ctx, /*$$scope*/ ctx[36], get_send_link_slot_context);

	const block = {
		c: function create() {
			if (send_link_slot) send_link_slot.c();
			t0 = space();
			t1 = text(/*sendLink*/ ctx[1]);
		},
		m: function mount(target, anchor) {
			if (send_link_slot) {
				send_link_slot.m(target, anchor);
			}

			insert_dev(target, t0, anchor);
			insert_dev(target, t1, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (send_link_slot) {
				if (send_link_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(send_link_slot, send_link_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_send_link_slot_changes, get_send_link_slot_context);
				}
			}

			if (!current || dirty[0] & /*sendLink*/ 2) set_data_dev(t1, /*sendLink*/ ctx[1]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(send_link_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(send_link_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (send_link_slot) send_link_slot.d(detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(t1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(235:6) <Link onClick={onClick}>",
		ctx
	});

	return block;
}

function create_fragment$T(ctx) {
	let div2;
	let t0;
	let div1;
	let t1;
	let div0;
	let t2;
	let input;
	let t3;
	let t4;
	let t5;
	let t6;
	let t7;
	let current;
	const before_inner_slot_template = /*#slots*/ ctx[34]["before-inner"];
	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[36], get_before_inner_slot_context$1);
	const inner_start_slot_template = /*#slots*/ ctx[34]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[36], get_inner_start_slot_context$2);
	const before_area_slot_template = /*#slots*/ ctx[34]["before-area"];
	const before_area_slot = create_slot(before_area_slot_template, ctx, /*$$scope*/ ctx[36], get_before_area_slot_context);

	input = new Input({
			props: {
				id: /*textareaId*/ ctx[5],
				type: "textarea",
				wrap: false,
				placeholder: /*placeholder*/ ctx[7],
				disabled: /*disabled*/ ctx[3],
				name: /*name*/ ctx[6],
				readonly: /*readonly*/ ctx[4],
				resizable: /*resizable*/ ctx[0],
				value: typeof /*value*/ ctx[2] === "undefined"
				? ""
				: /*value*/ ctx[2]
			},
			$$inline: true
		});

	input.$on("input", /*onInput*/ ctx[13]);
	input.$on("change", /*onChange*/ ctx[12]);
	input.$on("focus", /*onFocus*/ ctx[14]);
	input.$on("blur", /*onBlur*/ ctx[15]);
	const after_inner_slot_template = /*#slots*/ ctx[34]["after-inner"];
	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[36], get_after_inner_slot_context$1);
	let if_block = (/*sendLink*/ ctx[1] && /*sendLink*/ ctx[1].length > 0 || /*hasSendLinkSlots*/ ctx[11]) && create_if_block$j(ctx);
	const inner_end_slot_template = /*#slots*/ ctx[34]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[36], get_inner_end_slot_context$2);
	const default_slot_template = /*#slots*/ ctx[34].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[36], null);
	const after_inner_slot_template_1 = /*#slots*/ ctx[34]["after-inner"];
	const after_inner_slot_1 = create_slot(after_inner_slot_template_1, ctx, /*$$scope*/ ctx[36], get_after_inner_slot_context_1);

	let div2_levels = [
		{ class: /*classes*/ ctx[10] },
		{ "data-f7-slot": /*f7Slot*/ ctx[8] },
		restProps(/*$$restProps*/ ctx[17])
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			if (before_inner_slot) before_inner_slot.c();
			t0 = space();
			div1 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t1 = space();
			div0 = element("div");
			if (before_area_slot) before_area_slot.c();
			t2 = space();
			create_component(input.$$.fragment);
			t3 = space();
			if (after_inner_slot) after_inner_slot.c();
			t4 = space();
			if (if_block) if_block.c();
			t5 = space();
			if (inner_end_slot) inner_end_slot.c();
			t6 = space();
			if (default_slot) default_slot.c();
			t7 = space();
			if (after_inner_slot_1) after_inner_slot_1.c();
			attr_dev(div0, "class", "messagebar-area");
			add_location(div0, file$T, 214, 4, 6635);
			attr_dev(div1, "class", "toolbar-inner");
			add_location(div1, file$T, 212, 2, 6571);
			set_attributes(div2, div2_data);
			add_location(div2, file$T, 210, 0, 6451);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);

			if (before_inner_slot) {
				before_inner_slot.m(div2, null);
			}

			append_dev(div2, t0);
			append_dev(div2, div1);

			if (inner_start_slot) {
				inner_start_slot.m(div1, null);
			}

			append_dev(div1, t1);
			append_dev(div1, div0);

			if (before_area_slot) {
				before_area_slot.m(div0, null);
			}

			append_dev(div0, t2);
			mount_component(input, div0, null);
			append_dev(div0, t3);

			if (after_inner_slot) {
				after_inner_slot.m(div0, null);
			}

			append_dev(div1, t4);
			if (if_block) if_block.m(div1, null);
			append_dev(div1, t5);

			if (inner_end_slot) {
				inner_end_slot.m(div1, null);
			}

			append_dev(div1, t6);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_dev(div2, t7);

			if (after_inner_slot_1) {
				after_inner_slot_1.m(div2, null);
			}

			/*div2_binding*/ ctx[35](div2);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_inner_slot) {
				if (before_inner_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(before_inner_slot, before_inner_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_before_inner_slot_changes$1, get_before_inner_slot_context$1);
				}
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_inner_start_slot_changes$2, get_inner_start_slot_context$2);
				}
			}

			if (before_area_slot) {
				if (before_area_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(before_area_slot, before_area_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_before_area_slot_changes, get_before_area_slot_context);
				}
			}

			const input_changes = {};
			if (dirty[0] & /*textareaId*/ 32) input_changes.id = /*textareaId*/ ctx[5];
			if (dirty[0] & /*placeholder*/ 128) input_changes.placeholder = /*placeholder*/ ctx[7];
			if (dirty[0] & /*disabled*/ 8) input_changes.disabled = /*disabled*/ ctx[3];
			if (dirty[0] & /*name*/ 64) input_changes.name = /*name*/ ctx[6];
			if (dirty[0] & /*readonly*/ 16) input_changes.readonly = /*readonly*/ ctx[4];
			if (dirty[0] & /*resizable*/ 1) input_changes.resizable = /*resizable*/ ctx[0];

			if (dirty[0] & /*value*/ 4) input_changes.value = typeof /*value*/ ctx[2] === "undefined"
			? ""
			: /*value*/ ctx[2];

			input.$set(input_changes);

			if (after_inner_slot) {
				if (after_inner_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(after_inner_slot, after_inner_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_after_inner_slot_changes$1, get_after_inner_slot_context$1);
				}
			}

			if (/*sendLink*/ ctx[1] && /*sendLink*/ ctx[1].length > 0 || /*hasSendLinkSlots*/ ctx[11]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*sendLink, hasSendLinkSlots*/ 2050) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$j(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t5);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[36], dirty, get_inner_end_slot_changes$2, get_inner_end_slot_context$2);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[36], dirty, null, null);
				}
			}

			if (after_inner_slot_1) {
				if (after_inner_slot_1.p && dirty[1] & /*$$scope*/ 32) {
					update_slot(after_inner_slot_1, after_inner_slot_template_1, ctx, /*$$scope*/ ctx[36], dirty, get_after_inner_slot_changes_1, get_after_inner_slot_context_1);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty[0] & /*classes*/ 1024) && { class: /*classes*/ ctx[10] },
				(!current || dirty[0] & /*f7Slot*/ 256) && { "data-f7-slot": /*f7Slot*/ ctx[8] },
				dirty[0] & /*$$restProps*/ 131072 && restProps(/*$$restProps*/ ctx[17])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_inner_slot, local);
			transition_in(inner_start_slot, local);
			transition_in(before_area_slot, local);
			transition_in(input.$$.fragment, local);
			transition_in(after_inner_slot, local);
			transition_in(if_block);
			transition_in(inner_end_slot, local);
			transition_in(default_slot, local);
			transition_in(after_inner_slot_1, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_inner_slot, local);
			transition_out(inner_start_slot, local);
			transition_out(before_area_slot, local);
			transition_out(input.$$.fragment, local);
			transition_out(after_inner_slot, local);
			transition_out(if_block);
			transition_out(inner_end_slot, local);
			transition_out(default_slot, local);
			transition_out(after_inner_slot_1, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (before_inner_slot) before_inner_slot.d(detaching);
			if (inner_start_slot) inner_start_slot.d(detaching);
			if (before_area_slot) before_area_slot.d(detaching);
			destroy_component(input);
			if (after_inner_slot) after_inner_slot.d(detaching);
			if (if_block) if_block.d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (after_inner_slot_1) after_inner_slot_1.d(detaching);
			/*div2_binding*/ ctx[35](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$T.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$6($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","sheetVisible","attachmentsVisible","top","resizable","bottomOffset","topOffset","maxHeight","resizePage","sendLink","value","disabled","readonly","textareaId","name","placeholder","init","f7Slot","instance","clear","getValue","setValue","resize","focus","blur"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;

	validate_slots("Messagebar", slots, [
		'before-inner','inner-start','before-area','after-inner','send-link','inner-end','default'
	]);

	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { sheetVisible = false } = $$props;
	let { attachmentsVisible = false } = $$props;
	let { top = false } = $$props;
	let { resizable = true } = $$props;
	let { bottomOffset = 0 } = $$props;
	let { topOffset = 0 } = $$props;
	let { maxHeight = undefined } = $$props;
	let { resizePage = true } = $$props;
	let { sendLink = undefined } = $$props;
	let { value = undefined } = $$props;
	let { disabled = false } = $$props;
	let { readonly = false } = $$props;
	let { textareaId = undefined } = $$props;
	let { name = undefined } = $$props;
	let { placeholder = "Message" } = $$props;
	let { init = true } = $$props;
	let { f7Slot = "fixed" } = $$props;
	let el;
	let f7Messagebar;
	let updateSheetVisible;
	let updateAttachmentsVisible;

	function instance() {
		return f7Messagebar;
	}

	function clear(...args) {
		if (!f7Messagebar) return undefined;
		return f7Messagebar.clear(...args);
	}

	function getValue(...args) {
		if (!f7Messagebar) return undefined;
		return f7Messagebar.getValue(...args);
	}

	function setValue(...args) {
		if (!f7Messagebar) return undefined;
		return f7Messagebar.setValue(...args);
	}

	function resize(...args) {
		if (!f7Messagebar) return undefined;
		return f7Messagebar.resizePage(...args);
	}

	function focus(...args) {
		if (!f7Messagebar) return undefined;
		return f7Messagebar.focus(...args);
	}

	function blur(...args) {
		if (!f7Messagebar) return undefined;
		return f7Messagebar.blur(...args);
	}

	let initialWatchedSheet = false;

	function watchSheetVisible() {
		if (!initialWatchedSheet) {
			initialWatchedSheet = true;
			return;
		}

		if (!resizable || !f7Messagebar) return;
		updateSheetVisible = true;
	}

	let initialWatchedAttachments;

	function watchAttachmentsVisible() {
		if (!initialWatchedAttachments) {
			initialWatchedAttachments = true;
			return;
		}

		if (!resizable || !f7Messagebar) return;
		updateAttachmentsVisible = true;
	}

	function onChange(event) {
		dispatch("change", [...event.detail]);
		if (typeof $$props.onChange === "function") $$props.onChange(...event.detail);
	}

	function onInput(event) {
		dispatch("input", [...event.detail]);
		if (typeof $$props.onInput === "function") $$props.onInput(...event.detail);
	}

	function onFocus(event) {
		dispatch("focus", [...event.detail]);
		if (typeof $$props.onFocus === "function") $$props.onFocus(...event.detail);
	}

	function onBlur(event) {
		dispatch("blur", [...event.detail]);
		if (typeof $$props.onBlur === "function") $$props.onBlur(...event.detail);
	}

	function onClick(event) {
		const inputValue = el.querySelector("textarea");

		const clear = f7Messagebar
		? () => {
				f7Messagebar.clear();
			}
		: () => {
				
			};

		dispatch("submit", [inputValue, clear]);
		if (typeof $$props.onSubmit === "function") $$props.onSubmit(inputValue, clear);
		dispatch("send", [inputValue, clear]);
		if (typeof $$props.onSend === "function") $$props.onSend(inputValue, clear);
		dispatch("click", [event]);
		if (typeof $$props.onClick === "function") $$props.onClick(event);
	}

	function onAttachmentDelete(inst, attachmentEl, attachmentElIndex) {
		dispatch("messagebarAttachmentDelete", [inst, attachmentEl, attachmentElIndex]);
		if (typeof $$props.onMessagebarAttachmentDelete === "function") $$props.onMessagebarAttachmentDelete(inst, attachmentEl, attachmentElIndex);
	}

	function onAttachmentClick(inst, attachmentEl, attachmentElIndex) {
		dispatch("messagebarAttachmentClick", [inst, attachmentEl, attachmentElIndex]);
		if (typeof $$props.onMessagebarAttachmentClick === "function") $$props.onMessagebarAttachmentClick(inst, attachmentEl, attachmentElIndex);
	}

	function onResizePage(inst) {
		dispatch("messagebarResizePage", [inst]);
		if (typeof $$props.onMessagebarResizePage === "function") $$props.onMessagebarResizePage(inst);
	}

	onMount(() => {
		if (!init || !el) return;

		f7.ready(() => {
			if (el) {
				const dom7 = f7.instance.$;
				const attachmentsEl = dom7(el).find(".toolbar-inner > .messagebar-attachments");
				if (attachmentsEl.length) dom7(el).find(".messagebar-area").prepend(attachmentsEl);
				const sheetEl = dom7(el).find(".toolbar-inner > .messagebar-sheet");
				if (sheetEl.length) dom7(el).append(sheetEl);
			}

			f7Messagebar = f7.instance.messagebar.create(Utils.noUndefinedProps({
				el,
				top,
				resizePage,
				bottomOffset,
				topOffset,
				maxHeight,
				on: {
					attachmentDelete: onAttachmentDelete,
					attachmentClick: onAttachmentClick,
					resizePage: onResizePage
				}
			}));
		});
	});

	afterUpdate(() => {
		if (!f7Messagebar) return;

		if (el && f7.instance) {
			const dom7 = f7.instance.$;
			const attachmentsEl = dom7(el).find(".toolbar-inner > .messagebar-attachments");
			if (attachmentsEl.length) dom7(el).find(".messagebar-area").prepend(attachmentsEl);
			const sheetEl = dom7(el).find(".toolbar-inner > .messagebar-sheet");
			if (sheetEl.length) dom7(el).append(sheetEl);
		}

		if (updateSheetVisible) {
			updateSheetVisible = false;
			f7Messagebar.sheetVisible = sheetVisible;
			f7Messagebar.resizePage();
		}

		if (updateAttachmentsVisible) {
			updateAttachmentsVisible = false;
			f7Messagebar.attachmentsVisible = attachmentsVisible;
			f7Messagebar.resizePage();
		}
	});

	onDestroy(() => {
		if (f7Messagebar && f7Messagebar.destroy) f7Messagebar.destroy();
	});

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(9, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(48, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(18, className = $$new_props.class);
		if ("sheetVisible" in $$new_props) $$invalidate(19, sheetVisible = $$new_props.sheetVisible);
		if ("attachmentsVisible" in $$new_props) $$invalidate(20, attachmentsVisible = $$new_props.attachmentsVisible);
		if ("top" in $$new_props) $$invalidate(21, top = $$new_props.top);
		if ("resizable" in $$new_props) $$invalidate(0, resizable = $$new_props.resizable);
		if ("bottomOffset" in $$new_props) $$invalidate(22, bottomOffset = $$new_props.bottomOffset);
		if ("topOffset" in $$new_props) $$invalidate(23, topOffset = $$new_props.topOffset);
		if ("maxHeight" in $$new_props) $$invalidate(24, maxHeight = $$new_props.maxHeight);
		if ("resizePage" in $$new_props) $$invalidate(25, resizePage = $$new_props.resizePage);
		if ("sendLink" in $$new_props) $$invalidate(1, sendLink = $$new_props.sendLink);
		if ("value" in $$new_props) $$invalidate(2, value = $$new_props.value);
		if ("disabled" in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
		if ("readonly" in $$new_props) $$invalidate(4, readonly = $$new_props.readonly);
		if ("textareaId" in $$new_props) $$invalidate(5, textareaId = $$new_props.textareaId);
		if ("name" in $$new_props) $$invalidate(6, name = $$new_props.name);
		if ("placeholder" in $$new_props) $$invalidate(7, placeholder = $$new_props.placeholder);
		if ("init" in $$new_props) $$invalidate(26, init = $$new_props.init);
		if ("f7Slot" in $$new_props) $$invalidate(8, f7Slot = $$new_props.f7Slot);
		if ("$$scope" in $$new_props) $$invalidate(36, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		afterUpdate,
		Mixins,
		Utils,
		restProps,
		f7,
		hasSlots,
		Link,
		Input,
		dispatch,
		className,
		sheetVisible,
		attachmentsVisible,
		top,
		resizable,
		bottomOffset,
		topOffset,
		maxHeight,
		resizePage,
		sendLink,
		value,
		disabled,
		readonly,
		textareaId,
		name,
		placeholder,
		init,
		f7Slot,
		el,
		f7Messagebar,
		updateSheetVisible,
		updateAttachmentsVisible,
		instance,
		clear,
		getValue,
		setValue,
		resize,
		focus,
		blur,
		initialWatchedSheet,
		watchSheetVisible,
		initialWatchedAttachments,
		watchAttachmentsVisible,
		onChange,
		onInput,
		onFocus,
		onBlur,
		onClick,
		onAttachmentDelete,
		onAttachmentClick,
		onResizePage,
		classes,
		hasSendLinkSlots
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(48, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(18, className = $$new_props.className);
		if ("sheetVisible" in $$props) $$invalidate(19, sheetVisible = $$new_props.sheetVisible);
		if ("attachmentsVisible" in $$props) $$invalidate(20, attachmentsVisible = $$new_props.attachmentsVisible);
		if ("top" in $$props) $$invalidate(21, top = $$new_props.top);
		if ("resizable" in $$props) $$invalidate(0, resizable = $$new_props.resizable);
		if ("bottomOffset" in $$props) $$invalidate(22, bottomOffset = $$new_props.bottomOffset);
		if ("topOffset" in $$props) $$invalidate(23, topOffset = $$new_props.topOffset);
		if ("maxHeight" in $$props) $$invalidate(24, maxHeight = $$new_props.maxHeight);
		if ("resizePage" in $$props) $$invalidate(25, resizePage = $$new_props.resizePage);
		if ("sendLink" in $$props) $$invalidate(1, sendLink = $$new_props.sendLink);
		if ("value" in $$props) $$invalidate(2, value = $$new_props.value);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$new_props.disabled);
		if ("readonly" in $$props) $$invalidate(4, readonly = $$new_props.readonly);
		if ("textareaId" in $$props) $$invalidate(5, textareaId = $$new_props.textareaId);
		if ("name" in $$props) $$invalidate(6, name = $$new_props.name);
		if ("placeholder" in $$props) $$invalidate(7, placeholder = $$new_props.placeholder);
		if ("init" in $$props) $$invalidate(26, init = $$new_props.init);
		if ("f7Slot" in $$props) $$invalidate(8, f7Slot = $$new_props.f7Slot);
		if ("el" in $$props) $$invalidate(9, el = $$new_props.el);
		if ("f7Messagebar" in $$props) f7Messagebar = $$new_props.f7Messagebar;
		if ("updateSheetVisible" in $$props) updateSheetVisible = $$new_props.updateSheetVisible;
		if ("updateAttachmentsVisible" in $$props) updateAttachmentsVisible = $$new_props.updateAttachmentsVisible;
		if ("initialWatchedSheet" in $$props) initialWatchedSheet = $$new_props.initialWatchedSheet;
		if ("initialWatchedAttachments" in $$props) initialWatchedAttachments = $$new_props.initialWatchedAttachments;
		if ("classes" in $$props) $$invalidate(10, classes = $$new_props.classes);
		if ("hasSendLinkSlots" in $$props) $$invalidate(11, hasSendLinkSlots = $$new_props.hasSendLinkSlots);
	};

	let classes;
	let hasSendLinkSlots;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(10, classes = Utils.classNames(
			className,
			"toolbar",
			"messagebar",
			{
				"messagebar-attachments-visible": attachmentsVisible,
				"messagebar-sheet-visible": sheetVisible
			},
			Mixins.colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*sheetVisible*/ 524288) {
			 watchSheetVisible();
		}

		if ($$self.$$.dirty[0] & /*attachmentsVisible*/ 1048576) {
			 watchAttachmentsVisible();
		}
	};

	 $$invalidate(11, hasSendLinkSlots = hasSlots(arguments, "send-link"));
	$$props = exclude_internal_props($$props);

	return [
		resizable,
		sendLink,
		value,
		disabled,
		readonly,
		textareaId,
		name,
		placeholder,
		f7Slot,
		el,
		classes,
		hasSendLinkSlots,
		onChange,
		onInput,
		onFocus,
		onBlur,
		onClick,
		$$restProps,
		className,
		sheetVisible,
		attachmentsVisible,
		top,
		bottomOffset,
		topOffset,
		maxHeight,
		resizePage,
		init,
		instance,
		clear,
		getValue,
		setValue,
		resize,
		focus,
		blur,
		slots,
		div2_binding,
		$$scope
	];
}

class Messagebar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance_1$6,
			create_fragment$T,
			safe_not_equal,
			{
				class: 18,
				sheetVisible: 19,
				attachmentsVisible: 20,
				top: 21,
				resizable: 0,
				bottomOffset: 22,
				topOffset: 23,
				maxHeight: 24,
				resizePage: 25,
				sendLink: 1,
				value: 2,
				disabled: 3,
				readonly: 4,
				textareaId: 5,
				name: 6,
				placeholder: 7,
				init: 26,
				f7Slot: 8,
				instance: 27,
				clear: 28,
				getValue: 29,
				setValue: 30,
				resize: 31,
				focus: 32,
				blur: 33
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Messagebar",
			options,
			id: create_fragment$T.name
		});
	}

	get class() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sheetVisible() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sheetVisible(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get attachmentsVisible() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set attachmentsVisible(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get top() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set top(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizable() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizable(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bottomOffset() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bottomOffset(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get topOffset() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set topOffset(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get maxHeight() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set maxHeight(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizePage() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizePage(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sendLink() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sendLink(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get textareaId() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set textareaId(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get init() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set init(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get f7Slot() {
		throw new Error("<Messagebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set f7Slot(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[27];
	}

	set instance(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clear() {
		return this.$$.ctx[28];
	}

	set clear(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get getValue() {
		return this.$$.ctx[29];
	}

	set getValue(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get setValue() {
		return this.$$.ctx[30];
	}

	set setValue(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resize() {
		return this.$$.ctx[31];
	}

	set resize(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get focus() {
		return this.$$.ctx[32];
	}

	set focus(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get blur() {
		return this.$$.ctx[33];
	}

	set blur(value) {
		throw new Error("<Messagebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/messages-title.svelte generated by Svelte v3.31.0 */
const file$U = "node_modules/framework7-svelte/components/messages-title.svelte";

function create_fragment$U(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$U, 16, 0, 319);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$U.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$N($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Messages_title", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "messages-title", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class Messages_title extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$N, create_fragment$U, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Messages_title",
			options,
			id: create_fragment$U.name
		});
	}

	get class() {
		throw new Error("<Messages_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Messages_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/messages.svelte generated by Svelte v3.31.0 */
const file$V = "node_modules/framework7-svelte/components/messages.svelte";

function create_fragment$V(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[24].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], null);
	let div_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$V, 112, 0, 2881);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[25](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8388608) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[23], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[25](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$V.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$7($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","autoLayout","messages","newMessagesFirst","scrollMessages","scrollMessagesOnEdge","firstMessageRule","lastMessageRule","tailMessageRule","sameNameMessageRule","sameHeaderMessageRule","sameFooterMessageRule","sameAvatarMessageRule","customClassMessageRule","renderMessage","init","instance","scroll","showTyping","hideTyping"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Messages", slots, ['default']);
	let { class: className = undefined } = $$props;
	let { autoLayout = false } = $$props;
	let { messages = [] } = $$props;
	let { newMessagesFirst = false } = $$props;
	let { scrollMessages = true } = $$props;
	let { scrollMessagesOnEdge = true } = $$props;
	let { firstMessageRule = undefined } = $$props;
	let { lastMessageRule = undefined } = $$props;
	let { tailMessageRule = undefined } = $$props;
	let { sameNameMessageRule = undefined } = $$props;
	let { sameHeaderMessageRule = undefined } = $$props;
	let { sameFooterMessageRule = undefined } = $$props;
	let { sameAvatarMessageRule = undefined } = $$props;
	let { customClassMessageRule = undefined } = $$props;
	let { renderMessage = undefined } = $$props;
	let { init = true } = $$props;
	let el;
	let f7Messages;

	function instance() {
		return f7Messages;
	}

	function scroll(duration, scrollTop) {
		if (!f7Messages) return undefined;
		return f7Messages.scroll(duration, scrollTop);
	}

	function showTyping(message) {
		if (!f7Messages) return undefined;
		return f7Messages.showTyping(message);
	}

	function hideTyping() {
		if (!f7Messages) return undefined;
		return f7Messages.hideTyping();
	}

	onMount(() => {
		if (!init) return;

		f7.ready(() => {
			f7Messages = f7.instance.messages.create(Utils.noUndefinedProps({
				el,
				autoLayout,
				messages,
				newMessagesFirst,
				scrollMessages,
				scrollMessagesOnEdge,
				firstMessageRule,
				lastMessageRule,
				tailMessageRule,
				sameNameMessageRule,
				sameHeaderMessageRule,
				sameFooterMessageRule,
				sameAvatarMessageRule,
				customClassMessageRule,
				renderMessage
			}));
		});
	});

	beforeUpdate(() => {
		if (!init || !el) return;
		const children = el.children;
		if (!children) return;

		for (let i = 0; i < children.length; i += 1) {
			children[i].classList.add("message-appeared");
		}
	});

	afterUpdate(() => {
		if (!init) return;
		if (!el) return;
		const children = el.children;
		if (!children) return;

		for (let i = 0; i < children.length; i += 1) {
			if (!children[i].classList.contains("message-appeared")) {
				children[i].classList.add("message-appear-from-bottom");
			}
		}

		if (f7Messages && f7Messages.layout && autoLayout) {
			f7Messages.layout();
		}

		if (f7Messages && f7Messages.scroll && scrollMessages) {
			f7Messages.scroll();
		}
	});

	onDestroy(() => {
		if (f7Messages && f7Messages.destroy) f7Messages.destroy();
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(27, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("autoLayout" in $$new_props) $$invalidate(4, autoLayout = $$new_props.autoLayout);
		if ("messages" in $$new_props) $$invalidate(5, messages = $$new_props.messages);
		if ("newMessagesFirst" in $$new_props) $$invalidate(6, newMessagesFirst = $$new_props.newMessagesFirst);
		if ("scrollMessages" in $$new_props) $$invalidate(7, scrollMessages = $$new_props.scrollMessages);
		if ("scrollMessagesOnEdge" in $$new_props) $$invalidate(8, scrollMessagesOnEdge = $$new_props.scrollMessagesOnEdge);
		if ("firstMessageRule" in $$new_props) $$invalidate(9, firstMessageRule = $$new_props.firstMessageRule);
		if ("lastMessageRule" in $$new_props) $$invalidate(10, lastMessageRule = $$new_props.lastMessageRule);
		if ("tailMessageRule" in $$new_props) $$invalidate(11, tailMessageRule = $$new_props.tailMessageRule);
		if ("sameNameMessageRule" in $$new_props) $$invalidate(12, sameNameMessageRule = $$new_props.sameNameMessageRule);
		if ("sameHeaderMessageRule" in $$new_props) $$invalidate(13, sameHeaderMessageRule = $$new_props.sameHeaderMessageRule);
		if ("sameFooterMessageRule" in $$new_props) $$invalidate(14, sameFooterMessageRule = $$new_props.sameFooterMessageRule);
		if ("sameAvatarMessageRule" in $$new_props) $$invalidate(15, sameAvatarMessageRule = $$new_props.sameAvatarMessageRule);
		if ("customClassMessageRule" in $$new_props) $$invalidate(16, customClassMessageRule = $$new_props.customClassMessageRule);
		if ("renderMessage" in $$new_props) $$invalidate(17, renderMessage = $$new_props.renderMessage);
		if ("init" in $$new_props) $$invalidate(18, init = $$new_props.init);
		if ("$$scope" in $$new_props) $$invalidate(23, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		beforeUpdate,
		afterUpdate,
		Mixins,
		Utils,
		restProps,
		f7,
		className,
		autoLayout,
		messages,
		newMessagesFirst,
		scrollMessages,
		scrollMessagesOnEdge,
		firstMessageRule,
		lastMessageRule,
		tailMessageRule,
		sameNameMessageRule,
		sameHeaderMessageRule,
		sameFooterMessageRule,
		sameAvatarMessageRule,
		customClassMessageRule,
		renderMessage,
		init,
		el,
		f7Messages,
		instance,
		scroll,
		showTyping,
		hideTyping,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(27, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("autoLayout" in $$props) $$invalidate(4, autoLayout = $$new_props.autoLayout);
		if ("messages" in $$props) $$invalidate(5, messages = $$new_props.messages);
		if ("newMessagesFirst" in $$props) $$invalidate(6, newMessagesFirst = $$new_props.newMessagesFirst);
		if ("scrollMessages" in $$props) $$invalidate(7, scrollMessages = $$new_props.scrollMessages);
		if ("scrollMessagesOnEdge" in $$props) $$invalidate(8, scrollMessagesOnEdge = $$new_props.scrollMessagesOnEdge);
		if ("firstMessageRule" in $$props) $$invalidate(9, firstMessageRule = $$new_props.firstMessageRule);
		if ("lastMessageRule" in $$props) $$invalidate(10, lastMessageRule = $$new_props.lastMessageRule);
		if ("tailMessageRule" in $$props) $$invalidate(11, tailMessageRule = $$new_props.tailMessageRule);
		if ("sameNameMessageRule" in $$props) $$invalidate(12, sameNameMessageRule = $$new_props.sameNameMessageRule);
		if ("sameHeaderMessageRule" in $$props) $$invalidate(13, sameHeaderMessageRule = $$new_props.sameHeaderMessageRule);
		if ("sameFooterMessageRule" in $$props) $$invalidate(14, sameFooterMessageRule = $$new_props.sameFooterMessageRule);
		if ("sameAvatarMessageRule" in $$props) $$invalidate(15, sameAvatarMessageRule = $$new_props.sameAvatarMessageRule);
		if ("customClassMessageRule" in $$props) $$invalidate(16, customClassMessageRule = $$new_props.customClassMessageRule);
		if ("renderMessage" in $$props) $$invalidate(17, renderMessage = $$new_props.renderMessage);
		if ("init" in $$props) $$invalidate(18, init = $$new_props.init);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("f7Messages" in $$props) f7Messages = $$new_props.f7Messages;
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classes = Utils.classNames(className, "messages", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		classes,
		$$restProps,
		className,
		autoLayout,
		messages,
		newMessagesFirst,
		scrollMessages,
		scrollMessagesOnEdge,
		firstMessageRule,
		lastMessageRule,
		tailMessageRule,
		sameNameMessageRule,
		sameHeaderMessageRule,
		sameFooterMessageRule,
		sameAvatarMessageRule,
		customClassMessageRule,
		renderMessage,
		init,
		instance,
		scroll,
		showTyping,
		hideTyping,
		$$scope,
		slots,
		div_binding
	];
}

class Messages extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance_1$7, create_fragment$V, safe_not_equal, {
			class: 3,
			autoLayout: 4,
			messages: 5,
			newMessagesFirst: 6,
			scrollMessages: 7,
			scrollMessagesOnEdge: 8,
			firstMessageRule: 9,
			lastMessageRule: 10,
			tailMessageRule: 11,
			sameNameMessageRule: 12,
			sameHeaderMessageRule: 13,
			sameFooterMessageRule: 14,
			sameAvatarMessageRule: 15,
			customClassMessageRule: 16,
			renderMessage: 17,
			init: 18,
			instance: 19,
			scroll: 20,
			showTyping: 21,
			hideTyping: 22
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Messages",
			options,
			id: create_fragment$V.name
		});
	}

	get class() {
		throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autoLayout() {
		throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autoLayout(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get messages() {
		throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set messages(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get newMessagesFirst() {
		throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set newMessagesFirst(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrollMessages() {
		throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scrollMessages(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrollMessagesOnEdge() {
		throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scrollMessagesOnEdge(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get firstMessageRule() {
		throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set firstMessageRule(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get lastMessageRule() {
		throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set lastMessageRule(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tailMessageRule() {
		throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tailMessageRule(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sameNameMessageRule() {
		throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sameNameMessageRule(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sameHeaderMessageRule() {
		throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sameHeaderMessageRule(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sameFooterMessageRule() {
		throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sameFooterMessageRule(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sameAvatarMessageRule() {
		throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sameAvatarMessageRule(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get customClassMessageRule() {
		throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set customClassMessageRule(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get renderMessage() {
		throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set renderMessage(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get init() {
		throw new Error("<Messages>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set init(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[19];
	}

	set instance(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scroll() {
		return this.$$.ctx[20];
	}

	set scroll(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showTyping() {
		return this.$$.ctx[21];
	}

	set showTyping(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideTyping() {
		return this.$$.ctx[22];
	}

	set hideTyping(value) {
		throw new Error("<Messages>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/nav-left.svelte generated by Svelte v3.31.0 */
const file$W = "node_modules/framework7-svelte/components/nav-left.svelte";

// (55:2) {#if backLink}
function create_if_block$k(ctx) {
	let link;
	let current;

	link = new Link({
			props: {
				href: /*backLinkUrl*/ ctx[1] || "#",
				back: true,
				icon: "icon-back",
				force: /*backLinkForce*/ ctx[2] || undefined,
				class: !/*backLinkText*/ ctx[4] ? "icon-only" : undefined,
				text: /*backLinkText*/ ctx[4],
				onClick: /*onBackClick*/ ctx[5]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(link.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(link, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const link_changes = {};
			if (dirty & /*backLinkUrl*/ 2) link_changes.href = /*backLinkUrl*/ ctx[1] || "#";
			if (dirty & /*backLinkForce*/ 4) link_changes.force = /*backLinkForce*/ ctx[2] || undefined;
			if (dirty & /*backLinkText*/ 16) link_changes.class = !/*backLinkText*/ ctx[4] ? "icon-only" : undefined;
			if (dirty & /*backLinkText*/ 16) link_changes.text = /*backLinkText*/ ctx[4];
			link.$set(link_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(link.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(link.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(link, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$k.name,
		type: "if",
		source: "(55:2) {#if backLink}",
		ctx
	});

	return block;
}

function create_fragment$W(ctx) {
	let div;
	let t;
	let current;
	let if_block = /*backLink*/ ctx[0] && create_if_block$k(ctx);
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
	let div_levels = [{ class: /*classes*/ ctx[3] }, restProps(/*$$restProps*/ ctx[6])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$W, 50, 0, 1335);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*backLink*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*backLink*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$k(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 4096) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$W.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$O($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","backLink","backLinkUrl","backLinkForce","backLinkShowText","sliding"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Nav_left", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { backLink = undefined } = $$props;
	let { backLinkUrl = undefined } = $$props;
	let { backLinkForce = undefined } = $$props;
	let { backLinkShowText = undefined } = $$props;
	let { sliding = undefined } = $$props;

	// eslint-disable-next-line
	let _theme = f7.instance ? f7Theme : null;

	if (!f7.instance) {
		f7.ready(() => {
			$$invalidate(10, _theme = f7Theme);
		});
	}

	function onBackClick() {
		dispatch("clickBack");
		if (typeof $$props.onClickBack === "function") $$props.onClickBack();
		dispatch("backClick");
		if (typeof $$props.onBackClick === "function") $$props.onBackClick();
	}

	$$self.$$set = $$new_props => {
		$$invalidate(15, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(7, className = $$new_props.class);
		if ("backLink" in $$new_props) $$invalidate(0, backLink = $$new_props.backLink);
		if ("backLinkUrl" in $$new_props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
		if ("backLinkForce" in $$new_props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
		if ("backLinkShowText" in $$new_props) $$invalidate(8, backLinkShowText = $$new_props.backLinkShowText);
		if ("sliding" in $$new_props) $$invalidate(9, sliding = $$new_props.sliding);
		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		Mixins,
		Utils,
		restProps,
		f7,
		theme: f7Theme,
		Link,
		dispatch,
		className,
		backLink,
		backLinkUrl,
		backLinkForce,
		backLinkShowText,
		sliding,
		_theme,
		onBackClick,
		classes,
		needBackLinkText,
		backLinkText
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(15, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(7, className = $$new_props.className);
		if ("backLink" in $$props) $$invalidate(0, backLink = $$new_props.backLink);
		if ("backLinkUrl" in $$props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
		if ("backLinkForce" in $$props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
		if ("backLinkShowText" in $$props) $$invalidate(8, backLinkShowText = $$new_props.backLinkShowText);
		if ("sliding" in $$props) $$invalidate(9, sliding = $$new_props.sliding);
		if ("_theme" in $$props) $$invalidate(10, _theme = $$new_props._theme);
		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
		if ("needBackLinkText" in $$props) $$invalidate(11, needBackLinkText = $$new_props.needBackLinkText);
		if ("backLinkText" in $$props) $$invalidate(4, backLinkText = $$new_props.backLinkText);
	};

	let classes;
	let needBackLinkText;
	let backLinkText;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(3, classes = Utils.classNames(className, "left", { sliding }, Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*backLinkShowText*/ 256) {
			 $$invalidate(11, needBackLinkText = backLinkShowText);
		}

		if ($$self.$$.dirty & /*needBackLinkText, _theme*/ 3072) {
			 if (typeof needBackLinkText === "undefined") $$invalidate(11, needBackLinkText = _theme && !_theme.md);
		}

		if ($$self.$$.dirty & /*backLink, needBackLinkText*/ 2049) {
			 $$invalidate(4, backLinkText = backLink !== true && needBackLinkText
			? backLink
			: undefined);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		backLink,
		backLinkUrl,
		backLinkForce,
		classes,
		backLinkText,
		onBackClick,
		$$restProps,
		className,
		backLinkShowText,
		sliding,
		_theme,
		needBackLinkText,
		$$scope,
		slots
	];
}

class Nav_left extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$O, create_fragment$W, safe_not_equal, {
			class: 7,
			backLink: 0,
			backLinkUrl: 1,
			backLinkForce: 2,
			backLinkShowText: 8,
			sliding: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Nav_left",
			options,
			id: create_fragment$W.name
		});
	}

	get class() {
		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backLink() {
		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backLink(value) {
		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backLinkUrl() {
		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backLinkUrl(value) {
		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backLinkForce() {
		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backLinkForce(value) {
		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backLinkShowText() {
		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backLinkShowText(value) {
		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sliding() {
		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sliding(value) {
		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/nav-right.svelte generated by Svelte v3.31.0 */
const file$X = "node_modules/framework7-svelte/components/nav-right.svelte";

function create_fragment$X(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$X, 19, 0, 371);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$X.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$P($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","sliding"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Nav_right", slots, ['default']);
	let { class: className = undefined } = $$props;
	let { sliding = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("sliding" in $$new_props) $$invalidate(3, sliding = $$new_props.sliding);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		sliding,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("sliding" in $$props) $$invalidate(3, sliding = $$new_props.sliding);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "right", { sliding }, Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, sliding, $$scope, slots];
}

class Nav_right extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$P, create_fragment$X, safe_not_equal, { class: 2, sliding: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Nav_right",
			options,
			id: create_fragment$X.name
		});
	}

	get class() {
		throw new Error("<Nav_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Nav_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sliding() {
		throw new Error("<Nav_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sliding(value) {
		throw new Error("<Nav_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/nav-title-large.svelte generated by Svelte v3.31.0 */
const file$Y = "node_modules/framework7-svelte/components/nav-title-large.svelte";

function create_fragment$Y(ctx) {
	let div1;
	let div0;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div1_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div0, "class", "title-large-text");
			add_location(div0, file$Y, 18, 2, 371);
			set_attributes(div1, div1_data);
			add_location(div1, file$Y, 14, 0, 314);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Q($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Nav_title_large", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "title-large", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class Nav_title_large extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$Q, create_fragment$Y, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Nav_title_large",
			options,
			id: create_fragment$Y.name
		});
	}

	get class() {
		throw new Error("<Nav_title_large>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Nav_title_large>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/nav-title.svelte generated by Svelte v3.31.0 */
const file$Z = "node_modules/framework7-svelte/components/nav-title.svelte";

// (26:2) {#if typeof title !== 'undefined'}
function create_if_block_1$d(ctx) {
	let t_value = Utils.text(/*title*/ ctx[0]) + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 1 && t_value !== (t_value = Utils.text(/*title*/ ctx[0]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$d.name,
		type: "if",
		source: "(26:2) {#if typeof title !== 'undefined'}",
		ctx
	});

	return block;
}

// (27:2) {#if typeof subtitle !== 'undefined'}
function create_if_block$l(ctx) {
	let span;
	let t_value = Utils.text(/*subtitle*/ ctx[1]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			attr_dev(span, "class", "subtitle");
			add_location(span, file$Z, 27, 4, 598);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*subtitle*/ 2 && t_value !== (t_value = Utils.text(/*subtitle*/ ctx[1]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$l.name,
		type: "if",
		source: "(27:2) {#if typeof subtitle !== 'undefined'}",
		ctx
	});

	return block;
}

function create_fragment$Z(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	let if_block0 = typeof /*title*/ ctx[0] !== "undefined" && create_if_block_1$d(ctx);
	let if_block1 = typeof /*subtitle*/ ctx[1] !== "undefined" && create_if_block$l(ctx);
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	let div_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$Z, 21, 0, 438);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t1);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (typeof /*title*/ ctx[0] !== "undefined") {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$d(ctx);
					if_block0.c();
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (typeof /*subtitle*/ ctx[1] !== "undefined") {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$l(ctx);
					if_block1.c();
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$R($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","title","subtitle","sliding"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Nav_title", slots, ['default']);
	let { class: className = undefined } = $$props;
	let { title = undefined } = $$props;
	let { subtitle = undefined } = $$props;
	let { sliding = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("title" in $$new_props) $$invalidate(0, title = $$new_props.title);
		if ("subtitle" in $$new_props) $$invalidate(1, subtitle = $$new_props.subtitle);
		if ("sliding" in $$new_props) $$invalidate(5, sliding = $$new_props.sliding);
		if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		title,
		subtitle,
		sliding,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("title" in $$props) $$invalidate(0, title = $$new_props.title);
		if ("subtitle" in $$props) $$invalidate(1, subtitle = $$new_props.subtitle);
		if ("sliding" in $$props) $$invalidate(5, sliding = $$new_props.sliding);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(2, classes = Utils.classNames(className, "title", { sliding }, Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [title, subtitle, classes, $$restProps, className, sliding, $$scope, slots];
}

class Nav_title extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$R, create_fragment$Z, safe_not_equal, {
			class: 4,
			title: 0,
			subtitle: 1,
			sliding: 5
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Nav_title",
			options,
			id: create_fragment$Z.name
		});
	}

	get class() {
		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtitle() {
		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtitle(value) {
		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sliding() {
		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sliding(value) {
		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/navbar.svelte generated by Svelte v3.31.0 */
const file$_ = "node_modules/framework7-svelte/components/navbar.svelte";
const get_after_inner_slot_changes$2 = dirty => ({});
const get_after_inner_slot_context$2 = ctx => ({});
const get_title_large_slot_changes = dirty => ({});
const get_title_large_slot_context = ctx => ({});
const get_right_slot_changes = dirty => ({});
const get_right_slot_context = ctx => ({});
const get_nav_right_slot_changes = dirty => ({});
const get_nav_right_slot_context = ctx => ({});
const get_title_slot_changes$1 = dirty => ({});
const get_title_slot_context$1 = ctx => ({});
const get_left_slot_changes = dirty => ({});
const get_left_slot_context = ctx => ({});
const get_nav_left_slot_changes = dirty => ({});
const get_nav_left_slot_context = ctx => ({});
const get_before_inner_slot_changes$2 = dirty => ({});
const get_before_inner_slot_context$2 = ctx => ({});

// (218:4) {#if backLink || hasLeftSlots}
function create_if_block_3$a(ctx) {
	let navleft;
	let current;

	navleft = new Nav_left({
			props: {
				backLink: /*backLink*/ ctx[0],
				backLinkUrl: /*backLinkUrl*/ ctx[1],
				backLinkForce: /*backLinkForce*/ ctx[2],
				backLinkShowText: /*backLinkShowText*/ ctx[3],
				onBackClick: /*onBackClick*/ ctx[15],
				$$slots: { default: [create_default_slot_2$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(navleft.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(navleft, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const navleft_changes = {};
			if (dirty[0] & /*backLink*/ 1) navleft_changes.backLink = /*backLink*/ ctx[0];
			if (dirty[0] & /*backLinkUrl*/ 2) navleft_changes.backLinkUrl = /*backLinkUrl*/ ctx[1];
			if (dirty[0] & /*backLinkForce*/ 4) navleft_changes.backLinkForce = /*backLinkForce*/ ctx[2];
			if (dirty[0] & /*backLinkShowText*/ 8) navleft_changes.backLinkShowText = /*backLinkShowText*/ ctx[3];

			if (dirty[1] & /*$$scope*/ 16384) {
				navleft_changes.$$scope = { dirty, ctx };
			}

			navleft.$set(navleft_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(navleft.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(navleft.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(navleft, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$a.name,
		type: "if",
		source: "(218:4) {#if backLink || hasLeftSlots}",
		ctx
	});

	return block;
}

// (219:6) <NavLeft         backLink={backLink}         backLinkUrl={backLinkUrl}         backLinkForce={backLinkForce}         backLinkShowText={backLinkShowText}         onBackClick={onBackClick}       >
function create_default_slot_2$3(ctx) {
	let t;
	let current;
	const nav_left_slot_template = /*#slots*/ ctx[43]["nav-left"];
	const nav_left_slot = create_slot(nav_left_slot_template, ctx, /*$$scope*/ ctx[45], get_nav_left_slot_context);
	const left_slot_template = /*#slots*/ ctx[43].left;
	const left_slot = create_slot(left_slot_template, ctx, /*$$scope*/ ctx[45], get_left_slot_context);

	const block = {
		c: function create() {
			if (nav_left_slot) nav_left_slot.c();
			t = space();
			if (left_slot) left_slot.c();
		},
		m: function mount(target, anchor) {
			if (nav_left_slot) {
				nav_left_slot.m(target, anchor);
			}

			insert_dev(target, t, anchor);

			if (left_slot) {
				left_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (nav_left_slot) {
				if (nav_left_slot.p && dirty[1] & /*$$scope*/ 16384) {
					update_slot(nav_left_slot, nav_left_slot_template, ctx, /*$$scope*/ ctx[45], dirty, get_nav_left_slot_changes, get_nav_left_slot_context);
				}
			}

			if (left_slot) {
				if (left_slot.p && dirty[1] & /*$$scope*/ 16384) {
					update_slot(left_slot, left_slot_template, ctx, /*$$scope*/ ctx[45], dirty, get_left_slot_changes, get_left_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(nav_left_slot, local);
			transition_in(left_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(nav_left_slot, local);
			transition_out(left_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (nav_left_slot) nav_left_slot.d(detaching);
			if (detaching) detach_dev(t);
			if (left_slot) left_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2$3.name,
		type: "slot",
		source: "(219:6) <NavLeft         backLink={backLink}         backLinkUrl={backLinkUrl}         backLinkForce={backLinkForce}         backLinkShowText={backLinkShowText}         onBackClick={onBackClick}       >",
		ctx
	});

	return block;
}

// (230:4) {#if title || subtitle || hasTitleSlots}
function create_if_block_2$c(ctx) {
	let navtitle;
	let current;

	navtitle = new Nav_title({
			props: {
				title: /*title*/ ctx[4],
				subtitle: /*subtitle*/ ctx[5],
				$$slots: { default: [create_default_slot_1$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(navtitle.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(navtitle, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const navtitle_changes = {};
			if (dirty[0] & /*title*/ 16) navtitle_changes.title = /*title*/ ctx[4];
			if (dirty[0] & /*subtitle*/ 32) navtitle_changes.subtitle = /*subtitle*/ ctx[5];

			if (dirty[1] & /*$$scope*/ 16384) {
				navtitle_changes.$$scope = { dirty, ctx };
			}

			navtitle.$set(navtitle_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(navtitle.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(navtitle.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(navtitle, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$c.name,
		type: "if",
		source: "(230:4) {#if title || subtitle || hasTitleSlots}",
		ctx
	});

	return block;
}

// (231:6) <NavTitle         title={title}         subtitle={subtitle}       >
function create_default_slot_1$3(ctx) {
	let current;
	const title_slot_template = /*#slots*/ ctx[43].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[45], get_title_slot_context$1);

	const block = {
		c: function create() {
			if (title_slot) title_slot.c();
		},
		m: function mount(target, anchor) {
			if (title_slot) {
				title_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (title_slot) {
				if (title_slot.p && dirty[1] & /*$$scope*/ 16384) {
					update_slot(title_slot, title_slot_template, ctx, /*$$scope*/ ctx[45], dirty, get_title_slot_changes$1, get_title_slot_context$1);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (title_slot) title_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$3.name,
		type: "slot",
		source: "(231:6) <NavTitle         title={title}         subtitle={subtitle}       >",
		ctx
	});

	return block;
}

// (238:4) {#if hasRightSlots}
function create_if_block_1$e(ctx) {
	let navright;
	let current;

	navright = new Nav_right({
			props: {
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(navright.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(navright, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const navright_changes = {};

			if (dirty[1] & /*$$scope*/ 16384) {
				navright_changes.$$scope = { dirty, ctx };
			}

			navright.$set(navright_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(navright.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(navright.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(navright, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$e.name,
		type: "if",
		source: "(238:4) {#if hasRightSlots}",
		ctx
	});

	return block;
}

// (239:6) <NavRight>
function create_default_slot$4(ctx) {
	let t;
	let current;
	const nav_right_slot_template = /*#slots*/ ctx[43]["nav-right"];
	const nav_right_slot = create_slot(nav_right_slot_template, ctx, /*$$scope*/ ctx[45], get_nav_right_slot_context);
	const right_slot_template = /*#slots*/ ctx[43].right;
	const right_slot = create_slot(right_slot_template, ctx, /*$$scope*/ ctx[45], get_right_slot_context);

	const block = {
		c: function create() {
			if (nav_right_slot) nav_right_slot.c();
			t = space();
			if (right_slot) right_slot.c();
		},
		m: function mount(target, anchor) {
			if (nav_right_slot) {
				nav_right_slot.m(target, anchor);
			}

			insert_dev(target, t, anchor);

			if (right_slot) {
				right_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (nav_right_slot) {
				if (nav_right_slot.p && dirty[1] & /*$$scope*/ 16384) {
					update_slot(nav_right_slot, nav_right_slot_template, ctx, /*$$scope*/ ctx[45], dirty, get_nav_right_slot_changes, get_nav_right_slot_context);
				}
			}

			if (right_slot) {
				if (right_slot.p && dirty[1] & /*$$scope*/ 16384) {
					update_slot(right_slot, right_slot_template, ctx, /*$$scope*/ ctx[45], dirty, get_right_slot_changes, get_right_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(nav_right_slot, local);
			transition_in(right_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(nav_right_slot, local);
			transition_out(right_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (nav_right_slot) nav_right_slot.d(detaching);
			if (detaching) detach_dev(t);
			if (right_slot) right_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$4.name,
		type: "slot",
		source: "(239:6) <NavRight>",
		ctx
	});

	return block;
}

// (244:4) {#if largeTitle || hasTitleLargeSlots}
function create_if_block$m(ctx) {
	let div1;
	let div0;
	let t0_value = Utils.text(/*largeTitle*/ ctx[11]) + "";
	let t0;
	let t1;
	let current;
	const title_large_slot_template = /*#slots*/ ctx[43]["title-large"];
	const title_large_slot = create_slot(title_large_slot_template, ctx, /*$$scope*/ ctx[45], get_title_large_slot_context);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			t0 = text(t0_value);
			t1 = space();
			if (title_large_slot) title_large_slot.c();
			attr_dev(div0, "class", "title-large-text");
			add_location(div0, file$_, 245, 8, 7906);
			attr_dev(div1, "class", "title-large");
			add_location(div1, file$_, 244, 6, 7872);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
			append_dev(div0, t0);
			append_dev(div0, t1);

			if (title_large_slot) {
				title_large_slot.m(div0, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*largeTitle*/ 2048) && t0_value !== (t0_value = Utils.text(/*largeTitle*/ ctx[11]) + "")) set_data_dev(t0, t0_value);

			if (title_large_slot) {
				if (title_large_slot.p && dirty[1] & /*$$scope*/ 16384) {
					update_slot(title_large_slot, title_large_slot_template, ctx, /*$$scope*/ ctx[45], dirty, get_title_large_slot_changes, get_title_large_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(title_large_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(title_large_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (title_large_slot) title_large_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$m.name,
		type: "if",
		source: "(244:4) {#if largeTitle || hasTitleLargeSlots}",
		ctx
	});

	return block;
}

function create_fragment$_(ctx) {
	let div2;
	let div0;
	let t0;
	let t1;
	let div1;
	let t2;
	let t3;
	let t4;
	let t5;
	let t6;
	let current;
	const before_inner_slot_template = /*#slots*/ ctx[43]["before-inner"];
	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[45], get_before_inner_slot_context$2);
	let if_block0 = (/*backLink*/ ctx[0] || /*hasLeftSlots*/ ctx[8]) && create_if_block_3$a(ctx);
	let if_block1 = (/*title*/ ctx[4] || /*subtitle*/ ctx[5] || /*hasTitleSlots*/ ctx[10]) && create_if_block_2$c(ctx);
	let if_block2 = /*hasRightSlots*/ ctx[9] && create_if_block_1$e(ctx);
	let if_block3 = (/*largeTitle*/ ctx[11] || /*hasTitleLargeSlots*/ ctx[12]) && create_if_block$m(ctx);
	const default_slot_template = /*#slots*/ ctx[43].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[45], null);
	const after_inner_slot_template = /*#slots*/ ctx[43]["after-inner"];
	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[45], get_after_inner_slot_context$2);

	let div2_levels = [
		{ class: /*classes*/ ctx[13] },
		{ "data-f7-slot": /*f7Slot*/ ctx[6] },
		restProps(/*$$restProps*/ ctx[16])
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t0 = space();
			if (before_inner_slot) before_inner_slot.c();
			t1 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			t5 = space();
			if (default_slot) default_slot.c();
			t6 = space();
			if (after_inner_slot) after_inner_slot.c();
			attr_dev(div0, "class", "navbar-bg");
			add_location(div0, file$_, 214, 2, 7093);
			attr_dev(div1, "class", /*innerClasses*/ ctx[14]);
			add_location(div1, file$_, 216, 2, 7161);
			set_attributes(div2, div2_data);
			add_location(div2, file$_, 208, 0, 6995);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div2, t0);

			if (before_inner_slot) {
				before_inner_slot.m(div2, null);
			}

			append_dev(div2, t1);
			append_dev(div2, div1);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t2);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t3);
			if (if_block2) if_block2.m(div1, null);
			append_dev(div1, t4);
			if (if_block3) if_block3.m(div1, null);
			append_dev(div1, t5);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_dev(div2, t6);

			if (after_inner_slot) {
				after_inner_slot.m(div2, null);
			}

			/*div2_binding*/ ctx[44](div2);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (before_inner_slot) {
				if (before_inner_slot.p && dirty[1] & /*$$scope*/ 16384) {
					update_slot(before_inner_slot, before_inner_slot_template, ctx, /*$$scope*/ ctx[45], dirty, get_before_inner_slot_changes$2, get_before_inner_slot_context$2);
				}
			}

			if (/*backLink*/ ctx[0] || /*hasLeftSlots*/ ctx[8]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*backLink, hasLeftSlots*/ 257) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$a(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*title*/ ctx[4] || /*subtitle*/ ctx[5] || /*hasTitleSlots*/ ctx[10]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*title, subtitle, hasTitleSlots*/ 1072) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2$c(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (/*hasRightSlots*/ ctx[9]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*hasRightSlots*/ 512) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1$e(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, t4);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*largeTitle*/ ctx[11] || /*hasTitleLargeSlots*/ ctx[12]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*largeTitle, hasTitleLargeSlots*/ 6144) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block$m(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div1, t5);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 16384) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[45], dirty, null, null);
				}
			}

			if (!current || dirty[0] & /*innerClasses*/ 16384) {
				attr_dev(div1, "class", /*innerClasses*/ ctx[14]);
			}

			if (after_inner_slot) {
				if (after_inner_slot.p && dirty[1] & /*$$scope*/ 16384) {
					update_slot(after_inner_slot, after_inner_slot_template, ctx, /*$$scope*/ ctx[45], dirty, get_after_inner_slot_changes$2, get_after_inner_slot_context$2);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty[0] & /*classes*/ 8192) && { class: /*classes*/ ctx[13] },
				(!current || dirty[0] & /*f7Slot*/ 64) && { "data-f7-slot": /*f7Slot*/ ctx[6] },
				dirty[0] & /*$$restProps*/ 65536 && restProps(/*$$restProps*/ ctx[16])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_inner_slot, local);
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(if_block3);
			transition_in(default_slot, local);
			transition_in(after_inner_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_inner_slot, local);
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(if_block3);
			transition_out(default_slot, local);
			transition_out(after_inner_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (before_inner_slot) before_inner_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (default_slot) default_slot.d(detaching);
			if (after_inner_slot) after_inner_slot.d(detaching);
			/*div2_binding*/ ctx[44](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$_.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$S($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","backLink","backLinkUrl","backLinkForce","backLinkShowText","sliding","title","subtitle","hidden","noShadow","noHairline","innerClass","innerClassName","large","largeTransparent","transparent","titleLarge","f7Slot","hide","show","size"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;

	validate_slots("Navbar", slots, [
		'before-inner','nav-left','left','title','nav-right','right','title-large','default','after-inner'
	]);

	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { backLink = undefined } = $$props;
	let { backLinkUrl = undefined } = $$props;
	let { backLinkForce = false } = $$props;
	let { backLinkShowText = undefined } = $$props;
	let { sliding = true } = $$props;
	let { title = undefined } = $$props;
	let { subtitle = undefined } = $$props;
	let { hidden = false } = $$props;
	let { noShadow = false } = $$props;
	let { noHairline = false } = $$props;
	let { innerClass = undefined } = $$props;
	let { innerClassName = undefined } = $$props;
	let { large = false } = $$props;
	let { largeTransparent = false } = $$props;
	let { transparent = false } = $$props;
	let { titleLarge = undefined } = $$props;
	let { f7Slot = "fixed" } = $$props;
	let el;

	// eslint-disable-next-line
	let _theme = f7.instance ? f7Theme : null;

	let routerPositionClass = "";
	let largeCollapsed = false;
	let routerNavbarRole = null;
	let routerNavbarRoleDetailRoot = false;
	let routerNavbarMasterStack = false;
	let transparentVisible = false;

	function hide(animate) {
		f7.navbar.hide(el, animate);
	}

	function show(animate) {
		f7.navbar.show(el, animate);
	}

	function size() {
		f7.navbar.size(el);
	}

	if (!f7.instance) {
		f7.ready(() => {
			$$invalidate(31, _theme = f7Theme);
		});
	}

	function onHide(navbarEl) {
		if (el !== navbarEl) return;
		dispatch("navbarHide");
		if (typeof $$props.onNavbarHide === "function") $$props.onNavbarHide();
	}

	function onShow(navbarEl) {
		if (el !== navbarEl) return;
		dispatch("navbarShow");
		if (typeof $$props.onNavbarShow === "function") $$props.onNavbarShow();
	}

	function onNavbarTransparentShow(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(37, transparentVisible = true);
		dispatch("navbarTransparentShow");
		if (typeof $$props.onNavbarTransparentShow === "function") $$props.onNavbarTransparentShow();
	}

	function onNavbarTransparentHide(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(37, transparentVisible = false);
		dispatch("navbarTransparentHide");
		if (typeof $$props.onNavbarTransparentHide === "function") $$props.onNavbarTransparentHide();
	}

	function onExpand(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(33, largeCollapsed = false);
		dispatch("navbarExpand");
		if (typeof $$props.onNavbarExpand === "function") $$props.onNavbarExpand();
	}

	function onCollapse(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(33, largeCollapsed = true);
		dispatch("navbarCollapse");
		if (typeof $$props.onNavbarCollapse === "function") $$props.onNavbarCollapse();
	}

	function onNavbarPosition(navbarEl, position) {
		if (el !== navbarEl) return;
		$$invalidate(32, routerPositionClass = position ? `navbar-${position}` : position);
	}

	function onNavbarRole(navbarEl, rolesData) {
		if (el !== navbarEl) return;
		$$invalidate(34, routerNavbarRole = rolesData.role);
		$$invalidate(35, routerNavbarRoleDetailRoot = rolesData.detailRoot);
	}

	function onNavbarMasterStack(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(36, routerNavbarMasterStack = true);
	}

	function onNavbarMasterUnstack(navbarEl) {
		if (el !== navbarEl) return;
		$$invalidate(36, routerNavbarMasterStack = false);
	}

	function onBackClick() {
		dispatch("clickBack");
		if (typeof $$props.onClickBack === "function") $$props.onClickBack();
	}

	function mountNavbar() {
		f7.instance.on("navbarShow", onShow);
		f7.instance.on("navbarHide", onHide);
		f7.instance.on("navbarCollapse", onCollapse);
		f7.instance.on("navbarExpand", onExpand);
		f7.instance.on("navbarPosition", onNavbarPosition);
		f7.instance.on("navbarRole", onNavbarRole);
		f7.instance.on("navbarMasterStack", onNavbarMasterStack);
		f7.instance.on("navbarMasterUnstack", onNavbarMasterUnstack);
		f7.instance.on("navbarTransparentShow", onNavbarTransparentShow);
		f7.instance.on("navbarTransparentHide", onNavbarTransparentHide);
	}

	function destroyNavbar() {
		f7.instance.off("navbarShow", onShow);
		f7.instance.off("navbarHide", onHide);
		f7.instance.off("navbarCollapse", onCollapse);
		f7.instance.off("navbarExpand", onExpand);
		f7.instance.off("navbarPosition", onNavbarPosition);
		f7.instance.off("navbarRole", onNavbarRole);
		f7.instance.off("navbarMasterStack", onNavbarMasterStack);
		f7.instance.off("navbarMasterUnstack", onNavbarMasterUnstack);
		f7.instance.off("navbarTransparentShow", onNavbarTransparentShow);
		f7.instance.off("navbarTransparentHide", onNavbarTransparentHide);
	}

	onMount(() => {
		f7.ready(() => {
			mountNavbar();
		});
	});

	afterUpdate(() => {
		if (!f7.instance) return;
		f7.instance.navbar.size(el);
	});

	onDestroy(() => {
		if (!f7.instance) return;
		destroyNavbar();
	});

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(7, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(59, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(17, className = $$new_props.class);
		if ("backLink" in $$new_props) $$invalidate(0, backLink = $$new_props.backLink);
		if ("backLinkUrl" in $$new_props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
		if ("backLinkForce" in $$new_props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
		if ("backLinkShowText" in $$new_props) $$invalidate(3, backLinkShowText = $$new_props.backLinkShowText);
		if ("sliding" in $$new_props) $$invalidate(18, sliding = $$new_props.sliding);
		if ("title" in $$new_props) $$invalidate(4, title = $$new_props.title);
		if ("subtitle" in $$new_props) $$invalidate(5, subtitle = $$new_props.subtitle);
		if ("hidden" in $$new_props) $$invalidate(19, hidden = $$new_props.hidden);
		if ("noShadow" in $$new_props) $$invalidate(20, noShadow = $$new_props.noShadow);
		if ("noHairline" in $$new_props) $$invalidate(21, noHairline = $$new_props.noHairline);
		if ("innerClass" in $$new_props) $$invalidate(22, innerClass = $$new_props.innerClass);
		if ("innerClassName" in $$new_props) $$invalidate(23, innerClassName = $$new_props.innerClassName);
		if ("large" in $$new_props) $$invalidate(24, large = $$new_props.large);
		if ("largeTransparent" in $$new_props) $$invalidate(25, largeTransparent = $$new_props.largeTransparent);
		if ("transparent" in $$new_props) $$invalidate(26, transparent = $$new_props.transparent);
		if ("titleLarge" in $$new_props) $$invalidate(27, titleLarge = $$new_props.titleLarge);
		if ("f7Slot" in $$new_props) $$invalidate(6, f7Slot = $$new_props.f7Slot);
		if ("$$scope" in $$new_props) $$invalidate(45, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		afterUpdate,
		Mixins,
		Utils,
		restProps,
		theme: f7Theme,
		f7,
		hasSlots,
		NavLeft: Nav_left,
		NavTitle: Nav_title,
		NavRight: Nav_right,
		dispatch,
		className,
		backLink,
		backLinkUrl,
		backLinkForce,
		backLinkShowText,
		sliding,
		title,
		subtitle,
		hidden,
		noShadow,
		noHairline,
		innerClass,
		innerClassName,
		large,
		largeTransparent,
		transparent,
		titleLarge,
		f7Slot,
		el,
		_theme,
		routerPositionClass,
		largeCollapsed,
		routerNavbarRole,
		routerNavbarRoleDetailRoot,
		routerNavbarMasterStack,
		transparentVisible,
		hide,
		show,
		size,
		onHide,
		onShow,
		onNavbarTransparentShow,
		onNavbarTransparentHide,
		onExpand,
		onCollapse,
		onNavbarPosition,
		onNavbarRole,
		onNavbarMasterStack,
		onNavbarMasterUnstack,
		onBackClick,
		mountNavbar,
		destroyNavbar,
		hasLeftSlots,
		hasRightSlots,
		hasTitleSlots,
		largeTitle,
		hasTitleLargeSlots,
		addLeftTitleClass,
		addCenterTitleClass,
		isLarge,
		isTransparent,
		isTransparentVisible,
		classes,
		innerClasses
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(59, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(17, className = $$new_props.className);
		if ("backLink" in $$props) $$invalidate(0, backLink = $$new_props.backLink);
		if ("backLinkUrl" in $$props) $$invalidate(1, backLinkUrl = $$new_props.backLinkUrl);
		if ("backLinkForce" in $$props) $$invalidate(2, backLinkForce = $$new_props.backLinkForce);
		if ("backLinkShowText" in $$props) $$invalidate(3, backLinkShowText = $$new_props.backLinkShowText);
		if ("sliding" in $$props) $$invalidate(18, sliding = $$new_props.sliding);
		if ("title" in $$props) $$invalidate(4, title = $$new_props.title);
		if ("subtitle" in $$props) $$invalidate(5, subtitle = $$new_props.subtitle);
		if ("hidden" in $$props) $$invalidate(19, hidden = $$new_props.hidden);
		if ("noShadow" in $$props) $$invalidate(20, noShadow = $$new_props.noShadow);
		if ("noHairline" in $$props) $$invalidate(21, noHairline = $$new_props.noHairline);
		if ("innerClass" in $$props) $$invalidate(22, innerClass = $$new_props.innerClass);
		if ("innerClassName" in $$props) $$invalidate(23, innerClassName = $$new_props.innerClassName);
		if ("large" in $$props) $$invalidate(24, large = $$new_props.large);
		if ("largeTransparent" in $$props) $$invalidate(25, largeTransparent = $$new_props.largeTransparent);
		if ("transparent" in $$props) $$invalidate(26, transparent = $$new_props.transparent);
		if ("titleLarge" in $$props) $$invalidate(27, titleLarge = $$new_props.titleLarge);
		if ("f7Slot" in $$props) $$invalidate(6, f7Slot = $$new_props.f7Slot);
		if ("el" in $$props) $$invalidate(7, el = $$new_props.el);
		if ("_theme" in $$props) $$invalidate(31, _theme = $$new_props._theme);
		if ("routerPositionClass" in $$props) $$invalidate(32, routerPositionClass = $$new_props.routerPositionClass);
		if ("largeCollapsed" in $$props) $$invalidate(33, largeCollapsed = $$new_props.largeCollapsed);
		if ("routerNavbarRole" in $$props) $$invalidate(34, routerNavbarRole = $$new_props.routerNavbarRole);
		if ("routerNavbarRoleDetailRoot" in $$props) $$invalidate(35, routerNavbarRoleDetailRoot = $$new_props.routerNavbarRoleDetailRoot);
		if ("routerNavbarMasterStack" in $$props) $$invalidate(36, routerNavbarMasterStack = $$new_props.routerNavbarMasterStack);
		if ("transparentVisible" in $$props) $$invalidate(37, transparentVisible = $$new_props.transparentVisible);
		if ("hasLeftSlots" in $$props) $$invalidate(8, hasLeftSlots = $$new_props.hasLeftSlots);
		if ("hasRightSlots" in $$props) $$invalidate(9, hasRightSlots = $$new_props.hasRightSlots);
		if ("hasTitleSlots" in $$props) $$invalidate(10, hasTitleSlots = $$new_props.hasTitleSlots);
		if ("largeTitle" in $$props) $$invalidate(11, largeTitle = $$new_props.largeTitle);
		if ("hasTitleLargeSlots" in $$props) $$invalidate(12, hasTitleLargeSlots = $$new_props.hasTitleLargeSlots);
		if ("addLeftTitleClass" in $$props) $$invalidate(38, addLeftTitleClass = $$new_props.addLeftTitleClass);
		if ("addCenterTitleClass" in $$props) $$invalidate(39, addCenterTitleClass = $$new_props.addCenterTitleClass);
		if ("isLarge" in $$props) $$invalidate(40, isLarge = $$new_props.isLarge);
		if ("isTransparent" in $$props) $$invalidate(41, isTransparent = $$new_props.isTransparent);
		if ("isTransparentVisible" in $$props) $$invalidate(42, isTransparentVisible = $$new_props.isTransparentVisible);
		if ("classes" in $$props) $$invalidate(13, classes = $$new_props.classes);
		if ("innerClasses" in $$props) $$invalidate(14, innerClasses = $$new_props.innerClasses);
	};

	let hasLeftSlots;
	let hasRightSlots;
	let hasTitleSlots;
	let largeTitle;
	let hasTitleLargeSlots;
	let addLeftTitleClass;
	let addCenterTitleClass;
	let isLarge;
	let isTransparent;
	let isTransparentVisible;
	let classes;
	let innerClasses;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*titleLarge, large, title*/ 150994960) {
			 $$invalidate(11, largeTitle = titleLarge || large && title);
		}

		if ($$self.$$.dirty[1] & /*_theme*/ 1) {
			 $$invalidate(38, addLeftTitleClass = _theme && _theme.ios && f7.instance && !f7.instance.params.navbar.iosCenterTitle);
		}

		if ($$self.$$.dirty[1] & /*_theme*/ 1) {
			 $$invalidate(39, addCenterTitleClass = _theme && _theme.md && f7.instance && f7.instance.params.navbar.mdCenterTitle || _theme && _theme.aurora && f7.instance && f7.instance.params.navbar.auroraCenterTitle);
		}

		if ($$self.$$.dirty[0] & /*large, largeTransparent*/ 50331648) {
			 $$invalidate(40, isLarge = large || largeTransparent);
		}

		if ($$self.$$.dirty[0] & /*transparent, largeTransparent*/ 100663296 | $$self.$$.dirty[1] & /*isLarge*/ 512) {
			 $$invalidate(41, isTransparent = transparent || isLarge && largeTransparent);
		}

		if ($$self.$$.dirty[1] & /*isTransparent, transparentVisible*/ 1088) {
			 $$invalidate(42, isTransparentVisible = isTransparent && transparentVisible);
		}

		 $$invalidate(13, classes = Utils.classNames(
			className,
			"navbar",
			routerPositionClass,
			{
				"navbar-hidden": hidden,
				"navbar-large": isLarge,
				"navbar-large-collapsed": isLarge && largeCollapsed,
				"navbar-transparent": isTransparent,
				"navbar-transparent-visible": isTransparentVisible,
				"navbar-master": routerNavbarRole === "master",
				"navbar-master-detail": routerNavbarRole === "detail",
				"navbar-master-detail-root": routerNavbarRoleDetailRoot === true,
				"navbar-master-stacked": routerNavbarMasterStack === true,
				"no-shadow": noShadow,
				"no-hairline": noHairline
			},
			Mixins.colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*innerClass, innerClassName, sliding*/ 12845056 | $$self.$$.dirty[1] & /*addLeftTitleClass, addCenterTitleClass*/ 384) {
			 $$invalidate(14, innerClasses = Utils.classNames("navbar-inner", innerClass, innerClassName, {
				sliding,
				"navbar-inner-left-title": addLeftTitleClass,
				"navbar-inner-centered-title": addCenterTitleClass
			}));
		}
	};

	 $$invalidate(8, hasLeftSlots = hasSlots(arguments, "nav-left") || hasSlots(arguments, "left"));

	// eslint-disable-next-line
	 $$invalidate(9, hasRightSlots = hasSlots(arguments, "nav-right") || hasSlots(arguments, "right"));

	// eslint-disable-next-line
	 $$invalidate(10, hasTitleSlots = hasSlots(arguments, "title"));

	// eslint-disable-next-line
	 $$invalidate(12, hasTitleLargeSlots = hasSlots(arguments, "title-large"));

	$$props = exclude_internal_props($$props);

	return [
		backLink,
		backLinkUrl,
		backLinkForce,
		backLinkShowText,
		title,
		subtitle,
		f7Slot,
		el,
		hasLeftSlots,
		hasRightSlots,
		hasTitleSlots,
		largeTitle,
		hasTitleLargeSlots,
		classes,
		innerClasses,
		onBackClick,
		$$restProps,
		className,
		sliding,
		hidden,
		noShadow,
		noHairline,
		innerClass,
		innerClassName,
		large,
		largeTransparent,
		transparent,
		titleLarge,
		hide,
		show,
		size,
		_theme,
		routerPositionClass,
		largeCollapsed,
		routerNavbarRole,
		routerNavbarRoleDetailRoot,
		routerNavbarMasterStack,
		transparentVisible,
		addLeftTitleClass,
		addCenterTitleClass,
		isLarge,
		isTransparent,
		isTransparentVisible,
		slots,
		div2_binding,
		$$scope
	];
}

class Navbar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$S,
			create_fragment$_,
			safe_not_equal,
			{
				class: 17,
				backLink: 0,
				backLinkUrl: 1,
				backLinkForce: 2,
				backLinkShowText: 3,
				sliding: 18,
				title: 4,
				subtitle: 5,
				hidden: 19,
				noShadow: 20,
				noHairline: 21,
				innerClass: 22,
				innerClassName: 23,
				large: 24,
				largeTransparent: 25,
				transparent: 26,
				titleLarge: 27,
				f7Slot: 6,
				hide: 28,
				show: 29,
				size: 30
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Navbar",
			options,
			id: create_fragment$_.name
		});
	}

	get class() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backLink() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backLink(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backLinkUrl() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backLinkUrl(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backLinkForce() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backLinkForce(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backLinkShowText() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backLinkShowText(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sliding() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sliding(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subtitle() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subtitle(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hidden() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hidden(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noShadow() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noShadow(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairline() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairline(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get innerClass() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set innerClass(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get innerClassName() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set innerClassName(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get large() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set large(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get largeTransparent() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set largeTransparent(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get transparent() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set transparent(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get titleLarge() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set titleLarge(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get f7Slot() {
		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set f7Slot(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hide() {
		return this.$$.ctx[28];
	}

	set hide(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show() {
		return this.$$.ctx[29];
	}

	set show(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		return this.$$.ctx[30];
	}

	set size(value) {
		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/preloader.svelte generated by Svelte v3.31.0 */
const file$$ = "node_modules/framework7-svelte/components/preloader.svelte";

// (67:2) {:else}
function create_else_block$8(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "preloader-inner");
			add_location(span, file$$, 67, 2, 2080);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$8.name,
		type: "else",
		source: "(67:2) {:else}",
		ctx
	});

	return block;
}

// (63:36) 
function create_if_block_2$d(ctx) {
	let span1;
	let span0;

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			attr_dev(span0, "class", "preloader-inner-circle");
			add_location(span0, file$$, 64, 4, 2013);
			attr_dev(span1, "class", "preloader-inner");
			add_location(span1, file$$, 63, 2, 1978);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$d.name,
		type: "if",
		source: "(63:36) ",
		ctx
	});

	return block;
}

// (48:33) 
function create_if_block_1$f(ctx) {
	let span12;
	let span0;
	let t0;
	let span1;
	let t1;
	let span2;
	let t2;
	let span3;
	let t3;
	let span4;
	let t4;
	let span5;
	let t5;
	let span6;
	let t6;
	let span7;
	let t7;
	let span8;
	let t8;
	let span9;
	let t9;
	let span10;
	let t10;
	let span11;

	const block = {
		c: function create() {
			span12 = element("span");
			span0 = element("span");
			t0 = space();
			span1 = element("span");
			t1 = space();
			span2 = element("span");
			t2 = space();
			span3 = element("span");
			t3 = space();
			span4 = element("span");
			t4 = space();
			span5 = element("span");
			t5 = space();
			span6 = element("span");
			t6 = space();
			span7 = element("span");
			t7 = space();
			span8 = element("span");
			t8 = space();
			span9 = element("span");
			t9 = space();
			span10 = element("span");
			t10 = space();
			span11 = element("span");
			attr_dev(span0, "class", "preloader-inner-line");
			add_location(span0, file$$, 49, 4, 1369);
			attr_dev(span1, "class", "preloader-inner-line");
			add_location(span1, file$$, 50, 4, 1416);
			attr_dev(span2, "class", "preloader-inner-line");
			add_location(span2, file$$, 51, 4, 1463);
			attr_dev(span3, "class", "preloader-inner-line");
			add_location(span3, file$$, 52, 4, 1510);
			attr_dev(span4, "class", "preloader-inner-line");
			add_location(span4, file$$, 53, 4, 1557);
			attr_dev(span5, "class", "preloader-inner-line");
			add_location(span5, file$$, 54, 4, 1604);
			attr_dev(span6, "class", "preloader-inner-line");
			add_location(span6, file$$, 55, 4, 1651);
			attr_dev(span7, "class", "preloader-inner-line");
			add_location(span7, file$$, 56, 4, 1698);
			attr_dev(span8, "class", "preloader-inner-line");
			add_location(span8, file$$, 57, 4, 1745);
			attr_dev(span9, "class", "preloader-inner-line");
			add_location(span9, file$$, 58, 4, 1792);
			attr_dev(span10, "class", "preloader-inner-line");
			add_location(span10, file$$, 59, 4, 1839);
			attr_dev(span11, "class", "preloader-inner-line");
			add_location(span11, file$$, 60, 4, 1886);
			attr_dev(span12, "class", "preloader-inner");
			add_location(span12, file$$, 48, 2, 1334);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span12, anchor);
			append_dev(span12, span0);
			append_dev(span12, t0);
			append_dev(span12, span1);
			append_dev(span12, t1);
			append_dev(span12, span2);
			append_dev(span12, t2);
			append_dev(span12, span3);
			append_dev(span12, t3);
			append_dev(span12, span4);
			append_dev(span12, t4);
			append_dev(span12, span5);
			append_dev(span12, t5);
			append_dev(span12, span6);
			append_dev(span12, t6);
			append_dev(span12, span7);
			append_dev(span12, t7);
			append_dev(span12, span8);
			append_dev(span12, t8);
			append_dev(span12, span9);
			append_dev(span12, t9);
			append_dev(span12, span10);
			append_dev(span12, t10);
			append_dev(span12, span11);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span12);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$f.name,
		type: "if",
		source: "(48:33) ",
		ctx
	});

	return block;
}

// (38:2) {#if _theme && _theme.md}
function create_if_block$n(ctx) {
	let span5;
	let span0;
	let t0;
	let span2;
	let span1;
	let t1;
	let span4;
	let span3;

	const block = {
		c: function create() {
			span5 = element("span");
			span0 = element("span");
			t0 = space();
			span2 = element("span");
			span1 = element("span");
			t1 = space();
			span4 = element("span");
			span3 = element("span");
			attr_dev(span0, "class", "preloader-inner-gap");
			add_location(span0, file$$, 39, 4, 1044);
			attr_dev(span1, "class", "preloader-inner-half-circle");
			add_location(span1, file$$, 41, 6, 1127);
			attr_dev(span2, "class", "preloader-inner-left");
			add_location(span2, file$$, 40, 4, 1085);
			attr_dev(span3, "class", "preloader-inner-half-circle");
			add_location(span3, file$$, 44, 6, 1231);
			attr_dev(span4, "class", "preloader-inner-right");
			add_location(span4, file$$, 43, 4, 1188);
			attr_dev(span5, "class", "preloader-inner");
			add_location(span5, file$$, 38, 2, 1009);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span5, anchor);
			append_dev(span5, span0);
			append_dev(span5, t0);
			append_dev(span5, span2);
			append_dev(span2, span1);
			append_dev(span5, t1);
			append_dev(span5, span4);
			append_dev(span4, span3);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span5);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$n.name,
		type: "if",
		source: "(38:2) {#if _theme && _theme.md}",
		ctx
	});

	return block;
}

function create_fragment$$(ctx) {
	let span;

	function select_block_type(ctx, dirty) {
		if (/*_theme*/ ctx[0] && /*_theme*/ ctx[0].md) return create_if_block$n;
		if (/*_theme*/ ctx[0] && /*_theme*/ ctx[0].ios) return create_if_block_1$f;
		if (/*_theme*/ ctx[0] && /*_theme*/ ctx[0].aurora) return create_if_block_2$d;
		return create_else_block$8;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	let span_levels = [
		{ style: /*preloaderStyle*/ ctx[1] },
		{ class: /*classes*/ ctx[2] },
		restProps(/*$$restProps*/ ctx[3])
	];

	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if_block.c();
			set_attributes(span, span_data);
			add_location(span, file$$, 36, 0, 905);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			if_block.m(span, null);
		},
		p: function update(ctx, [dirty]) {
			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(span, null);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				dirty & /*preloaderStyle*/ 2 && { style: /*preloaderStyle*/ ctx[1] },
				dirty & /*classes*/ 4 && { class: /*classes*/ ctx[2] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$$.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$T($$self, $$props, $$invalidate) {
	const omit_props_names = ["style","class","size"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Preloader", slots, []);
	let { style = undefined } = $$props;
	let { class: className = undefined } = $$props;
	let { size = undefined } = $$props;

	// eslint-disable-next-line
	let _theme = f7.instance ? f7Theme : null;

	if (!f7.instance) {
		f7.ready(() => {
			$$invalidate(0, _theme = f7Theme);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("style" in $$new_props) $$invalidate(4, style = $$new_props.style);
		if ("class" in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ("size" in $$new_props) $$invalidate(6, size = $$new_props.size);
	};

	$$self.$capture_state = () => ({
		theme: f7Theme,
		Utils,
		restProps,
		Mixins,
		f7,
		style,
		className,
		size,
		_theme,
		sizeComputed,
		preloaderStyle,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
		if ("style" in $$props) $$invalidate(4, style = $$new_props.style);
		if ("className" in $$props) $$invalidate(5, className = $$new_props.className);
		if ("size" in $$props) $$invalidate(6, size = $$new_props.size);
		if ("_theme" in $$props) $$invalidate(0, _theme = $$new_props._theme);
		if ("sizeComputed" in $$props) $$invalidate(7, sizeComputed = $$new_props.sizeComputed);
		if ("preloaderStyle" in $$props) $$invalidate(1, preloaderStyle = $$new_props.preloaderStyle);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	let sizeComputed;
	let preloaderStyle;
	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*size*/ 64) {
			 $$invalidate(7, sizeComputed = size && typeof size === "string" && size.indexOf("px") >= 0
			? size.replace("px", "")
			: size);
		}

		if ($$self.$$.dirty & /*style, sizeComputed*/ 144) {
			 $$invalidate(1, preloaderStyle = ((style || "") + (sizeComputed
			? `;width: ${sizeComputed}px; height: ${sizeComputed}px; --f7-preloader-size: ${sizeComputed}px`
			: "")).replace(";;", ";"));
		}

		 $$invalidate(2, classes = Utils.classNames(className, "preloader", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);

	return [
		_theme,
		preloaderStyle,
		classes,
		$$restProps,
		style,
		className,
		size,
		sizeComputed
	];
}

class Preloader extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$T, create_fragment$$, safe_not_equal, { style: 4, class: 5, size: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Preloader",
			options,
			id: create_fragment$$.name
		});
	}

	get style() {
		throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/page-content.svelte generated by Svelte v3.31.0 */
const file$10 = "node_modules/framework7-svelte/components/page-content.svelte";

// (147:2) {#if ptr && ptrPreloader && !ptrBottom}
function create_if_block_3$b(ctx) {
	let div1;
	let preloader;
	let t;
	let div0;
	let current;
	preloader = new Preloader({ $$inline: true });

	const block = {
		c: function create() {
			div1 = element("div");
			create_component(preloader.$$.fragment);
			t = space();
			div0 = element("div");
			attr_dev(div0, "class", "ptr-arrow");
			add_location(div0, file$10, 149, 6, 4501);
			attr_dev(div1, "class", "ptr-preloader");
			add_location(div1, file$10, 147, 4, 4447);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			mount_component(preloader, div1, null);
			append_dev(div1, t);
			append_dev(div1, div0);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(preloader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(preloader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(preloader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$b.name,
		type: "if",
		source: "(147:2) {#if ptr && ptrPreloader && !ptrBottom}",
		ctx
	});

	return block;
}

// (153:2) {#if infinite && infiniteTop && infinitePreloader}
function create_if_block_2$e(ctx) {
	let preloader;
	let current;

	preloader = new Preloader({
			props: { class: "infinite-scroll-preloader" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(preloader.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(preloader, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(preloader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(preloader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(preloader, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$e.name,
		type: "if",
		source: "(153:2) {#if infinite && infiniteTop && infinitePreloader}",
		ctx
	});

	return block;
}

// (157:2) {#if infinite && !infiniteTop && infinitePreloader}
function create_if_block_1$g(ctx) {
	let preloader;
	let current;

	preloader = new Preloader({
			props: { class: "infinite-scroll-preloader" },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(preloader.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(preloader, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(preloader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(preloader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(preloader, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$g.name,
		type: "if",
		source: "(157:2) {#if infinite && !infiniteTop && infinitePreloader}",
		ctx
	});

	return block;
}

// (160:2) {#if ptr && ptrPreloader && ptrBottom}
function create_if_block$o(ctx) {
	let div1;
	let preloader;
	let t;
	let div0;
	let current;
	preloader = new Preloader({ $$inline: true });

	const block = {
		c: function create() {
			div1 = element("div");
			create_component(preloader.$$.fragment);
			t = space();
			div0 = element("div");
			attr_dev(div0, "class", "ptr-arrow");
			add_location(div0, file$10, 162, 6, 4881);
			attr_dev(div1, "class", "ptr-preloader");
			add_location(div1, file$10, 160, 4, 4827);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			mount_component(preloader, div1, null);
			append_dev(div1, t);
			append_dev(div1, div0);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(preloader.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(preloader.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_component(preloader);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$o.name,
		type: "if",
		source: "(160:2) {#if ptr && ptrPreloader && ptrBottom}",
		ctx
	});

	return block;
}

function create_fragment$10(ctx) {
	let div;
	let t0;
	let t1;
	let t2;
	let t3;
	let div_data_ptr_mousewheel_value;
	let div_data_infinite_distance_value;
	let current;
	let if_block0 = /*ptr*/ ctx[0] && /*ptrPreloader*/ ctx[2] && !/*ptrBottom*/ ctx[3] && create_if_block_3$b(ctx);
	let if_block1 = /*infinite*/ ctx[5] && /*infiniteTop*/ ctx[6] && /*infinitePreloader*/ ctx[8] && create_if_block_2$e(ctx);
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
	let if_block2 = /*infinite*/ ctx[5] && !/*infiniteTop*/ ctx[6] && /*infinitePreloader*/ ctx[8] && create_if_block_1$g(ctx);
	let if_block3 = /*ptr*/ ctx[0] && /*ptrPreloader*/ ctx[2] && /*ptrBottom*/ ctx[3] && create_if_block$o(ctx);

	let div_levels = [
		{ class: /*pageContentClasses*/ ctx[10] },
		{
			"data-ptr-distance": /*ptrDistance*/ ctx[1]
		},
		{
			"data-ptr-mousewheel": div_data_ptr_mousewheel_value = /*ptrMousewheel*/ ctx[4] || undefined
		},
		{
			"data-infinite-distance": div_data_infinite_distance_value = /*infiniteDistance*/ ctx[7] || undefined
		},
		restProps(/*$$restProps*/ ctx[11])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			if (if_block3) if_block3.c();
			set_attributes(div, div_data);
			add_location(div, file$10, 138, 0, 4165);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_dev(div, t0);
			if (if_block1) if_block1.m(div, null);
			append_dev(div, t1);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_dev(div, t2);
			if (if_block2) if_block2.m(div, null);
			append_dev(div, t3);
			if (if_block3) if_block3.m(div, null);
			/*div_binding*/ ctx[22](div);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*ptr*/ ctx[0] && /*ptrPreloader*/ ctx[2] && !/*ptrBottom*/ ctx[3]) {
				if (if_block0) {
					if (dirty[0] & /*ptr, ptrPreloader, ptrBottom*/ 13) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$b(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*infinite*/ ctx[5] && /*infiniteTop*/ ctx[6] && /*infinitePreloader*/ ctx[8]) {
				if (if_block1) {
					if (dirty[0] & /*infinite, infiniteTop, infinitePreloader*/ 352) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2$e(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 1048576) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[20], dirty, null, null);
				}
			}

			if (/*infinite*/ ctx[5] && !/*infiniteTop*/ ctx[6] && /*infinitePreloader*/ ctx[8]) {
				if (if_block2) {
					if (dirty[0] & /*infinite, infiniteTop, infinitePreloader*/ 352) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1$g(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div, t3);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*ptr*/ ctx[0] && /*ptrPreloader*/ ctx[2] && /*ptrBottom*/ ctx[3]) {
				if (if_block3) {
					if (dirty[0] & /*ptr, ptrPreloader, ptrBottom*/ 13) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block$o(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div, null);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*pageContentClasses*/ 1024) && { class: /*pageContentClasses*/ ctx[10] },
				(!current || dirty[0] & /*ptrDistance*/ 2) && {
					"data-ptr-distance": /*ptrDistance*/ ctx[1]
				},
				(!current || dirty[0] & /*ptrMousewheel*/ 16 && div_data_ptr_mousewheel_value !== (div_data_ptr_mousewheel_value = /*ptrMousewheel*/ ctx[4] || undefined)) && {
					"data-ptr-mousewheel": div_data_ptr_mousewheel_value
				},
				(!current || dirty[0] & /*infiniteDistance*/ 128 && div_data_infinite_distance_value !== (div_data_infinite_distance_value = /*infiniteDistance*/ ctx[7] || undefined)) && {
					"data-infinite-distance": div_data_infinite_distance_value
				},
				dirty[0] & /*$$restProps*/ 2048 && restProps(/*$$restProps*/ ctx[11])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			/*div_binding*/ ctx[22](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$10.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$U($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"tab","tabActive","ptr","ptrDistance","ptrPreloader","ptrBottom","ptrMousewheel","infinite","infiniteTop","infiniteDistance","infinitePreloader","hideBarsOnScroll","hideNavbarOnScroll","hideToolbarOnScroll","messagesContent","loginScreen","class"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Page_content", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { tab = false } = $$props;
	let { tabActive = false } = $$props;
	let { ptr = false } = $$props;
	let { ptrDistance = undefined } = $$props;
	let { ptrPreloader = true } = $$props;
	let { ptrBottom = false } = $$props;
	let { ptrMousewheel = false } = $$props;
	let { infinite = false } = $$props;
	let { infiniteTop = false } = $$props;
	let { infiniteDistance = undefined } = $$props;
	let { infinitePreloader = true } = $$props;
	let { hideBarsOnScroll = false } = $$props;
	let { hideNavbarOnScroll = false } = $$props;
	let { hideToolbarOnScroll = false } = $$props;
	let { messagesContent = false } = $$props;
	let { loginScreen = false } = $$props;
	let { class: className = undefined } = $$props;
	let pageContentEl;

	// Event handlers
	function onPtrPullStart(ptrEl) {
		if (ptrEl !== pageContentEl) return;
		dispatch("ptrPullStart");
		if (typeof $$props.onPtrPullStart === "function") $$props.onPtrPullStart();
	}

	function onPtrPullMove(ptrEl) {
		if (ptrEl !== pageContentEl) return;
		dispatch("ptrPullMove");
		if (typeof $$props.onPtrPullMove === "function") $$props.onPtrPullMove();
	}

	function onPtrPullEnd(ptrEl) {
		if (ptrEl !== pageContentEl) return;
		dispatch("ptrPullEnd");
		if (typeof $$props.onPtrPullEnd === "function") $$props.onPtrPullEnd();
	}

	function onPtrRefresh(ptrEl, done) {
		if (ptrEl !== pageContentEl) return;
		dispatch("ptrRefresh", [done]);
		if (typeof $$props.onPtrRefresh === "function") $$props.onPtrRefresh(done);
	}

	function onPtrDone(ptrEl) {
		if (ptrEl !== pageContentEl) return;
		dispatch("ptrDone");
		if (typeof $$props.onPtrDone === "function") $$props.onPtrDone();
	}

	function onInfinite(infEl) {
		if (infEl !== pageContentEl) return;
		dispatch("infinite");
		if (typeof $$props.onInfinite === "function") $$props.onInfinite();
	}

	function onTabShow(tabEl) {
		if (pageContentEl !== tabEl) return;
		dispatch("tabShow");
		if (typeof $$props.onTabShow === "function") $$props.onTabShow(tabEl);
	}

	function onTabHide(tabEl) {
		if (pageContentEl !== tabEl) return;
		dispatch("tabHide");
		if (typeof $$props.onTabHide === "function") $$props.onTabHide(tabEl);
	}

	function mountPageContent() {
		if (ptr) {
			f7.instance.on("ptrPullStart", onPtrPullStart);
			f7.instance.on("ptrPullMove", onPtrPullMove);
			f7.instance.on("ptrPullEnd", onPtrPullEnd);
			f7.instance.on("ptrRefresh", onPtrRefresh);
			f7.instance.on("ptrDone", onPtrDone);
		}

		if (infinite) {
			f7.instance.on("infinite", onInfinite);
		}

		if (tab) {
			f7.instance.on("tabShow", onTabShow);
			f7.instance.on("tabHide", onTabHide);
		}
	}

	function destroyPageContent() {
		if (ptr) {
			f7.instance.off("ptrPullStart", onPtrPullStart);
			f7.instance.off("ptrPullMove", onPtrPullMove);
			f7.instance.off("ptrPullEnd", onPtrPullEnd);
			f7.instance.off("ptrRefresh", onPtrRefresh);
			f7.instance.off("ptrDone", onPtrDone);
		}

		if (infinite) {
			f7.instance.off("infinite", onInfinite);
		}

		if (tab) {
			f7.instance.off("tabShow", onTabShow);
			f7.instance.off("tabHide", onTabHide);
		}
	}

	onMount(() => {
		f7.ready(() => {
			mountPageContent();
		});
	});

	onDestroy(() => {
		if (!f7.instance) return;
		destroyPageContent();
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			pageContentEl = $$value;
			$$invalidate(9, pageContentEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(34, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("tab" in $$new_props) $$invalidate(12, tab = $$new_props.tab);
		if ("tabActive" in $$new_props) $$invalidate(13, tabActive = $$new_props.tabActive);
		if ("ptr" in $$new_props) $$invalidate(0, ptr = $$new_props.ptr);
		if ("ptrDistance" in $$new_props) $$invalidate(1, ptrDistance = $$new_props.ptrDistance);
		if ("ptrPreloader" in $$new_props) $$invalidate(2, ptrPreloader = $$new_props.ptrPreloader);
		if ("ptrBottom" in $$new_props) $$invalidate(3, ptrBottom = $$new_props.ptrBottom);
		if ("ptrMousewheel" in $$new_props) $$invalidate(4, ptrMousewheel = $$new_props.ptrMousewheel);
		if ("infinite" in $$new_props) $$invalidate(5, infinite = $$new_props.infinite);
		if ("infiniteTop" in $$new_props) $$invalidate(6, infiniteTop = $$new_props.infiniteTop);
		if ("infiniteDistance" in $$new_props) $$invalidate(7, infiniteDistance = $$new_props.infiniteDistance);
		if ("infinitePreloader" in $$new_props) $$invalidate(8, infinitePreloader = $$new_props.infinitePreloader);
		if ("hideBarsOnScroll" in $$new_props) $$invalidate(14, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
		if ("hideNavbarOnScroll" in $$new_props) $$invalidate(15, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
		if ("hideToolbarOnScroll" in $$new_props) $$invalidate(16, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
		if ("messagesContent" in $$new_props) $$invalidate(17, messagesContent = $$new_props.messagesContent);
		if ("loginScreen" in $$new_props) $$invalidate(18, loginScreen = $$new_props.loginScreen);
		if ("class" in $$new_props) $$invalidate(19, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		createEventDispatcher,
		Utils,
		restProps,
		Mixins,
		f7,
		Preloader,
		dispatch,
		tab,
		tabActive,
		ptr,
		ptrDistance,
		ptrPreloader,
		ptrBottom,
		ptrMousewheel,
		infinite,
		infiniteTop,
		infiniteDistance,
		infinitePreloader,
		hideBarsOnScroll,
		hideNavbarOnScroll,
		hideToolbarOnScroll,
		messagesContent,
		loginScreen,
		className,
		pageContentEl,
		onPtrPullStart,
		onPtrPullMove,
		onPtrPullEnd,
		onPtrRefresh,
		onPtrDone,
		onInfinite,
		onTabShow,
		onTabHide,
		mountPageContent,
		destroyPageContent,
		pageContentClasses
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(34, $$props = assign(assign({}, $$props), $$new_props));
		if ("tab" in $$props) $$invalidate(12, tab = $$new_props.tab);
		if ("tabActive" in $$props) $$invalidate(13, tabActive = $$new_props.tabActive);
		if ("ptr" in $$props) $$invalidate(0, ptr = $$new_props.ptr);
		if ("ptrDistance" in $$props) $$invalidate(1, ptrDistance = $$new_props.ptrDistance);
		if ("ptrPreloader" in $$props) $$invalidate(2, ptrPreloader = $$new_props.ptrPreloader);
		if ("ptrBottom" in $$props) $$invalidate(3, ptrBottom = $$new_props.ptrBottom);
		if ("ptrMousewheel" in $$props) $$invalidate(4, ptrMousewheel = $$new_props.ptrMousewheel);
		if ("infinite" in $$props) $$invalidate(5, infinite = $$new_props.infinite);
		if ("infiniteTop" in $$props) $$invalidate(6, infiniteTop = $$new_props.infiniteTop);
		if ("infiniteDistance" in $$props) $$invalidate(7, infiniteDistance = $$new_props.infiniteDistance);
		if ("infinitePreloader" in $$props) $$invalidate(8, infinitePreloader = $$new_props.infinitePreloader);
		if ("hideBarsOnScroll" in $$props) $$invalidate(14, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
		if ("hideNavbarOnScroll" in $$props) $$invalidate(15, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
		if ("hideToolbarOnScroll" in $$props) $$invalidate(16, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
		if ("messagesContent" in $$props) $$invalidate(17, messagesContent = $$new_props.messagesContent);
		if ("loginScreen" in $$props) $$invalidate(18, loginScreen = $$new_props.loginScreen);
		if ("className" in $$props) $$invalidate(19, className = $$new_props.className);
		if ("pageContentEl" in $$props) $$invalidate(9, pageContentEl = $$new_props.pageContentEl);
		if ("pageContentClasses" in $$props) $$invalidate(10, pageContentClasses = $$new_props.pageContentClasses);
	};

	let pageContentClasses;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(10, pageContentClasses = Utils.classNames(
			className,
			"page-content",
			{
				tab,
				"tab-active": tabActive,
				"ptr-content": ptr,
				"ptr-bottom": ptrBottom,
				"infinite-scroll-content": infinite,
				"infinite-scroll-top": infiniteTop,
				"hide-bars-on-scroll": hideBarsOnScroll,
				"hide-navbar-on-scroll": hideNavbarOnScroll,
				"hide-toolbar-on-scroll": hideToolbarOnScroll,
				"messages-content": messagesContent,
				"login-screen-content": loginScreen
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		ptr,
		ptrDistance,
		ptrPreloader,
		ptrBottom,
		ptrMousewheel,
		infinite,
		infiniteTop,
		infiniteDistance,
		infinitePreloader,
		pageContentEl,
		pageContentClasses,
		$$restProps,
		tab,
		tabActive,
		hideBarsOnScroll,
		hideNavbarOnScroll,
		hideToolbarOnScroll,
		messagesContent,
		loginScreen,
		className,
		$$scope,
		slots,
		div_binding
	];
}

class Page_content extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$U,
			create_fragment$10,
			safe_not_equal,
			{
				tab: 12,
				tabActive: 13,
				ptr: 0,
				ptrDistance: 1,
				ptrPreloader: 2,
				ptrBottom: 3,
				ptrMousewheel: 4,
				infinite: 5,
				infiniteTop: 6,
				infiniteDistance: 7,
				infinitePreloader: 8,
				hideBarsOnScroll: 14,
				hideNavbarOnScroll: 15,
				hideToolbarOnScroll: 16,
				messagesContent: 17,
				loginScreen: 18,
				class: 19
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Page_content",
			options,
			id: create_fragment$10.name
		});
	}

	get tab() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tab(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabActive() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabActive(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptr() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptr(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptrDistance() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptrDistance(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptrPreloader() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptrPreloader(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptrBottom() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptrBottom(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptrMousewheel() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptrMousewheel(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infinite() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infinite(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infiniteTop() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infiniteTop(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infiniteDistance() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infiniteDistance(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infinitePreloader() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infinitePreloader(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideBarsOnScroll() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideBarsOnScroll(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideNavbarOnScroll() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideNavbarOnScroll(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideToolbarOnScroll() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideToolbarOnScroll(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get messagesContent() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set messagesContent(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get loginScreen() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set loginScreen(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/page.svelte generated by Svelte v3.31.0 */
const file$11 = "node_modules/framework7-svelte/components/page.svelte";
const get_static_slot_changes_1 = dirty => ({});
const get_static_slot_context_1 = ctx => ({});
const get_static_slot_changes = dirty => ({});
const get_static_slot_context = ctx => ({});
const get_fixed_slot_changes = dirty => ({});
const get_fixed_slot_context = ctx => ({});

// (353:2) {:else}
function create_else_block$9(ctx) {
	let t;
	let current;
	const static_slot_template = /*#slots*/ ctx[46].static;
	const static_slot = create_slot(static_slot_template, ctx, /*$$scope*/ ctx[48], get_static_slot_context_1);
	const default_slot_template = /*#slots*/ ctx[46].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[48], null);

	const block = {
		c: function create() {
			if (static_slot) static_slot.c();
			t = space();
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (static_slot) {
				static_slot.m(target, anchor);
			}

			insert_dev(target, t, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (static_slot) {
				if (static_slot.p && dirty[1] & /*$$scope*/ 131072) {
					update_slot(static_slot, static_slot_template, ctx, /*$$scope*/ ctx[48], dirty, get_static_slot_changes_1, get_static_slot_context_1);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 131072) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[48], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(static_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(static_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (static_slot) static_slot.d(detaching);
			if (detaching) detach_dev(t);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$9.name,
		type: "else",
		source: "(353:2) {:else}",
		ctx
	});

	return block;
}

// (327:2) {#if pageContent}
function create_if_block$p(ctx) {
	let pagecontent;
	let current;

	pagecontent = new Page_content({
			props: {
				ptr: /*ptr*/ ctx[2],
				ptrDistance: /*ptrDistance*/ ctx[3],
				ptrPreloader: /*ptrPreloader*/ ctx[4],
				ptrBottom: /*ptrBottom*/ ctx[5],
				ptrMousewheel: /*ptrMousewheel*/ ctx[6],
				infinite: /*infinite*/ ctx[7],
				infiniteTop: /*infiniteTop*/ ctx[8],
				infiniteDistance: /*infiniteDistance*/ ctx[9],
				infinitePreloader: /*infinitePreloader*/ ctx[10],
				hideBarsOnScroll: /*hideBarsOnScroll*/ ctx[11],
				hideNavbarOnScroll: /*hideNavbarOnScroll*/ ctx[12],
				hideToolbarOnScroll: /*hideToolbarOnScroll*/ ctx[13],
				messagesContent: /*messagesContent*/ ctx[14],
				loginScreen: /*loginScreen*/ ctx[15],
				onPtrPullStart: /*onPtrPullStart*/ ctx[18],
				onPtrPullMove: /*onPtrPullMove*/ ctx[19],
				onPtrPullEnd: /*onPtrPullEnd*/ ctx[20],
				onPtrRefresh: /*onPtrRefresh*/ ctx[21],
				onPtrDone: /*onPtrDone*/ ctx[22],
				onInfinite: /*onInfinite*/ ctx[23],
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(pagecontent.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(pagecontent, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const pagecontent_changes = {};
			if (dirty[0] & /*ptr*/ 4) pagecontent_changes.ptr = /*ptr*/ ctx[2];
			if (dirty[0] & /*ptrDistance*/ 8) pagecontent_changes.ptrDistance = /*ptrDistance*/ ctx[3];
			if (dirty[0] & /*ptrPreloader*/ 16) pagecontent_changes.ptrPreloader = /*ptrPreloader*/ ctx[4];
			if (dirty[0] & /*ptrBottom*/ 32) pagecontent_changes.ptrBottom = /*ptrBottom*/ ctx[5];
			if (dirty[0] & /*ptrMousewheel*/ 64) pagecontent_changes.ptrMousewheel = /*ptrMousewheel*/ ctx[6];
			if (dirty[0] & /*infinite*/ 128) pagecontent_changes.infinite = /*infinite*/ ctx[7];
			if (dirty[0] & /*infiniteTop*/ 256) pagecontent_changes.infiniteTop = /*infiniteTop*/ ctx[8];
			if (dirty[0] & /*infiniteDistance*/ 512) pagecontent_changes.infiniteDistance = /*infiniteDistance*/ ctx[9];
			if (dirty[0] & /*infinitePreloader*/ 1024) pagecontent_changes.infinitePreloader = /*infinitePreloader*/ ctx[10];
			if (dirty[0] & /*hideBarsOnScroll*/ 2048) pagecontent_changes.hideBarsOnScroll = /*hideBarsOnScroll*/ ctx[11];
			if (dirty[0] & /*hideNavbarOnScroll*/ 4096) pagecontent_changes.hideNavbarOnScroll = /*hideNavbarOnScroll*/ ctx[12];
			if (dirty[0] & /*hideToolbarOnScroll*/ 8192) pagecontent_changes.hideToolbarOnScroll = /*hideToolbarOnScroll*/ ctx[13];
			if (dirty[0] & /*messagesContent*/ 16384) pagecontent_changes.messagesContent = /*messagesContent*/ ctx[14];
			if (dirty[0] & /*loginScreen*/ 32768) pagecontent_changes.loginScreen = /*loginScreen*/ ctx[15];

			if (dirty[1] & /*$$scope*/ 131072) {
				pagecontent_changes.$$scope = { dirty, ctx };
			}

			pagecontent.$set(pagecontent_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(pagecontent.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(pagecontent.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(pagecontent, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$p.name,
		type: "if",
		source: "(327:2) {#if pageContent}",
		ctx
	});

	return block;
}

// (328:2) <PageContent     ptr={ptr}     ptrDistance={ptrDistance}     ptrPreloader={ptrPreloader}     ptrBottom={ptrBottom}     ptrMousewheel={ptrMousewheel}     infinite={infinite}     infiniteTop={infiniteTop}     infiniteDistance={infiniteDistance}     infinitePreloader={infinitePreloader}     hideBarsOnScroll={hideBarsOnScroll}     hideNavbarOnScroll={hideNavbarOnScroll}     hideToolbarOnScroll={hideToolbarOnScroll}     messagesContent={messagesContent}     loginScreen={loginScreen}     onPtrPullStart={onPtrPullStart}     onPtrPullMove={onPtrPullMove}     onPtrPullEnd={onPtrPullEnd}     onPtrRefresh={onPtrRefresh}     onPtrDone={onPtrDone}     onInfinite={onInfinite}   >
function create_default_slot$5(ctx) {
	let t;
	let current;
	const static_slot_template = /*#slots*/ ctx[46].static;
	const static_slot = create_slot(static_slot_template, ctx, /*$$scope*/ ctx[48], get_static_slot_context);
	const default_slot_template = /*#slots*/ ctx[46].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[48], null);

	const block = {
		c: function create() {
			if (static_slot) static_slot.c();
			t = space();
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (static_slot) {
				static_slot.m(target, anchor);
			}

			insert_dev(target, t, anchor);

			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (static_slot) {
				if (static_slot.p && dirty[1] & /*$$scope*/ 131072) {
					update_slot(static_slot, static_slot_template, ctx, /*$$scope*/ ctx[48], dirty, get_static_slot_changes, get_static_slot_context);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 131072) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[48], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(static_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(static_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (static_slot) static_slot.d(detaching);
			if (detaching) detach_dev(t);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$5.name,
		type: "slot",
		source: "(328:2) <PageContent     ptr={ptr}     ptrDistance={ptrDistance}     ptrPreloader={ptrPreloader}     ptrBottom={ptrBottom}     ptrMousewheel={ptrMousewheel}     infinite={infinite}     infiniteTop={infiniteTop}     infiniteDistance={infiniteDistance}     infinitePreloader={infinitePreloader}     hideBarsOnScroll={hideBarsOnScroll}     hideNavbarOnScroll={hideNavbarOnScroll}     hideToolbarOnScroll={hideToolbarOnScroll}     messagesContent={messagesContent}     loginScreen={loginScreen}     onPtrPullStart={onPtrPullStart}     onPtrPullMove={onPtrPullMove}     onPtrPullEnd={onPtrPullEnd}     onPtrRefresh={onPtrRefresh}     onPtrDone={onPtrDone}     onInfinite={onInfinite}   >",
		ctx
	});

	return block;
}

function create_fragment$11(ctx) {
	let div;
	let t;
	let current_block_type_index;
	let if_block;
	let current;
	const fixed_slot_template = /*#slots*/ ctx[46].fixed;
	const fixed_slot = create_slot(fixed_slot_template, ctx, /*$$scope*/ ctx[48], get_fixed_slot_context);
	const if_block_creators = [create_if_block$p, create_else_block$9];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*pageContent*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let div_levels = [
		{ class: /*classes*/ ctx[17] },
		{ "data-name": /*name*/ ctx[0] },
		restProps(/*$$restProps*/ ctx[24])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (fixed_slot) fixed_slot.c();
			t = space();
			if_block.c();
			set_attributes(div, div_data);
			add_location(div, file$11, 324, 0, 11332);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (fixed_slot) {
				fixed_slot.m(div, null);
			}

			append_dev(div, t);
			if_blocks[current_block_type_index].m(div, null);
			/*div_binding*/ ctx[47](div);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (fixed_slot) {
				if (fixed_slot.p && dirty[1] & /*$$scope*/ 131072) {
					update_slot(fixed_slot, fixed_slot_template, ctx, /*$$scope*/ ctx[48], dirty, get_fixed_slot_changes, get_fixed_slot_context);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 131072) && { class: /*classes*/ ctx[17] },
				(!current || dirty[0] & /*name*/ 1) && { "data-name": /*name*/ ctx[0] },
				dirty[0] & /*$$restProps*/ 16777216 && restProps(/*$$restProps*/ ctx[24])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fixed_slot, local);
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(fixed_slot, local);
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (fixed_slot) fixed_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			/*div_binding*/ ctx[47](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$11.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$V($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"name","stacked","withSubnavbar","subnavbar","withNavbarLarge","navbarLarge","noNavbar","noToolbar","tabs","pageContent","noSwipeback","ptr","ptrDistance","ptrPreloader","ptrBottom","ptrMousewheel","infinite","infiniteTop","infiniteDistance","infinitePreloader","hideBarsOnScroll","hideNavbarOnScroll","hideToolbarOnScroll","messagesContent","loginScreen","class"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Page", slots, ['fixed','static','default']);
	const dispatch = createEventDispatcher();
	let { name = undefined } = $$props;
	let { stacked = undefined } = $$props;
	let { withSubnavbar = undefined } = $$props;
	let { subnavbar = undefined } = $$props;
	let { withNavbarLarge = undefined } = $$props;
	let { navbarLarge = undefined } = $$props;
	let { noNavbar = undefined } = $$props;
	let { noToolbar = undefined } = $$props;
	let { tabs = undefined } = $$props;
	let { pageContent = true } = $$props;
	let { noSwipeback = undefined } = $$props;
	let { ptr = undefined } = $$props;
	let { ptrDistance = undefined } = $$props;
	let { ptrPreloader = true } = $$props;
	let { ptrBottom = undefined } = $$props;
	let { ptrMousewheel = undefined } = $$props;
	let { infinite = undefined } = $$props;
	let { infiniteTop = undefined } = $$props;
	let { infiniteDistance = undefined } = $$props;
	let { infinitePreloader = true } = $$props;
	let { hideBarsOnScroll = undefined } = $$props;
	let { hideNavbarOnScroll = undefined } = $$props;
	let { hideToolbarOnScroll = undefined } = $$props;
	let { messagesContent = undefined } = $$props;
	let { loginScreen = undefined } = $$props;
	let { class: className = undefined } = $$props;

	// State
	let el;

	let hasSubnavbar = false;
	let hasNavbarLarge = false;
	let hasNavbarLargeCollapsed = false;
	let hasCardExpandableOpened = false;
	let routerPositionClass = "";
	let routerForceUnstack = false;
	let routerPageRole = null;
	let routerPageRoleDetailRoot = false;
	let routerPageMasterStack = false;

	// Handlers
	function onPtrPullStart() {
		dispatch("ptrPullStart");
		if (typeof $$props.onPtrPullStart === "function") $$props.onPtrPullStart();
	}

	function onPtrPullMove() {
		dispatch("ptrPullMove");
		if (typeof $$props.onPtrPullMove === "function") $$props.onPtrPullMove();
	}

	function onPtrPullEnd() {
		dispatch("ptrPullEnd");
		if (typeof $$props.onPtrPullEnd === "function") $$props.onPtrPullEnd();
	}

	function onPtrRefresh(done) {
		dispatch("ptrRefresh", [done]);
		if (typeof $$props.onPtrRefresh === "function") $$props.onPtrRefresh(done);
	}

	function onPtrDone() {
		dispatch("ptrDone");
		if (typeof $$props.onPtrDone === "function") $$props.onPtrDone();
	}

	function onInfinite() {
		dispatch("infinite");
		if (typeof $$props.onInfinite === "function") $$props.onInfinite();
	}

	// Main Page Events
	function onPageMounted(page) {
		if (el !== page.el) return;
		dispatch("pageMounted", [page]);
		if (typeof $$props.onPageMounted === "function") $$props.onPageMounted(page);
	}

	function onPageInit(page) {
		if (el !== page.el) return;

		if (typeof withSubnavbar === "undefined" && typeof subnavbar === "undefined") {
			if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find(".subnavbar").length || page.$el.children(".navbar").find(".subnavbar").length) {
				$$invalidate(35, hasSubnavbar = true);
			}
		}

		if (typeof withNavbarLarge === "undefined" && typeof navbarLarge === "undefined") {
			if (page.$navbarEl && page.$navbarEl.hasClass("navbar-large") || page.$el.children(".navbar-large").length) {
				$$invalidate(36, hasNavbarLarge = true);
			}
		}

		dispatch("pageInit", [page]);
		if (typeof $$props.onPageInit === "function") $$props.onPageInit(page);
	}

	function onPageReinit(page) {
		if (el !== page.el) return;
		dispatch("pageReinit", [page]);
		if (typeof $$props.onPageReinit === "function") $$props.onPageReinit(page);
	}

	function onPageBeforeIn(page) {
		if (el !== page.el) return;

		if (!page.swipeBack) {
			if (page.from === "next") {
				$$invalidate(39, routerPositionClass = "page-next");
			}

			if (page.from === "previous") {
				$$invalidate(39, routerPositionClass = "page-previous");
			}
		}

		dispatch("pageBeforeIn", [page]);
		if (typeof $$props.onPageBeforeIn === "function") $$props.onPageBeforeIn(page);
	}

	function onPageBeforeOut(page) {
		if (el !== page.el) return;
		dispatch("pageBeforeOut", [page]);
		if (typeof $$props.onPageBeforeOut === "function") $$props.onPageBeforeOut(page);
	}

	function onPageAfterOut(page) {
		if (el !== page.el) return;

		if (page.to === "next") {
			$$invalidate(39, routerPositionClass = "page-next");
		}

		if (page.to === "previous") {
			$$invalidate(39, routerPositionClass = "page-previous");
		}

		dispatch("pageAfterOut", [page]);
		if (typeof $$props.onPageAfterOut === "function") $$props.onPageAfterOut(page);
	}

	function onPageAfterIn(page) {
		if (el !== page.el) return;
		$$invalidate(39, routerPositionClass = "page-current");
		dispatch("pageAfterIn", [page]);
		if (typeof $$props.onPageAfterIn === "function") $$props.onPageAfterIn(page);
	}

	function onPageBeforeRemove(page) {
		if (el !== page.el) return;

		if (page.$navbarEl && page.$navbarEl[0] && page.$navbarEl.parent()[0] && page.$navbarEl.parent()[0] !== el) {
			page.$el.prepend(page.$navbarEl);
		}

		dispatch("pageBeforeRemove", [page]);
		if (typeof $$props.onPageBeforeRemove === "function") $$props.onPageBeforeRemove(page);
	}

	function onPageBeforeUnmount(page) {
		if (el !== page.el) return;
		dispatch("pageBeforeUnmount", [page]);
		if (typeof $$props.onPageBeforeUnmount === "function") $$props.onPageBeforeUnmount(page);
	}

	// Helper events
	function onPageStack(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(40, routerForceUnstack = false);
	}

	function onPageUnstack(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(40, routerForceUnstack = true);
	}

	function onPagePosition(pageEl, position) {
		if (el !== pageEl) return;
		$$invalidate(39, routerPositionClass = `page-${position}`);
	}

	function onPageRole(pageEl, rolesData) {
		if (el !== pageEl) return;
		$$invalidate(41, routerPageRole = rolesData.role);
		$$invalidate(42, routerPageRoleDetailRoot = rolesData.detailRoot);
	}

	function onPageMasterStack(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(43, routerPageMasterStack = true);
	}

	function onPageMasterUnstack(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(43, routerPageMasterStack = false);
	}

	function onPageNavbarLargeCollapsed(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(37, hasNavbarLargeCollapsed = true);
	}

	function onPageNavbarLargeExpanded(pageEl) {
		if (el !== pageEl) return;
		$$invalidate(37, hasNavbarLargeCollapsed = false);
	}

	function onCardOpened(cardEl, pageEl) {
		if (el !== pageEl) return;
		$$invalidate(38, hasCardExpandableOpened = true);
	}

	function onCardClose(cardEl, pageEl) {
		if (el !== pageEl) return;
		$$invalidate(38, hasCardExpandableOpened = false);
	}

	function onPageTabShow(pageEl) {
		if (el !== pageEl) return;
		dispatch("pageTabShow");
		if (typeof $$props.onPageTabShow === "function") $$props.onPageTabShow();
	}

	function onPageTabHide(pageEl) {
		if (el !== pageEl) return;
		dispatch("pageTabHide");
		if (typeof $$props.onPageTabHide === "function") $$props.onPageTabHide();
	}

	// Mount/destroy
	function mountPage() {
		f7.instance.on("pageMounted", onPageMounted);
		f7.instance.on("pageInit", onPageInit);
		f7.instance.on("pageReinit", onPageReinit);
		f7.instance.on("pageBeforeIn", onPageBeforeIn);
		f7.instance.on("pageBeforeOut", onPageBeforeOut);
		f7.instance.on("pageAfterOut", onPageAfterOut);
		f7.instance.on("pageAfterIn", onPageAfterIn);
		f7.instance.on("pageBeforeRemove", onPageBeforeRemove);
		f7.instance.on("pageBeforeUnmount", onPageBeforeUnmount);
		f7.instance.on("pageStack", onPageStack);
		f7.instance.on("pageUnstack", onPageUnstack);
		f7.instance.on("pagePosition", onPagePosition);
		f7.instance.on("pageRole", onPageRole);
		f7.instance.on("pageMasterStack", onPageMasterStack);
		f7.instance.on("pageMasterUnstack", onPageMasterUnstack);
		f7.instance.on("pageNavbarLargeCollapsed", onPageNavbarLargeCollapsed);
		f7.instance.on("pageNavbarLargeExpanded", onPageNavbarLargeExpanded);
		f7.instance.on("cardOpened", onCardOpened);
		f7.instance.on("cardClose", onCardClose);
		f7.instance.on("pageTabShow", onPageTabShow);
		f7.instance.on("pageTabHide", onPageTabHide);
	}

	function destroyPage() {
		f7.instance.off("pageMounted", onPageMounted);
		f7.instance.off("pageInit", onPageInit);
		f7.instance.off("pageReinit", onPageReinit);
		f7.instance.off("pageBeforeIn", onPageBeforeIn);
		f7.instance.off("pageBeforeOut", onPageBeforeOut);
		f7.instance.off("pageAfterOut", onPageAfterOut);
		f7.instance.off("pageAfterIn", onPageAfterIn);
		f7.instance.off("pageBeforeRemove", onPageBeforeRemove);
		f7.instance.off("pageBeforeUnmount", onPageBeforeUnmount);
		f7.instance.off("pageStack", onPageStack);
		f7.instance.off("pageUnstack", onPageUnstack);
		f7.instance.off("pagePosition", onPagePosition);
		f7.instance.off("pageRole", onPageRole);
		f7.instance.off("pageMasterStack", onPageMasterStack);
		f7.instance.off("pageMasterUnstack", onPageMasterUnstack);
		f7.instance.off("pageNavbarLargeCollapsed", onPageNavbarLargeCollapsed);
		f7.instance.off("pageNavbarLargeExpanded", onPageNavbarLargeExpanded);
		f7.instance.off("cardOpened", onCardOpened);
		f7.instance.off("cardClose", onCardClose);
		f7.instance.off("pageTabShow", onPageTabShow);
		f7.instance.off("pageTabHide", onPageTabHide);
	}

	onMount(() => {
		f7.ready(() => {
			if (el) {
				const dom7 = f7.instance.$;
				const fixedEls = dom7(el).children(".page-content").children("[data-f7-slot=\"fixed\"]");

				if (fixedEls.length) {
					for (let i = fixedEls.length - 1; i >= 0; i -= 1) {
						dom7(el).prepend(fixedEls[i]);
					}
				}
			}

			mountPage();
		});
	});

	afterUpdate(() => {
		if (el && f7.instance) {
			const dom7 = f7.instance.$;
			const fixedEls = dom7(el).children(".page-content").children("[data-f7-slot=\"fixed\"]");

			if (fixedEls.length) {
				for (let i = fixedEls.length - 1; i >= 0; i -= 1) {
					dom7(el).prepend(fixedEls[i]);
				}
			}
		}
	});

	onDestroy(() => {
		if (!f7.instance) return;
		destroyPage();
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(16, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(73, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(24, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("name" in $$new_props) $$invalidate(0, name = $$new_props.name);
		if ("stacked" in $$new_props) $$invalidate(25, stacked = $$new_props.stacked);
		if ("withSubnavbar" in $$new_props) $$invalidate(26, withSubnavbar = $$new_props.withSubnavbar);
		if ("subnavbar" in $$new_props) $$invalidate(27, subnavbar = $$new_props.subnavbar);
		if ("withNavbarLarge" in $$new_props) $$invalidate(28, withNavbarLarge = $$new_props.withNavbarLarge);
		if ("navbarLarge" in $$new_props) $$invalidate(29, navbarLarge = $$new_props.navbarLarge);
		if ("noNavbar" in $$new_props) $$invalidate(30, noNavbar = $$new_props.noNavbar);
		if ("noToolbar" in $$new_props) $$invalidate(31, noToolbar = $$new_props.noToolbar);
		if ("tabs" in $$new_props) $$invalidate(32, tabs = $$new_props.tabs);
		if ("pageContent" in $$new_props) $$invalidate(1, pageContent = $$new_props.pageContent);
		if ("noSwipeback" in $$new_props) $$invalidate(33, noSwipeback = $$new_props.noSwipeback);
		if ("ptr" in $$new_props) $$invalidate(2, ptr = $$new_props.ptr);
		if ("ptrDistance" in $$new_props) $$invalidate(3, ptrDistance = $$new_props.ptrDistance);
		if ("ptrPreloader" in $$new_props) $$invalidate(4, ptrPreloader = $$new_props.ptrPreloader);
		if ("ptrBottom" in $$new_props) $$invalidate(5, ptrBottom = $$new_props.ptrBottom);
		if ("ptrMousewheel" in $$new_props) $$invalidate(6, ptrMousewheel = $$new_props.ptrMousewheel);
		if ("infinite" in $$new_props) $$invalidate(7, infinite = $$new_props.infinite);
		if ("infiniteTop" in $$new_props) $$invalidate(8, infiniteTop = $$new_props.infiniteTop);
		if ("infiniteDistance" in $$new_props) $$invalidate(9, infiniteDistance = $$new_props.infiniteDistance);
		if ("infinitePreloader" in $$new_props) $$invalidate(10, infinitePreloader = $$new_props.infinitePreloader);
		if ("hideBarsOnScroll" in $$new_props) $$invalidate(11, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
		if ("hideNavbarOnScroll" in $$new_props) $$invalidate(12, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
		if ("hideToolbarOnScroll" in $$new_props) $$invalidate(13, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
		if ("messagesContent" in $$new_props) $$invalidate(14, messagesContent = $$new_props.messagesContent);
		if ("loginScreen" in $$new_props) $$invalidate(15, loginScreen = $$new_props.loginScreen);
		if ("class" in $$new_props) $$invalidate(34, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(48, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		afterUpdate,
		onDestroy,
		createEventDispatcher,
		Utils,
		restProps,
		Mixins,
		f7,
		PageContent: Page_content,
		dispatch,
		name,
		stacked,
		withSubnavbar,
		subnavbar,
		withNavbarLarge,
		navbarLarge,
		noNavbar,
		noToolbar,
		tabs,
		pageContent,
		noSwipeback,
		ptr,
		ptrDistance,
		ptrPreloader,
		ptrBottom,
		ptrMousewheel,
		infinite,
		infiniteTop,
		infiniteDistance,
		infinitePreloader,
		hideBarsOnScroll,
		hideNavbarOnScroll,
		hideToolbarOnScroll,
		messagesContent,
		loginScreen,
		className,
		el,
		hasSubnavbar,
		hasNavbarLarge,
		hasNavbarLargeCollapsed,
		hasCardExpandableOpened,
		routerPositionClass,
		routerForceUnstack,
		routerPageRole,
		routerPageRoleDetailRoot,
		routerPageMasterStack,
		onPtrPullStart,
		onPtrPullMove,
		onPtrPullEnd,
		onPtrRefresh,
		onPtrDone,
		onInfinite,
		onPageMounted,
		onPageInit,
		onPageReinit,
		onPageBeforeIn,
		onPageBeforeOut,
		onPageAfterOut,
		onPageAfterIn,
		onPageBeforeRemove,
		onPageBeforeUnmount,
		onPageStack,
		onPageUnstack,
		onPagePosition,
		onPageRole,
		onPageMasterStack,
		onPageMasterUnstack,
		onPageNavbarLargeCollapsed,
		onPageNavbarLargeExpanded,
		onCardOpened,
		onCardClose,
		onPageTabShow,
		onPageTabHide,
		mountPage,
		destroyPage,
		forceSubnavbar,
		forceNavbarLarge,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(73, $$props = assign(assign({}, $$props), $$new_props));
		if ("name" in $$props) $$invalidate(0, name = $$new_props.name);
		if ("stacked" in $$props) $$invalidate(25, stacked = $$new_props.stacked);
		if ("withSubnavbar" in $$props) $$invalidate(26, withSubnavbar = $$new_props.withSubnavbar);
		if ("subnavbar" in $$props) $$invalidate(27, subnavbar = $$new_props.subnavbar);
		if ("withNavbarLarge" in $$props) $$invalidate(28, withNavbarLarge = $$new_props.withNavbarLarge);
		if ("navbarLarge" in $$props) $$invalidate(29, navbarLarge = $$new_props.navbarLarge);
		if ("noNavbar" in $$props) $$invalidate(30, noNavbar = $$new_props.noNavbar);
		if ("noToolbar" in $$props) $$invalidate(31, noToolbar = $$new_props.noToolbar);
		if ("tabs" in $$props) $$invalidate(32, tabs = $$new_props.tabs);
		if ("pageContent" in $$props) $$invalidate(1, pageContent = $$new_props.pageContent);
		if ("noSwipeback" in $$props) $$invalidate(33, noSwipeback = $$new_props.noSwipeback);
		if ("ptr" in $$props) $$invalidate(2, ptr = $$new_props.ptr);
		if ("ptrDistance" in $$props) $$invalidate(3, ptrDistance = $$new_props.ptrDistance);
		if ("ptrPreloader" in $$props) $$invalidate(4, ptrPreloader = $$new_props.ptrPreloader);
		if ("ptrBottom" in $$props) $$invalidate(5, ptrBottom = $$new_props.ptrBottom);
		if ("ptrMousewheel" in $$props) $$invalidate(6, ptrMousewheel = $$new_props.ptrMousewheel);
		if ("infinite" in $$props) $$invalidate(7, infinite = $$new_props.infinite);
		if ("infiniteTop" in $$props) $$invalidate(8, infiniteTop = $$new_props.infiniteTop);
		if ("infiniteDistance" in $$props) $$invalidate(9, infiniteDistance = $$new_props.infiniteDistance);
		if ("infinitePreloader" in $$props) $$invalidate(10, infinitePreloader = $$new_props.infinitePreloader);
		if ("hideBarsOnScroll" in $$props) $$invalidate(11, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
		if ("hideNavbarOnScroll" in $$props) $$invalidate(12, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
		if ("hideToolbarOnScroll" in $$props) $$invalidate(13, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
		if ("messagesContent" in $$props) $$invalidate(14, messagesContent = $$new_props.messagesContent);
		if ("loginScreen" in $$props) $$invalidate(15, loginScreen = $$new_props.loginScreen);
		if ("className" in $$props) $$invalidate(34, className = $$new_props.className);
		if ("el" in $$props) $$invalidate(16, el = $$new_props.el);
		if ("hasSubnavbar" in $$props) $$invalidate(35, hasSubnavbar = $$new_props.hasSubnavbar);
		if ("hasNavbarLarge" in $$props) $$invalidate(36, hasNavbarLarge = $$new_props.hasNavbarLarge);
		if ("hasNavbarLargeCollapsed" in $$props) $$invalidate(37, hasNavbarLargeCollapsed = $$new_props.hasNavbarLargeCollapsed);
		if ("hasCardExpandableOpened" in $$props) $$invalidate(38, hasCardExpandableOpened = $$new_props.hasCardExpandableOpened);
		if ("routerPositionClass" in $$props) $$invalidate(39, routerPositionClass = $$new_props.routerPositionClass);
		if ("routerForceUnstack" in $$props) $$invalidate(40, routerForceUnstack = $$new_props.routerForceUnstack);
		if ("routerPageRole" in $$props) $$invalidate(41, routerPageRole = $$new_props.routerPageRole);
		if ("routerPageRoleDetailRoot" in $$props) $$invalidate(42, routerPageRoleDetailRoot = $$new_props.routerPageRoleDetailRoot);
		if ("routerPageMasterStack" in $$props) $$invalidate(43, routerPageMasterStack = $$new_props.routerPageMasterStack);
		if ("forceSubnavbar" in $$props) $$invalidate(44, forceSubnavbar = $$new_props.forceSubnavbar);
		if ("forceNavbarLarge" in $$props) $$invalidate(45, forceNavbarLarge = $$new_props.forceNavbarLarge);
		if ("classes" in $$props) $$invalidate(17, classes = $$new_props.classes);
	};

	let forceSubnavbar;
	let forceNavbarLarge;
	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*subnavbar, withSubnavbar*/ 201326592 | $$self.$$.dirty[1] & /*hasSubnavbar*/ 16) {
			 $$invalidate(44, forceSubnavbar = typeof subnavbar === "undefined" && typeof withSubnavbar === "undefined"
			? hasSubnavbar
			: false);
		}

		if ($$self.$$.dirty[0] & /*navbarLarge, withNavbarLarge*/ 805306368 | $$self.$$.dirty[1] & /*hasNavbarLarge*/ 32) {
			 $$invalidate(45, forceNavbarLarge = typeof navbarLarge === "undefined" && typeof withNavbarLarge === "undefined"
			? hasNavbarLarge
			: false);
		}

		 $$invalidate(17, classes = Utils.classNames(
			className,
			"page",
			routerPositionClass,
			{
				stacked: stacked && !routerForceUnstack,
				tabs,
				"page-with-subnavbar": subnavbar || withSubnavbar || forceSubnavbar,
				"page-with-navbar-large": navbarLarge || withNavbarLarge || forceNavbarLarge,
				"no-navbar": noNavbar,
				"no-toolbar": noToolbar,
				"no-swipeback": noSwipeback,
				"page-master": routerPageRole === "master",
				"page-master-detail": routerPageRole === "detail",
				"page-master-detail-root": routerPageRoleDetailRoot === true,
				"page-master-stacked": routerPageMasterStack === true,
				"page-with-navbar-large-collapsed": hasNavbarLargeCollapsed === true,
				"page-with-card-opened": hasCardExpandableOpened === true,
				"login-screen-page": loginScreen
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		name,
		pageContent,
		ptr,
		ptrDistance,
		ptrPreloader,
		ptrBottom,
		ptrMousewheel,
		infinite,
		infiniteTop,
		infiniteDistance,
		infinitePreloader,
		hideBarsOnScroll,
		hideNavbarOnScroll,
		hideToolbarOnScroll,
		messagesContent,
		loginScreen,
		el,
		classes,
		onPtrPullStart,
		onPtrPullMove,
		onPtrPullEnd,
		onPtrRefresh,
		onPtrDone,
		onInfinite,
		$$restProps,
		stacked,
		withSubnavbar,
		subnavbar,
		withNavbarLarge,
		navbarLarge,
		noNavbar,
		noToolbar,
		tabs,
		noSwipeback,
		className,
		hasSubnavbar,
		hasNavbarLarge,
		hasNavbarLargeCollapsed,
		hasCardExpandableOpened,
		routerPositionClass,
		routerForceUnstack,
		routerPageRole,
		routerPageRoleDetailRoot,
		routerPageMasterStack,
		forceSubnavbar,
		forceNavbarLarge,
		slots,
		div_binding,
		$$scope
	];
}

class Page extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$V,
			create_fragment$11,
			safe_not_equal,
			{
				name: 0,
				stacked: 25,
				withSubnavbar: 26,
				subnavbar: 27,
				withNavbarLarge: 28,
				navbarLarge: 29,
				noNavbar: 30,
				noToolbar: 31,
				tabs: 32,
				pageContent: 1,
				noSwipeback: 33,
				ptr: 2,
				ptrDistance: 3,
				ptrPreloader: 4,
				ptrBottom: 5,
				ptrMousewheel: 6,
				infinite: 7,
				infiniteTop: 8,
				infiniteDistance: 9,
				infinitePreloader: 10,
				hideBarsOnScroll: 11,
				hideNavbarOnScroll: 12,
				hideToolbarOnScroll: 13,
				messagesContent: 14,
				loginScreen: 15,
				class: 34
			},
			[-1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Page",
			options,
			id: create_fragment$11.name
		});
	}

	get name() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get stacked() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stacked(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get withSubnavbar() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set withSubnavbar(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get subnavbar() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set subnavbar(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get withNavbarLarge() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set withNavbarLarge(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get navbarLarge() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set navbarLarge(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noNavbar() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noNavbar(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noToolbar() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noToolbar(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabs() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabs(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pageContent() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pageContent(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noSwipeback() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noSwipeback(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptr() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptr(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptrDistance() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptrDistance(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptrPreloader() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptrPreloader(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptrBottom() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptrBottom(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ptrMousewheel() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ptrMousewheel(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infinite() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infinite(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infiniteTop() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infiniteTop(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infiniteDistance() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infiniteDistance(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infinitePreloader() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infinitePreloader(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideBarsOnScroll() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideBarsOnScroll(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideNavbarOnScroll() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideNavbarOnScroll(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideToolbarOnScroll() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideToolbarOnScroll(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get messagesContent() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set messagesContent(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get loginScreen() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set loginScreen(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/panel.svelte generated by Svelte v3.31.0 */
const file$12 = "node_modules/framework7-svelte/components/panel.svelte";

// (188:2) {#if resizable}
function create_if_block$q(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "panel-resize-handler");
			add_location(div, file$12, 188, 4, 5415);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$q.name,
		type: "if",
		source: "(188:2) {#if resizable}",
		ctx
	});

	return block;
}

function create_fragment$12(ctx) {
	let div;
	let t;
	let current;
	const default_slot_template = /*#slots*/ ctx[28].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[27], null);
	let if_block = /*resizable*/ ctx[0] && create_if_block$q(ctx);
	let div_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			set_attributes(div, div_data);
			add_location(div, file$12, 185, 0, 5317);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_dev(div, t);
			if (if_block) if_block.m(div, null);
			/*div_binding*/ ctx[29](div);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 134217728) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[27], dirty, null, null);
				}
			}

			if (/*resizable*/ ctx[0]) {
				if (if_block) ; else {
					if_block = create_if_block$q(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty[0] & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*div_binding*/ ctx[29](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$12.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$8($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","side","effect","cover","reveal","left","right","opened","resizable","backdrop","backdropEl","visibleBreakpoint","collapsedBreakpoint","swipe","swipeNoFollow","swipeOnlyClose","swipeActiveArea","swipeThreshold","instance","open","close","toggle"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Panel", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { side = undefined } = $$props;
	let { effect = undefined } = $$props;
	let { cover = false } = $$props;
	let { reveal = false } = $$props;
	let { left = false } = $$props;
	let { right = false } = $$props;
	let { opened = false } = $$props;
	let { resizable = false } = $$props;
	let { backdrop = true } = $$props;
	let { backdropEl = undefined } = $$props;
	let { visibleBreakpoint = undefined } = $$props;
	let { collapsedBreakpoint = undefined } = $$props;
	let { swipe = false } = $$props;
	let { swipeNoFollow = false } = $$props;
	let { swipeOnlyClose = false } = $$props;
	let { swipeActiveArea = 0 } = $$props;
	let { swipeThreshold = 0 } = $$props;
	let el;
	let f7Panel;

	function instance() {
		return f7Panel;
	}

	let resizableOld = resizable;
	let initialWatchedResizable = false;

	function watchResizable(r) {
		if (!initialWatchedResizable) {
			initialWatchedResizable = true;
			return;
		}

		if (f7Panel && r && !resizableOld) {
			f7Panel.enableResizable();
		} else if (f7Panel && !r && resizableOld) {
			f7Panel.disableResizable();
		}

		resizableOld = r;
	}

	let openedOld = opened;
	let initialWatchedOpened = false;

	function watchOpened(o) {
		if (!initialWatchedOpened) {
			initialWatchedOpened = true;
			return;
		}

		if (f7Panel && o && !openedOld) {
			f7Panel.open();
		} else if (f7Panel && !o && openedOld) {
			f7Panel.close();
		}

		openedOld = o;
	}

	function onOpen(...args) {
		dispatch("panelOpen", [...args]);
		if (typeof $$props.onPanelOpen === "function") $$props.onPanelOpen(...args);
	}

	function onOpened(...args) {
		dispatch("panelOpened", [...args]);
		if (typeof $$props.onPanelOpened === "function") $$props.onPanelOpened(...args);
	}

	function onClose(...args) {
		dispatch("panelClose", [...args]);
		if (typeof $$props.onPanelClose === "function") $$props.onPanelClose(...args);
	}

	function onClosed(...args) {
		dispatch("panelClosed", [...args]);
		if (typeof $$props.onPanelClosed === "function") $$props.onPanelClosed(...args);
	}

	function onBackdropClick(...args) {
		dispatch("panelBackdropClick", [...args]);
		if (typeof $$props.onPanelBackdropClick === "function") $$props.onPanelBackdropClick(...args);
	}

	function onSwipe(...args) {
		dispatch("panelSwipe", [...args]);
		if (typeof $$props.onPanelSwipe === "function") $$props.onPanelSwipe(...args);
	}

	function onSwipeOpen(...args) {
		dispatch("panelSwipeOpen", [...args]);
		if (typeof $$props.onPanelSwipeOpen === "function") $$props.onPanelSwipeOpen(...args);
	}

	function onBreakpoint(...args) {
		dispatch("panelBreakpoint", [...args]);
		if (typeof $$props.onPanelBreakpoint === "function") $$props.onPanelBreakpoint(...args);
	}

	function onCollapsedBreakpoint(...args) {
		dispatch("panelCollapsedBreakpoint", [...args]);
		if (typeof $$props.onPanelCollapsedBreakpoint === "function") $$props.onPanelCollapsedBreakpoint(...args);
	}

	function onResize(...args) {
		dispatch("panelResize", [...args]);
		if (typeof $$props.onPanelResize === "function") $$props.onPanelResize(...args);
	}

	function open(animate) {
		if (!f7Panel) return;
		f7Panel.open(animate);
	}

	function close(animate) {
		if (!f7Panel) return;
		f7Panel.close(animate);
	}

	function toggle(animate) {
		if (!f7Panel) return;
		f7Panel.toggle(animate);
	} // eslint-disable-line

	onMount(() => {
		f7.ready(() => {
			const dom7 = f7.instance.$;

			if (dom7(".panel-backdrop").length === 0) {
				dom7("<div class=\"panel-backdrop\"></div>").insertBefore(el);
			}

			const params = Utils.noUndefinedProps({
				el,
				resizable,
				backdrop,
				backdropEl,
				visibleBreakpoint,
				collapsedBreakpoint,
				swipe,
				swipeNoFollow,
				swipeOnlyClose,
				swipeActiveArea,
				swipeThreshold,
				on: {
					open: onOpen,
					opened: onOpened,
					close: onClose,
					closed: onClosed,
					backdropClick: onBackdropClick,
					swipe: onSwipe,
					swipeOpen: onSwipeOpen,
					collapsedBreakpoint: onCollapsedBreakpoint,
					breakpoint: onBreakpoint,
					resize: onResize
				}
			});

			f7Panel = f7.instance.panel.create(params);

			if (opened) {
				f7Panel.open(false);
			}
		});
	});

	onDestroy(() => {
		if (f7Panel && f7Panel.destroy) {
			f7Panel.destroy();
		}

		f7Panel = null;
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(48, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("side" in $$new_props) $$invalidate(5, side = $$new_props.side);
		if ("effect" in $$new_props) $$invalidate(6, effect = $$new_props.effect);
		if ("cover" in $$new_props) $$invalidate(7, cover = $$new_props.cover);
		if ("reveal" in $$new_props) $$invalidate(8, reveal = $$new_props.reveal);
		if ("left" in $$new_props) $$invalidate(9, left = $$new_props.left);
		if ("right" in $$new_props) $$invalidate(10, right = $$new_props.right);
		if ("opened" in $$new_props) $$invalidate(11, opened = $$new_props.opened);
		if ("resizable" in $$new_props) $$invalidate(0, resizable = $$new_props.resizable);
		if ("backdrop" in $$new_props) $$invalidate(12, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$new_props) $$invalidate(13, backdropEl = $$new_props.backdropEl);
		if ("visibleBreakpoint" in $$new_props) $$invalidate(14, visibleBreakpoint = $$new_props.visibleBreakpoint);
		if ("collapsedBreakpoint" in $$new_props) $$invalidate(15, collapsedBreakpoint = $$new_props.collapsedBreakpoint);
		if ("swipe" in $$new_props) $$invalidate(16, swipe = $$new_props.swipe);
		if ("swipeNoFollow" in $$new_props) $$invalidate(17, swipeNoFollow = $$new_props.swipeNoFollow);
		if ("swipeOnlyClose" in $$new_props) $$invalidate(18, swipeOnlyClose = $$new_props.swipeOnlyClose);
		if ("swipeActiveArea" in $$new_props) $$invalidate(19, swipeActiveArea = $$new_props.swipeActiveArea);
		if ("swipeThreshold" in $$new_props) $$invalidate(20, swipeThreshold = $$new_props.swipeThreshold);
		if ("$$scope" in $$new_props) $$invalidate(27, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		createEventDispatcher,
		Utils,
		restProps,
		Mixins,
		f7,
		dispatch,
		className,
		side,
		effect,
		cover,
		reveal,
		left,
		right,
		opened,
		resizable,
		backdrop,
		backdropEl,
		visibleBreakpoint,
		collapsedBreakpoint,
		swipe,
		swipeNoFollow,
		swipeOnlyClose,
		swipeActiveArea,
		swipeThreshold,
		el,
		f7Panel,
		instance,
		resizableOld,
		initialWatchedResizable,
		watchResizable,
		openedOld,
		initialWatchedOpened,
		watchOpened,
		onOpen,
		onOpened,
		onClose,
		onClosed,
		onBackdropClick,
		onSwipe,
		onSwipeOpen,
		onBreakpoint,
		onCollapsedBreakpoint,
		onResize,
		open,
		close,
		toggle,
		sideComputed,
		effectComputed,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(48, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("side" in $$props) $$invalidate(5, side = $$new_props.side);
		if ("effect" in $$props) $$invalidate(6, effect = $$new_props.effect);
		if ("cover" in $$props) $$invalidate(7, cover = $$new_props.cover);
		if ("reveal" in $$props) $$invalidate(8, reveal = $$new_props.reveal);
		if ("left" in $$props) $$invalidate(9, left = $$new_props.left);
		if ("right" in $$props) $$invalidate(10, right = $$new_props.right);
		if ("opened" in $$props) $$invalidate(11, opened = $$new_props.opened);
		if ("resizable" in $$props) $$invalidate(0, resizable = $$new_props.resizable);
		if ("backdrop" in $$props) $$invalidate(12, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$props) $$invalidate(13, backdropEl = $$new_props.backdropEl);
		if ("visibleBreakpoint" in $$props) $$invalidate(14, visibleBreakpoint = $$new_props.visibleBreakpoint);
		if ("collapsedBreakpoint" in $$props) $$invalidate(15, collapsedBreakpoint = $$new_props.collapsedBreakpoint);
		if ("swipe" in $$props) $$invalidate(16, swipe = $$new_props.swipe);
		if ("swipeNoFollow" in $$props) $$invalidate(17, swipeNoFollow = $$new_props.swipeNoFollow);
		if ("swipeOnlyClose" in $$props) $$invalidate(18, swipeOnlyClose = $$new_props.swipeOnlyClose);
		if ("swipeActiveArea" in $$props) $$invalidate(19, swipeActiveArea = $$new_props.swipeActiveArea);
		if ("swipeThreshold" in $$props) $$invalidate(20, swipeThreshold = $$new_props.swipeThreshold);
		if ("el" in $$props) $$invalidate(1, el = $$new_props.el);
		if ("f7Panel" in $$props) f7Panel = $$new_props.f7Panel;
		if ("resizableOld" in $$props) resizableOld = $$new_props.resizableOld;
		if ("initialWatchedResizable" in $$props) initialWatchedResizable = $$new_props.initialWatchedResizable;
		if ("openedOld" in $$props) openedOld = $$new_props.openedOld;
		if ("initialWatchedOpened" in $$props) initialWatchedOpened = $$new_props.initialWatchedOpened;
		if ("sideComputed" in $$props) $$invalidate(25, sideComputed = $$new_props.sideComputed);
		if ("effectComputed" in $$props) $$invalidate(26, effectComputed = $$new_props.effectComputed);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	let sideComputed;
	let effectComputed;
	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*side, left, right*/ 1568) {
			// eslint-disable-next-line
			 $$invalidate(25, sideComputed = side || (left ? "left" : right ? "right" : "left"));
		}

		if ($$self.$$.dirty[0] & /*effect, reveal, cover*/ 448) {
			// eslint-disable-next-line
			 $$invalidate(26, effectComputed = effect || (reveal ? "reveal" : cover ? "cover" : "cover"));
		}

		 $$invalidate(2, classes = Utils.classNames(
			className,
			"panel",
			{
				"panel-resizable": resizable,
				[`panel-${sideComputed}`]: sideComputed,
				[`panel-${effectComputed}`]: effectComputed
			},
			Mixins.colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*resizable*/ 1) {
			 watchResizable(resizable);
		}

		if ($$self.$$.dirty[0] & /*opened*/ 2048) {
			 watchOpened(opened);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		resizable,
		el,
		classes,
		$$restProps,
		className,
		side,
		effect,
		cover,
		reveal,
		left,
		right,
		opened,
		backdrop,
		backdropEl,
		visibleBreakpoint,
		collapsedBreakpoint,
		swipe,
		swipeNoFollow,
		swipeOnlyClose,
		swipeActiveArea,
		swipeThreshold,
		instance,
		open,
		close,
		toggle,
		sideComputed,
		effectComputed,
		$$scope,
		slots,
		div_binding
	];
}

class Panel extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance_1$8,
			create_fragment$12,
			safe_not_equal,
			{
				class: 4,
				side: 5,
				effect: 6,
				cover: 7,
				reveal: 8,
				left: 9,
				right: 10,
				opened: 11,
				resizable: 0,
				backdrop: 12,
				backdropEl: 13,
				visibleBreakpoint: 14,
				collapsedBreakpoint: 15,
				swipe: 16,
				swipeNoFollow: 17,
				swipeOnlyClose: 18,
				swipeActiveArea: 19,
				swipeThreshold: 20,
				instance: 21,
				open: 22,
				close: 23,
				toggle: 24
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Panel",
			options,
			id: create_fragment$12.name
		});
	}

	get class() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get side() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set side(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get effect() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set effect(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get cover() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set cover(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get reveal() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set reveal(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get left() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set left(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get right() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set right(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get opened() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set opened(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizable() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizable(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdrop() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdrop(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdropEl() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdropEl(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get visibleBreakpoint() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set visibleBreakpoint(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get collapsedBreakpoint() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set collapsedBreakpoint(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipe() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipe(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeNoFollow() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeNoFollow(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeOnlyClose() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeOnlyClose(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeActiveArea() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeActiveArea(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeThreshold() {
		throw new Error("<Panel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeThreshold(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[21];
	}

	set instance(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		return this.$$.ctx[22];
	}

	set open(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get close() {
		return this.$$.ctx[23];
	}

	set close(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		return this.$$.ctx[24];
	}

	set toggle(value) {
		throw new Error("<Panel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/photo-browser.svelte generated by Svelte v3.31.0 */

function create_fragment$13(ctx) {
	const block = {
		c: noop,
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$13.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$9($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Photo_browser", slots, []);
	const dispatch = createEventDispatcher();
	let { init = true } = $$props;
	let { params = undefined } = $$props;
	let { photos = undefined } = $$props;
	let { exposition = true } = $$props;
	let { expositionHideCaptions = false } = $$props;
	let { type = undefined } = $$props;
	let { navbar = true } = $$props;
	let { toolbar = true } = $$props;
	let { theme = undefined } = $$props;
	let { captionsTheme = undefined } = $$props;
	let { iconsColor = undefined } = $$props;
	let { swipeToClose = true } = $$props;
	let { pageBackLinkText = undefined } = $$props;
	let { popupCloseLinkText = undefined } = $$props;
	let { navbarOfText = undefined } = $$props;
	let { navbarShowCount = undefined } = $$props;
	let { swiper = undefined } = $$props;
	let { url = undefined } = $$props;
	let { routableModals = true } = $$props;
	let { virtualSlides = true } = $$props;
	let { view = undefined } = $$props;
	let { renderNavbar = undefined } = $$props;
	let { renderToolbar = undefined } = $$props;
	let { renderCaption = undefined } = $$props;
	let { renderObject = undefined } = $$props;
	let { renderLazyPhoto = undefined } = $$props;
	let { renderPhoto = undefined } = $$props;
	let { renderPage = undefined } = $$props;
	let { renderPopup = undefined } = $$props;
	let { renderStandalone = undefined } = $$props;
	let f7PhotoBrowser;

	function instance() {
		return f7PhotoBrowser;
	}

	function open(index) {
		return f7PhotoBrowser.open(index);
	}

	function close() {
		return f7PhotoBrowser.close();
	}

	function expositionToggle() {
		return f7PhotoBrowser.expositionToggle();
	}

	function expositionEnable() {
		return f7PhotoBrowser.expositionEnable();
	}

	function expositionDisable() {
		return f7PhotoBrowser.expositionDisable();
	}

	let initialWatched = false;

	function watchPhotos(newValue) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7PhotoBrowser) return;
		f7PhotoBrowser.params.photos = newValue;

		if (f7PhotoBrowser.opened && f7PhotoBrowser.swiper) {
			f7PhotoBrowser.swiper.update();
		}
	}

	onMount(() => {
		if (!init) return;

		f7.ready(() => {
			let pbParams;

			if (typeof params !== "undefined") pbParams = params; else {
				pbParams = {
					photos,
					exposition,
					expositionHideCaptions,
					type,
					navbar,
					toolbar,
					theme,
					captionsTheme,
					iconsColor,
					swipeToClose,
					pageBackLinkText,
					popupCloseLinkText,
					navbarOfText,
					navbarShowCount,
					swiper,
					url,
					routableModals,
					virtualSlides,
					view,
					renderNavbar,
					renderToolbar,
					renderCaption,
					renderObject,
					renderLazyPhoto,
					renderPhoto,
					renderPage,
					renderPopup,
					renderStandalone
				};
			}

			Object.keys(pbParams).forEach(param => {
				if (typeof pbParams[param] === "undefined" || pbParams[param] === "") delete pbParams[param];
			});

			pbParams = Utils.extend({}, pbParams, {
				on: {
					open() {
						dispatch("photoBrowserOpen");
						if (typeof $$props.onPhotoBrowserOpen === "function") $$props.onPhotoBrowserOpen();
					},
					close() {
						dispatch("photoBrowserClose");
						if (typeof $$props.onPhotoBrowserClose === "function") $$props.onPhotoBrowserClose();
					},
					opened() {
						dispatch("photoBrowserOpened");
						if (typeof $$props.onPhotoBrowserOpened === "function") $$props.onPhotoBrowserOpened();
					},
					closed() {
						dispatch("photoBrowserClosed");
						if (typeof $$props.onPhotoBrowserClosed === "function") $$props.onPhotoBrowserClosed();
					},
					swipeToClose() {
						dispatch("photoBrowserSwipeToClose");
						if (typeof $$props.onPhotoBrowserSwipeToClose === "function") $$props.onPhotoBrowserSwipeToClose();
					}
				}
			});

			f7PhotoBrowser = f7.instance.photoBrowser.create(pbParams);
		});
	});

	onDestroy(() => {
		if (f7PhotoBrowser && f7PhotoBrowser.destroy) f7PhotoBrowser.destroy();
	});

	$$self.$$set = $$new_props => {
		$$invalidate(40, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("init" in $$new_props) $$invalidate(0, init = $$new_props.init);
		if ("params" in $$new_props) $$invalidate(1, params = $$new_props.params);
		if ("photos" in $$new_props) $$invalidate(2, photos = $$new_props.photos);
		if ("exposition" in $$new_props) $$invalidate(3, exposition = $$new_props.exposition);
		if ("expositionHideCaptions" in $$new_props) $$invalidate(4, expositionHideCaptions = $$new_props.expositionHideCaptions);
		if ("type" in $$new_props) $$invalidate(5, type = $$new_props.type);
		if ("navbar" in $$new_props) $$invalidate(6, navbar = $$new_props.navbar);
		if ("toolbar" in $$new_props) $$invalidate(7, toolbar = $$new_props.toolbar);
		if ("theme" in $$new_props) $$invalidate(8, theme = $$new_props.theme);
		if ("captionsTheme" in $$new_props) $$invalidate(9, captionsTheme = $$new_props.captionsTheme);
		if ("iconsColor" in $$new_props) $$invalidate(10, iconsColor = $$new_props.iconsColor);
		if ("swipeToClose" in $$new_props) $$invalidate(11, swipeToClose = $$new_props.swipeToClose);
		if ("pageBackLinkText" in $$new_props) $$invalidate(12, pageBackLinkText = $$new_props.pageBackLinkText);
		if ("popupCloseLinkText" in $$new_props) $$invalidate(13, popupCloseLinkText = $$new_props.popupCloseLinkText);
		if ("navbarOfText" in $$new_props) $$invalidate(14, navbarOfText = $$new_props.navbarOfText);
		if ("navbarShowCount" in $$new_props) $$invalidate(15, navbarShowCount = $$new_props.navbarShowCount);
		if ("swiper" in $$new_props) $$invalidate(16, swiper = $$new_props.swiper);
		if ("url" in $$new_props) $$invalidate(17, url = $$new_props.url);
		if ("routableModals" in $$new_props) $$invalidate(18, routableModals = $$new_props.routableModals);
		if ("virtualSlides" in $$new_props) $$invalidate(19, virtualSlides = $$new_props.virtualSlides);
		if ("view" in $$new_props) $$invalidate(20, view = $$new_props.view);
		if ("renderNavbar" in $$new_props) $$invalidate(21, renderNavbar = $$new_props.renderNavbar);
		if ("renderToolbar" in $$new_props) $$invalidate(22, renderToolbar = $$new_props.renderToolbar);
		if ("renderCaption" in $$new_props) $$invalidate(23, renderCaption = $$new_props.renderCaption);
		if ("renderObject" in $$new_props) $$invalidate(24, renderObject = $$new_props.renderObject);
		if ("renderLazyPhoto" in $$new_props) $$invalidate(25, renderLazyPhoto = $$new_props.renderLazyPhoto);
		if ("renderPhoto" in $$new_props) $$invalidate(26, renderPhoto = $$new_props.renderPhoto);
		if ("renderPage" in $$new_props) $$invalidate(27, renderPage = $$new_props.renderPage);
		if ("renderPopup" in $$new_props) $$invalidate(28, renderPopup = $$new_props.renderPopup);
		if ("renderStandalone" in $$new_props) $$invalidate(29, renderStandalone = $$new_props.renderStandalone);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Utils,
		f7,
		dispatch,
		init,
		params,
		photos,
		exposition,
		expositionHideCaptions,
		type,
		navbar,
		toolbar,
		theme,
		captionsTheme,
		iconsColor,
		swipeToClose,
		pageBackLinkText,
		popupCloseLinkText,
		navbarOfText,
		navbarShowCount,
		swiper,
		url,
		routableModals,
		virtualSlides,
		view,
		renderNavbar,
		renderToolbar,
		renderCaption,
		renderObject,
		renderLazyPhoto,
		renderPhoto,
		renderPage,
		renderPopup,
		renderStandalone,
		f7PhotoBrowser,
		instance,
		open,
		close,
		expositionToggle,
		expositionEnable,
		expositionDisable,
		initialWatched,
		watchPhotos
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(40, $$props = assign(assign({}, $$props), $$new_props));
		if ("init" in $$props) $$invalidate(0, init = $$new_props.init);
		if ("params" in $$props) $$invalidate(1, params = $$new_props.params);
		if ("photos" in $$props) $$invalidate(2, photos = $$new_props.photos);
		if ("exposition" in $$props) $$invalidate(3, exposition = $$new_props.exposition);
		if ("expositionHideCaptions" in $$props) $$invalidate(4, expositionHideCaptions = $$new_props.expositionHideCaptions);
		if ("type" in $$props) $$invalidate(5, type = $$new_props.type);
		if ("navbar" in $$props) $$invalidate(6, navbar = $$new_props.navbar);
		if ("toolbar" in $$props) $$invalidate(7, toolbar = $$new_props.toolbar);
		if ("theme" in $$props) $$invalidate(8, theme = $$new_props.theme);
		if ("captionsTheme" in $$props) $$invalidate(9, captionsTheme = $$new_props.captionsTheme);
		if ("iconsColor" in $$props) $$invalidate(10, iconsColor = $$new_props.iconsColor);
		if ("swipeToClose" in $$props) $$invalidate(11, swipeToClose = $$new_props.swipeToClose);
		if ("pageBackLinkText" in $$props) $$invalidate(12, pageBackLinkText = $$new_props.pageBackLinkText);
		if ("popupCloseLinkText" in $$props) $$invalidate(13, popupCloseLinkText = $$new_props.popupCloseLinkText);
		if ("navbarOfText" in $$props) $$invalidate(14, navbarOfText = $$new_props.navbarOfText);
		if ("navbarShowCount" in $$props) $$invalidate(15, navbarShowCount = $$new_props.navbarShowCount);
		if ("swiper" in $$props) $$invalidate(16, swiper = $$new_props.swiper);
		if ("url" in $$props) $$invalidate(17, url = $$new_props.url);
		if ("routableModals" in $$props) $$invalidate(18, routableModals = $$new_props.routableModals);
		if ("virtualSlides" in $$props) $$invalidate(19, virtualSlides = $$new_props.virtualSlides);
		if ("view" in $$props) $$invalidate(20, view = $$new_props.view);
		if ("renderNavbar" in $$props) $$invalidate(21, renderNavbar = $$new_props.renderNavbar);
		if ("renderToolbar" in $$props) $$invalidate(22, renderToolbar = $$new_props.renderToolbar);
		if ("renderCaption" in $$props) $$invalidate(23, renderCaption = $$new_props.renderCaption);
		if ("renderObject" in $$props) $$invalidate(24, renderObject = $$new_props.renderObject);
		if ("renderLazyPhoto" in $$props) $$invalidate(25, renderLazyPhoto = $$new_props.renderLazyPhoto);
		if ("renderPhoto" in $$props) $$invalidate(26, renderPhoto = $$new_props.renderPhoto);
		if ("renderPage" in $$props) $$invalidate(27, renderPage = $$new_props.renderPage);
		if ("renderPopup" in $$props) $$invalidate(28, renderPopup = $$new_props.renderPopup);
		if ("renderStandalone" in $$props) $$invalidate(29, renderStandalone = $$new_props.renderStandalone);
		if ("f7PhotoBrowser" in $$props) f7PhotoBrowser = $$new_props.f7PhotoBrowser;
		if ("initialWatched" in $$props) initialWatched = $$new_props.initialWatched;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*photos*/ 4) {
			 watchPhotos(photos);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		init,
		params,
		photos,
		exposition,
		expositionHideCaptions,
		type,
		navbar,
		toolbar,
		theme,
		captionsTheme,
		iconsColor,
		swipeToClose,
		pageBackLinkText,
		popupCloseLinkText,
		navbarOfText,
		navbarShowCount,
		swiper,
		url,
		routableModals,
		virtualSlides,
		view,
		renderNavbar,
		renderToolbar,
		renderCaption,
		renderObject,
		renderLazyPhoto,
		renderPhoto,
		renderPage,
		renderPopup,
		renderStandalone,
		instance,
		open,
		close,
		expositionToggle,
		expositionEnable,
		expositionDisable
	];
}

class Photo_browser extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance_1$9,
			create_fragment$13,
			safe_not_equal,
			{
				init: 0,
				params: 1,
				photos: 2,
				exposition: 3,
				expositionHideCaptions: 4,
				type: 5,
				navbar: 6,
				toolbar: 7,
				theme: 8,
				captionsTheme: 9,
				iconsColor: 10,
				swipeToClose: 11,
				pageBackLinkText: 12,
				popupCloseLinkText: 13,
				navbarOfText: 14,
				navbarShowCount: 15,
				swiper: 16,
				url: 17,
				routableModals: 18,
				virtualSlides: 19,
				view: 20,
				renderNavbar: 21,
				renderToolbar: 22,
				renderCaption: 23,
				renderObject: 24,
				renderLazyPhoto: 25,
				renderPhoto: 26,
				renderPage: 27,
				renderPopup: 28,
				renderStandalone: 29,
				instance: 30,
				open: 31,
				close: 32,
				expositionToggle: 33,
				expositionEnable: 34,
				expositionDisable: 35
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Photo_browser",
			options,
			id: create_fragment$13.name
		});
	}

	get init() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set init(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get params() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set params(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get photos() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set photos(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get exposition() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set exposition(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expositionHideCaptions() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expositionHideCaptions(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get navbar() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set navbar(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toolbar() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toolbar(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theme() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theme(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get captionsTheme() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set captionsTheme(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get iconsColor() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set iconsColor(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeToClose() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeToClose(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pageBackLinkText() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pageBackLinkText(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get popupCloseLinkText() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set popupCloseLinkText(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get navbarOfText() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set navbarOfText(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get navbarShowCount() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set navbarShowCount(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swiper() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swiper(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get url() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set url(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get routableModals() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set routableModals(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get virtualSlides() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set virtualSlides(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get view() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set view(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get renderNavbar() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set renderNavbar(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get renderToolbar() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set renderToolbar(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get renderCaption() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set renderCaption(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get renderObject() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set renderObject(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get renderLazyPhoto() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set renderLazyPhoto(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get renderPhoto() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set renderPhoto(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get renderPage() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set renderPage(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get renderPopup() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set renderPopup(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get renderStandalone() {
		throw new Error("<Photo_browser>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set renderStandalone(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[30];
	}

	set instance(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		return this.$$.ctx[31];
	}

	set open(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get close() {
		return this.$$.ctx[32];
	}

	set close(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expositionToggle() {
		return this.$$.ctx[33];
	}

	set expositionToggle(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expositionEnable() {
		return this.$$.ctx[34];
	}

	set expositionEnable(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expositionDisable() {
		return this.$$.ctx[35];
	}

	set expositionDisable(value) {
		throw new Error("<Photo_browser>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/popover.svelte generated by Svelte v3.31.0 */
const file$13 = "node_modules/framework7-svelte/components/popover.svelte";

function create_fragment$14(ctx) {
	let div2;
	let div0;
	let t;
	let div1;
	let current;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);
	let div2_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t = space();
			div1 = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div0, "class", "popover-angle");
			add_location(div0, file$13, 108, 2, 2939);
			attr_dev(div1, "class", "popover-inner");
			add_location(div1, file$13, 109, 2, 2971);
			set_attributes(div2, div2_data);
			add_location(div2, file$13, 103, 0, 2865);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div2, t);
			append_dev(div2, div1);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			/*div2_binding*/ ctx[16](div2);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16384) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[14], dirty, null, null);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (default_slot) default_slot.d(detaching);
			/*div2_binding*/ ctx[16](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$14.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$a($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","opened","target","backdrop","backdropEl","closeByBackdropClick","closeByOutsideClick","closeOnEscape","instance","open","close"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Popover", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { opened = undefined } = $$props;
	let { target = undefined } = $$props;
	let { backdrop = undefined } = $$props;
	let { backdropEl = undefined } = $$props;
	let { closeByBackdropClick = undefined } = $$props;
	let { closeByOutsideClick = undefined } = $$props;
	let { closeOnEscape = undefined } = $$props;
	let el;
	let f7Popover;

	function instance() {
		return f7Popover;
	}

	function open(anim) {
		if (!f7Popover) return undefined;
		return f7Popover.open(anim);
	}

	function close(anim) {
		if (!f7Popover) return undefined;
		return f7Popover.close(anim);
	}

	function onOpen(instance) {
		dispatch("popoverOpen", [instance]);
		if (typeof $$props.onPopoverOpen === "function") $$props.onPopoverOpen(instance);
	}

	function onOpened(instance) {
		dispatch("popoverOpened", [instance]);
		if (typeof $$props.onPopoverOpened === "function") $$props.onPopoverOpened(instance);
	}

	function onClose(instance) {
		dispatch("popoverClose", [instance]);
		if (typeof $$props.onPopoverClose === "function") $$props.onPopoverClose(instance);
	}

	function onClosed(instance) {
		dispatch("popoverClosed", [instance]);
		if (typeof $$props.onPopoverClosed === "function") $$props.onPopoverClosed(instance);
	}

	let initialWatched = false;

	function watchOpened(openedPassed) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7Popover) return;
		if (openedPassed) f7Popover.open(); else f7Popover.close();
	}

	onMount(() => {
		const params = {
			el,
			on: {
				open: onOpen,
				opened: onOpened,
				close: onClose,
				closed: onClosed
			}
		};

		if (target) params.targetEl = target;
		if (typeof closeByBackdropClick !== "undefined") params.closeByBackdropClick = closeByBackdropClick;
		if (typeof closeByOutsideClick !== "undefined") params.closeByOutsideClick = closeByOutsideClick;
		if (typeof closeOnEscape !== "undefined") params.closeOnEscape = closeOnEscape;
		if (typeof backdrop !== "undefined") params.backdrop = backdrop;
		if (typeof backdropEl !== "undefined") params.backdropEl = backdropEl;

		f7.ready(() => {
			f7Popover = f7.instance.popover.create(params);

			if (opened) {
				f7Popover.open(false);
			}
		});
	});

	onDestroy(() => {
		if (f7Popover) f7Popover.destroy();
		f7Popover = undefined;
	});

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(25, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("opened" in $$new_props) $$invalidate(4, opened = $$new_props.opened);
		if ("target" in $$new_props) $$invalidate(5, target = $$new_props.target);
		if ("backdrop" in $$new_props) $$invalidate(6, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$new_props) $$invalidate(7, backdropEl = $$new_props.backdropEl);
		if ("closeByBackdropClick" in $$new_props) $$invalidate(8, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ("closeByOutsideClick" in $$new_props) $$invalidate(9, closeByOutsideClick = $$new_props.closeByOutsideClick);
		if ("closeOnEscape" in $$new_props) $$invalidate(10, closeOnEscape = $$new_props.closeOnEscape);
		if ("$$scope" in $$new_props) $$invalidate(14, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		opened,
		target,
		backdrop,
		backdropEl,
		closeByBackdropClick,
		closeByOutsideClick,
		closeOnEscape,
		el,
		f7Popover,
		instance,
		open,
		close,
		onOpen,
		onOpened,
		onClose,
		onClosed,
		initialWatched,
		watchOpened,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(25, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("opened" in $$props) $$invalidate(4, opened = $$new_props.opened);
		if ("target" in $$props) $$invalidate(5, target = $$new_props.target);
		if ("backdrop" in $$props) $$invalidate(6, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$props) $$invalidate(7, backdropEl = $$new_props.backdropEl);
		if ("closeByBackdropClick" in $$props) $$invalidate(8, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ("closeByOutsideClick" in $$props) $$invalidate(9, closeByOutsideClick = $$new_props.closeByOutsideClick);
		if ("closeOnEscape" in $$props) $$invalidate(10, closeOnEscape = $$new_props.closeOnEscape);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("f7Popover" in $$props) f7Popover = $$new_props.f7Popover;
		if ("initialWatched" in $$props) initialWatched = $$new_props.initialWatched;
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classes = Utils.classNames(className, "popover", Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*opened*/ 16) {
			 watchOpened(opened);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		classes,
		$$restProps,
		className,
		opened,
		target,
		backdrop,
		backdropEl,
		closeByBackdropClick,
		closeByOutsideClick,
		closeOnEscape,
		instance,
		open,
		close,
		$$scope,
		slots,
		div2_binding
	];
}

class Popover extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance_1$a, create_fragment$14, safe_not_equal, {
			class: 3,
			opened: 4,
			target: 5,
			backdrop: 6,
			backdropEl: 7,
			closeByBackdropClick: 8,
			closeByOutsideClick: 9,
			closeOnEscape: 10,
			instance: 11,
			open: 12,
			close: 13
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Popover",
			options,
			id: create_fragment$14.name
		});
	}

	get class() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get opened() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set opened(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get target() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set target(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdrop() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdrop(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdropEl() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdropEl(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeByBackdropClick() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeByBackdropClick(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeByOutsideClick() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeByOutsideClick(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeOnEscape() {
		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeOnEscape(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[11];
	}

	set instance(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		return this.$$.ctx[12];
	}

	set open(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get close() {
		return this.$$.ctx[13];
	}

	set close(value) {
		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/popup.svelte generated by Svelte v3.31.0 */
const file$14 = "node_modules/framework7-svelte/components/popup.svelte";

function create_fragment$15(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);
	let div_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$14, 130, 0, 3964);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[19](div);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 131072) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[17], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty[0] & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty[0] & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[19](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$15.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$b($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","tabletFullscreen","opened","animate","backdrop","backdropEl","closeByBackdropClick","closeOnEscape","swipeToClose","swipeHandler","push","instance","open","close"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Popup", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { tabletFullscreen = undefined } = $$props;
	let { opened = undefined } = $$props;
	let { animate = undefined } = $$props;
	let { backdrop = undefined } = $$props;
	let { backdropEl = undefined } = $$props;
	let { closeByBackdropClick = undefined } = $$props;
	let { closeOnEscape = undefined } = $$props;
	let { swipeToClose = false } = $$props;
	let { swipeHandler = undefined } = $$props;
	let { push = undefined } = $$props;
	let el;
	let f7Popup;

	function instance() {
		return f7Popup;
	}

	function open(anim) {
		if (!f7Popup) return undefined;
		return f7Popup.open(anim);
	}

	function close(anim) {
		if (!f7Popup) return undefined;
		return f7Popup.close(anim);
	}

	function onSwipeStart(instance) {
		dispatch("popupSwipeStart", [instance]);
		if (typeof $$props.onPopupSwipeStart === "function") $$props.onPopupSwipeStart(instance);
	}

	function onSwipeMove(instance) {
		dispatch("popupSwipeMove", [instance]);
		if (typeof $$props.onPopupSwipeMove === "function") $$props.onPopupSwipeMove(instance);
	}

	function onSwipeEnd(instance) {
		dispatch("popupSwipeEnd", [instance]);
		if (typeof $$props.onPopupSwipeEnd === "function") $$props.onPopupSwipeEnd(instance);
	}

	function onSwipeClose(instance) {
		dispatch("popupSwipeClose", [instance]);
		if (typeof $$props.onPopupSwipeClose === "function") $$props.onPopupSwipeClose(instance);
	}

	function onOpen(instance) {
		dispatch("popupOpen", [instance]);
		if (typeof $$props.onPopupOpen === "function") $$props.onPopupOpen(instance);
	}

	function onOpened(instance) {
		dispatch("popupOpened", [instance]);
		if (typeof $$props.onPopupOpened === "function") $$props.onPopupOpened(instance);
	}

	function onClose(instance) {
		dispatch("popupClose", [instance]);
		if (typeof $$props.onPopupClose === "function") $$props.onPopupClose(instance);
	}

	function onClosed(instance) {
		dispatch("popupClosed", [instance]);
		if (typeof $$props.onPopupClosed === "function") $$props.onPopupClosed(instance);
	}

	let initialWatched = false;

	function watchOpened(openedPassed) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7Popup) return;
		if (openedPassed) f7Popup.open(); else f7Popup.close();
	}

	onMount(() => {
		const popupParams = {
			el,
			on: {
				swipeStart: onSwipeStart,
				swipeMove: onSwipeMove,
				swipeEnd: onSwipeEnd,
				swipeClose: onSwipeClose,
				open: onOpen,
				opened: onOpened,
				close: onClose,
				closed: onClosed
			}
		};

		if (typeof closeByBackdropClick !== "undefined") popupParams.closeByBackdropClick = closeByBackdropClick;
		if (typeof closeOnEscape !== "undefined") popupParams.closeOnEscape = closeOnEscape;
		if (typeof animate !== "undefined") popupParams.animate = animate;
		if (typeof backdrop !== "undefined") popupParams.backdrop = backdrop;
		if (typeof backdropEl !== "undefined") popupParams.backdropEl = backdropEl;
		if (typeof swipeToClose !== "undefined") popupParams.swipeToClose = swipeToClose;
		if (typeof swipeHandler !== "undefined") popupParams.swipeHandler = swipeHandler;

		f7.ready(() => {
			f7Popup = f7.instance.popup.create(popupParams);

			if (opened) {
				f7Popup.open(false);
			}
		});
	});

	onDestroy(() => {
		if (f7Popup) f7Popup.destroy();
		f7Popup = undefined;
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("tabletFullscreen" in $$new_props) $$invalidate(4, tabletFullscreen = $$new_props.tabletFullscreen);
		if ("opened" in $$new_props) $$invalidate(5, opened = $$new_props.opened);
		if ("animate" in $$new_props) $$invalidate(6, animate = $$new_props.animate);
		if ("backdrop" in $$new_props) $$invalidate(7, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$new_props) $$invalidate(8, backdropEl = $$new_props.backdropEl);
		if ("closeByBackdropClick" in $$new_props) $$invalidate(9, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ("closeOnEscape" in $$new_props) $$invalidate(10, closeOnEscape = $$new_props.closeOnEscape);
		if ("swipeToClose" in $$new_props) $$invalidate(11, swipeToClose = $$new_props.swipeToClose);
		if ("swipeHandler" in $$new_props) $$invalidate(12, swipeHandler = $$new_props.swipeHandler);
		if ("push" in $$new_props) $$invalidate(13, push = $$new_props.push);
		if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		tabletFullscreen,
		opened,
		animate,
		backdrop,
		backdropEl,
		closeByBackdropClick,
		closeOnEscape,
		swipeToClose,
		swipeHandler,
		push,
		el,
		f7Popup,
		instance,
		open,
		close,
		onSwipeStart,
		onSwipeMove,
		onSwipeEnd,
		onSwipeClose,
		onOpen,
		onOpened,
		onClose,
		onClosed,
		initialWatched,
		watchOpened,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("tabletFullscreen" in $$props) $$invalidate(4, tabletFullscreen = $$new_props.tabletFullscreen);
		if ("opened" in $$props) $$invalidate(5, opened = $$new_props.opened);
		if ("animate" in $$props) $$invalidate(6, animate = $$new_props.animate);
		if ("backdrop" in $$props) $$invalidate(7, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$props) $$invalidate(8, backdropEl = $$new_props.backdropEl);
		if ("closeByBackdropClick" in $$props) $$invalidate(9, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ("closeOnEscape" in $$props) $$invalidate(10, closeOnEscape = $$new_props.closeOnEscape);
		if ("swipeToClose" in $$props) $$invalidate(11, swipeToClose = $$new_props.swipeToClose);
		if ("swipeHandler" in $$props) $$invalidate(12, swipeHandler = $$new_props.swipeHandler);
		if ("push" in $$props) $$invalidate(13, push = $$new_props.push);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("f7Popup" in $$props) f7Popup = $$new_props.f7Popup;
		if ("initialWatched" in $$props) initialWatched = $$new_props.initialWatched;
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classes = Utils.classNames(
			className,
			"popup",
			{
				"popup-tablet-fullscreen": tabletFullscreen,
				"popup-push": push
			},
			Mixins.colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*opened*/ 32) {
			 watchOpened(opened);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		classes,
		$$restProps,
		className,
		tabletFullscreen,
		opened,
		animate,
		backdrop,
		backdropEl,
		closeByBackdropClick,
		closeOnEscape,
		swipeToClose,
		swipeHandler,
		push,
		instance,
		open,
		close,
		$$scope,
		slots,
		div_binding
	];
}

class Popup extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance_1$b,
			create_fragment$15,
			safe_not_equal,
			{
				class: 3,
				tabletFullscreen: 4,
				opened: 5,
				animate: 6,
				backdrop: 7,
				backdropEl: 8,
				closeByBackdropClick: 9,
				closeOnEscape: 10,
				swipeToClose: 11,
				swipeHandler: 12,
				push: 13,
				instance: 14,
				open: 15,
				close: 16
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Popup",
			options,
			id: create_fragment$15.name
		});
	}

	get class() {
		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabletFullscreen() {
		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabletFullscreen(value) {
		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get opened() {
		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set opened(value) {
		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get animate() {
		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set animate(value) {
		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdrop() {
		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdrop(value) {
		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdropEl() {
		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdropEl(value) {
		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeByBackdropClick() {
		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeByBackdropClick(value) {
		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeOnEscape() {
		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeOnEscape(value) {
		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeToClose() {
		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeToClose(value) {
		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeHandler() {
		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeHandler(value) {
		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get push() {
		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set push(value) {
		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[14];
	}

	set instance(value) {
		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		return this.$$.ctx[15];
	}

	set open(value) {
		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get close() {
		return this.$$.ctx[16];
	}

	set close(value) {
		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/progressbar.svelte generated by Svelte v3.31.0 */
const file$15 = "node_modules/framework7-svelte/components/progressbar.svelte";

function create_fragment$16(ctx) {
	let span1;
	let span0;

	let span1_levels = [
		{ class: /*classes*/ ctx[2] },
		{ "data-progress": /*progress*/ ctx[0] },
		restProps(/*$$restProps*/ ctx[4])
	];

	let span1_data = {};

	for (let i = 0; i < span1_levels.length; i += 1) {
		span1_data = assign(span1_data, span1_levels[i]);
	}

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			attr_dev(span0, "style", /*transformStyle*/ ctx[3]);
			add_location(span0, file$15, 40, 2, 884);
			set_attributes(span1, span1_data);
			add_location(span1, file$15, 34, 0, 782);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, span1, anchor);
			append_dev(span1, span0);
			/*span1_binding*/ ctx[8](span1);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*transformStyle*/ 8) {
				attr_dev(span0, "style", /*transformStyle*/ ctx[3]);
			}

			set_attributes(span1, span1_data = get_spread_update(span1_levels, [
				dirty & /*classes*/ 4 && { class: /*classes*/ ctx[2] },
				dirty & /*progress*/ 1 && { "data-progress": /*progress*/ ctx[0] },
				dirty & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
			/*span1_binding*/ ctx[8](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$16.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$W($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","progress","infinite","set"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Progressbar", slots, []);
	let { class: className = undefined } = $$props;
	let { progress = 0 } = $$props;
	let { infinite = false } = $$props;
	let el;

	function set(progress, speed) {
		if (!f7.instance) return;
		f7.instance.progressbar.set(el, progress, speed);
	}

	function span1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(1, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ("progress" in $$new_props) $$invalidate(0, progress = $$new_props.progress);
		if ("infinite" in $$new_props) $$invalidate(6, infinite = $$new_props.infinite);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		f7,
		className,
		progress,
		infinite,
		el,
		set,
		classes,
		transformStyle
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(5, className = $$new_props.className);
		if ("progress" in $$props) $$invalidate(0, progress = $$new_props.progress);
		if ("infinite" in $$props) $$invalidate(6, infinite = $$new_props.infinite);
		if ("el" in $$props) $$invalidate(1, el = $$new_props.el);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
		if ("transformStyle" in $$props) $$invalidate(3, transformStyle = $$new_props.transformStyle);
	};

	let classes;
	let transformStyle;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(2, classes = Utils.classNames(className, "progressbar", { "progressbar-infinite": infinite }, Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*progress*/ 1) {
			 $$invalidate(3, transformStyle = {
				transform: progress ? `translate3d(${-100 + progress}%, 0, 0)` : "",
				WebkitTransform: progress ? `translate3d(${-100 + progress}%, 0, 0)` : ""
			});
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		progress,
		el,
		classes,
		transformStyle,
		$$restProps,
		className,
		infinite,
		set,
		span1_binding
	];
}

class Progressbar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$W, create_fragment$16, safe_not_equal, {
			class: 5,
			progress: 0,
			infinite: 6,
			set: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Progressbar",
			options,
			id: create_fragment$16.name
		});
	}

	get class() {
		throw new Error("<Progressbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Progressbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get progress() {
		throw new Error("<Progressbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set progress(value) {
		throw new Error("<Progressbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get infinite() {
		throw new Error("<Progressbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set infinite(value) {
		throw new Error("<Progressbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get set() {
		return this.$$.ctx[7];
	}

	set set(value) {
		throw new Error("<Progressbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/radio.svelte generated by Svelte v3.31.0 */
const file$16 = "node_modules/framework7-svelte/components/radio.svelte";

function create_fragment$17(ctx) {
	let label;
	let input;
	let input_value_value;
	let t0;
	let i;
	let t1;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);
	let label_levels = [{ class: /*classes*/ ctx[6] }, restProps(/*$$restProps*/ ctx[8])];
	let label_data = {};

	for (let i = 0; i < label_levels.length; i += 1) {
		label_data = assign(label_data, label_levels[i]);
	}

	const block = {
		c: function create() {
			label = element("label");
			input = element("input");
			t0 = space();
			i = element("i");
			t1 = space();
			if (default_slot) default_slot.c();
			attr_dev(input, "type", "radio");
			attr_dev(input, "name", /*name*/ ctx[1]);

			input.value = input_value_value = typeof /*value*/ ctx[2] === "undefined"
			? ""
			: /*value*/ ctx[2];

			input.disabled = /*disabled*/ ctx[3];
			input.readOnly = /*readonly*/ ctx[4];
			input.checked = /*checked*/ ctx[0];
			add_location(input, file$16, 35, 2, 811);
			attr_dev(i, "class", "icon-radio");
			add_location(i, file$16, 45, 2, 1031);
			set_attributes(label, label_data);
			add_location(label, file$16, 34, 0, 757);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, label, anchor);
			append_dev(label, input);
			/*input_binding*/ ctx[12](input);
			append_dev(label, t0);
			append_dev(label, i);
			append_dev(label, t1);

			if (default_slot) {
				default_slot.m(label, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(input, "change", /*onChange*/ ctx[7], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*name*/ 2) {
				attr_dev(input, "name", /*name*/ ctx[1]);
			}

			if (!current || dirty & /*value*/ 4 && input_value_value !== (input_value_value = typeof /*value*/ ctx[2] === "undefined"
			? ""
			: /*value*/ ctx[2])) {
				prop_dev(input, "value", input_value_value);
			}

			if (!current || dirty & /*disabled*/ 8) {
				prop_dev(input, "disabled", /*disabled*/ ctx[3]);
			}

			if (!current || dirty & /*readonly*/ 16) {
				prop_dev(input, "readOnly", /*readonly*/ ctx[4]);
			}

			if (!current || dirty & /*checked*/ 1) {
				prop_dev(input, "checked", /*checked*/ ctx[0]);
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1024) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, null, null);
				}
			}

			set_attributes(label, label_data = get_spread_update(label_levels, [
				(!current || dirty & /*classes*/ 64) && { class: /*classes*/ ctx[6] },
				dirty & /*$$restProps*/ 256 && restProps(/*$$restProps*/ ctx[8])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(label);
			/*input_binding*/ ctx[12](null);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$17.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$X($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","checked","name","value","disabled","readonly"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Radio", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { checked = undefined } = $$props;
	let { name = undefined } = $$props;
	let { value = undefined } = $$props;
	let { disabled = undefined } = $$props;
	let { readonly = undefined } = $$props;
	let inputEl;

	function onChange(event) {
		dispatch("change", [event]);
		if (typeof $$props.onChange === "function") $$props.onChange(event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			inputEl = $$value;
			$$invalidate(5, inputEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(9, className = $$new_props.class);
		if ("checked" in $$new_props) $$invalidate(0, checked = $$new_props.checked);
		if ("name" in $$new_props) $$invalidate(1, name = $$new_props.name);
		if ("value" in $$new_props) $$invalidate(2, value = $$new_props.value);
		if ("disabled" in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
		if ("readonly" in $$new_props) $$invalidate(4, readonly = $$new_props.readonly);
		if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		Mixins,
		Utils,
		restProps,
		dispatch,
		className,
		checked,
		name,
		value,
		disabled,
		readonly,
		inputEl,
		onChange,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(14, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(9, className = $$new_props.className);
		if ("checked" in $$props) $$invalidate(0, checked = $$new_props.checked);
		if ("name" in $$props) $$invalidate(1, name = $$new_props.name);
		if ("value" in $$props) $$invalidate(2, value = $$new_props.value);
		if ("disabled" in $$props) $$invalidate(3, disabled = $$new_props.disabled);
		if ("readonly" in $$props) $$invalidate(4, readonly = $$new_props.readonly);
		if ("inputEl" in $$props) $$invalidate(5, inputEl = $$new_props.inputEl);
		if ("classes" in $$props) $$invalidate(6, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(6, classes = Utils.classNames(className, "radio", { disabled }, Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);

	return [
		checked,
		name,
		value,
		disabled,
		readonly,
		inputEl,
		classes,
		onChange,
		$$restProps,
		className,
		$$scope,
		slots,
		input_binding
	];
}

class Radio extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$X, create_fragment$17, safe_not_equal, {
			class: 9,
			checked: 0,
			name: 1,
			value: 2,
			disabled: 3,
			readonly: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Radio",
			options,
			id: create_fragment$17.name
		});
	}

	get class() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get checked() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set checked(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get readonly() {
		throw new Error("<Radio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set readonly(value) {
		throw new Error("<Radio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/row.svelte generated by Svelte v3.31.0 */
const file$17 = "node_modules/framework7-svelte/components/row.svelte";

// (66:22) 
function create_if_block_2$f(ctx) {
	let p;
	let t;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	let if_block = /*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2] && create_if_block_3$c(ctx);
	let p_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[6])];
	let p_data = {};

	for (let i = 0; i < p_levels.length; i += 1) {
		p_data = assign(p_data, p_levels[i]);
	}

	const block = {
		c: function create() {
			p = element("p");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			set_attributes(p, p_data);
			add_location(p, file$17, 66, 2, 1563);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);

			if (default_slot) {
				default_slot.m(p, null);
			}

			append_dev(p, t);
			if (if_block) if_block.m(p, null);
			/*p_binding*/ ctx[14](p);
			current = true;

			if (!mounted) {
				dispose = listen_dev(p, "click", /*onClick*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			if (/*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2]) {
				if (if_block) ; else {
					if_block = create_if_block_3$c(ctx);
					if_block.c();
					if_block.m(p, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_attributes(p, p_data = get_spread_update(p_levels, [
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*p_binding*/ ctx[14](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$f.name,
		type: "if",
		source: "(66:22) ",
		ctx
	});

	return block;
}

// (54:0) {#if tag === 'div'}
function create_if_block$r(ctx) {
	let div;
	let t;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	let if_block = /*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2] && create_if_block_1$h(ctx);
	let div_levels = [{ class: /*classes*/ ctx[4] }, restProps(/*$$restProps*/ ctx[6])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			set_attributes(div, div_data);
			add_location(div, file$17, 54, 2, 1320);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_dev(div, t);
			if (if_block) if_block.m(div, null);
			/*div_binding*/ ctx[13](div);
			current = true;

			if (!mounted) {
				dispose = listen_dev(div, "click", /*onClick*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			if (/*resizable*/ ctx[1] && /*resizableHandler*/ ctx[2]) {
				if (if_block) ; else {
					if_block = create_if_block_1$h(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
			/*div_binding*/ ctx[13](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$r.name,
		type: "if",
		source: "(54:0) {#if tag === 'div'}",
		ctx
	});

	return block;
}

// (74:4) {#if resizable && resizableHandler}
function create_if_block_3$c(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "resize-handler");
			add_location(span, file$17, 74, 6, 1723);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$c.name,
		type: "if",
		source: "(74:4) {#if resizable && resizableHandler}",
		ctx
	});

	return block;
}

// (62:4) {#if resizable && resizableHandler}
function create_if_block_1$h(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "resize-handler");
			add_location(span, file$17, 62, 6, 1482);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$h.name,
		type: "if",
		source: "(62:4) {#if resizable && resizableHandler}",
		ctx
	});

	return block;
}

function create_fragment$18(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$r, create_if_block_2$f];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[0] === "div") return 0;
		if (/*tag*/ ctx[0] === "p") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$18.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Y($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","noGap","tag","resizable","resizableFixed","resizableAbsolute","resizableHandler"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Row", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { noGap = false } = $$props;
	let { tag = "div" } = $$props;
	let { resizable = false } = $$props;
	let { resizableFixed = false } = $$props;
	let { resizableAbsolute = false } = $$props;
	let { resizableHandler = true } = $$props;
	let el;

	function onClick() {
		dispatch("click");
		if (typeof $$props.onClick === "function") $$props.onClick();
	}

	function onResize(targetEl) {
		if (el !== targetEl) return;
		dispatch("gridResize");
		if (typeof $$props.onGridResize === "function") $$props.onGridResize();
	}

	onMount(() => {
		f7.ready(() => {
			f7.instance.on("gridResize", onResize);
		});
	});

	onDestroy(() => {
		if (!f7.instance) return;
		f7.instance.off("gridResize", onResize);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	function p_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(3, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(17, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(7, className = $$new_props.class);
		if ("noGap" in $$new_props) $$invalidate(8, noGap = $$new_props.noGap);
		if ("tag" in $$new_props) $$invalidate(0, tag = $$new_props.tag);
		if ("resizable" in $$new_props) $$invalidate(1, resizable = $$new_props.resizable);
		if ("resizableFixed" in $$new_props) $$invalidate(9, resizableFixed = $$new_props.resizableFixed);
		if ("resizableAbsolute" in $$new_props) $$invalidate(10, resizableAbsolute = $$new_props.resizableAbsolute);
		if ("resizableHandler" in $$new_props) $$invalidate(2, resizableHandler = $$new_props.resizableHandler);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		noGap,
		tag,
		resizable,
		resizableFixed,
		resizableAbsolute,
		resizableHandler,
		el,
		onClick,
		onResize,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(17, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(7, className = $$new_props.className);
		if ("noGap" in $$props) $$invalidate(8, noGap = $$new_props.noGap);
		if ("tag" in $$props) $$invalidate(0, tag = $$new_props.tag);
		if ("resizable" in $$props) $$invalidate(1, resizable = $$new_props.resizable);
		if ("resizableFixed" in $$props) $$invalidate(9, resizableFixed = $$new_props.resizableFixed);
		if ("resizableAbsolute" in $$props) $$invalidate(10, resizableAbsolute = $$new_props.resizableAbsolute);
		if ("resizableHandler" in $$props) $$invalidate(2, resizableHandler = $$new_props.resizableHandler);
		if ("el" in $$props) $$invalidate(3, el = $$new_props.el);
		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(4, classes = Utils.classNames(
			className,
			"row",
			{
				"no-gap": noGap,
				resizable,
				"resizable-fixed": resizableFixed,
				"resizable-absolute": resizableAbsolute
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		tag,
		resizable,
		resizableHandler,
		el,
		classes,
		onClick,
		$$restProps,
		className,
		noGap,
		resizableFixed,
		resizableAbsolute,
		$$scope,
		slots,
		div_binding,
		p_binding
	];
}

class Row extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$Y, create_fragment$18, safe_not_equal, {
			class: 7,
			noGap: 8,
			tag: 0,
			resizable: 1,
			resizableFixed: 9,
			resizableAbsolute: 10,
			resizableHandler: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Row",
			options,
			id: create_fragment$18.name
		});
	}

	get class() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noGap() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noGap(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tag() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tag(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizable() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizable(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizableFixed() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizableFixed(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizableAbsolute() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizableAbsolute(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get resizableHandler() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set resizableHandler(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/searchbar.svelte generated by Svelte v3.31.0 */
const file$18 = "node_modules/framework7-svelte/components/searchbar.svelte";
const get_after_inner_slot_changes_1$1 = dirty => ({});
const get_after_inner_slot_context_1$1 = ctx => ({});
const get_inner_end_slot_changes_1$2 = dirty => ({});
const get_inner_end_slot_context_1$2 = ctx => ({});
const get_input_wrap_end_slot_changes_1 = dirty => ({});
const get_input_wrap_end_slot_context_1 = ctx => ({});
const get_input_wrap_start_slot_changes_1 = dirty => ({});
const get_input_wrap_start_slot_context_1 = ctx => ({});
const get_inner_start_slot_changes_1$2 = dirty => ({});
const get_inner_start_slot_context_1$2 = ctx => ({});
const get_before_inner_slot_changes_1 = dirty => ({});
const get_before_inner_slot_context_1 = ctx => ({});
const get_after_inner_slot_changes$3 = dirty => ({});
const get_after_inner_slot_context$3 = ctx => ({});
const get_inner_end_slot_changes$3 = dirty => ({});
const get_inner_end_slot_context$3 = ctx => ({});
const get_input_wrap_end_slot_changes = dirty => ({});
const get_input_wrap_end_slot_context = ctx => ({});
const get_input_wrap_start_slot_changes = dirty => ({});
const get_input_wrap_start_slot_context = ctx => ({});
const get_inner_start_slot_changes$3 = dirty => ({});
const get_inner_start_slot_context$3 = ctx => ({});
const get_before_inner_slot_changes$3 = dirty => ({});
const get_before_inner_slot_context$3 = ctx => ({});

// (210:0) {:else}
function create_else_block$a(ctx) {
	let div2;
	let t0;
	let div1;
	let t1;
	let div0;
	let t2;
	let input;
	let input_value_value;
	let t3;
	let i;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let t9;
	let current;
	let mounted;
	let dispose;
	const before_inner_slot_template = /*#slots*/ ctx[48]["before-inner"];
	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[47], get_before_inner_slot_context_1);
	const inner_start_slot_template = /*#slots*/ ctx[48]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[47], get_inner_start_slot_context_1$2);
	const input_wrap_start_slot_template = /*#slots*/ ctx[48]["input-wrap-start"];
	const input_wrap_start_slot = create_slot(input_wrap_start_slot_template, ctx, /*$$scope*/ ctx[47], get_input_wrap_start_slot_context_1);
	let if_block0 = /*clearButton*/ ctx[5] && create_if_block_4$7(ctx);
	const input_wrap_end_slot_template = /*#slots*/ ctx[48]["input-wrap-end"];
	const input_wrap_end_slot = create_slot(input_wrap_end_slot_template, ctx, /*$$scope*/ ctx[47], get_input_wrap_end_slot_context_1);
	let if_block1 = /*disableButton*/ ctx[3] && create_if_block_3$d(ctx);
	const inner_end_slot_template = /*#slots*/ ctx[48]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[47], get_inner_end_slot_context_1$2);
	const default_slot_template = /*#slots*/ ctx[48].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[47], null);
	const after_inner_slot_template = /*#slots*/ ctx[48]["after-inner"];
	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[47], get_after_inner_slot_context_1$1);

	let div2_levels = [
		{ class: /*classes*/ ctx[9] },
		{ "data-f7-slot": /*f7Slot*/ ctx[7] },
		restProps(/*$$restProps*/ ctx[17])
	];

	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			if (before_inner_slot) before_inner_slot.c();
			t0 = space();
			div1 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t1 = space();
			div0 = element("div");
			if (input_wrap_start_slot) input_wrap_start_slot.c();
			t2 = space();
			input = element("input");
			t3 = space();
			i = element("i");
			t4 = space();
			if (if_block0) if_block0.c();
			t5 = space();
			if (input_wrap_end_slot) input_wrap_end_slot.c();
			t6 = space();
			if (if_block1) if_block1.c();
			t7 = space();
			if (inner_end_slot) inner_end_slot.c();
			t8 = space();
			if (default_slot) default_slot.c();
			t9 = space();
			if (after_inner_slot) after_inner_slot.c();

			input.value = input_value_value = typeof /*value*/ ctx[6] === "undefined"
			? ""
			: /*value*/ ctx[6];

			attr_dev(input, "placeholder", /*placeholder*/ ctx[1]);
			attr_dev(input, "spellcheck", /*spellcheck*/ ctx[2]);
			attr_dev(input, "type", "search");
			add_location(input, file$18, 216, 8, 6433);
			attr_dev(i, "class", "searchbar-icon");
			add_location(i, file$18, 226, 8, 6729);
			attr_dev(div0, "class", "searchbar-input-wrap");
			add_location(div0, file$18, 214, 6, 6349);
			attr_dev(div1, "class", "searchbar-inner");
			add_location(div1, file$18, 212, 4, 6279);
			set_attributes(div2, div2_data);
			add_location(div2, file$18, 210, 2, 6155);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);

			if (before_inner_slot) {
				before_inner_slot.m(div2, null);
			}

			append_dev(div2, t0);
			append_dev(div2, div1);

			if (inner_start_slot) {
				inner_start_slot.m(div1, null);
			}

			append_dev(div1, t1);
			append_dev(div1, div0);

			if (input_wrap_start_slot) {
				input_wrap_start_slot.m(div0, null);
			}

			append_dev(div0, t2);
			append_dev(div0, input);
			append_dev(div0, t3);
			append_dev(div0, i);
			append_dev(div0, t4);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div0, t5);

			if (input_wrap_end_slot) {
				input_wrap_end_slot.m(div0, null);
			}

			append_dev(div1, t6);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t7);

			if (inner_end_slot) {
				inner_end_slot.m(div1, null);
			}

			append_dev(div1, t8);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_dev(div2, t9);

			if (after_inner_slot) {
				after_inner_slot.m(div2, null);
			}

			/*div2_binding*/ ctx[50](div2);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*onInput*/ ctx[11], false, false, false),
					listen_dev(input, "change", /*onChange*/ ctx[10], false, false, false),
					listen_dev(input, "focus", /*onFocus*/ ctx[12], false, false, false),
					listen_dev(input, "blur", /*onBlur*/ ctx[13], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (before_inner_slot) {
				if (before_inner_slot.p && dirty[1] & /*$$scope*/ 65536) {
					update_slot(before_inner_slot, before_inner_slot_template, ctx, /*$$scope*/ ctx[47], dirty, get_before_inner_slot_changes_1, get_before_inner_slot_context_1);
				}
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[1] & /*$$scope*/ 65536) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[47], dirty, get_inner_start_slot_changes_1$2, get_inner_start_slot_context_1$2);
				}
			}

			if (input_wrap_start_slot) {
				if (input_wrap_start_slot.p && dirty[1] & /*$$scope*/ 65536) {
					update_slot(input_wrap_start_slot, input_wrap_start_slot_template, ctx, /*$$scope*/ ctx[47], dirty, get_input_wrap_start_slot_changes_1, get_input_wrap_start_slot_context_1);
				}
			}

			if (!current || dirty[0] & /*value*/ 64 && input_value_value !== (input_value_value = typeof /*value*/ ctx[6] === "undefined"
			? ""
			: /*value*/ ctx[6])) {
				prop_dev(input, "value", input_value_value);
			}

			if (!current || dirty[0] & /*placeholder*/ 2) {
				attr_dev(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (!current || dirty[0] & /*spellcheck*/ 4) {
				attr_dev(input, "spellcheck", /*spellcheck*/ ctx[2]);
			}

			if (/*clearButton*/ ctx[5]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4$7(ctx);
					if_block0.c();
					if_block0.m(div0, t5);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (input_wrap_end_slot) {
				if (input_wrap_end_slot.p && dirty[1] & /*$$scope*/ 65536) {
					update_slot(input_wrap_end_slot, input_wrap_end_slot_template, ctx, /*$$scope*/ ctx[47], dirty, get_input_wrap_end_slot_changes_1, get_input_wrap_end_slot_context_1);
				}
			}

			if (/*disableButton*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_3$d(ctx);
					if_block1.c();
					if_block1.m(div1, t7);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[1] & /*$$scope*/ 65536) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[47], dirty, get_inner_end_slot_changes_1$2, get_inner_end_slot_context_1$2);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[47], dirty, null, null);
				}
			}

			if (after_inner_slot) {
				if (after_inner_slot.p && dirty[1] & /*$$scope*/ 65536) {
					update_slot(after_inner_slot, after_inner_slot_template, ctx, /*$$scope*/ ctx[47], dirty, get_after_inner_slot_changes_1$1, get_after_inner_slot_context_1$1);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty[0] & /*classes*/ 512) && { class: /*classes*/ ctx[9] },
				(!current || dirty[0] & /*f7Slot*/ 128) && { "data-f7-slot": /*f7Slot*/ ctx[7] },
				dirty[0] & /*$$restProps*/ 131072 && restProps(/*$$restProps*/ ctx[17])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_inner_slot, local);
			transition_in(inner_start_slot, local);
			transition_in(input_wrap_start_slot, local);
			transition_in(input_wrap_end_slot, local);
			transition_in(inner_end_slot, local);
			transition_in(default_slot, local);
			transition_in(after_inner_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_inner_slot, local);
			transition_out(inner_start_slot, local);
			transition_out(input_wrap_start_slot, local);
			transition_out(input_wrap_end_slot, local);
			transition_out(inner_end_slot, local);
			transition_out(default_slot, local);
			transition_out(after_inner_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (before_inner_slot) before_inner_slot.d(detaching);
			if (inner_start_slot) inner_start_slot.d(detaching);
			if (input_wrap_start_slot) input_wrap_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (input_wrap_end_slot) input_wrap_end_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (after_inner_slot) after_inner_slot.d(detaching);
			/*div2_binding*/ ctx[50](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$a.name,
		type: "else",
		source: "(210:0) {:else}",
		ctx
	});

	return block;
}

// (179:0) {#if form}
function create_if_block$s(ctx) {
	let form_1;
	let t0;
	let div1;
	let t1;
	let div0;
	let t2;
	let input;
	let input_value_value;
	let t3;
	let i;
	let t4;
	let t5;
	let t6;
	let t7;
	let t8;
	let t9;
	let current;
	let mounted;
	let dispose;
	const before_inner_slot_template = /*#slots*/ ctx[48]["before-inner"];
	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[47], get_before_inner_slot_context$3);
	const inner_start_slot_template = /*#slots*/ ctx[48]["inner-start"];
	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[47], get_inner_start_slot_context$3);
	const input_wrap_start_slot_template = /*#slots*/ ctx[48]["input-wrap-start"];
	const input_wrap_start_slot = create_slot(input_wrap_start_slot_template, ctx, /*$$scope*/ ctx[47], get_input_wrap_start_slot_context);
	let if_block0 = /*clearButton*/ ctx[5] && create_if_block_2$g(ctx);
	const input_wrap_end_slot_template = /*#slots*/ ctx[48]["input-wrap-end"];
	const input_wrap_end_slot = create_slot(input_wrap_end_slot_template, ctx, /*$$scope*/ ctx[47], get_input_wrap_end_slot_context);
	let if_block1 = /*disableButton*/ ctx[3] && create_if_block_1$i(ctx);
	const inner_end_slot_template = /*#slots*/ ctx[48]["inner-end"];
	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[47], get_inner_end_slot_context$3);
	const default_slot_template = /*#slots*/ ctx[48].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[47], null);
	const after_inner_slot_template = /*#slots*/ ctx[48]["after-inner"];
	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[47], get_after_inner_slot_context$3);

	let form_1_levels = [
		{ class: /*classes*/ ctx[9] },
		{ "data-f7-slot": /*f7Slot*/ ctx[7] },
		restProps(/*$$restProps*/ ctx[17])
	];

	let form_1_data = {};

	for (let i = 0; i < form_1_levels.length; i += 1) {
		form_1_data = assign(form_1_data, form_1_levels[i]);
	}

	const block = {
		c: function create() {
			form_1 = element("form");
			if (before_inner_slot) before_inner_slot.c();
			t0 = space();
			div1 = element("div");
			if (inner_start_slot) inner_start_slot.c();
			t1 = space();
			div0 = element("div");
			if (input_wrap_start_slot) input_wrap_start_slot.c();
			t2 = space();
			input = element("input");
			t3 = space();
			i = element("i");
			t4 = space();
			if (if_block0) if_block0.c();
			t5 = space();
			if (input_wrap_end_slot) input_wrap_end_slot.c();
			t6 = space();
			if (if_block1) if_block1.c();
			t7 = space();
			if (inner_end_slot) inner_end_slot.c();
			t8 = space();
			if (default_slot) default_slot.c();
			t9 = space();
			if (after_inner_slot) after_inner_slot.c();

			input.value = input_value_value = typeof /*value*/ ctx[6] === "undefined"
			? ""
			: /*value*/ ctx[6];

			attr_dev(input, "placeholder", /*placeholder*/ ctx[1]);
			attr_dev(input, "spellcheck", /*spellcheck*/ ctx[2]);
			attr_dev(input, "type", "search");
			add_location(input, file$18, 185, 8, 5408);
			attr_dev(i, "class", "searchbar-icon");
			add_location(i, file$18, 195, 8, 5704);
			attr_dev(div0, "class", "searchbar-input-wrap");
			add_location(div0, file$18, 183, 6, 5324);
			attr_dev(div1, "class", "searchbar-inner");
			add_location(div1, file$18, 181, 4, 5254);
			set_attributes(form_1, form_1_data);
			add_location(form_1, file$18, 179, 2, 5108);
		},
		m: function mount(target, anchor) {
			insert_dev(target, form_1, anchor);

			if (before_inner_slot) {
				before_inner_slot.m(form_1, null);
			}

			append_dev(form_1, t0);
			append_dev(form_1, div1);

			if (inner_start_slot) {
				inner_start_slot.m(div1, null);
			}

			append_dev(div1, t1);
			append_dev(div1, div0);

			if (input_wrap_start_slot) {
				input_wrap_start_slot.m(div0, null);
			}

			append_dev(div0, t2);
			append_dev(div0, input);
			append_dev(div0, t3);
			append_dev(div0, i);
			append_dev(div0, t4);
			if (if_block0) if_block0.m(div0, null);
			append_dev(div0, t5);

			if (input_wrap_end_slot) {
				input_wrap_end_slot.m(div0, null);
			}

			append_dev(div1, t6);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t7);

			if (inner_end_slot) {
				inner_end_slot.m(div1, null);
			}

			append_dev(div1, t8);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_dev(form_1, t9);

			if (after_inner_slot) {
				after_inner_slot.m(form_1, null);
			}

			/*form_1_binding*/ ctx[49](form_1);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*onInput*/ ctx[11], false, false, false),
					listen_dev(input, "change", /*onChange*/ ctx[10], false, false, false),
					listen_dev(input, "focus", /*onFocus*/ ctx[12], false, false, false),
					listen_dev(input, "blur", /*onBlur*/ ctx[13], false, false, false),
					listen_dev(form_1, "submit", /*onSubmit*/ ctx[14], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (before_inner_slot) {
				if (before_inner_slot.p && dirty[1] & /*$$scope*/ 65536) {
					update_slot(before_inner_slot, before_inner_slot_template, ctx, /*$$scope*/ ctx[47], dirty, get_before_inner_slot_changes$3, get_before_inner_slot_context$3);
				}
			}

			if (inner_start_slot) {
				if (inner_start_slot.p && dirty[1] & /*$$scope*/ 65536) {
					update_slot(inner_start_slot, inner_start_slot_template, ctx, /*$$scope*/ ctx[47], dirty, get_inner_start_slot_changes$3, get_inner_start_slot_context$3);
				}
			}

			if (input_wrap_start_slot) {
				if (input_wrap_start_slot.p && dirty[1] & /*$$scope*/ 65536) {
					update_slot(input_wrap_start_slot, input_wrap_start_slot_template, ctx, /*$$scope*/ ctx[47], dirty, get_input_wrap_start_slot_changes, get_input_wrap_start_slot_context);
				}
			}

			if (!current || dirty[0] & /*value*/ 64 && input_value_value !== (input_value_value = typeof /*value*/ ctx[6] === "undefined"
			? ""
			: /*value*/ ctx[6])) {
				prop_dev(input, "value", input_value_value);
			}

			if (!current || dirty[0] & /*placeholder*/ 2) {
				attr_dev(input, "placeholder", /*placeholder*/ ctx[1]);
			}

			if (!current || dirty[0] & /*spellcheck*/ 4) {
				attr_dev(input, "spellcheck", /*spellcheck*/ ctx[2]);
			}

			if (/*clearButton*/ ctx[5]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$g(ctx);
					if_block0.c();
					if_block0.m(div0, t5);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (input_wrap_end_slot) {
				if (input_wrap_end_slot.p && dirty[1] & /*$$scope*/ 65536) {
					update_slot(input_wrap_end_slot, input_wrap_end_slot_template, ctx, /*$$scope*/ ctx[47], dirty, get_input_wrap_end_slot_changes, get_input_wrap_end_slot_context);
				}
			}

			if (/*disableButton*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1$i(ctx);
					if_block1.c();
					if_block1.m(div1, t7);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (inner_end_slot) {
				if (inner_end_slot.p && dirty[1] & /*$$scope*/ 65536) {
					update_slot(inner_end_slot, inner_end_slot_template, ctx, /*$$scope*/ ctx[47], dirty, get_inner_end_slot_changes$3, get_inner_end_slot_context$3);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[1] & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[47], dirty, null, null);
				}
			}

			if (after_inner_slot) {
				if (after_inner_slot.p && dirty[1] & /*$$scope*/ 65536) {
					update_slot(after_inner_slot, after_inner_slot_template, ctx, /*$$scope*/ ctx[47], dirty, get_after_inner_slot_changes$3, get_after_inner_slot_context$3);
				}
			}

			set_attributes(form_1, form_1_data = get_spread_update(form_1_levels, [
				(!current || dirty[0] & /*classes*/ 512) && { class: /*classes*/ ctx[9] },
				(!current || dirty[0] & /*f7Slot*/ 128) && { "data-f7-slot": /*f7Slot*/ ctx[7] },
				dirty[0] & /*$$restProps*/ 131072 && restProps(/*$$restProps*/ ctx[17])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_inner_slot, local);
			transition_in(inner_start_slot, local);
			transition_in(input_wrap_start_slot, local);
			transition_in(input_wrap_end_slot, local);
			transition_in(inner_end_slot, local);
			transition_in(default_slot, local);
			transition_in(after_inner_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_inner_slot, local);
			transition_out(inner_start_slot, local);
			transition_out(input_wrap_start_slot, local);
			transition_out(input_wrap_end_slot, local);
			transition_out(inner_end_slot, local);
			transition_out(default_slot, local);
			transition_out(after_inner_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form_1);
			if (before_inner_slot) before_inner_slot.d(detaching);
			if (inner_start_slot) inner_start_slot.d(detaching);
			if (input_wrap_start_slot) input_wrap_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (input_wrap_end_slot) input_wrap_end_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (inner_end_slot) inner_end_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (after_inner_slot) after_inner_slot.d(detaching);
			/*form_1_binding*/ ctx[49](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$s.name,
		type: "if",
		source: "(179:0) {#if form}",
		ctx
	});

	return block;
}

// (228:8) {#if clearButton}
function create_if_block_4$7(ctx) {
	let span;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "input-clear-button");
			add_location(span, file$18, 228, 10, 6794);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (!mounted) {
				dispose = listen_dev(span, "click", /*onClearButtonClick*/ ctx[15], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$7.name,
		type: "if",
		source: "(228:8) {#if clearButton}",
		ctx
	});

	return block;
}

// (233:6) {#if disableButton}
function create_if_block_3$d(ctx) {
	let span;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*disableButtonText*/ ctx[4]);
			attr_dev(span, "class", "searchbar-disable-button");
			add_location(span, file$18, 233, 8, 6960);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);

			if (!mounted) {
				dispose = listen_dev(span, "click", /*onDisableButtonClick*/ ctx[16], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*disableButtonText*/ 16) set_data_dev(t, /*disableButtonText*/ ctx[4]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$d.name,
		type: "if",
		source: "(233:6) {#if disableButton}",
		ctx
	});

	return block;
}

// (197:8) {#if clearButton}
function create_if_block_2$g(ctx) {
	let span;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "input-clear-button");
			add_location(span, file$18, 197, 10, 5769);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (!mounted) {
				dispose = listen_dev(span, "click", /*onClearButtonClick*/ ctx[15], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$g.name,
		type: "if",
		source: "(197:8) {#if clearButton}",
		ctx
	});

	return block;
}

// (202:6) {#if disableButton}
function create_if_block_1$i(ctx) {
	let span;
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*disableButtonText*/ ctx[4]);
			attr_dev(span, "class", "searchbar-disable-button");
			add_location(span, file$18, 202, 8, 5935);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			append_dev(span, t);

			if (!mounted) {
				dispose = listen_dev(span, "click", /*onDisableButtonClick*/ ctx[16], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*disableButtonText*/ 16) set_data_dev(t, /*disableButtonText*/ ctx[4]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$i.name,
		type: "if",
		source: "(202:6) {#if disableButton}",
		ctx
	});

	return block;
}

function create_fragment$19(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$s, create_else_block$a];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*form*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$19.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$c($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","noShadow","noHairline","form","placeholder","spellcheck","disableButton","disableButtonText","clearButton","value","inputEvents","expandable","inline","searchContainer","searchIn","searchItem","searchGroup","searchGroupTitle","foundEl","notFoundEl","backdrop","backdropEl","hideOnEnableEl","hideOnSearchEl","ignore","customSearch","removeDiacritics","hideDividers","hideGroups","init","f7Slot","instance","search","enable","disable","toggle","clear"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;

	validate_slots("Searchbar", slots, [
		'before-inner','inner-start','input-wrap-start','input-wrap-end','inner-end','default','after-inner'
	]);

	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { noShadow = false } = $$props;
	let { noHairline = false } = $$props;
	let { form = true } = $$props;
	let { placeholder = "Search" } = $$props;
	let { spellcheck = undefined } = $$props;
	let { disableButton = true } = $$props;
	let { disableButtonText = "Cancel" } = $$props;
	let { clearButton = true } = $$props;
	let { value = undefined } = $$props;
	let { inputEvents = "change input compositionend" } = $$props;
	let { expandable = false } = $$props;
	let { inline = false } = $$props;
	let { searchContainer = undefined } = $$props;
	let { searchIn = ".item-title" } = $$props;
	let { searchItem = "li" } = $$props;
	let { searchGroup = ".list-group" } = $$props;
	let { searchGroupTitle = ".item-divider, .list-group-title" } = $$props;
	let { foundEl = ".searchbar-found" } = $$props;
	let { notFoundEl = ".searchbar-not-found" } = $$props;
	let { backdrop = undefined } = $$props;
	let { backdropEl = undefined } = $$props;
	let { hideOnEnableEl = ".searchbar-hide-on-enable" } = $$props;
	let { hideOnSearchEl = ".searchbar-hide-on-search" } = $$props;
	let { ignore = ".searchbar-ignore" } = $$props;
	let { customSearch = false } = $$props;
	let { removeDiacritics = false } = $$props;
	let { hideDividers = true } = $$props;
	let { hideGroups = true } = $$props;
	let { init = true } = $$props;
	let { f7Slot = "fixed" } = $$props;
	let el;
	let f7Searchbar;

	function instance() {
		return f7Searchbar;
	}

	function search(query) {
		if (!f7Searchbar) return undefined;
		return f7Searchbar.search(query);
	}

	function enable() {
		if (!f7Searchbar) return undefined;
		return f7Searchbar.enable();
	}

	function disable() {
		if (!f7Searchbar) return undefined;
		return f7Searchbar.disable();
	}

	function toggle() {
		if (!f7Searchbar) return undefined;
		return f7Searchbar.toggle();
	}

	function clear() {
		if (!f7Searchbar) return undefined;
		return f7Searchbar.clear();
	}

	function onChange(event) {
		dispatch("change", [event]);
		if (typeof $$props.onChange === "function") $$props.onChange(event);
	}

	function onInput(event) {
		dispatch("input", [event]);
		if (typeof $$props.onInput === "function") $$props.onInput(event);
	}

	function onFocus(event) {
		dispatch("focus", [event]);
		if (typeof $$props.onFocus === "function") $$props.onFocus(event);
	}

	function onBlur(event) {
		dispatch("blur", [event]);
		if (typeof $$props.onBlur === "function") $$props.onBlur(event);
	}

	function onSubmit(event) {
		dispatch("submit", [event]);
		if (typeof $$props.onSubmit === "function") $$props.onSubmit(event);
	}

	function onClearButtonClick(event) {
		dispatch("click:clear", [event]);
	}

	function onDisableButtonClick(event) {
		dispatch("click:disable", [event]);
	}

	onMount(() => {
		if (!init) return;

		f7.ready(() => {
			const params = Utils.noUndefinedProps({
				el,
				inputEvents,
				searchContainer,
				searchIn,
				searchItem,
				searchGroup,
				searchGroupTitle,
				hideOnEnableEl,
				hideOnSearchEl,
				foundEl,
				notFoundEl,
				backdrop,
				backdropEl,
				disableButton,
				ignore,
				customSearch,
				removeDiacritics,
				hideDividers,
				hideGroups,
				expandable,
				inline,
				on: {
					search(searchbar, query, previousQuery) {
						dispatch("searchbarSearch", [searchbar, query, previousQuery]);
						if (typeof $$props.onSearchbarSearch === "function") $$props.onSearchbarSearch(searchbar, query, previousQuery);
					},
					clear(searchbar, previousQuery) {
						dispatch("searchbarClear", [searchbar, previousQuery]);
						if (typeof $$props.onSearchbarClear === "function") $$props.onSearchbarClear(searchbar, previousQuery);
					},
					enable(searchbar) {
						dispatch("searchbarEnable", [searchbar]);
						if (typeof $$props.onSearchbarEnable === "function") $$props.onSearchbarEnable(searchbar);
					},
					disable(searchbar) {
						dispatch("searchbarDisable", [searchbar]);
						if (typeof $$props.onSearchbarDisable === "function") $$props.onSearchbarDisable(searchbar);
					}
				}
			});

			Object.keys(params).forEach(key => {
				if (params[key] === "") {
					delete params[key];
				}
			});

			f7Searchbar = f7.instance.searchbar.create(params);
		});
	});

	onDestroy(() => {
		if (f7Searchbar && f7Searchbar.destroy) {
			f7Searchbar.destroy();
		}
	});

	function form_1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(8, el);
		});
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(8, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(53, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(17, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(18, className = $$new_props.class);
		if ("noShadow" in $$new_props) $$invalidate(19, noShadow = $$new_props.noShadow);
		if ("noHairline" in $$new_props) $$invalidate(20, noHairline = $$new_props.noHairline);
		if ("form" in $$new_props) $$invalidate(0, form = $$new_props.form);
		if ("placeholder" in $$new_props) $$invalidate(1, placeholder = $$new_props.placeholder);
		if ("spellcheck" in $$new_props) $$invalidate(2, spellcheck = $$new_props.spellcheck);
		if ("disableButton" in $$new_props) $$invalidate(3, disableButton = $$new_props.disableButton);
		if ("disableButtonText" in $$new_props) $$invalidate(4, disableButtonText = $$new_props.disableButtonText);
		if ("clearButton" in $$new_props) $$invalidate(5, clearButton = $$new_props.clearButton);
		if ("value" in $$new_props) $$invalidate(6, value = $$new_props.value);
		if ("inputEvents" in $$new_props) $$invalidate(21, inputEvents = $$new_props.inputEvents);
		if ("expandable" in $$new_props) $$invalidate(22, expandable = $$new_props.expandable);
		if ("inline" in $$new_props) $$invalidate(23, inline = $$new_props.inline);
		if ("searchContainer" in $$new_props) $$invalidate(24, searchContainer = $$new_props.searchContainer);
		if ("searchIn" in $$new_props) $$invalidate(25, searchIn = $$new_props.searchIn);
		if ("searchItem" in $$new_props) $$invalidate(26, searchItem = $$new_props.searchItem);
		if ("searchGroup" in $$new_props) $$invalidate(27, searchGroup = $$new_props.searchGroup);
		if ("searchGroupTitle" in $$new_props) $$invalidate(28, searchGroupTitle = $$new_props.searchGroupTitle);
		if ("foundEl" in $$new_props) $$invalidate(29, foundEl = $$new_props.foundEl);
		if ("notFoundEl" in $$new_props) $$invalidate(30, notFoundEl = $$new_props.notFoundEl);
		if ("backdrop" in $$new_props) $$invalidate(31, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$new_props) $$invalidate(32, backdropEl = $$new_props.backdropEl);
		if ("hideOnEnableEl" in $$new_props) $$invalidate(33, hideOnEnableEl = $$new_props.hideOnEnableEl);
		if ("hideOnSearchEl" in $$new_props) $$invalidate(34, hideOnSearchEl = $$new_props.hideOnSearchEl);
		if ("ignore" in $$new_props) $$invalidate(35, ignore = $$new_props.ignore);
		if ("customSearch" in $$new_props) $$invalidate(36, customSearch = $$new_props.customSearch);
		if ("removeDiacritics" in $$new_props) $$invalidate(37, removeDiacritics = $$new_props.removeDiacritics);
		if ("hideDividers" in $$new_props) $$invalidate(38, hideDividers = $$new_props.hideDividers);
		if ("hideGroups" in $$new_props) $$invalidate(39, hideGroups = $$new_props.hideGroups);
		if ("init" in $$new_props) $$invalidate(40, init = $$new_props.init);
		if ("f7Slot" in $$new_props) $$invalidate(7, f7Slot = $$new_props.f7Slot);
		if ("$$scope" in $$new_props) $$invalidate(47, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		noShadow,
		noHairline,
		form,
		placeholder,
		spellcheck,
		disableButton,
		disableButtonText,
		clearButton,
		value,
		inputEvents,
		expandable,
		inline,
		searchContainer,
		searchIn,
		searchItem,
		searchGroup,
		searchGroupTitle,
		foundEl,
		notFoundEl,
		backdrop,
		backdropEl,
		hideOnEnableEl,
		hideOnSearchEl,
		ignore,
		customSearch,
		removeDiacritics,
		hideDividers,
		hideGroups,
		init,
		f7Slot,
		el,
		f7Searchbar,
		instance,
		search,
		enable,
		disable,
		toggle,
		clear,
		onChange,
		onInput,
		onFocus,
		onBlur,
		onSubmit,
		onClearButtonClick,
		onDisableButtonClick,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(53, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(18, className = $$new_props.className);
		if ("noShadow" in $$props) $$invalidate(19, noShadow = $$new_props.noShadow);
		if ("noHairline" in $$props) $$invalidate(20, noHairline = $$new_props.noHairline);
		if ("form" in $$props) $$invalidate(0, form = $$new_props.form);
		if ("placeholder" in $$props) $$invalidate(1, placeholder = $$new_props.placeholder);
		if ("spellcheck" in $$props) $$invalidate(2, spellcheck = $$new_props.spellcheck);
		if ("disableButton" in $$props) $$invalidate(3, disableButton = $$new_props.disableButton);
		if ("disableButtonText" in $$props) $$invalidate(4, disableButtonText = $$new_props.disableButtonText);
		if ("clearButton" in $$props) $$invalidate(5, clearButton = $$new_props.clearButton);
		if ("value" in $$props) $$invalidate(6, value = $$new_props.value);
		if ("inputEvents" in $$props) $$invalidate(21, inputEvents = $$new_props.inputEvents);
		if ("expandable" in $$props) $$invalidate(22, expandable = $$new_props.expandable);
		if ("inline" in $$props) $$invalidate(23, inline = $$new_props.inline);
		if ("searchContainer" in $$props) $$invalidate(24, searchContainer = $$new_props.searchContainer);
		if ("searchIn" in $$props) $$invalidate(25, searchIn = $$new_props.searchIn);
		if ("searchItem" in $$props) $$invalidate(26, searchItem = $$new_props.searchItem);
		if ("searchGroup" in $$props) $$invalidate(27, searchGroup = $$new_props.searchGroup);
		if ("searchGroupTitle" in $$props) $$invalidate(28, searchGroupTitle = $$new_props.searchGroupTitle);
		if ("foundEl" in $$props) $$invalidate(29, foundEl = $$new_props.foundEl);
		if ("notFoundEl" in $$props) $$invalidate(30, notFoundEl = $$new_props.notFoundEl);
		if ("backdrop" in $$props) $$invalidate(31, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$props) $$invalidate(32, backdropEl = $$new_props.backdropEl);
		if ("hideOnEnableEl" in $$props) $$invalidate(33, hideOnEnableEl = $$new_props.hideOnEnableEl);
		if ("hideOnSearchEl" in $$props) $$invalidate(34, hideOnSearchEl = $$new_props.hideOnSearchEl);
		if ("ignore" in $$props) $$invalidate(35, ignore = $$new_props.ignore);
		if ("customSearch" in $$props) $$invalidate(36, customSearch = $$new_props.customSearch);
		if ("removeDiacritics" in $$props) $$invalidate(37, removeDiacritics = $$new_props.removeDiacritics);
		if ("hideDividers" in $$props) $$invalidate(38, hideDividers = $$new_props.hideDividers);
		if ("hideGroups" in $$props) $$invalidate(39, hideGroups = $$new_props.hideGroups);
		if ("init" in $$props) $$invalidate(40, init = $$new_props.init);
		if ("f7Slot" in $$props) $$invalidate(7, f7Slot = $$new_props.f7Slot);
		if ("el" in $$props) $$invalidate(8, el = $$new_props.el);
		if ("f7Searchbar" in $$props) f7Searchbar = $$new_props.f7Searchbar;
		if ("classes" in $$props) $$invalidate(9, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(9, classes = Utils.classNames(
			className,
			"searchbar",
			{
				"searchbar-inline": inline,
				"no-shadow": noShadow,
				"no-hairline": noHairline,
				"searchbar-expandable": expandable
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		form,
		placeholder,
		spellcheck,
		disableButton,
		disableButtonText,
		clearButton,
		value,
		f7Slot,
		el,
		classes,
		onChange,
		onInput,
		onFocus,
		onBlur,
		onSubmit,
		onClearButtonClick,
		onDisableButtonClick,
		$$restProps,
		className,
		noShadow,
		noHairline,
		inputEvents,
		expandable,
		inline,
		searchContainer,
		searchIn,
		searchItem,
		searchGroup,
		searchGroupTitle,
		foundEl,
		notFoundEl,
		backdrop,
		backdropEl,
		hideOnEnableEl,
		hideOnSearchEl,
		ignore,
		customSearch,
		removeDiacritics,
		hideDividers,
		hideGroups,
		init,
		instance,
		search,
		enable,
		disable,
		toggle,
		clear,
		$$scope,
		slots,
		form_1_binding,
		div2_binding
	];
}

class Searchbar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance_1$c,
			create_fragment$19,
			safe_not_equal,
			{
				class: 18,
				noShadow: 19,
				noHairline: 20,
				form: 0,
				placeholder: 1,
				spellcheck: 2,
				disableButton: 3,
				disableButtonText: 4,
				clearButton: 5,
				value: 6,
				inputEvents: 21,
				expandable: 22,
				inline: 23,
				searchContainer: 24,
				searchIn: 25,
				searchItem: 26,
				searchGroup: 27,
				searchGroupTitle: 28,
				foundEl: 29,
				notFoundEl: 30,
				backdrop: 31,
				backdropEl: 32,
				hideOnEnableEl: 33,
				hideOnSearchEl: 34,
				ignore: 35,
				customSearch: 36,
				removeDiacritics: 37,
				hideDividers: 38,
				hideGroups: 39,
				init: 40,
				f7Slot: 7,
				instance: 41,
				search: 42,
				enable: 43,
				disable: 44,
				toggle: 45,
				clear: 46
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Searchbar",
			options,
			id: create_fragment$19.name
		});
	}

	get class() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noShadow() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noShadow(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairline() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairline(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get form() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set form(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get spellcheck() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set spellcheck(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disableButton() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disableButton(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disableButtonText() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disableButtonText(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clearButton() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set clearButton(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputEvents() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputEvents(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expandable() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expandable(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inline() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inline(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchContainer() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchContainer(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchIn() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchIn(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchItem() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchItem(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchGroup() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchGroup(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get searchGroupTitle() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set searchGroupTitle(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get foundEl() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set foundEl(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get notFoundEl() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set notFoundEl(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdrop() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdrop(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdropEl() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdropEl(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideOnEnableEl() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideOnEnableEl(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideOnSearchEl() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideOnSearchEl(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ignore() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ignore(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get customSearch() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set customSearch(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get removeDiacritics() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set removeDiacritics(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideDividers() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideDividers(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hideGroups() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hideGroups(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get init() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set init(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get f7Slot() {
		throw new Error("<Searchbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set f7Slot(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[41];
	}

	set instance(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get search() {
		return this.$$.ctx[42];
	}

	set search(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get enable() {
		return this.$$.ctx[43];
	}

	set enable(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disable() {
		return this.$$.ctx[44];
	}

	set disable(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		return this.$$.ctx[45];
	}

	set toggle(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get clear() {
		return this.$$.ctx[46];
	}

	set clear(value) {
		throw new Error("<Searchbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/segmented.svelte generated by Svelte v3.31.0 */
const file$19 = "node_modules/framework7-svelte/components/segmented.svelte";

// (53:22) 
function create_if_block_2$h(ctx) {
	let p;
	let t;
	let current;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
	let if_block = (/*strong*/ ctx[0] || /*strongIos*/ ctx[1] || /*strongMd*/ ctx[2] || /*strongAurora*/ ctx[3]) && create_if_block_3$e(ctx);
	let p_levels = [{ class: /*classes*/ ctx[5] }, restProps(/*$$restProps*/ ctx[6])];
	let p_data = {};

	for (let i = 0; i < p_levels.length; i += 1) {
		p_data = assign(p_data, p_levels[i]);
	}

	const block = {
		c: function create() {
			p = element("p");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			set_attributes(p, p_data);
			add_location(p, file$19, 53, 2, 1449);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);

			if (default_slot) {
				default_slot.m(p, null);
			}

			append_dev(p, t);
			if (if_block) if_block.m(p, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}

			if (/*strong*/ ctx[0] || /*strongIos*/ ctx[1] || /*strongMd*/ ctx[2] || /*strongAurora*/ ctx[3]) {
				if (if_block) ; else {
					if_block = create_if_block_3$e(ctx);
					if_block.c();
					if_block.m(p, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_attributes(p, p_data = get_spread_update(p_levels, [
				(!current || dirty & /*classes*/ 32) && { class: /*classes*/ ctx[5] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$h.name,
		type: "if",
		source: "(53:22) ",
		ctx
	});

	return block;
}

// (43:0) {#if tag === 'div'}
function create_if_block$t(ctx) {
	let div;
	let t;
	let current;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
	let if_block = (/*strong*/ ctx[0] || /*strongIos*/ ctx[1] || /*strongMd*/ ctx[2] || /*strongAurora*/ ctx[3]) && create_if_block_1$j(ctx);
	let div_levels = [{ class: /*classes*/ ctx[5] }, restProps(/*$$restProps*/ ctx[6])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();
			if (if_block) if_block.c();
			set_attributes(div, div_data);
			add_location(div, file$19, 43, 2, 1232);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_dev(div, t);
			if (if_block) if_block.m(div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}

			if (/*strong*/ ctx[0] || /*strongIos*/ ctx[1] || /*strongMd*/ ctx[2] || /*strongAurora*/ ctx[3]) {
				if (if_block) ; else {
					if_block = create_if_block_1$j(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 32) && { class: /*classes*/ ctx[5] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$t.name,
		type: "if",
		source: "(43:0) {#if tag === 'div'}",
		ctx
	});

	return block;
}

// (59:4) {#if strong || strongIos || strongMd || strongAurora}
function create_if_block_3$e(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "segmented-highlight");
			add_location(span, file$19, 59, 4, 1583);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$e.name,
		type: "if",
		source: "(59:4) {#if strong || strongIos || strongMd || strongAurora}",
		ctx
	});

	return block;
}

// (49:4) {#if strong || strongIos || strongMd || strongAurora}
function create_if_block_1$j(ctx) {
	let span;

	const block = {
		c: function create() {
			span = element("span");
			attr_dev(span, "class", "segmented-highlight");
			add_location(span, file$19, 49, 4, 1368);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$j.name,
		type: "if",
		source: "(49:4) {#if strong || strongIos || strongMd || strongAurora}",
		ctx
	});

	return block;
}

function create_fragment$1a(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$t, create_if_block_2$h];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[4] === "div") return 0;
		if (/*tag*/ ctx[4] === "p") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Z($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","raised","raisedIos","raisedMd","raisedAurora","round","roundIos","roundMd","roundAurora","strong","strongIos","strongMd","strongAurora","tag"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Segmented", slots, ['default']);
	let { class: className = undefined } = $$props;
	let { raised = false } = $$props;
	let { raisedIos = false } = $$props;
	let { raisedMd = false } = $$props;
	let { raisedAurora = false } = $$props;
	let { round = false } = $$props;
	let { roundIos = false } = $$props;
	let { roundMd = false } = $$props;
	let { roundAurora = false } = $$props;
	let { strong = false } = $$props;
	let { strongIos = false } = $$props;
	let { strongMd = false } = $$props;
	let { strongAurora = false } = $$props;
	let { tag = "div" } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(7, className = $$new_props.class);
		if ("raised" in $$new_props) $$invalidate(8, raised = $$new_props.raised);
		if ("raisedIos" in $$new_props) $$invalidate(9, raisedIos = $$new_props.raisedIos);
		if ("raisedMd" in $$new_props) $$invalidate(10, raisedMd = $$new_props.raisedMd);
		if ("raisedAurora" in $$new_props) $$invalidate(11, raisedAurora = $$new_props.raisedAurora);
		if ("round" in $$new_props) $$invalidate(12, round = $$new_props.round);
		if ("roundIos" in $$new_props) $$invalidate(13, roundIos = $$new_props.roundIos);
		if ("roundMd" in $$new_props) $$invalidate(14, roundMd = $$new_props.roundMd);
		if ("roundAurora" in $$new_props) $$invalidate(15, roundAurora = $$new_props.roundAurora);
		if ("strong" in $$new_props) $$invalidate(0, strong = $$new_props.strong);
		if ("strongIos" in $$new_props) $$invalidate(1, strongIos = $$new_props.strongIos);
		if ("strongMd" in $$new_props) $$invalidate(2, strongMd = $$new_props.strongMd);
		if ("strongAurora" in $$new_props) $$invalidate(3, strongAurora = $$new_props.strongAurora);
		if ("tag" in $$new_props) $$invalidate(4, tag = $$new_props.tag);
		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		raised,
		raisedIos,
		raisedMd,
		raisedAurora,
		round,
		roundIos,
		roundMd,
		roundAurora,
		strong,
		strongIos,
		strongMd,
		strongAurora,
		tag,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(7, className = $$new_props.className);
		if ("raised" in $$props) $$invalidate(8, raised = $$new_props.raised);
		if ("raisedIos" in $$props) $$invalidate(9, raisedIos = $$new_props.raisedIos);
		if ("raisedMd" in $$props) $$invalidate(10, raisedMd = $$new_props.raisedMd);
		if ("raisedAurora" in $$props) $$invalidate(11, raisedAurora = $$new_props.raisedAurora);
		if ("round" in $$props) $$invalidate(12, round = $$new_props.round);
		if ("roundIos" in $$props) $$invalidate(13, roundIos = $$new_props.roundIos);
		if ("roundMd" in $$props) $$invalidate(14, roundMd = $$new_props.roundMd);
		if ("roundAurora" in $$props) $$invalidate(15, roundAurora = $$new_props.roundAurora);
		if ("strong" in $$props) $$invalidate(0, strong = $$new_props.strong);
		if ("strongIos" in $$props) $$invalidate(1, strongIos = $$new_props.strongIos);
		if ("strongMd" in $$props) $$invalidate(2, strongMd = $$new_props.strongMd);
		if ("strongAurora" in $$props) $$invalidate(3, strongAurora = $$new_props.strongAurora);
		if ("tag" in $$props) $$invalidate(4, tag = $$new_props.tag);
		if ("classes" in $$props) $$invalidate(5, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(5, classes = Utils.classNames(
			className,
			{
				segmented: true,
				"segmented-raised": raised,
				"segmented-raised-ios": raisedIos,
				"segmented-raised-aurora": raisedAurora,
				"segmented-raised-md": raisedMd,
				"segmented-round": round,
				"segmented-round-ios": roundIos,
				"segmented-round-aurora": roundAurora,
				"segmented-round-md": roundMd,
				"segmented-strong": strong,
				"segmented-strong-ios": strongIos,
				"segmented-strong-md": strongMd,
				"segmented-strong-aurora": strongAurora
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		strong,
		strongIos,
		strongMd,
		strongAurora,
		tag,
		classes,
		$$restProps,
		className,
		raised,
		raisedIos,
		raisedMd,
		raisedAurora,
		round,
		roundIos,
		roundMd,
		roundAurora,
		$$scope,
		slots
	];
}

class Segmented extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$Z, create_fragment$1a, safe_not_equal, {
			class: 7,
			raised: 8,
			raisedIos: 9,
			raisedMd: 10,
			raisedAurora: 11,
			round: 12,
			roundIos: 13,
			roundMd: 14,
			roundAurora: 15,
			strong: 0,
			strongIos: 1,
			strongMd: 2,
			strongAurora: 3,
			tag: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Segmented",
			options,
			id: create_fragment$1a.name
		});
	}

	get class() {
		throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raised() {
		throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raised(value) {
		throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raisedIos() {
		throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raisedIos(value) {
		throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raisedMd() {
		throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raisedMd(value) {
		throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raisedAurora() {
		throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raisedAurora(value) {
		throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get round() {
		throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set round(value) {
		throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get roundIos() {
		throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set roundIos(value) {
		throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get roundMd() {
		throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set roundMd(value) {
		throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get roundAurora() {
		throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set roundAurora(value) {
		throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get strong() {
		throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set strong(value) {
		throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get strongIos() {
		throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set strongIos(value) {
		throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get strongMd() {
		throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set strongMd(value) {
		throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get strongAurora() {
		throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set strongAurora(value) {
		throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tag() {
		throw new Error("<Segmented>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tag(value) {
		throw new Error("<Segmented>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/sheet.svelte generated by Svelte v3.31.0 */
const file$1a = "node_modules/framework7-svelte/components/sheet.svelte";
const get_fixed_slot_changes$1 = dirty => ({});
const get_fixed_slot_context$1 = ctx => ({});

function create_fragment$1b(ctx) {
	let div1;
	let t;
	let div0;
	let current;
	const fixed_slot_template = /*#slots*/ ctx[23].fixed;
	const fixed_slot = create_slot(fixed_slot_template, ctx, /*$$scope*/ ctx[22], get_fixed_slot_context$1);
	const default_slot_template = /*#slots*/ ctx[23].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[22], null);
	let div1_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			if (fixed_slot) fixed_slot.c();
			t = space();
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div0, "class", "sheet-modal-inner");
			add_location(div0, file$1a, 150, 2, 4483);
			set_attributes(div1, div1_data);
			add_location(div1, file$1a, 144, 0, 4385);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);

			if (fixed_slot) {
				fixed_slot.m(div1, null);
			}

			append_dev(div1, t);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div0_binding*/ ctx[24](div0);
			/*div1_binding*/ ctx[25](div1);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (fixed_slot) {
				if (fixed_slot.p && dirty[0] & /*$$scope*/ 4194304) {
					update_slot(fixed_slot, fixed_slot_template, ctx, /*$$scope*/ ctx[22], dirty, get_fixed_slot_changes$1, get_fixed_slot_context$1);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 4194304) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[22], dirty, null, null);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty[0] & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty[0] & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fixed_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fixed_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (fixed_slot) fixed_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			/*div0_binding*/ ctx[24](null);
			/*div1_binding*/ ctx[25](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$d($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","opened","top","bottom","position","backdrop","backdropEl","closeByBackdropClick","closeByOutsideClick","closeOnEscape","push","swipeToClose","swipeToStep","swipeHandler","instance","open","close"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Sheet", slots, ['fixed','default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { opened = undefined } = $$props;
	let { top = undefined } = $$props;
	let { bottom = undefined } = $$props;
	let { position = undefined } = $$props;
	let { backdrop = undefined } = $$props;
	let { backdropEl = undefined } = $$props;
	let { closeByBackdropClick = undefined } = $$props;
	let { closeByOutsideClick = undefined } = $$props;
	let { closeOnEscape = undefined } = $$props;
	let { push = undefined } = $$props;
	let { swipeToClose = undefined } = $$props;
	let { swipeToStep = undefined } = $$props;
	let { swipeHandler = undefined } = $$props;
	let el;
	let innerEl;
	let f7Sheet;

	function instance() {
		return f7Sheet;
	}

	function open(anim) {
		if (!f7Sheet) return undefined;
		return f7Sheet.open(anim);
	}

	function close(anim) {
		if (!f7Sheet) return undefined;
		return f7Sheet.close(anim);
	}

	function onOpen(instance) {
		dispatch("sheetOpen", [instance]);
		if (typeof $$props.onSheetOpen === "function") $$props.onSheetOpen(instance);
	}

	function onOpened(instance) {
		dispatch("sheetOpened", [instance]);
		if (typeof $$props.onSheetOpened === "function") $$props.onSheetOpened(instance);
	}

	function onClose(instance) {
		dispatch("sheetClose", [instance]);
		if (typeof $$props.onSheetClose === "function") $$props.onSheetClose(instance);
	}

	function onClosed(instance) {
		dispatch("sheetClosed", [instance]);
		if (typeof $$props.onSheetClosed === "function") $$props.onSheetClosed(instance);
	}

	function onStepProgress(instance, progress) {
		dispatch("sheetStepProgress", [instance, progress]);
		if (typeof $$props.onSheetStepProgress === "function") $$props.onSheetStepProgress(instance, progress);
	}

	function onStepOpen(instance) {
		dispatch("sheetStepOpen", [instance]);
		if (typeof $$props.onSheetStepOpen === "function") $$props.onSheetStepOpen(instance);
	}

	function onStepClose(instance) {
		dispatch("sheetStepClose", [instance]);
		if (typeof $$props.onSheetStepClose === "function") $$props.onSheetStepClose(instance);
	}

	let initialWatched = false;

	function watchOpened(openedPassed) {
		if (!initialWatched) {
			initialWatched = true;
			return;
		}

		if (!f7Sheet) return;
		if (openedPassed) f7Sheet.open(); else f7Sheet.close();
	}

	onMount(() => {
		const params = {
			el,
			on: {
				open: onOpen,
				opened: onOpened,
				close: onClose,
				closed: onClosed,
				stepOpen: onStepOpen,
				stepClose: onStepClose,
				stepProgress: onStepProgress
			}
		};

		if (typeof backdrop !== "undefined") params.backdrop = backdrop;
		if (typeof backdropEl !== "undefined") params.backdropEl = backdropEl;
		if (typeof closeByBackdropClick !== "undefined") params.closeByBackdropClick = closeByBackdropClick;
		if (typeof closeByOutsideClick !== "undefined") params.closeByOutsideClick = closeByOutsideClick;
		if (typeof closeOnEscape !== "undefined") params.closeOnEscape = closeOnEscape;
		if (typeof swipeToClose !== "undefined") params.swipeToClose = swipeToClose;
		if (typeof swipeToStep !== "undefined") params.swipeToStep = swipeToStep;
		if (typeof swipeHandler !== "undefined") params.swipeHandler = swipeHandler;

		f7.ready(() => {
			if (el && innerEl) {
				const dom7 = f7.instance.$;
				const fixedEls = dom7(innerEl).children(".navbar, .toolbar, .tabbar, .searchbar");

				if (fixedEls.length) {
					dom7(el).prepend(fixedEls);
				}
			}

			f7Sheet = f7.instance.sheet.create(params);

			if (opened) {
				f7Sheet.open(false);
			}
		});
	});

	onDestroy(() => {
		if (f7Sheet) f7Sheet.destroy();
		f7Sheet = undefined;
	});

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			innerEl = $$value;
			$$invalidate(1, innerEl);
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(37, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("opened" in $$new_props) $$invalidate(5, opened = $$new_props.opened);
		if ("top" in $$new_props) $$invalidate(6, top = $$new_props.top);
		if ("bottom" in $$new_props) $$invalidate(7, bottom = $$new_props.bottom);
		if ("position" in $$new_props) $$invalidate(8, position = $$new_props.position);
		if ("backdrop" in $$new_props) $$invalidate(9, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$new_props) $$invalidate(10, backdropEl = $$new_props.backdropEl);
		if ("closeByBackdropClick" in $$new_props) $$invalidate(11, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ("closeByOutsideClick" in $$new_props) $$invalidate(12, closeByOutsideClick = $$new_props.closeByOutsideClick);
		if ("closeOnEscape" in $$new_props) $$invalidate(13, closeOnEscape = $$new_props.closeOnEscape);
		if ("push" in $$new_props) $$invalidate(14, push = $$new_props.push);
		if ("swipeToClose" in $$new_props) $$invalidate(15, swipeToClose = $$new_props.swipeToClose);
		if ("swipeToStep" in $$new_props) $$invalidate(16, swipeToStep = $$new_props.swipeToStep);
		if ("swipeHandler" in $$new_props) $$invalidate(17, swipeHandler = $$new_props.swipeHandler);
		if ("$$scope" in $$new_props) $$invalidate(22, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		opened,
		top,
		bottom,
		position,
		backdrop,
		backdropEl,
		closeByBackdropClick,
		closeByOutsideClick,
		closeOnEscape,
		push,
		swipeToClose,
		swipeToStep,
		swipeHandler,
		el,
		innerEl,
		f7Sheet,
		instance,
		open,
		close,
		onOpen,
		onOpened,
		onClose,
		onClosed,
		onStepProgress,
		onStepOpen,
		onStepClose,
		initialWatched,
		watchOpened,
		positionComputed,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(37, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("opened" in $$props) $$invalidate(5, opened = $$new_props.opened);
		if ("top" in $$props) $$invalidate(6, top = $$new_props.top);
		if ("bottom" in $$props) $$invalidate(7, bottom = $$new_props.bottom);
		if ("position" in $$props) $$invalidate(8, position = $$new_props.position);
		if ("backdrop" in $$props) $$invalidate(9, backdrop = $$new_props.backdrop);
		if ("backdropEl" in $$props) $$invalidate(10, backdropEl = $$new_props.backdropEl);
		if ("closeByBackdropClick" in $$props) $$invalidate(11, closeByBackdropClick = $$new_props.closeByBackdropClick);
		if ("closeByOutsideClick" in $$props) $$invalidate(12, closeByOutsideClick = $$new_props.closeByOutsideClick);
		if ("closeOnEscape" in $$props) $$invalidate(13, closeOnEscape = $$new_props.closeOnEscape);
		if ("push" in $$props) $$invalidate(14, push = $$new_props.push);
		if ("swipeToClose" in $$props) $$invalidate(15, swipeToClose = $$new_props.swipeToClose);
		if ("swipeToStep" in $$props) $$invalidate(16, swipeToStep = $$new_props.swipeToStep);
		if ("swipeHandler" in $$props) $$invalidate(17, swipeHandler = $$new_props.swipeHandler);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("innerEl" in $$props) $$invalidate(1, innerEl = $$new_props.innerEl);
		if ("f7Sheet" in $$props) f7Sheet = $$new_props.f7Sheet;
		if ("initialWatched" in $$props) initialWatched = $$new_props.initialWatched;
		if ("positionComputed" in $$props) $$invalidate(21, positionComputed = $$new_props.positionComputed);
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	let positionComputed;
	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*position, top, bottom*/ 448) {
			 $$invalidate(21, positionComputed = (() => {
				if (position) return position;
				if (top) return "top";
				if (bottom) return "bottom";
				return "bottom";
			})());
		}

		 $$invalidate(2, classes = Utils.classNames(className, "sheet-modal", `sheet-modal-${positionComputed}`, { "sheet-modal-push": push }, Mixins.colorClasses($$props)));

		if ($$self.$$.dirty[0] & /*opened*/ 32) {
			 watchOpened(opened);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		innerEl,
		classes,
		$$restProps,
		className,
		opened,
		top,
		bottom,
		position,
		backdrop,
		backdropEl,
		closeByBackdropClick,
		closeByOutsideClick,
		closeOnEscape,
		push,
		swipeToClose,
		swipeToStep,
		swipeHandler,
		instance,
		open,
		close,
		positionComputed,
		$$scope,
		slots,
		div0_binding,
		div1_binding
	];
}

class Sheet extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance_1$d,
			create_fragment$1b,
			safe_not_equal,
			{
				class: 4,
				opened: 5,
				top: 6,
				bottom: 7,
				position: 8,
				backdrop: 9,
				backdropEl: 10,
				closeByBackdropClick: 11,
				closeByOutsideClick: 12,
				closeOnEscape: 13,
				push: 14,
				swipeToClose: 15,
				swipeToStep: 16,
				swipeHandler: 17,
				instance: 18,
				open: 19,
				close: 20
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Sheet",
			options,
			id: create_fragment$1b.name
		});
	}

	get class() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get opened() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set opened(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get top() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set top(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bottom() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bottom(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get position() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set position(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdrop() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdrop(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get backdropEl() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set backdropEl(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeByBackdropClick() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeByBackdropClick(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeByOutsideClick() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeByOutsideClick(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get closeOnEscape() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set closeOnEscape(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get push() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set push(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeToClose() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeToClose(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeToStep() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeToStep(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeHandler() {
		throw new Error("<Sheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeHandler(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[18];
	}

	set instance(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get open() {
		return this.$$.ctx[19];
	}

	set open(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get close() {
		return this.$$.ctx[20];
	}

	set close(value) {
		throw new Error("<Sheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/skeleton-block.svelte generated by Svelte v3.31.0 */
const file$1b = "node_modules/framework7-svelte/components/skeleton-block.svelte";

// (39:25) 
function create_if_block_1$k(ctx) {
	let span;
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	let span_levels = [
		{ style: /*styleAttribute*/ ctx[2] },
		{ class: /*classes*/ ctx[1] },
		restProps(/*$$restProps*/ ctx[3])
	];

	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			set_attributes(span, span_data);
			add_location(span, file$1b, 39, 0, 942);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				(!current || dirty & /*styleAttribute*/ 4) && { style: /*styleAttribute*/ ctx[2] },
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$k.name,
		type: "if",
		source: "(39:25) ",
		ctx
	});

	return block;
}

// (35:0) {#if tag === 'div'}
function create_if_block$u(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	let div_levels = [
		{ style: /*styleAttribute*/ ctx[2] },
		{ class: /*classes*/ ctx[1] },
		restProps(/*$$restProps*/ ctx[3])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$1b, 35, 0, 825);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*styleAttribute*/ 4) && { style: /*styleAttribute*/ ctx[2] },
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$u.name,
		type: "if",
		source: "(35:0) {#if tag === 'div'}",
		ctx
	});

	return block;
}

function create_fragment$1c(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$u, create_if_block_1$k];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[0] === "div") return 0;
		if (/*tag*/ ctx[0] === "span") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$_($$self, $$props, $$invalidate) {
	const omit_props_names = ["style","class","width","height","tag"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Skeleton_block", slots, ['default']);
	let { style = undefined } = $$props;
	let { class: className = undefined } = $$props;
	let { width = undefined } = $$props;
	let { height = undefined } = $$props;
	let { tag = "div" } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("style" in $$new_props) $$invalidate(4, style = $$new_props.style);
		if ("class" in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ("width" in $$new_props) $$invalidate(6, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(7, height = $$new_props.height);
		if ("tag" in $$new_props) $$invalidate(0, tag = $$new_props.tag);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		style,
		className,
		width,
		height,
		tag,
		classes,
		styleAttribute
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
		if ("style" in $$props) $$invalidate(4, style = $$new_props.style);
		if ("className" in $$props) $$invalidate(5, className = $$new_props.className);
		if ("width" in $$props) $$invalidate(6, width = $$new_props.width);
		if ("height" in $$props) $$invalidate(7, height = $$new_props.height);
		if ("tag" in $$props) $$invalidate(0, tag = $$new_props.tag);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
		if ("styleAttribute" in $$props) $$invalidate(2, styleAttribute = $$new_props.styleAttribute);
	};

	let classes;
	let styleAttribute;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classes = Utils.classNames("skeleton-block", className, Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*style, width, height*/ 208) {
			 $$invalidate(2, styleAttribute = (() => {
				let s = style || "";

				if (width) {
					const widthValue = typeof width === "number" ? `${width}px` : width;
					s = `width: ${widthValue}; ${s}`;
				}

				if (height) {
					const heightValue = typeof height === "number" ? `${height}px` : height;
					s = `height: ${heightValue}; ${s}`;
				}

				return s;
			})());
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		tag,
		classes,
		styleAttribute,
		$$restProps,
		style,
		className,
		width,
		height,
		$$scope,
		slots
	];
}

class Skeleton_block extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$_, create_fragment$1c, safe_not_equal, {
			style: 4,
			class: 5,
			width: 6,
			height: 7,
			tag: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Skeleton_block",
			options,
			id: create_fragment$1c.name
		});
	}

	get style() {
		throw new Error("<Skeleton_block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Skeleton_block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Skeleton_block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Skeleton_block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Skeleton_block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Skeleton_block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<Skeleton_block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<Skeleton_block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tag() {
		throw new Error("<Skeleton_block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tag(value) {
		throw new Error("<Skeleton_block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/skeleton-text.svelte generated by Svelte v3.31.0 */
const file$1c = "node_modules/framework7-svelte/components/skeleton-text.svelte";

// (39:25) 
function create_if_block_1$l(ctx) {
	let span;
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	let span_levels = [
		{ style: /*styleAttribute*/ ctx[2] },
		{ class: /*classes*/ ctx[1] },
		restProps(/*$$restProps*/ ctx[3])
	];

	let span_data = {};

	for (let i = 0; i < span_levels.length; i += 1) {
		span_data = assign(span_data, span_levels[i]);
	}

	const block = {
		c: function create() {
			span = element("span");
			if (default_slot) default_slot.c();
			set_attributes(span, span_data);
			add_location(span, file$1c, 39, 0, 942);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			set_attributes(span, span_data = get_spread_update(span_levels, [
				(!current || dirty & /*styleAttribute*/ 4) && { style: /*styleAttribute*/ ctx[2] },
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$l.name,
		type: "if",
		source: "(39:25) ",
		ctx
	});

	return block;
}

// (35:0) {#if tag === 'div'}
function create_if_block$v(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	let div_levels = [
		{ style: /*styleAttribute*/ ctx[2] },
		{ class: /*classes*/ ctx[1] },
		restProps(/*$$restProps*/ ctx[3])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$1c, 35, 0, 825);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*styleAttribute*/ 4) && { style: /*styleAttribute*/ ctx[2] },
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$v.name,
		type: "if",
		source: "(35:0) {#if tag === 'div'}",
		ctx
	});

	return block;
}

function create_fragment$1d(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$v, create_if_block_1$l];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[0] === "div") return 0;
		if (/*tag*/ ctx[0] === "span") return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$$($$self, $$props, $$invalidate) {
	const omit_props_names = ["style","class","width","height","tag"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Skeleton_text", slots, ['default']);
	let { style = undefined } = $$props;
	let { class: className = undefined } = $$props;
	let { width = undefined } = $$props;
	let { height = undefined } = $$props;
	let { tag = "span" } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("style" in $$new_props) $$invalidate(4, style = $$new_props.style);
		if ("class" in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ("width" in $$new_props) $$invalidate(6, width = $$new_props.width);
		if ("height" in $$new_props) $$invalidate(7, height = $$new_props.height);
		if ("tag" in $$new_props) $$invalidate(0, tag = $$new_props.tag);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		style,
		className,
		width,
		height,
		tag,
		classes,
		styleAttribute
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
		if ("style" in $$props) $$invalidate(4, style = $$new_props.style);
		if ("className" in $$props) $$invalidate(5, className = $$new_props.className);
		if ("width" in $$props) $$invalidate(6, width = $$new_props.width);
		if ("height" in $$props) $$invalidate(7, height = $$new_props.height);
		if ("tag" in $$props) $$invalidate(0, tag = $$new_props.tag);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
		if ("styleAttribute" in $$props) $$invalidate(2, styleAttribute = $$new_props.styleAttribute);
	};

	let classes;
	let styleAttribute;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classes = Utils.classNames("skeleton-text", className, Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*style, width, height*/ 208) {
			 $$invalidate(2, styleAttribute = (() => {
				let s = style || "";

				if (width) {
					const widthValue = typeof width === "number" ? `${width}px` : width;
					s = `width: ${widthValue}; ${s}`;
				}

				if (height) {
					const heightValue = typeof height === "number" ? `${height}px` : height;
					s = `height: ${heightValue}; ${s}`;
				}

				return s;
			})());
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		tag,
		classes,
		styleAttribute,
		$$restProps,
		style,
		className,
		width,
		height,
		$$scope,
		slots
	];
}

class Skeleton_text extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$$, create_fragment$1d, safe_not_equal, {
			style: 4,
			class: 5,
			width: 6,
			height: 7,
			tag: 0
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Skeleton_text",
			options,
			id: create_fragment$1d.name
		});
	}

	get style() {
		throw new Error("<Skeleton_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Skeleton_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Skeleton_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Skeleton_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Skeleton_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Skeleton_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<Skeleton_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<Skeleton_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tag() {
		throw new Error("<Skeleton_text>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tag(value) {
		throw new Error("<Skeleton_text>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/stepper.svelte generated by Svelte v3.31.0 */
const file$1d = "node_modules/framework7-svelte/components/stepper.svelte";

// (150:2) {#if (input && !buttonsOnly)}
function create_if_block_1$m(ctx) {
	let div;
	let input_1;
	let input_1_min_value;
	let input_1_max_value;
	let input_1_step_value;
	let input_1_value_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			input_1 = element("input");
			attr_dev(input_1, "name", /*name*/ ctx[4]);
			attr_dev(input_1, "id", /*inputId*/ ctx[5]);
			attr_dev(input_1, "type", /*inputType*/ ctx[7]);

			attr_dev(input_1, "min", input_1_min_value = /*inputType*/ ctx[7] === "number"
			? /*min*/ ctx[1]
			: undefined);

			attr_dev(input_1, "max", input_1_max_value = /*inputType*/ ctx[7] === "number"
			? /*max*/ ctx[2]
			: undefined);

			attr_dev(input_1, "step", input_1_step_value = /*inputType*/ ctx[7] === "number"
			? /*step*/ ctx[3]
			: undefined);

			input_1.value = input_1_value_value = typeof /*value*/ ctx[0] === "undefined"
			? ""
			: /*value*/ ctx[0];

			input_1.readOnly = /*inputReadonly*/ ctx[8];
			add_location(input_1, file$1d, 151, 4, 4253);
			attr_dev(div, "class", "stepper-input-wrap");
			add_location(div, file$1d, 150, 2, 4216);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, input_1);

			if (!mounted) {
				dispose = [
					listen_dev(input_1, "input", /*onInput*/ ctx[12], false, false, false),
					listen_dev(input_1, "change", /*onChange*/ ctx[13], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*name*/ 16) {
				attr_dev(input_1, "name", /*name*/ ctx[4]);
			}

			if (dirty[0] & /*inputId*/ 32) {
				attr_dev(input_1, "id", /*inputId*/ ctx[5]);
			}

			if (dirty[0] & /*inputType*/ 128) {
				attr_dev(input_1, "type", /*inputType*/ ctx[7]);
			}

			if (dirty[0] & /*inputType, min*/ 130 && input_1_min_value !== (input_1_min_value = /*inputType*/ ctx[7] === "number"
			? /*min*/ ctx[1]
			: undefined)) {
				attr_dev(input_1, "min", input_1_min_value);
			}

			if (dirty[0] & /*inputType, max*/ 132 && input_1_max_value !== (input_1_max_value = /*inputType*/ ctx[7] === "number"
			? /*max*/ ctx[2]
			: undefined)) {
				attr_dev(input_1, "max", input_1_max_value);
			}

			if (dirty[0] & /*inputType, step*/ 136 && input_1_step_value !== (input_1_step_value = /*inputType*/ ctx[7] === "number"
			? /*step*/ ctx[3]
			: undefined)) {
				attr_dev(input_1, "step", input_1_step_value);
			}

			if (dirty[0] & /*value*/ 1 && input_1_value_value !== (input_1_value_value = typeof /*value*/ ctx[0] === "undefined"
			? ""
			: /*value*/ ctx[0]) && input_1.value !== input_1_value_value) {
				prop_dev(input_1, "value", input_1_value_value);
			}

			if (dirty[0] & /*inputReadonly*/ 256) {
				prop_dev(input_1, "readOnly", /*inputReadonly*/ ctx[8]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$m.name,
		type: "if",
		source: "(150:2) {#if (input && !buttonsOnly)}",
		ctx
	});

	return block;
}

// (166:2) {#if (!input && !buttonsOnly)}
function create_if_block$w(ctx) {
	let div;
	let t_value = Utils.text(/*value*/ ctx[0]) + "";
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(t_value);
			attr_dev(div, "class", "stepper-value");
			add_location(div, file$1d, 166, 4, 4681);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*value*/ 1 && t_value !== (t_value = Utils.text(/*value*/ ctx[0]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$w.name,
		type: "if",
		source: "(166:2) {#if (!input && !buttonsOnly)}",
		ctx
	});

	return block;
}

function create_fragment$1e(ctx) {
	let div2;
	let div0;
	let t0;
	let t1;
	let t2;
	let div1;
	let mounted;
	let dispose;
	let if_block0 = /*input*/ ctx[6] && !/*buttonsOnly*/ ctx[9] && create_if_block_1$m(ctx);
	let if_block1 = !/*input*/ ctx[6] && !/*buttonsOnly*/ ctx[9] && create_if_block$w(ctx);
	let div2_levels = [{ class: /*classes*/ ctx[11] }, restProps(/*$$restProps*/ ctx[16])];
	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			div1 = element("div");
			attr_dev(div0, "class", "stepper-button-minus");
			add_location(div0, file$1d, 148, 2, 4121);
			attr_dev(div1, "class", "stepper-button-plus");
			add_location(div1, file$1d, 168, 2, 4744);
			set_attributes(div2, div2_data);
			add_location(div2, file$1d, 147, 0, 4054);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			append_dev(div2, t0);
			if (if_block0) if_block0.m(div2, null);
			append_dev(div2, t1);
			if (if_block1) if_block1.m(div2, null);
			append_dev(div2, t2);
			append_dev(div2, div1);
			/*div2_binding*/ ctx[48](div2);

			if (!mounted) {
				dispose = [
					listen_dev(div0, "click", /*onMinusClick*/ ctx[14], false, false, false),
					listen_dev(div1, "click", /*onPlusClick*/ ctx[15], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*input*/ ctx[6] && !/*buttonsOnly*/ ctx[9]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$m(ctx);
					if_block0.c();
					if_block0.m(div2, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!/*input*/ ctx[6] && !/*buttonsOnly*/ ctx[9]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$w(ctx);
					if_block1.c();
					if_block1.m(div2, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				dirty[0] & /*classes*/ 2048 && { class: /*classes*/ ctx[11] },
				dirty[0] & /*$$restProps*/ 65536 && restProps(/*$$restProps*/ ctx[16])
			]));
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			/*div2_binding*/ ctx[48](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$e($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","init","value","min","max","step","formatValue","name","inputId","input","inputType","inputReadonly","autorepeat","autorepeatDynamic","wraps","manualInputMode","decimalPoint","buttonsEndInputMode","disabled","buttonsOnly","round","roundMd","roundIos","roundAurora","fill","fillMd","fillIos","fillAurora","large","largeMd","largeIos","largeAurora","small","smallMd","smallIos","smallAurora","raised","raisedMd","raisedIos","raisedAurora","instance"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Stepper", slots, []);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { init = true } = $$props;
	let { value = 0 } = $$props;
	let { min = 0 } = $$props;
	let { max = 100 } = $$props;
	let { step = 1 } = $$props;
	let { formatValue = undefined } = $$props;
	let { name = undefined } = $$props;
	let { inputId = undefined } = $$props;
	let { input = true } = $$props;
	let { inputType = "text" } = $$props;
	let { inputReadonly = false } = $$props;
	let { autorepeat = false } = $$props;
	let { autorepeatDynamic = false } = $$props;
	let { wraps = false } = $$props;
	let { manualInputMode = false } = $$props;
	let { decimalPoint = 4 } = $$props;
	let { buttonsEndInputMode = true } = $$props;
	let { disabled = undefined } = $$props;
	let { buttonsOnly = undefined } = $$props;
	let { round = false } = $$props;
	let { roundMd = false } = $$props;
	let { roundIos = false } = $$props;
	let { roundAurora = false } = $$props;
	let { fill = false } = $$props;
	let { fillMd = false } = $$props;
	let { fillIos = false } = $$props;
	let { fillAurora = false } = $$props;
	let { large = false } = $$props;
	let { largeMd = false } = $$props;
	let { largeIos = false } = $$props;
	let { largeAurora = false } = $$props;
	let { small = false } = $$props;
	let { smallMd = false } = $$props;
	let { smallIos = false } = $$props;
	let { smallAurora = false } = $$props;
	let { raised = false } = $$props;
	let { raisedMd = false } = $$props;
	let { raisedIos = false } = $$props;
	let { raisedAurora = false } = $$props;
	let el;
	let f7Stepper;

	function instance() {
		return f7Stepper;
	}

	function watchValue(newValue) {
		if (!f7Stepper) return;
		f7Stepper.setValue(newValue);
	}

	function onInput(event) {
		dispatch("input", [event, f7Stepper]);
		if (typeof $$props.onInput === "function") $$props.onInput(event, f7Stepper);
	}

	function onChange(event) {
		dispatch("change", [event, f7Stepper]);
		if (typeof $$props.onChange === "function") $$props.onChange(event, f7Stepper);
	}

	function onMinusClick(event) {
		dispatch("stepperMinusClick", [event, f7Stepper]);
		if (typeof $$props.onStepperMinusClick === "function") $$props.onStepperMinusClick(event, f7Stepper);
	}

	function onPlusClick(event) {
		dispatch("stepperPlusClick", [event, f7Stepper]);
		if (typeof $$props.onStepperPlusClick === "function") $$props.onStepperPlusClick(event, f7Stepper);
	}

	onMount(() => {
		if (!init) return;

		f7.ready(() => {
			f7Stepper = f7.instance.stepper.create(Utils.noUndefinedProps({
				el,
				min,
				max,
				value,
				step,
				formatValue,
				autorepeat,
				autorepeatDynamic,
				wraps,
				manualInputMode,
				decimalPoint,
				buttonsEndInputMode,
				on: {
					change(stepper, newValue) {
						dispatch("stepperChange", [newValue]);
						if (typeof $$props.onStepperChange === "function") $$props.onStepperChange(newValue);
					}
				}
			}));
		});
	});

	onDestroy(() => {
		if (f7Stepper && f7Stepper.destroy) f7Stepper.destroy();
	});

	function div2_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(10, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(52, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(17, className = $$new_props.class);
		if ("init" in $$new_props) $$invalidate(18, init = $$new_props.init);
		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ("min" in $$new_props) $$invalidate(1, min = $$new_props.min);
		if ("max" in $$new_props) $$invalidate(2, max = $$new_props.max);
		if ("step" in $$new_props) $$invalidate(3, step = $$new_props.step);
		if ("formatValue" in $$new_props) $$invalidate(19, formatValue = $$new_props.formatValue);
		if ("name" in $$new_props) $$invalidate(4, name = $$new_props.name);
		if ("inputId" in $$new_props) $$invalidate(5, inputId = $$new_props.inputId);
		if ("input" in $$new_props) $$invalidate(6, input = $$new_props.input);
		if ("inputType" in $$new_props) $$invalidate(7, inputType = $$new_props.inputType);
		if ("inputReadonly" in $$new_props) $$invalidate(8, inputReadonly = $$new_props.inputReadonly);
		if ("autorepeat" in $$new_props) $$invalidate(20, autorepeat = $$new_props.autorepeat);
		if ("autorepeatDynamic" in $$new_props) $$invalidate(21, autorepeatDynamic = $$new_props.autorepeatDynamic);
		if ("wraps" in $$new_props) $$invalidate(22, wraps = $$new_props.wraps);
		if ("manualInputMode" in $$new_props) $$invalidate(23, manualInputMode = $$new_props.manualInputMode);
		if ("decimalPoint" in $$new_props) $$invalidate(24, decimalPoint = $$new_props.decimalPoint);
		if ("buttonsEndInputMode" in $$new_props) $$invalidate(25, buttonsEndInputMode = $$new_props.buttonsEndInputMode);
		if ("disabled" in $$new_props) $$invalidate(26, disabled = $$new_props.disabled);
		if ("buttonsOnly" in $$new_props) $$invalidate(9, buttonsOnly = $$new_props.buttonsOnly);
		if ("round" in $$new_props) $$invalidate(27, round = $$new_props.round);
		if ("roundMd" in $$new_props) $$invalidate(28, roundMd = $$new_props.roundMd);
		if ("roundIos" in $$new_props) $$invalidate(29, roundIos = $$new_props.roundIos);
		if ("roundAurora" in $$new_props) $$invalidate(30, roundAurora = $$new_props.roundAurora);
		if ("fill" in $$new_props) $$invalidate(31, fill = $$new_props.fill);
		if ("fillMd" in $$new_props) $$invalidate(32, fillMd = $$new_props.fillMd);
		if ("fillIos" in $$new_props) $$invalidate(33, fillIos = $$new_props.fillIos);
		if ("fillAurora" in $$new_props) $$invalidate(34, fillAurora = $$new_props.fillAurora);
		if ("large" in $$new_props) $$invalidate(35, large = $$new_props.large);
		if ("largeMd" in $$new_props) $$invalidate(36, largeMd = $$new_props.largeMd);
		if ("largeIos" in $$new_props) $$invalidate(37, largeIos = $$new_props.largeIos);
		if ("largeAurora" in $$new_props) $$invalidate(38, largeAurora = $$new_props.largeAurora);
		if ("small" in $$new_props) $$invalidate(39, small = $$new_props.small);
		if ("smallMd" in $$new_props) $$invalidate(40, smallMd = $$new_props.smallMd);
		if ("smallIos" in $$new_props) $$invalidate(41, smallIos = $$new_props.smallIos);
		if ("smallAurora" in $$new_props) $$invalidate(42, smallAurora = $$new_props.smallAurora);
		if ("raised" in $$new_props) $$invalidate(43, raised = $$new_props.raised);
		if ("raisedMd" in $$new_props) $$invalidate(44, raisedMd = $$new_props.raisedMd);
		if ("raisedIos" in $$new_props) $$invalidate(45, raisedIos = $$new_props.raisedIos);
		if ("raisedAurora" in $$new_props) $$invalidate(46, raisedAurora = $$new_props.raisedAurora);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		dispatch,
		className,
		init,
		value,
		min,
		max,
		step,
		formatValue,
		name,
		inputId,
		input,
		inputType,
		inputReadonly,
		autorepeat,
		autorepeatDynamic,
		wraps,
		manualInputMode,
		decimalPoint,
		buttonsEndInputMode,
		disabled,
		buttonsOnly,
		round,
		roundMd,
		roundIos,
		roundAurora,
		fill,
		fillMd,
		fillIos,
		fillAurora,
		large,
		largeMd,
		largeIos,
		largeAurora,
		small,
		smallMd,
		smallIos,
		smallAurora,
		raised,
		raisedMd,
		raisedIos,
		raisedAurora,
		el,
		f7Stepper,
		instance,
		watchValue,
		onInput,
		onChange,
		onMinusClick,
		onPlusClick,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(52, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(17, className = $$new_props.className);
		if ("init" in $$props) $$invalidate(18, init = $$new_props.init);
		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
		if ("min" in $$props) $$invalidate(1, min = $$new_props.min);
		if ("max" in $$props) $$invalidate(2, max = $$new_props.max);
		if ("step" in $$props) $$invalidate(3, step = $$new_props.step);
		if ("formatValue" in $$props) $$invalidate(19, formatValue = $$new_props.formatValue);
		if ("name" in $$props) $$invalidate(4, name = $$new_props.name);
		if ("inputId" in $$props) $$invalidate(5, inputId = $$new_props.inputId);
		if ("input" in $$props) $$invalidate(6, input = $$new_props.input);
		if ("inputType" in $$props) $$invalidate(7, inputType = $$new_props.inputType);
		if ("inputReadonly" in $$props) $$invalidate(8, inputReadonly = $$new_props.inputReadonly);
		if ("autorepeat" in $$props) $$invalidate(20, autorepeat = $$new_props.autorepeat);
		if ("autorepeatDynamic" in $$props) $$invalidate(21, autorepeatDynamic = $$new_props.autorepeatDynamic);
		if ("wraps" in $$props) $$invalidate(22, wraps = $$new_props.wraps);
		if ("manualInputMode" in $$props) $$invalidate(23, manualInputMode = $$new_props.manualInputMode);
		if ("decimalPoint" in $$props) $$invalidate(24, decimalPoint = $$new_props.decimalPoint);
		if ("buttonsEndInputMode" in $$props) $$invalidate(25, buttonsEndInputMode = $$new_props.buttonsEndInputMode);
		if ("disabled" in $$props) $$invalidate(26, disabled = $$new_props.disabled);
		if ("buttonsOnly" in $$props) $$invalidate(9, buttonsOnly = $$new_props.buttonsOnly);
		if ("round" in $$props) $$invalidate(27, round = $$new_props.round);
		if ("roundMd" in $$props) $$invalidate(28, roundMd = $$new_props.roundMd);
		if ("roundIos" in $$props) $$invalidate(29, roundIos = $$new_props.roundIos);
		if ("roundAurora" in $$props) $$invalidate(30, roundAurora = $$new_props.roundAurora);
		if ("fill" in $$props) $$invalidate(31, fill = $$new_props.fill);
		if ("fillMd" in $$props) $$invalidate(32, fillMd = $$new_props.fillMd);
		if ("fillIos" in $$props) $$invalidate(33, fillIos = $$new_props.fillIos);
		if ("fillAurora" in $$props) $$invalidate(34, fillAurora = $$new_props.fillAurora);
		if ("large" in $$props) $$invalidate(35, large = $$new_props.large);
		if ("largeMd" in $$props) $$invalidate(36, largeMd = $$new_props.largeMd);
		if ("largeIos" in $$props) $$invalidate(37, largeIos = $$new_props.largeIos);
		if ("largeAurora" in $$props) $$invalidate(38, largeAurora = $$new_props.largeAurora);
		if ("small" in $$props) $$invalidate(39, small = $$new_props.small);
		if ("smallMd" in $$props) $$invalidate(40, smallMd = $$new_props.smallMd);
		if ("smallIos" in $$props) $$invalidate(41, smallIos = $$new_props.smallIos);
		if ("smallAurora" in $$props) $$invalidate(42, smallAurora = $$new_props.smallAurora);
		if ("raised" in $$props) $$invalidate(43, raised = $$new_props.raised);
		if ("raisedMd" in $$props) $$invalidate(44, raisedMd = $$new_props.raisedMd);
		if ("raisedIos" in $$props) $$invalidate(45, raisedIos = $$new_props.raisedIos);
		if ("raisedAurora" in $$props) $$invalidate(46, raisedAurora = $$new_props.raisedAurora);
		if ("el" in $$props) $$invalidate(10, el = $$new_props.el);
		if ("f7Stepper" in $$props) f7Stepper = $$new_props.f7Stepper;
		if ("classes" in $$props) $$invalidate(11, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(11, classes = Utils.classNames(
			className,
			"stepper",
			{
				disabled,
				"stepper-round": round,
				"stepper-round-ios": roundIos,
				"stepper-round-md": roundMd,
				"stepper-round-aurora": roundAurora,
				"stepper-fill": fill,
				"stepper-fill-ios": fillIos,
				"stepper-fill-md": fillMd,
				"stepper-fill-aurora": fillAurora,
				"stepper-large": large,
				"stepper-large-ios": largeIos,
				"stepper-large-md": largeMd,
				"stepper-large-aurora": largeAurora,
				"stepper-small": small,
				"stepper-small-ios": smallIos,
				"stepper-small-md": smallMd,
				"stepper-small-aurora": smallAurora,
				"stepper-raised": raised,
				"stepper-raised-ios": raisedIos,
				"stepper-raised-md": raisedMd,
				"stepper-raised-aurora": raisedAurora
			},
			Mixins.colorClasses($$props)
		));

		if ($$self.$$.dirty[0] & /*value*/ 1) {
			 watchValue(value);
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		value,
		min,
		max,
		step,
		name,
		inputId,
		input,
		inputType,
		inputReadonly,
		buttonsOnly,
		el,
		classes,
		onInput,
		onChange,
		onMinusClick,
		onPlusClick,
		$$restProps,
		className,
		init,
		formatValue,
		autorepeat,
		autorepeatDynamic,
		wraps,
		manualInputMode,
		decimalPoint,
		buttonsEndInputMode,
		disabled,
		round,
		roundMd,
		roundIos,
		roundAurora,
		fill,
		fillMd,
		fillIos,
		fillAurora,
		large,
		largeMd,
		largeIos,
		largeAurora,
		small,
		smallMd,
		smallIos,
		smallAurora,
		raised,
		raisedMd,
		raisedIos,
		raisedAurora,
		instance,
		div2_binding
	];
}

class Stepper extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance_1$e,
			create_fragment$1e,
			safe_not_equal,
			{
				class: 17,
				init: 18,
				value: 0,
				min: 1,
				max: 2,
				step: 3,
				formatValue: 19,
				name: 4,
				inputId: 5,
				input: 6,
				inputType: 7,
				inputReadonly: 8,
				autorepeat: 20,
				autorepeatDynamic: 21,
				wraps: 22,
				manualInputMode: 23,
				decimalPoint: 24,
				buttonsEndInputMode: 25,
				disabled: 26,
				buttonsOnly: 9,
				round: 27,
				roundMd: 28,
				roundIos: 29,
				roundAurora: 30,
				fill: 31,
				fillMd: 32,
				fillIos: 33,
				fillAurora: 34,
				large: 35,
				largeMd: 36,
				largeIos: 37,
				largeAurora: 38,
				small: 39,
				smallMd: 40,
				smallIos: 41,
				smallAurora: 42,
				raised: 43,
				raisedMd: 44,
				raisedIos: 45,
				raisedAurora: 46,
				instance: 47
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Stepper",
			options,
			id: create_fragment$1e.name
		});
	}

	get class() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get init() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set init(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get min() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set min(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get max() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set max(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get step() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set step(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get formatValue() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set formatValue(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputId() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputId(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get input() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set input(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputType() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputType(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inputReadonly() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inputReadonly(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autorepeat() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autorepeat(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autorepeatDynamic() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autorepeatDynamic(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get wraps() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set wraps(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get manualInputMode() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set manualInputMode(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get decimalPoint() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set decimalPoint(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get buttonsEndInputMode() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set buttonsEndInputMode(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get disabled() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set disabled(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get buttonsOnly() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set buttonsOnly(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get round() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set round(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get roundMd() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set roundMd(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get roundIos() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set roundIos(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get roundAurora() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set roundAurora(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fillMd() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fillMd(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fillIos() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fillIos(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fillAurora() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fillAurora(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get large() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set large(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get largeMd() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set largeMd(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get largeIos() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set largeIos(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get largeAurora() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set largeAurora(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get small() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set small(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smallMd() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smallMd(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smallIos() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smallIos(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get smallAurora() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set smallAurora(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raised() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raised(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raisedMd() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raisedMd(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raisedIos() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raisedIos(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get raisedAurora() {
		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set raisedAurora(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[47];
	}

	set instance(value) {
		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/subnavbar.svelte generated by Svelte v3.31.0 */
const file$1e = "node_modules/framework7-svelte/components/subnavbar.svelte";

// (33:2) {:else}
function create_else_block$b(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$b.name,
		type: "else",
		source: "(33:2) {:else}",
		ctx
	});

	return block;
}

// (26:2) {#if inner}
function create_if_block$x(ctx) {
	let div;
	let t;
	let current;
	let if_block = /*title*/ ctx[0] && create_if_block_1$n(ctx);
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			attr_dev(div, "class", "subnavbar-inner");
			add_location(div, file$1e, 26, 4, 557);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (/*title*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$n(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$x.name,
		type: "if",
		source: "(26:2) {#if inner}",
		ctx
	});

	return block;
}

// (28:6) {#if title}
function create_if_block_1$n(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*title*/ ctx[0]);
			attr_dev(div, "class", "subnavbar-title");
			add_location(div, file$1e, 28, 8, 613);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 1) set_data_dev(t, /*title*/ ctx[0]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$n.name,
		type: "if",
		source: "(28:6) {#if title}",
		ctx
	});

	return block;
}

function create_fragment$1f(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$x, create_else_block$b];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*inner*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	let div_levels = [
		{ class: /*classes*/ ctx[3] },
		{ "data-f7-slot": /*f7Slot*/ ctx[2] },
		restProps(/*$$restProps*/ ctx[4])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			set_attributes(div, div_data);
			add_location(div, file$1e, 24, 0, 467);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				(!current || dirty & /*f7Slot*/ 4) && { "data-f7-slot": /*f7Slot*/ ctx[2] },
				dirty & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$10($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","sliding","title","inner","f7Slot"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Subnavbar", slots, ['default']);
	let { class: className = undefined } = $$props;
	let { sliding = undefined } = $$props;
	let { title = undefined } = $$props;
	let { inner = true } = $$props;
	let { f7Slot = "fixed" } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ("sliding" in $$new_props) $$invalidate(6, sliding = $$new_props.sliding);
		if ("title" in $$new_props) $$invalidate(0, title = $$new_props.title);
		if ("inner" in $$new_props) $$invalidate(1, inner = $$new_props.inner);
		if ("f7Slot" in $$new_props) $$invalidate(2, f7Slot = $$new_props.f7Slot);
		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		sliding,
		title,
		inner,
		f7Slot,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(5, className = $$new_props.className);
		if ("sliding" in $$props) $$invalidate(6, sliding = $$new_props.sliding);
		if ("title" in $$props) $$invalidate(0, title = $$new_props.title);
		if ("inner" in $$props) $$invalidate(1, inner = $$new_props.inner);
		if ("f7Slot" in $$props) $$invalidate(2, f7Slot = $$new_props.f7Slot);
		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(3, classes = Utils.classNames(className, "subnavbar", { sliding }, Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [title, inner, f7Slot, classes, $$restProps, className, sliding, $$scope, slots];
}

class Subnavbar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$10, create_fragment$1f, safe_not_equal, {
			class: 5,
			sliding: 6,
			title: 0,
			inner: 1,
			f7Slot: 2
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Subnavbar",
			options,
			id: create_fragment$1f.name
		});
	}

	get class() {
		throw new Error("<Subnavbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Subnavbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sliding() {
		throw new Error("<Subnavbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sliding(value) {
		throw new Error("<Subnavbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<Subnavbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Subnavbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inner() {
		throw new Error("<Subnavbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inner(value) {
		throw new Error("<Subnavbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get f7Slot() {
		throw new Error("<Subnavbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set f7Slot(value) {
		throw new Error("<Subnavbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/swipeout-actions.svelte generated by Svelte v3.31.0 */
const file$1f = "node_modules/framework7-svelte/components/swipeout-actions.svelte";

function create_fragment$1g(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$1f, 23, 0, 537);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$11($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","left","right","side"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Swipeout_actions", slots, ['default']);
	let { class: className = undefined } = $$props;
	let { left = undefined } = $$props;
	let { right = undefined } = $$props;
	let { side = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("left" in $$new_props) $$invalidate(3, left = $$new_props.left);
		if ("right" in $$new_props) $$invalidate(4, right = $$new_props.right);
		if ("side" in $$new_props) $$invalidate(5, side = $$new_props.side);
		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		left,
		right,
		side,
		classes,
		sideComputed
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("left" in $$props) $$invalidate(3, left = $$new_props.left);
		if ("right" in $$props) $$invalidate(4, right = $$new_props.right);
		if ("side" in $$props) $$invalidate(5, side = $$new_props.side);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
		if ("sideComputed" in $$props) $$invalidate(6, sideComputed = $$new_props.sideComputed);
	};

	let classes;
	let sideComputed;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*side, left, right*/ 56) {
			// eslint-disable-next-line
			 $$invalidate(6, sideComputed = side || (left ? "left" : right ? "right" : "left"));
		}

		 $$invalidate(0, classes = Utils.classNames(className, `swipeout-actions-${sideComputed}`, Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);

	return [
		classes,
		$$restProps,
		className,
		left,
		right,
		side,
		sideComputed,
		$$scope,
		slots
	];
}

class Swipeout_actions extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$11, create_fragment$1g, safe_not_equal, { class: 2, left: 3, right: 4, side: 5 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Swipeout_actions",
			options,
			id: create_fragment$1g.name
		});
	}

	get class() {
		throw new Error("<Swipeout_actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Swipeout_actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get left() {
		throw new Error("<Swipeout_actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set left(value) {
		throw new Error("<Swipeout_actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get right() {
		throw new Error("<Swipeout_actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set right(value) {
		throw new Error("<Swipeout_actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get side() {
		throw new Error("<Swipeout_actions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set side(value) {
		throw new Error("<Swipeout_actions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/swipeout-button.svelte generated by Svelte v3.31.0 */
const file$1g = "node_modules/framework7-svelte/components/swipeout-button.svelte";

function create_fragment$1h(ctx) {
	let a;
	let t0_value = Utils.text(/*text*/ ctx[0]) + "";
	let t0;
	let t1;
	let a_href_value;
	let a_data_confirm_value;
	let a_data_confirm_title_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);

	let a_levels = [
		{
			href: a_href_value = /*href*/ ctx[3] || "#"
		},
		{
			"data-confirm": a_data_confirm_value = /*confirmText*/ ctx[2] || undefined
		},
		{
			"data-confirm-title": a_data_confirm_title_value = /*confirmTitle*/ ctx[1] || undefined
		},
		{ class: /*classes*/ ctx[4] },
		restProps(/*$$restProps*/ ctx[6])
	];

	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			t0 = text(t0_value);
			t1 = space();
			if (default_slot) default_slot.c();
			set_attributes(a, a_data);
			add_location(a, file$1g, 38, 0, 903);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, t0);
			append_dev(a, t1);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[5], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if ((!current || dirty & /*text*/ 1) && t0_value !== (t0_value = Utils.text(/*text*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 2048) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*href*/ 8 && a_href_value !== (a_href_value = /*href*/ ctx[3] || "#")) && { href: a_href_value },
				(!current || dirty & /*confirmText*/ 4 && a_data_confirm_value !== (a_data_confirm_value = /*confirmText*/ ctx[2] || undefined)) && { "data-confirm": a_data_confirm_value },
				(!current || dirty & /*confirmTitle*/ 2 && a_data_confirm_title_value !== (a_data_confirm_title_value = /*confirmTitle*/ ctx[1] || undefined)) && {
					"data-confirm-title": a_data_confirm_title_value
				},
				(!current || dirty & /*classes*/ 16) && { class: /*classes*/ ctx[4] },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$12($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","text","confirmTitle","confirmText","overswipe","close","delete","href"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Swipeout_button", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { text = undefined } = $$props;
	let { confirmTitle = undefined } = $$props;
	let { confirmText = undefined } = $$props;
	let { overswipe = undefined } = $$props;
	let { close = undefined } = $$props;
	let { delete: deleteProp = undefined } = $$props;
	let { href = undefined } = $$props;

	function onClick() {
		dispatch("click");
		if (typeof $$props.onClick === "function") $$props.onClick();
	}

	$$self.$$set = $$new_props => {
		$$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(7, className = $$new_props.class);
		if ("text" in $$new_props) $$invalidate(0, text = $$new_props.text);
		if ("confirmTitle" in $$new_props) $$invalidate(1, confirmTitle = $$new_props.confirmTitle);
		if ("confirmText" in $$new_props) $$invalidate(2, confirmText = $$new_props.confirmText);
		if ("overswipe" in $$new_props) $$invalidate(8, overswipe = $$new_props.overswipe);
		if ("close" in $$new_props) $$invalidate(9, close = $$new_props.close);
		if ("delete" in $$new_props) $$invalidate(10, deleteProp = $$new_props.delete);
		if ("href" in $$new_props) $$invalidate(3, href = $$new_props.href);
		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		Mixins,
		Utils,
		restProps,
		dispatch,
		className,
		text,
		confirmTitle,
		confirmText,
		overswipe,
		close,
		deleteProp,
		href,
		onClick,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(14, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(7, className = $$new_props.className);
		if ("text" in $$props) $$invalidate(0, text = $$new_props.text);
		if ("confirmTitle" in $$props) $$invalidate(1, confirmTitle = $$new_props.confirmTitle);
		if ("confirmText" in $$props) $$invalidate(2, confirmText = $$new_props.confirmText);
		if ("overswipe" in $$props) $$invalidate(8, overswipe = $$new_props.overswipe);
		if ("close" in $$props) $$invalidate(9, close = $$new_props.close);
		if ("deleteProp" in $$props) $$invalidate(10, deleteProp = $$new_props.deleteProp);
		if ("href" in $$props) $$invalidate(3, href = $$new_props.href);
		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(4, classes = Utils.classNames(
			className,
			{
				"swipeout-overswipe": overswipe,
				"swipeout-delete": deleteProp,
				"swipeout-close": close
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		text,
		confirmTitle,
		confirmText,
		href,
		classes,
		onClick,
		$$restProps,
		className,
		overswipe,
		close,
		deleteProp,
		$$scope,
		slots
	];
}

class Swipeout_button extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$12, create_fragment$1h, safe_not_equal, {
			class: 7,
			text: 0,
			confirmTitle: 1,
			confirmText: 2,
			overswipe: 8,
			close: 9,
			delete: 10,
			href: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Swipeout_button",
			options,
			id: create_fragment$1h.name
		});
	}

	get class() {
		throw new Error("<Swipeout_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Swipeout_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get text() {
		throw new Error("<Swipeout_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set text(value) {
		throw new Error("<Swipeout_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get confirmTitle() {
		throw new Error("<Swipeout_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set confirmTitle(value) {
		throw new Error("<Swipeout_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get confirmText() {
		throw new Error("<Swipeout_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set confirmText(value) {
		throw new Error("<Swipeout_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get overswipe() {
		throw new Error("<Swipeout_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set overswipe(value) {
		throw new Error("<Swipeout_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get close() {
		throw new Error("<Swipeout_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set close(value) {
		throw new Error("<Swipeout_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get delete() {
		throw new Error("<Swipeout_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set delete(value) {
		throw new Error("<Swipeout_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get href() {
		throw new Error("<Swipeout_button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<Swipeout_button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/swiper-slide.svelte generated by Svelte v3.31.0 */
const file$1h = "node_modules/framework7-svelte/components/swiper-slide.svelte";

// (24:2) {:else}
function create_else_block$c(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$c.name,
		type: "else",
		source: "(24:2) {:else}",
		ctx
	});

	return block;
}

// (20:2) {#if zoom}
function create_if_block$y(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", "swiper-zoom-container");
			add_location(div, file$1h, 20, 4, 416);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$y.name,
		type: "if",
		source: "(20:2) {#if zoom}",
		ctx
	});

	return block;
}

function create_fragment$1i(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block$y, create_else_block$c];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*zoom*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let div_levels = [{ class: /*classes*/ ctx[1] }, restProps(/*$$restProps*/ ctx[2])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if_block.c();
			set_attributes(div, div_data);
			add_location(div, file$1h, 18, 0, 349);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 2) && { class: /*classes*/ ctx[1] },
				dirty & /*$$restProps*/ 4 && restProps(/*$$restProps*/ ctx[2])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$13($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","zoom"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Swiper_slide", slots, ['default']);
	let { class: className = undefined } = $$props;
	let { zoom = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("zoom" in $$new_props) $$invalidate(0, zoom = $$new_props.zoom);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		zoom,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("zoom" in $$props) $$invalidate(0, zoom = $$new_props.zoom);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(1, classes = Utils.classNames(className, "swiper-slide", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [zoom, classes, $$restProps, className, $$scope, slots];
}

class Swiper_slide extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$13, create_fragment$1i, safe_not_equal, { class: 3, zoom: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Swiper_slide",
			options,
			id: create_fragment$1i.name
		});
	}

	get class() {
		throw new Error("<Swiper_slide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Swiper_slide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get zoom() {
		throw new Error("<Swiper_slide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set zoom(value) {
		throw new Error("<Swiper_slide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/swiper.svelte generated by Svelte v3.31.0 */
const file$1i = "node_modules/framework7-svelte/components/swiper.svelte";
const get_after_wrapper_slot_changes = dirty => ({});
const get_after_wrapper_slot_context = ctx => ({});
const get_before_wrapper_slot_changes = dirty => ({});
const get_before_wrapper_slot_context = ctx => ({});

// (90:2) {#if paginationComputed}
function create_if_block_2$i(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "swiper-pagination");
			add_location(div, file$1i, 90, 4, 2330);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			/*div_binding*/ ctx[18](div);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			/*div_binding*/ ctx[18](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$i.name,
		type: "if",
		source: "(90:2) {#if paginationComputed}",
		ctx
	});

	return block;
}

// (93:2) {#if scrollbarComputed}
function create_if_block_1$o(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "swiper-scrollbar");
			add_location(div, file$1i, 93, 4, 2427);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			/*div_binding_1*/ ctx[19](div);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			/*div_binding_1*/ ctx[19](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$o.name,
		type: "if",
		source: "(93:2) {#if scrollbarComputed}",
		ctx
	});

	return block;
}

// (96:2) {#if navigationComputed}
function create_if_block$z(ctx) {
	let div0;
	let t;
	let div1;

	const block = {
		c: function create() {
			div0 = element("div");
			t = space();
			div1 = element("div");
			attr_dev(div0, "class", "swiper-button-prev");
			add_location(div0, file$1i, 96, 4, 2523);
			attr_dev(div1, "class", "swiper-button-next");
			add_location(div1, file$1i, 97, 4, 2581);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);
			/*div0_binding*/ ctx[20](div0);
			insert_dev(target, t, anchor);
			insert_dev(target, div1, anchor);
			/*div1_binding*/ ctx[21](div1);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			/*div0_binding*/ ctx[20](null);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div1);
			/*div1_binding*/ ctx[21](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$z.name,
		type: "if",
		source: "(96:2) {#if navigationComputed}",
		ctx
	});

	return block;
}

function create_fragment$1j(ctx) {
	let div1;
	let t0;
	let div0;
	let t1;
	let t2;
	let t3;
	let t4;
	let current;
	const before_wrapper_slot_template = /*#slots*/ ctx[17]["before-wrapper"];
	const before_wrapper_slot = create_slot(before_wrapper_slot_template, ctx, /*$$scope*/ ctx[16], get_before_wrapper_slot_context);
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
	let if_block0 = /*paginationComputed*/ ctx[6] && create_if_block_2$i(ctx);
	let if_block1 = /*scrollbarComputed*/ ctx[7] && create_if_block_1$o(ctx);
	let if_block2 = /*navigationComputed*/ ctx[8] && create_if_block$z(ctx);
	const after_wrapper_slot_template = /*#slots*/ ctx[17]["after-wrapper"];
	const after_wrapper_slot = create_slot(after_wrapper_slot_template, ctx, /*$$scope*/ ctx[16], get_after_wrapper_slot_context);
	let div1_levels = [{ class: /*classes*/ ctx[5] }, restProps(/*$$restProps*/ ctx[9])];
	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			if (before_wrapper_slot) before_wrapper_slot.c();
			t0 = space();
			div0 = element("div");
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (after_wrapper_slot) after_wrapper_slot.c();
			attr_dev(div0, "class", "swiper-wrapper");
			add_location(div0, file$1i, 86, 2, 2248);
			set_attributes(div1, div1_data);
			add_location(div1, file$1i, 84, 0, 2148);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);

			if (before_wrapper_slot) {
				before_wrapper_slot.m(div1, null);
			}

			append_dev(div1, t0);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			append_dev(div1, t1);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t2);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t3);
			if (if_block2) if_block2.m(div1, null);
			append_dev(div1, t4);

			if (after_wrapper_slot) {
				after_wrapper_slot.m(div1, null);
			}

			/*div1_binding_1*/ ctx[22](div1);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (before_wrapper_slot) {
				if (before_wrapper_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(before_wrapper_slot, before_wrapper_slot_template, ctx, /*$$scope*/ ctx[16], dirty, get_before_wrapper_slot_changes, get_before_wrapper_slot_context);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
				}
			}

			if (/*paginationComputed*/ ctx[6]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$i(ctx);
					if_block0.c();
					if_block0.m(div1, t2);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*scrollbarComputed*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_1$o(ctx);
					if_block1.c();
					if_block1.m(div1, t3);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*navigationComputed*/ ctx[8]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$z(ctx);
					if_block2.c();
					if_block2.m(div1, t4);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (after_wrapper_slot) {
				if (after_wrapper_slot.p && dirty & /*$$scope*/ 65536) {
					update_slot(after_wrapper_slot, after_wrapper_slot_template, ctx, /*$$scope*/ ctx[16], dirty, get_after_wrapper_slot_changes, get_after_wrapper_slot_context);
				}
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty & /*classes*/ 32) && { class: /*classes*/ ctx[5] },
				dirty & /*$$restProps*/ 512 && restProps(/*$$restProps*/ ctx[9])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_wrapper_slot, local);
			transition_in(default_slot, local);
			transition_in(after_wrapper_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_wrapper_slot, local);
			transition_out(default_slot, local);
			transition_out(after_wrapper_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (before_wrapper_slot) before_wrapper_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (if_block2) if_block2.d();
			if (after_wrapper_slot) after_wrapper_slot.d(detaching);
			/*div1_binding_1*/ ctx[22](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$14($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","params","pagination","scrollbar","navigation","init"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Swiper", slots, ['before-wrapper','default','after-wrapper']);
	let { class: className = undefined } = $$props;
	let { params = undefined } = $$props;
	let { pagination = undefined } = $$props;
	let { scrollbar = undefined } = $$props;
	let { navigation = undefined } = $$props;
	let { init = true } = $$props;
	let el;
	let swiper;
	let paginationEl;
	let nextEl;
	let prevEl;
	let scrollbarEl;
	let initialUpdate = false;

	onMount(() => {
		if (!init) return;

		f7.ready(() => {
			const newParams = {
				pagination: {},
				navigation: {},
				scrollbar: {}
			};

			if (params) Utils.extend(newParams, params);
			if (pagination && !newParams.pagination.el) newParams.pagination.el = paginationEl;

			if (navigation && !newParams.navigation.nextEl && !newParams.navigation.prevEl) {
				newParams.navigation.nextEl = nextEl;
				newParams.navigation.prevEl = prevEl;
			}

			if (scrollbar && !newParams.scrollbar.el) newParams.scrollbar.el = scrollbarEl;
			swiper = f7.instance.swiper.create(el, newParams);
		});
	});

	afterUpdate(() => {
		if (!initialUpdate) {
			initialUpdate = true;
			return;
		}

		if (swiper && swiper.update) swiper.update();
	});

	onDestroy(() => {
		if (swiper && swiper.destroy) swiper.destroy();
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			paginationEl = $$value;
			$$invalidate(1, paginationEl);
		});
	}

	function div_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			scrollbarEl = $$value;
			$$invalidate(4, scrollbarEl);
		});
	}

	function div0_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			prevEl = $$value;
			$$invalidate(3, prevEl);
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			nextEl = $$value;
			$$invalidate(2, nextEl);
		});
	}

	function div1_binding_1($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(25, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(10, className = $$new_props.class);
		if ("params" in $$new_props) $$invalidate(11, params = $$new_props.params);
		if ("pagination" in $$new_props) $$invalidate(12, pagination = $$new_props.pagination);
		if ("scrollbar" in $$new_props) $$invalidate(13, scrollbar = $$new_props.scrollbar);
		if ("navigation" in $$new_props) $$invalidate(14, navigation = $$new_props.navigation);
		if ("init" in $$new_props) $$invalidate(15, init = $$new_props.init);
		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		afterUpdate,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		className,
		params,
		pagination,
		scrollbar,
		navigation,
		init,
		el,
		swiper,
		paginationEl,
		nextEl,
		prevEl,
		scrollbarEl,
		initialUpdate,
		classes,
		paginationComputed,
		scrollbarComputed,
		navigationComputed
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(25, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(10, className = $$new_props.className);
		if ("params" in $$props) $$invalidate(11, params = $$new_props.params);
		if ("pagination" in $$props) $$invalidate(12, pagination = $$new_props.pagination);
		if ("scrollbar" in $$props) $$invalidate(13, scrollbar = $$new_props.scrollbar);
		if ("navigation" in $$props) $$invalidate(14, navigation = $$new_props.navigation);
		if ("init" in $$props) $$invalidate(15, init = $$new_props.init);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("swiper" in $$props) swiper = $$new_props.swiper;
		if ("paginationEl" in $$props) $$invalidate(1, paginationEl = $$new_props.paginationEl);
		if ("nextEl" in $$props) $$invalidate(2, nextEl = $$new_props.nextEl);
		if ("prevEl" in $$props) $$invalidate(3, prevEl = $$new_props.prevEl);
		if ("scrollbarEl" in $$props) $$invalidate(4, scrollbarEl = $$new_props.scrollbarEl);
		if ("initialUpdate" in $$props) initialUpdate = $$new_props.initialUpdate;
		if ("classes" in $$props) $$invalidate(5, classes = $$new_props.classes);
		if ("paginationComputed" in $$props) $$invalidate(6, paginationComputed = $$new_props.paginationComputed);
		if ("scrollbarComputed" in $$props) $$invalidate(7, scrollbarComputed = $$new_props.scrollbarComputed);
		if ("navigationComputed" in $$props) $$invalidate(8, navigationComputed = $$new_props.navigationComputed);
	};

	let classes;
	let paginationComputed;
	let scrollbarComputed;
	let navigationComputed;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(5, classes = Utils.classNames(className, "swiper-container", Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*pagination, params*/ 6144) {
			 $$invalidate(6, paginationComputed = (() => {
				if (pagination === true || params && params.pagination && !params.pagination.el) {
					return true;
				}

				return false;
			})());
		}

		if ($$self.$$.dirty & /*scrollbar, params*/ 10240) {
			 $$invalidate(7, scrollbarComputed = (() => {
				if (scrollbar === true || params && params.scrollbar && !params.scrollbar.el) {
					return true;
				}

				return false;
			})());
		}

		if ($$self.$$.dirty & /*navigation, params*/ 18432) {
			 $$invalidate(8, navigationComputed = (() => {
				if (navigation === true || params && params.navigation && !params.navigation.nextEl && !params.navigation.prevEl) {
					return true;
				}

				return false;
			})());
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		paginationEl,
		nextEl,
		prevEl,
		scrollbarEl,
		classes,
		paginationComputed,
		scrollbarComputed,
		navigationComputed,
		$$restProps,
		className,
		params,
		pagination,
		scrollbar,
		navigation,
		init,
		$$scope,
		slots,
		div_binding,
		div_binding_1,
		div0_binding,
		div1_binding,
		div1_binding_1
	];
}

class Swiper extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$14, create_fragment$1j, safe_not_equal, {
			class: 10,
			params: 11,
			pagination: 12,
			scrollbar: 13,
			navigation: 14,
			init: 15
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Swiper",
			options,
			id: create_fragment$1j.name
		});
	}

	get class() {
		throw new Error("<Swiper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get params() {
		throw new Error("<Swiper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set params(value) {
		throw new Error("<Swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get pagination() {
		throw new Error("<Swiper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set pagination(value) {
		throw new Error("<Swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrollbar() {
		throw new Error("<Swiper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scrollbar(value) {
		throw new Error("<Swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get navigation() {
		throw new Error("<Swiper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set navigation(value) {
		throw new Error("<Swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get init() {
		throw new Error("<Swiper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set init(value) {
		throw new Error("<Swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/tab.svelte generated by Svelte v3.31.0 */
const file$1j = "node_modules/framework7-svelte/components/tab.svelte";

// (72:2) {#if tabContent}
function create_if_block$A(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*tabContent*/ ctx[1].props];
	var switch_value = /*tabContent*/ ctx[1].component;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty & /*tabContent*/ 2)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*tabContent*/ ctx[1].props)])
			: {};

			if (switch_value !== (switch_value = /*tabContent*/ ctx[1].component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$A.name,
		type: "if",
		source: "(72:2) {#if tabContent}",
		ctx
	});

	return block;
}

function create_fragment$1k(ctx) {
	let div;
	let t;
	let current;
	let if_block = /*tabContent*/ ctx[1] && create_if_block$A(ctx);
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
	let div_levels = [{ class: /*classes*/ ctx[2] }, restProps(/*$$restProps*/ ctx[3])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$1j, 70, 0, 1746);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_dev(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[9](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*tabContent*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*tabContent*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$A(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 4) && { class: /*classes*/ ctx[2] },
				dirty & /*$$restProps*/ 8 && restProps(/*$$restProps*/ ctx[3])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[9](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$15($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","tabActive","show"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Tab", slots, ['default']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { tabActive = false } = $$props;
	let el;
	let tabContent = null;
	let routerData = null;

	function onTabShow(tabEl) {
		if (tabEl !== el) return;
		dispatch("tabShow");
		if (typeof $$props.onTabShow === "function") $$props.onTabShow(tabEl);
	}

	function onTabHide(tabEl) {
		if (tabEl !== el) return;
		dispatch("tabHide");
		if (typeof $$props.onTabHide === "function") $$props.onTabHide(tabEl);
	}

	onMount(() => {
		f7.ready(() => {
			routerData = {
				el,
				setTabContent(tc) {
					tick().then(() => {
						$$invalidate(1, tabContent = tc);
					});
				}
			};

			f7.routers.tabs.push(routerData);
			f7.instance.on("tabShow", onTabShow);
			f7.instance.on("tabHide", onTabHide);
		});
	});

	afterUpdate(() => {
		if (!routerData) return;
		f7.events.emit("tabRouterDidUpdate", routerData);
	});

	onDestroy(() => {
		if (f7.instance) {
			f7.instance.off("tabShow", onTabShow);
			f7.instance.off("tabHide", onTabHide);
		}

		if (!routerData) return;
		f7.routers.tabs.splice(f7.routers.tabs.indexOf(routerData), 1);
		routerData = null;
	});

	function show(animate) {
		if (!f7.instance) return;
		f7.instance.tab.show(el, animate);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(0, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
		if ("tabActive" in $$new_props) $$invalidate(5, tabActive = $$new_props.tabActive);
		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		afterUpdate,
		createEventDispatcher,
		tick,
		Utils,
		restProps,
		Mixins,
		f7,
		dispatch,
		className,
		tabActive,
		el,
		tabContent,
		routerData,
		onTabShow,
		onTabHide,
		show,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(14, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
		if ("tabActive" in $$props) $$invalidate(5, tabActive = $$new_props.tabActive);
		if ("el" in $$props) $$invalidate(0, el = $$new_props.el);
		if ("tabContent" in $$props) $$invalidate(1, tabContent = $$new_props.tabContent);
		if ("routerData" in $$props) routerData = $$new_props.routerData;
		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(2, classes = Utils.classNames(className, "tab", tabActive && "tab-active", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);

	return [
		el,
		tabContent,
		classes,
		$$restProps,
		className,
		tabActive,
		show,
		$$scope,
		slots,
		div_binding
	];
}

class Tab extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$15, create_fragment$1k, safe_not_equal, { class: 4, tabActive: 5, show: 6 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tab",
			options,
			id: create_fragment$1k.name
		});
	}

	get class() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabActive() {
		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabActive(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show() {
		return this.$$.ctx[6];
	}

	set show(value) {
		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/tabs.svelte generated by Svelte v3.31.0 */
const file$1k = "node_modules/framework7-svelte/components/tabs.svelte";

// (42:0) {:else}
function create_else_block$d(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

	let div_levels = [
		{
			class: div_class_value = Utils.classNames(/*tabsClasses*/ ctx[5], /*classes*/ ctx[3])
		},
		restProps(/*$$restProps*/ ctx[6])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$1k, 42, 2, 1016);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1024) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*tabsClasses, classes*/ 40 && div_class_value !== (div_class_value = Utils.classNames(/*tabsClasses*/ ctx[5], /*classes*/ ctx[3]))) && { class: div_class_value },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$d.name,
		type: "else",
		source: "(42:0) {:else}",
		ctx
	});

	return block;
}

// (36:0) {#if animated || swipeable}
function create_if_block$B(ctx) {
	let div1;
	let div0;
	let div1_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

	let div1_levels = [
		{
			class: div1_class_value = Utils.classNames(/*wrapClasses*/ ctx[4], /*classes*/ ctx[3])
		},
		restProps(/*$$restProps*/ ctx[6])
	];

	let div1_data = {};

	for (let i = 0; i < div1_levels.length; i += 1) {
		div1_data = assign(div1_data, div1_levels[i]);
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div0, "class", /*tabsClasses*/ ctx[5]);
			add_location(div0, file$1k, 37, 4, 945);
			set_attributes(div1, div1_data);
			add_location(div1, file$1k, 36, 2, 841);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div1_binding*/ ctx[12](div1);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1024) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, null, null);
				}
			}

			if (!current || dirty & /*tabsClasses*/ 32) {
				attr_dev(div0, "class", /*tabsClasses*/ ctx[5]);
			}

			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
				(!current || dirty & /*wrapClasses, classes*/ 24 && div1_class_value !== (div1_class_value = Utils.classNames(/*wrapClasses*/ ctx[4], /*classes*/ ctx[3]))) && { class: div1_class_value },
				dirty & /*$$restProps*/ 64 && restProps(/*$$restProps*/ ctx[6])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (default_slot) default_slot.d(detaching);
			/*div1_binding*/ ctx[12](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$B.name,
		type: "if",
		source: "(36:0) {#if animated || swipeable}",
		ctx
	});

	return block;
}

function create_fragment$1l(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$B, create_else_block$d];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*animated*/ ctx[0] || /*swipeable*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$16($$self, $$props, $$invalidate) {
	const omit_props_names = ["class","animated","swipeable","routable","swiperParams"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Tabs", slots, ['default']);
	let { class: className = undefined } = $$props;
	let { animated = false } = $$props;
	let { swipeable = false } = $$props;
	let { routable = false } = $$props;
	let { swiperParams = undefined } = $$props;
	let wrapEl;

	onMount(() => {
		if (swipeable && swiperParams && wrapEl) {
			$$invalidate(2, wrapEl.f7SwiperParams = swiperParams, wrapEl);
		}
	});

	function div1_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			wrapEl = $$value;
			$$invalidate(2, wrapEl);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(7, className = $$new_props.class);
		if ("animated" in $$new_props) $$invalidate(0, animated = $$new_props.animated);
		if ("swipeable" in $$new_props) $$invalidate(1, swipeable = $$new_props.swipeable);
		if ("routable" in $$new_props) $$invalidate(8, routable = $$new_props.routable);
		if ("swiperParams" in $$new_props) $$invalidate(9, swiperParams = $$new_props.swiperParams);
		if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		Utils,
		restProps,
		Mixins,
		className,
		animated,
		swipeable,
		routable,
		swiperParams,
		wrapEl,
		classes,
		wrapClasses,
		tabsClasses
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(7, className = $$new_props.className);
		if ("animated" in $$props) $$invalidate(0, animated = $$new_props.animated);
		if ("swipeable" in $$props) $$invalidate(1, swipeable = $$new_props.swipeable);
		if ("routable" in $$props) $$invalidate(8, routable = $$new_props.routable);
		if ("swiperParams" in $$props) $$invalidate(9, swiperParams = $$new_props.swiperParams);
		if ("wrapEl" in $$props) $$invalidate(2, wrapEl = $$new_props.wrapEl);
		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
		if ("wrapClasses" in $$props) $$invalidate(4, wrapClasses = $$new_props.wrapClasses);
		if ("tabsClasses" in $$props) $$invalidate(5, tabsClasses = $$new_props.tabsClasses);
	};

	let classes;
	let wrapClasses;
	let tabsClasses;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(3, classes = Utils.classNames(className, Mixins.colorClasses($$props)));

		if ($$self.$$.dirty & /*animated, swipeable*/ 3) {
			 $$invalidate(4, wrapClasses = Utils.classNames({
				"tabs-animated-wrap": animated,
				"tabs-swipeable-wrap": swipeable
			}));
		}

		if ($$self.$$.dirty & /*routable*/ 256) {
			 $$invalidate(5, tabsClasses = Utils.classNames({ tabs: true, "tabs-routable": routable }));
		}
	};

	$$props = exclude_internal_props($$props);

	return [
		animated,
		swipeable,
		wrapEl,
		classes,
		wrapClasses,
		tabsClasses,
		$$restProps,
		className,
		routable,
		swiperParams,
		$$scope,
		slots,
		div1_binding
	];
}

class Tabs extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$16, create_fragment$1l, safe_not_equal, {
			class: 7,
			animated: 0,
			swipeable: 1,
			routable: 8,
			swiperParams: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tabs",
			options,
			id: create_fragment$1l.name
		});
	}

	get class() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get animated() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set animated(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swipeable() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swipeable(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get routable() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set routable(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get swiperParams() {
		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set swiperParams(value) {
		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/toolbar.svelte generated by Svelte v3.31.0 */
const file$1l = "node_modules/framework7-svelte/components/toolbar.svelte";
const get_after_inner_slot_changes$4 = dirty => ({});
const get_after_inner_slot_context$4 = ctx => ({});
const get_before_inner_slot_changes$4 = dirty => ({});
const get_before_inner_slot_context$4 = ctx => ({});

// (98:2) {:else}
function create_else_block$e(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[24].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8388608) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[23], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$e.name,
		type: "else",
		source: "(98:2) {:else}",
		ctx
	});

	return block;
}

// (94:2) {#if inner}
function create_if_block$C(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[24].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr_dev(div, "class", "toolbar-inner");
			add_location(div, file$1l, 94, 4, 2753);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8388608) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[23], dirty, null, null);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$C.name,
		type: "if",
		source: "(94:2) {#if inner}",
		ctx
	});

	return block;
}

function create_fragment$1m(ctx) {
	let div;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let current;
	const before_inner_slot_template = /*#slots*/ ctx[24]["before-inner"];
	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[23], get_before_inner_slot_context$4);
	const if_block_creators = [create_if_block$C, create_else_block$e];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*inner*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const after_inner_slot_template = /*#slots*/ ctx[24]["after-inner"];
	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[23], get_after_inner_slot_context$4);

	let div_levels = [
		{ class: /*classes*/ ctx[3] },
		{ "data-f7-slot": /*f7Slot*/ ctx[1] },
		restProps(/*$$restProps*/ ctx[4])
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (before_inner_slot) before_inner_slot.c();
			t0 = space();
			if_block.c();
			t1 = space();
			if (after_inner_slot) after_inner_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$1l, 91, 0, 2617);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (before_inner_slot) {
				before_inner_slot.m(div, null);
			}

			append_dev(div, t0);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t1);

			if (after_inner_slot) {
				after_inner_slot.m(div, null);
			}

			/*div_binding*/ ctx[25](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (before_inner_slot) {
				if (before_inner_slot.p && dirty & /*$$scope*/ 8388608) {
					update_slot(before_inner_slot, before_inner_slot_template, ctx, /*$$scope*/ ctx[23], dirty, get_before_inner_slot_changes$4, get_before_inner_slot_context$4);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, t1);
			}

			if (after_inner_slot) {
				if (after_inner_slot.p && dirty & /*$$scope*/ 8388608) {
					update_slot(after_inner_slot, after_inner_slot_template, ctx, /*$$scope*/ ctx[23], dirty, get_after_inner_slot_changes$4, get_after_inner_slot_context$4);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				(!current || dirty & /*f7Slot*/ 2) && { "data-f7-slot": /*f7Slot*/ ctx[1] },
				dirty & /*$$restProps*/ 16 && restProps(/*$$restProps*/ ctx[4])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(before_inner_slot, local);
			transition_in(if_block);
			transition_in(after_inner_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(before_inner_slot, local);
			transition_out(if_block);
			transition_out(after_inner_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (before_inner_slot) before_inner_slot.d(detaching);
			if_blocks[current_block_type_index].d();
			if (after_inner_slot) after_inner_slot.d(detaching);
			/*div_binding*/ ctx[25](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$17($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","tabbar","labels","scrollable","hidden","noShadow","noHairline","noBorder","position","topMd","topIos","topAurora","top","bottomMd","bottomIos","bottomAurora","bottom","inner","f7Slot"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Toolbar", slots, ['before-inner','default','after-inner']);
	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { tabbar = false } = $$props;
	let { labels = false } = $$props;
	let { scrollable = false } = $$props;
	let { hidden = false } = $$props;
	let { noShadow = false } = $$props;
	let { noHairline = false } = $$props;
	let { noBorder = false } = $$props;
	let { position = undefined } = $$props;
	let { topMd = undefined } = $$props;
	let { topIos = undefined } = $$props;
	let { topAurora = undefined } = $$props;
	let { top = undefined } = $$props;
	let { bottomMd = undefined } = $$props;
	let { bottomIos = undefined } = $$props;
	let { bottomAurora = undefined } = $$props;
	let { bottom = undefined } = $$props;
	let { inner = true } = $$props;
	let { f7Slot = "fixed" } = $$props;
	let el;

	// eslint-disable-next-line
	let _theme = f7.instance ? f7Theme : null;

	if (!f7.instance) {
		f7.ready(() => {
			$$invalidate(22, _theme = f7Theme);
		});
	}

	function onShow(toolbarEl) {
		if (el !== toolbarEl) return;
		dispatch("toolbarShow");
		if (typeof $$props.onToolbarShow === "function") $$props.onToolbarShow();
	}

	function onHide(toolbarEl) {
		if (el !== toolbarEl) return;
		dispatch("toolbarHide");
		if (typeof $$props.onToolbarHide === "function") $$props.onToolbarHide();
	}

	onMount(() => {
		f7.ready(() => {
			if (tabbar) f7.instance.toolbar.setHighlight(el);
			f7.instance.on("toolbarShow", onShow);
			f7.instance.on("toolbarHide", onHide);
		});
	});

	afterUpdate(() => {
		if (tabbar && f7.instance && el) {
			f7.instance.toolbar.setHighlight(el);
		}
	});

	onDestroy(() => {
		if (!f7.instance) return;
		f7.instance.off("toolbarShow", onShow);
		f7.instance.off("toolbarHide", onHide);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(29, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(5, className = $$new_props.class);
		if ("tabbar" in $$new_props) $$invalidate(6, tabbar = $$new_props.tabbar);
		if ("labels" in $$new_props) $$invalidate(7, labels = $$new_props.labels);
		if ("scrollable" in $$new_props) $$invalidate(8, scrollable = $$new_props.scrollable);
		if ("hidden" in $$new_props) $$invalidate(9, hidden = $$new_props.hidden);
		if ("noShadow" in $$new_props) $$invalidate(10, noShadow = $$new_props.noShadow);
		if ("noHairline" in $$new_props) $$invalidate(11, noHairline = $$new_props.noHairline);
		if ("noBorder" in $$new_props) $$invalidate(12, noBorder = $$new_props.noBorder);
		if ("position" in $$new_props) $$invalidate(13, position = $$new_props.position);
		if ("topMd" in $$new_props) $$invalidate(14, topMd = $$new_props.topMd);
		if ("topIos" in $$new_props) $$invalidate(15, topIos = $$new_props.topIos);
		if ("topAurora" in $$new_props) $$invalidate(16, topAurora = $$new_props.topAurora);
		if ("top" in $$new_props) $$invalidate(17, top = $$new_props.top);
		if ("bottomMd" in $$new_props) $$invalidate(18, bottomMd = $$new_props.bottomMd);
		if ("bottomIos" in $$new_props) $$invalidate(19, bottomIos = $$new_props.bottomIos);
		if ("bottomAurora" in $$new_props) $$invalidate(20, bottomAurora = $$new_props.bottomAurora);
		if ("bottom" in $$new_props) $$invalidate(21, bottom = $$new_props.bottom);
		if ("inner" in $$new_props) $$invalidate(0, inner = $$new_props.inner);
		if ("f7Slot" in $$new_props) $$invalidate(1, f7Slot = $$new_props.f7Slot);
		if ("$$scope" in $$new_props) $$invalidate(23, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		afterUpdate,
		Mixins,
		Utils,
		restProps,
		theme: f7Theme,
		f7,
		dispatch,
		className,
		tabbar,
		labels,
		scrollable,
		hidden,
		noShadow,
		noHairline,
		noBorder,
		position,
		topMd,
		topIos,
		topAurora,
		top,
		bottomMd,
		bottomIos,
		bottomAurora,
		bottom,
		inner,
		f7Slot,
		el,
		_theme,
		onShow,
		onHide,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(29, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(5, className = $$new_props.className);
		if ("tabbar" in $$props) $$invalidate(6, tabbar = $$new_props.tabbar);
		if ("labels" in $$props) $$invalidate(7, labels = $$new_props.labels);
		if ("scrollable" in $$props) $$invalidate(8, scrollable = $$new_props.scrollable);
		if ("hidden" in $$props) $$invalidate(9, hidden = $$new_props.hidden);
		if ("noShadow" in $$props) $$invalidate(10, noShadow = $$new_props.noShadow);
		if ("noHairline" in $$props) $$invalidate(11, noHairline = $$new_props.noHairline);
		if ("noBorder" in $$props) $$invalidate(12, noBorder = $$new_props.noBorder);
		if ("position" in $$props) $$invalidate(13, position = $$new_props.position);
		if ("topMd" in $$props) $$invalidate(14, topMd = $$new_props.topMd);
		if ("topIos" in $$props) $$invalidate(15, topIos = $$new_props.topIos);
		if ("topAurora" in $$props) $$invalidate(16, topAurora = $$new_props.topAurora);
		if ("top" in $$props) $$invalidate(17, top = $$new_props.top);
		if ("bottomMd" in $$props) $$invalidate(18, bottomMd = $$new_props.bottomMd);
		if ("bottomIos" in $$props) $$invalidate(19, bottomIos = $$new_props.bottomIos);
		if ("bottomAurora" in $$props) $$invalidate(20, bottomAurora = $$new_props.bottomAurora);
		if ("bottom" in $$props) $$invalidate(21, bottom = $$new_props.bottom);
		if ("inner" in $$props) $$invalidate(0, inner = $$new_props.inner);
		if ("f7Slot" in $$props) $$invalidate(1, f7Slot = $$new_props.f7Slot);
		if ("el" in $$props) $$invalidate(2, el = $$new_props.el);
		if ("_theme" in $$props) $$invalidate(22, _theme = $$new_props._theme);
		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(3, classes = Utils.classNames(
			className,
			"toolbar",
			{
				tabbar,
				"toolbar-bottom": _theme && _theme.md && bottomMd || _theme && _theme.ios && bottomIos || _theme && _theme.aurora && bottomAurora || bottom || position === "bottom",
				"toolbar-top": _theme && _theme.md && topMd || _theme && _theme.ios && topIos || _theme && _theme.aurora && topAurora || top || position === "top",
				"tabbar-labels": labels,
				"tabbar-scrollable": scrollable,
				"toolbar-hidden": hidden,
				"no-shadow": noShadow,
				"no-hairline": noHairline || noBorder
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		inner,
		f7Slot,
		el,
		classes,
		$$restProps,
		className,
		tabbar,
		labels,
		scrollable,
		hidden,
		noShadow,
		noHairline,
		noBorder,
		position,
		topMd,
		topIos,
		topAurora,
		top,
		bottomMd,
		bottomIos,
		bottomAurora,
		bottom,
		_theme,
		$$scope,
		slots,
		div_binding
	];
}

class Toolbar extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$17, create_fragment$1m, safe_not_equal, {
			class: 5,
			tabbar: 6,
			labels: 7,
			scrollable: 8,
			hidden: 9,
			noShadow: 10,
			noHairline: 11,
			noBorder: 12,
			position: 13,
			topMd: 14,
			topIos: 15,
			topAurora: 16,
			top: 17,
			bottomMd: 18,
			bottomIos: 19,
			bottomAurora: 20,
			bottom: 21,
			inner: 0,
			f7Slot: 1
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Toolbar",
			options,
			id: create_fragment$1m.name
		});
	}

	get class() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tabbar() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabbar(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get labels() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set labels(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get scrollable() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set scrollable(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hidden() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hidden(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noShadow() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noShadow(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noHairline() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noHairline(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noBorder() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noBorder(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get position() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set position(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get topMd() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set topMd(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get topIos() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set topIos(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get topAurora() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set topAurora(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get top() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set top(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bottomMd() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bottomMd(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bottomIos() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bottomIos(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bottomAurora() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bottomAurora(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bottom() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bottom(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get inner() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set inner(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get f7Slot() {
		throw new Error("<Toolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set f7Slot(value) {
		throw new Error("<Toolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/treeview-item.svelte generated by Svelte v3.31.0 */
const file$1m = "node_modules/framework7-svelte/components/treeview-item.svelte";
const get_children_slot_changes = dirty => ({});
const get_children_slot_context = ctx => ({});
const get_children_start_slot_changes = dirty => ({});
const get_children_start_slot_context = ctx => ({});
const get_root_end_slot_changes_1 = dirty => ({});
const get_root_end_slot_context_1 = ctx => ({});
const get_root_slot_changes_1 = dirty => ({});
const get_root_slot_context_1 = ctx => ({});
const get_content_end_slot_changes_1$2 = dirty => ({});
const get_content_end_slot_context_1$2 = ctx => ({});
const get_content_slot_changes_1$2 = dirty => ({});
const get_content_slot_context_1$2 = ctx => ({});
const get_label_slot_changes_1$1 = dirty => ({});
const get_label_slot_context_1$1 = ctx => ({});
const get_label_start_slot_changes_1 = dirty => ({});
const get_label_start_slot_context_1 = ctx => ({});
const get_media_slot_changes_1$2 = dirty => ({});
const get_media_slot_context_1$2 = ctx => ({});
const get_content_start_slot_changes_1$2 = dirty => ({});
const get_content_start_slot_context_1$2 = ctx => ({});
const get_root_start_slot_changes_1 = dirty => ({});
const get_root_start_slot_context_1 = ctx => ({});
const get_root_end_slot_changes$3 = dirty => ({});
const get_root_end_slot_context$3 = ctx => ({});
const get_root_slot_changes$4 = dirty => ({});
const get_root_slot_context$4 = ctx => ({});
const get_content_end_slot_changes$3 = dirty => ({});
const get_content_end_slot_context$3 = ctx => ({});
const get_content_slot_changes$3 = dirty => ({});
const get_content_slot_context$3 = ctx => ({});
const get_label_slot_changes$1 = dirty => ({});
const get_label_slot_context$1 = ctx => ({});
const get_label_start_slot_changes = dirty => ({});
const get_label_start_slot_context = ctx => ({});
const get_media_slot_changes$4 = dirty => ({});
const get_media_slot_context$4 = ctx => ({});
const get_content_start_slot_changes$3 = dirty => ({});
const get_content_start_slot_context$3 = ctx => ({});
const get_root_start_slot_changes$3 = dirty => ({});
const get_root_start_slot_context$3 = ctx => ({});

// (142:2) {:else}
function create_else_block$f(ctx) {
	let a;
	let t0;
	let t1;
	let div1;
	let t2;
	let t3;
	let t4;
	let div0;
	let t5;
	let t6_value = Utils.text(/*label*/ ctx[0]) + "";
	let t6;
	let t7;
	let t8;
	let t9;
	let t10;
	let t11;
	let current;
	let mounted;
	let dispose;
	const root_start_slot_template = /*#slots*/ ctx[21]["root-start"];
	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[20], get_root_start_slot_context_1);
	let if_block0 = /*needToggle*/ ctx[6] && create_if_block_5$4(ctx);
	const content_start_slot_template = /*#slots*/ ctx[21]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[20], get_content_start_slot_context_1$2);
	let if_block1 = /*hasIcon*/ ctx[7] && create_if_block_4$8(ctx);
	const media_slot_template = /*#slots*/ ctx[21].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[20], get_media_slot_context_1$2);
	const label_start_slot_template = /*#slots*/ ctx[21]["label-start"];
	const label_start_slot = create_slot(label_start_slot_template, ctx, /*$$scope*/ ctx[20], get_label_start_slot_context_1);
	const label_slot_template = /*#slots*/ ctx[21].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[20], get_label_slot_context_1$1);
	const content_slot_template = /*#slots*/ ctx[21].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[20], get_content_slot_context_1$2);
	const content_end_slot_template = /*#slots*/ ctx[21]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[20], get_content_end_slot_context_1$2);
	const root_slot_template = /*#slots*/ ctx[21].root;
	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[20], get_root_slot_context_1);
	const root_end_slot_template = /*#slots*/ ctx[21]["root-end"];
	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[20], get_root_end_slot_context_1);
	let a_levels = [{ class: /*itemRootClasses*/ ctx[4] }, /*itemRootAttrs*/ ctx[5]];
	let a_data = {};

	for (let i = 0; i < a_levels.length; i += 1) {
		a_data = assign(a_data, a_levels[i]);
	}

	const block = {
		c: function create() {
			a = element("a");
			if (root_start_slot) root_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (media_slot) media_slot.c();
			t4 = space();
			div0 = element("div");
			if (label_start_slot) label_start_slot.c();
			t5 = space();
			t6 = text(t6_value);
			t7 = space();
			if (label_slot) label_slot.c();
			t8 = space();
			if (content_slot) content_slot.c();
			t9 = space();
			if (content_end_slot) content_end_slot.c();
			t10 = space();
			if (root_slot) root_slot.c();
			t11 = space();
			if (root_end_slot) root_end_slot.c();
			attr_dev(div0, "class", "treeview-item-label");
			add_location(div0, file$1m, 166, 8, 4827);
			attr_dev(div1, "class", "treeview-item-content");
			add_location(div1, file$1m, 151, 6, 4362);
			set_attributes(a, a_data);
			add_location(a, file$1m, 142, 4, 4155);
		},
		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);

			if (root_start_slot) {
				root_start_slot.m(a, null);
			}

			append_dev(a, t0);
			if (if_block0) if_block0.m(a, null);
			append_dev(a, t1);
			append_dev(a, div1);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_dev(div1, t2);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t3);

			if (media_slot) {
				media_slot.m(div1, null);
			}

			append_dev(div1, t4);
			append_dev(div1, div0);

			if (label_start_slot) {
				label_start_slot.m(div0, null);
			}

			append_dev(div0, t5);
			append_dev(div0, t6);
			append_dev(div0, t7);

			if (label_slot) {
				label_slot.m(div0, null);
			}

			append_dev(div1, t8);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			append_dev(div1, t9);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			append_dev(a, t10);

			if (root_slot) {
				root_slot.m(a, null);
			}

			append_dev(a, t11);

			if (root_end_slot) {
				root_end_slot.m(a, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(a, "click", /*onClick*/ ctx[9], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (root_start_slot) {
				if (root_start_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(root_start_slot, root_start_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_root_start_slot_changes_1, get_root_start_slot_context_1);
				}
			}

			if (/*needToggle*/ ctx[6]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_5$4(ctx);
					if_block0.c();
					if_block0.m(a, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (content_start_slot) {
				if (content_start_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_content_start_slot_changes_1$2, get_content_start_slot_context_1$2);
				}
			}

			if (/*hasIcon*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*hasIcon*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_4$8(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (media_slot) {
				if (media_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_media_slot_changes_1$2, get_media_slot_context_1$2);
				}
			}

			if (label_start_slot) {
				if (label_start_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(label_start_slot, label_start_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_label_start_slot_changes_1, get_label_start_slot_context_1);
				}
			}

			if ((!current || dirty & /*label*/ 1) && t6_value !== (t6_value = Utils.text(/*label*/ ctx[0]) + "")) set_data_dev(t6, t6_value);

			if (label_slot) {
				if (label_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(label_slot, label_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_label_slot_changes_1$1, get_label_slot_context_1$1);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_content_slot_changes_1$2, get_content_slot_context_1$2);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_content_end_slot_changes_1$2, get_content_end_slot_context_1$2);
				}
			}

			if (root_slot) {
				if (root_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(root_slot, root_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_root_slot_changes_1, get_root_slot_context_1);
				}
			}

			if (root_end_slot) {
				if (root_end_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(root_end_slot, root_end_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_root_end_slot_changes_1, get_root_end_slot_context_1);
				}
			}

			set_attributes(a, a_data = get_spread_update(a_levels, [
				(!current || dirty & /*itemRootClasses*/ 16) && { class: /*itemRootClasses*/ ctx[4] },
				dirty & /*itemRootAttrs*/ 32 && /*itemRootAttrs*/ ctx[5]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(root_start_slot, local);
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(media_slot, local);
			transition_in(label_start_slot, local);
			transition_in(label_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			transition_in(root_slot, local);
			transition_in(root_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(root_start_slot, local);
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(media_slot, local);
			transition_out(label_start_slot, local);
			transition_out(label_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			transition_out(root_slot, local);
			transition_out(root_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
			if (root_start_slot) root_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (media_slot) media_slot.d(detaching);
			if (label_start_slot) label_start_slot.d(detaching);
			if (label_slot) label_slot.d(detaching);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			if (root_slot) root_slot.d(detaching);
			if (root_end_slot) root_end_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$f.name,
		type: "else",
		source: "(142:2) {:else}",
		ctx
	});

	return block;
}

// (106:2) {#if treeviewRootTag === 'div'}
function create_if_block_1$p(ctx) {
	let div2;
	let t0;
	let t1;
	let div1;
	let t2;
	let t3;
	let t4;
	let div0;
	let t5;
	let t6_value = Utils.text(/*label*/ ctx[0]) + "";
	let t6;
	let t7;
	let t8;
	let t9;
	let t10;
	let t11;
	let current;
	let mounted;
	let dispose;
	const root_start_slot_template = /*#slots*/ ctx[21]["root-start"];
	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[20], get_root_start_slot_context$3);
	let if_block0 = /*needToggle*/ ctx[6] && create_if_block_3$f(ctx);
	const content_start_slot_template = /*#slots*/ ctx[21]["content-start"];
	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[20], get_content_start_slot_context$3);
	let if_block1 = /*hasIcon*/ ctx[7] && create_if_block_2$j(ctx);
	const media_slot_template = /*#slots*/ ctx[21].media;
	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[20], get_media_slot_context$4);
	const label_start_slot_template = /*#slots*/ ctx[21]["label-start"];
	const label_start_slot = create_slot(label_start_slot_template, ctx, /*$$scope*/ ctx[20], get_label_start_slot_context);
	const label_slot_template = /*#slots*/ ctx[21].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[20], get_label_slot_context$1);
	const content_slot_template = /*#slots*/ ctx[21].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[20], get_content_slot_context$3);
	const content_end_slot_template = /*#slots*/ ctx[21]["content-end"];
	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[20], get_content_end_slot_context$3);
	const root_slot_template = /*#slots*/ ctx[21].root;
	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[20], get_root_slot_context$4);
	const root_end_slot_template = /*#slots*/ ctx[21]["root-end"];
	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[20], get_root_end_slot_context$3);
	let div2_levels = [{ class: /*itemRootClasses*/ ctx[4] }, /*itemRootAttrs*/ ctx[5]];
	let div2_data = {};

	for (let i = 0; i < div2_levels.length; i += 1) {
		div2_data = assign(div2_data, div2_levels[i]);
	}

	const block = {
		c: function create() {
			div2 = element("div");
			if (root_start_slot) root_start_slot.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			div1 = element("div");
			if (content_start_slot) content_start_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (media_slot) media_slot.c();
			t4 = space();
			div0 = element("div");
			if (label_start_slot) label_start_slot.c();
			t5 = space();
			t6 = text(t6_value);
			t7 = space();
			if (label_slot) label_slot.c();
			t8 = space();
			if (content_slot) content_slot.c();
			t9 = space();
			if (content_end_slot) content_end_slot.c();
			t10 = space();
			if (root_slot) root_slot.c();
			t11 = space();
			if (root_end_slot) root_end_slot.c();
			attr_dev(div0, "class", "treeview-item-label");
			add_location(div0, file$1m, 130, 8, 3842);
			attr_dev(div1, "class", "treeview-item-content");
			add_location(div1, file$1m, 115, 6, 3377);
			set_attributes(div2, div2_data);
			add_location(div2, file$1m, 106, 4, 3168);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);

			if (root_start_slot) {
				root_start_slot.m(div2, null);
			}

			append_dev(div2, t0);
			if (if_block0) if_block0.m(div2, null);
			append_dev(div2, t1);
			append_dev(div2, div1);

			if (content_start_slot) {
				content_start_slot.m(div1, null);
			}

			append_dev(div1, t2);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div1, t3);

			if (media_slot) {
				media_slot.m(div1, null);
			}

			append_dev(div1, t4);
			append_dev(div1, div0);

			if (label_start_slot) {
				label_start_slot.m(div0, null);
			}

			append_dev(div0, t5);
			append_dev(div0, t6);
			append_dev(div0, t7);

			if (label_slot) {
				label_slot.m(div0, null);
			}

			append_dev(div1, t8);

			if (content_slot) {
				content_slot.m(div1, null);
			}

			append_dev(div1, t9);

			if (content_end_slot) {
				content_end_slot.m(div1, null);
			}

			append_dev(div2, t10);

			if (root_slot) {
				root_slot.m(div2, null);
			}

			append_dev(div2, t11);

			if (root_end_slot) {
				root_end_slot.m(div2, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(div2, "click", /*onClick*/ ctx[9], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (root_start_slot) {
				if (root_start_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(root_start_slot, root_start_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_root_start_slot_changes$3, get_root_start_slot_context$3);
				}
			}

			if (/*needToggle*/ ctx[6]) {
				if (if_block0) ; else {
					if_block0 = create_if_block_3$f(ctx);
					if_block0.c();
					if_block0.m(div2, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (content_start_slot) {
				if (content_start_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(content_start_slot, content_start_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_content_start_slot_changes$3, get_content_start_slot_context$3);
				}
			}

			if (/*hasIcon*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*hasIcon*/ 128) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2$j(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, t3);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (media_slot) {
				if (media_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(media_slot, media_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_media_slot_changes$4, get_media_slot_context$4);
				}
			}

			if (label_start_slot) {
				if (label_start_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(label_start_slot, label_start_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_label_start_slot_changes, get_label_start_slot_context);
				}
			}

			if ((!current || dirty & /*label*/ 1) && t6_value !== (t6_value = Utils.text(/*label*/ ctx[0]) + "")) set_data_dev(t6, t6_value);

			if (label_slot) {
				if (label_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(label_slot, label_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_label_slot_changes$1, get_label_slot_context$1);
				}
			}

			if (content_slot) {
				if (content_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_content_slot_changes$3, get_content_slot_context$3);
				}
			}

			if (content_end_slot) {
				if (content_end_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(content_end_slot, content_end_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_content_end_slot_changes$3, get_content_end_slot_context$3);
				}
			}

			if (root_slot) {
				if (root_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(root_slot, root_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_root_slot_changes$4, get_root_slot_context$4);
				}
			}

			if (root_end_slot) {
				if (root_end_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(root_end_slot, root_end_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_root_end_slot_changes$3, get_root_end_slot_context$3);
				}
			}

			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
				(!current || dirty & /*itemRootClasses*/ 16) && { class: /*itemRootClasses*/ ctx[4] },
				dirty & /*itemRootAttrs*/ 32 && /*itemRootAttrs*/ ctx[5]
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(root_start_slot, local);
			transition_in(content_start_slot, local);
			transition_in(if_block1);
			transition_in(media_slot, local);
			transition_in(label_start_slot, local);
			transition_in(label_slot, local);
			transition_in(content_slot, local);
			transition_in(content_end_slot, local);
			transition_in(root_slot, local);
			transition_in(root_end_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(root_start_slot, local);
			transition_out(content_start_slot, local);
			transition_out(if_block1);
			transition_out(media_slot, local);
			transition_out(label_start_slot, local);
			transition_out(label_slot, local);
			transition_out(content_slot, local);
			transition_out(content_end_slot, local);
			transition_out(root_slot, local);
			transition_out(root_end_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (root_start_slot) root_start_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (content_start_slot) content_start_slot.d(detaching);
			if (if_block1) if_block1.d();
			if (media_slot) media_slot.d(detaching);
			if (label_start_slot) label_start_slot.d(detaching);
			if (label_slot) label_slot.d(detaching);
			if (content_slot) content_slot.d(detaching);
			if (content_end_slot) content_end_slot.d(detaching);
			if (root_slot) root_slot.d(detaching);
			if (root_end_slot) root_end_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$p.name,
		type: "if",
		source: "(106:2) {#if treeviewRootTag === 'div'}",
		ctx
	});

	return block;
}

// (149:6) {#if needToggle}
function create_if_block_5$4(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "treeview-toggle");
			add_location(div, file$1m, 149, 8, 4308);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5$4.name,
		type: "if",
		source: "(149:6) {#if needToggle}",
		ctx
	});

	return block;
}

// (154:8) {#if hasIcon}
function create_if_block_4$8(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				material: /*$$props*/ ctx[10].iconMaterial,
				f7: /*$$props*/ ctx[10].iconF7,
				icon: /*$$props*/ ctx[10].icon,
				md: /*$$props*/ ctx[10].iconMd,
				ios: /*$$props*/ ctx[10].iconIos,
				aurora: /*$$props*/ ctx[10].iconAurora,
				color: /*$$props*/ ctx[10].iconColor,
				size: /*$$props*/ ctx[10].iconSize
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*$$props*/ 1024) icon_changes.material = /*$$props*/ ctx[10].iconMaterial;
			if (dirty & /*$$props*/ 1024) icon_changes.f7 = /*$$props*/ ctx[10].iconF7;
			if (dirty & /*$$props*/ 1024) icon_changes.icon = /*$$props*/ ctx[10].icon;
			if (dirty & /*$$props*/ 1024) icon_changes.md = /*$$props*/ ctx[10].iconMd;
			if (dirty & /*$$props*/ 1024) icon_changes.ios = /*$$props*/ ctx[10].iconIos;
			if (dirty & /*$$props*/ 1024) icon_changes.aurora = /*$$props*/ ctx[10].iconAurora;
			if (dirty & /*$$props*/ 1024) icon_changes.color = /*$$props*/ ctx[10].iconColor;
			if (dirty & /*$$props*/ 1024) icon_changes.size = /*$$props*/ ctx[10].iconSize;
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$8.name,
		type: "if",
		source: "(154:8) {#if hasIcon}",
		ctx
	});

	return block;
}

// (113:6) {#if needToggle}
function create_if_block_3$f(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			attr_dev(div, "class", "treeview-toggle");
			add_location(div, file$1m, 113, 8, 3323);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$f.name,
		type: "if",
		source: "(113:6) {#if needToggle}",
		ctx
	});

	return block;
}

// (118:8) {#if hasIcon}
function create_if_block_2$j(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				material: /*$$props*/ ctx[10].iconMaterial,
				f7: /*$$props*/ ctx[10].iconF7,
				icon: /*$$props*/ ctx[10].icon,
				md: /*$$props*/ ctx[10].iconMd,
				ios: /*$$props*/ ctx[10].iconIos,
				aurora: /*$$props*/ ctx[10].iconAurora,
				color: /*$$props*/ ctx[10].iconColor,
				size: /*$$props*/ ctx[10].iconSize
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(icon.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*$$props*/ 1024) icon_changes.material = /*$$props*/ ctx[10].iconMaterial;
			if (dirty & /*$$props*/ 1024) icon_changes.f7 = /*$$props*/ ctx[10].iconF7;
			if (dirty & /*$$props*/ 1024) icon_changes.icon = /*$$props*/ ctx[10].icon;
			if (dirty & /*$$props*/ 1024) icon_changes.md = /*$$props*/ ctx[10].iconMd;
			if (dirty & /*$$props*/ 1024) icon_changes.ios = /*$$props*/ ctx[10].iconIos;
			if (dirty & /*$$props*/ 1024) icon_changes.aurora = /*$$props*/ ctx[10].iconAurora;
			if (dirty & /*$$props*/ 1024) icon_changes.color = /*$$props*/ ctx[10].iconColor;
			if (dirty & /*$$props*/ 1024) icon_changes.size = /*$$props*/ ctx[10].iconSize;
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$j.name,
		type: "if",
		source: "(118:8) {#if hasIcon}",
		ctx
	});

	return block;
}

// (179:2) {#if hasChildren}
function create_if_block$D(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	const children_start_slot_template = /*#slots*/ ctx[21]["children-start"];
	const children_start_slot = create_slot(children_start_slot_template, ctx, /*$$scope*/ ctx[20], get_children_start_slot_context);
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
	const children_slot_template = /*#slots*/ ctx[21].children;
	const children_slot = create_slot(children_slot_template, ctx, /*$$scope*/ ctx[20], get_children_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			if (children_start_slot) children_start_slot.c();
			t0 = space();
			if (default_slot) default_slot.c();
			t1 = space();
			if (children_slot) children_slot.c();
			attr_dev(div, "class", "treeview-item-children");
			add_location(div, file$1m, 179, 4, 5156);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (children_start_slot) {
				children_start_slot.m(div, null);
			}

			append_dev(div, t0);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_dev(div, t1);

			if (children_slot) {
				children_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (children_start_slot) {
				if (children_start_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(children_start_slot, children_start_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_children_start_slot_changes, get_children_start_slot_context);
				}
			}

			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[20], dirty, null, null);
				}
			}

			if (children_slot) {
				if (children_slot.p && dirty & /*$$scope*/ 1048576) {
					update_slot(children_slot, children_slot_template, ctx, /*$$scope*/ ctx[20], dirty, get_children_slot_changes, get_children_slot_context);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(children_start_slot, local);
			transition_in(default_slot, local);
			transition_in(children_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(children_start_slot, local);
			transition_out(default_slot, local);
			transition_out(children_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (children_start_slot) children_start_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (children_slot) children_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$D.name,
		type: "if",
		source: "(179:2) {#if hasChildren}",
		ctx
	});

	return block;
}

function create_fragment$1n(ctx) {
	let div;
	let current_block_type_index;
	let if_block0;
	let t;
	let current;
	const if_block_creators = [create_if_block_1$p, create_else_block$f];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*treeviewRootTag*/ ctx[8] === "div") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = /*hasChildren*/ ctx[1] && create_if_block$D(ctx);
	let div_levels = [{ class: /*classes*/ ctx[3] }, restProps(/*$$restProps*/ ctx[11])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			set_attributes(div, div_data);
			add_location(div, file$1m, 104, 0, 3065);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append_dev(div, t);
			if (if_block1) if_block1.m(div, null);
			/*div_binding*/ ctx[22](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(div, t);
			}

			if (/*hasChildren*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*hasChildren*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$D(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 8) && { class: /*classes*/ ctx[3] },
				dirty & /*$$restProps*/ 2048 && restProps(/*$$restProps*/ ctx[11])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			/*div_binding*/ ctx[22](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$18($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"class","toggle","itemToggle","selectable","selected","opened","label","loadChildren","link"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;

	validate_slots("Treeview_item", slots, [
		'root-start','content-start','media','label-start','label','content','content-end','root','root-end','children-start','default','children'
	]);

	const dispatch = createEventDispatcher();
	let { class: className = undefined } = $$props;
	let { toggle = undefined } = $$props;
	let { itemToggle = false } = $$props;
	let { selectable = false } = $$props;
	let { selected = false } = $$props;
	let { opened = false } = $$props;
	let { label = undefined } = $$props;
	let { loadChildren = false } = $$props;
	let { link = undefined } = $$props;
	let el;

	function onClick(e) {
		dispatch("click", [e]);
		if (typeof $$props.onClick === "function") $$props.onClick(e);
	}

	function onOpen(itemEl) {
		if (itemEl !== el) return;
		dispatch("treeviewOpen", [el]);
		if (typeof $$props.onTreeviewOpen === "function") $$props.onTreeviewOpen(el);
	}

	function onClose(itemEl) {
		if (itemEl !== el) return;
		dispatch("treeviewClose", [el]);
		if (typeof $$props.onTreeviewClose === "function") $$props.onTreeviewClose(el);
	}

	function onLoadChildren(itemEl, done) {
		if (itemEl !== el) return;
		dispatch("treeviewLoadChildren", [el, done]);
		if (typeof $$props.onTreeviewLoadChildren === "function") $$props.onTreeviewLoadChildren(el, done);
	}

	onMount(() => {
		if (!el) return;

		f7.ready(() => {
			f7.instance.on("treeviewOpen", onOpen);
			f7.instance.on("treeviewClose", onClose);
			f7.instance.on("treeviewLoadChildren", onLoadChildren);
		});
	});

	onDestroy(() => {
		if (!el || !f7.instance) return;
		f7.instance.off("treeviewOpen", onOpen);
		f7.instance.off("treeviewClose", onClose);
		f7.instance.off("treeviewLoadChildren", onLoadChildren);
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(12, className = $$new_props.class);
		if ("toggle" in $$new_props) $$invalidate(13, toggle = $$new_props.toggle);
		if ("itemToggle" in $$new_props) $$invalidate(14, itemToggle = $$new_props.itemToggle);
		if ("selectable" in $$new_props) $$invalidate(15, selectable = $$new_props.selectable);
		if ("selected" in $$new_props) $$invalidate(16, selected = $$new_props.selected);
		if ("opened" in $$new_props) $$invalidate(17, opened = $$new_props.opened);
		if ("label" in $$new_props) $$invalidate(0, label = $$new_props.label);
		if ("loadChildren" in $$new_props) $$invalidate(18, loadChildren = $$new_props.loadChildren);
		if ("link" in $$new_props) $$invalidate(19, link = $$new_props.link);
		if ("$$scope" in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		createEventDispatcher,
		onMount,
		onDestroy,
		Mixins,
		Utils,
		restProps,
		f7,
		hasSlots,
		Icon,
		dispatch,
		className,
		toggle,
		itemToggle,
		selectable,
		selected,
		opened,
		label,
		loadChildren,
		link,
		el,
		onClick,
		onOpen,
		onClose,
		onLoadChildren,
		classes,
		itemRootClasses,
		itemRootAttrs,
		hasChildren,
		needToggle,
		hasIcon,
		treeviewRootTag
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(12, className = $$new_props.className);
		if ("toggle" in $$props) $$invalidate(13, toggle = $$new_props.toggle);
		if ("itemToggle" in $$props) $$invalidate(14, itemToggle = $$new_props.itemToggle);
		if ("selectable" in $$props) $$invalidate(15, selectable = $$new_props.selectable);
		if ("selected" in $$props) $$invalidate(16, selected = $$new_props.selected);
		if ("opened" in $$props) $$invalidate(17, opened = $$new_props.opened);
		if ("label" in $$props) $$invalidate(0, label = $$new_props.label);
		if ("loadChildren" in $$props) $$invalidate(18, loadChildren = $$new_props.loadChildren);
		if ("link" in $$props) $$invalidate(19, link = $$new_props.link);
		if ("el" in $$props) $$invalidate(2, el = $$new_props.el);
		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
		if ("itemRootClasses" in $$props) $$invalidate(4, itemRootClasses = $$new_props.itemRootClasses);
		if ("itemRootAttrs" in $$props) $$invalidate(5, itemRootAttrs = $$new_props.itemRootAttrs);
		if ("hasChildren" in $$props) $$invalidate(1, hasChildren = $$new_props.hasChildren);
		if ("needToggle" in $$props) $$invalidate(6, needToggle = $$new_props.needToggle);
		if ("hasIcon" in $$props) $$invalidate(7, hasIcon = $$new_props.hasIcon);
		if ("treeviewRootTag" in $$props) $$invalidate(8, treeviewRootTag = $$new_props.treeviewRootTag);
	};

	let classes;
	let itemRootClasses;
	let itemRootAttrs;
	let hasChildren;
	let needToggle;
	let hasIcon;
	let treeviewRootTag;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(3, classes = Utils.classNames(
			className,
			"treeview-item",
			{
				"treeview-item-opened": opened,
				"treeview-load-children": loadChildren
			},
			Mixins.colorClasses($$props)
		));

		 $$invalidate(4, itemRootClasses = Utils.classNames(
			"treeview-item-root",
			{
				"treeview-item-selectable": selectable,
				"treeview-item-selected": selected,
				"treeview-item-toggle": itemToggle
			},
			Mixins.linkRouterClasses($$props),
			Mixins.linkActionsClasses($$props)
		));

		 $$invalidate(5, itemRootAttrs = Utils.extend(
			{
				href: link === true ? "#" : link || undefined
			},
			Mixins.linkRouterAttrs($$props),
			Mixins.linkActionsAttrs($$props)
		));

		if ($$self.$$.dirty & /*toggle, hasChildren*/ 8194) {
			/* eslint-enable no-undef */
			 $$invalidate(6, needToggle = typeof toggle === "undefined" ? hasChildren : toggle);
		}

		 $$invalidate(7, hasIcon = $$props.icon || $$props.iconMaterial || $$props.iconF7 || $$props.iconMd || $$props.iconIos || $$props.iconAurora);

		if ($$self.$$.dirty & /*link*/ 524288) {
			 $$invalidate(8, treeviewRootTag = link || link === "" ? "a" : "div");
		}
	};

	 $$invalidate(1, hasChildren = hasSlots(arguments, "default") || hasSlots(arguments, "children") || hasSlots(arguments, "children-start"));
	$$props = exclude_internal_props($$props);

	return [
		label,
		hasChildren,
		el,
		classes,
		itemRootClasses,
		itemRootAttrs,
		needToggle,
		hasIcon,
		treeviewRootTag,
		onClick,
		$$props,
		$$restProps,
		className,
		toggle,
		itemToggle,
		selectable,
		selected,
		opened,
		loadChildren,
		link,
		$$scope,
		slots,
		div_binding
	];
}

class Treeview_item extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$18, create_fragment$1n, safe_not_equal, {
			class: 12,
			toggle: 13,
			itemToggle: 14,
			selectable: 15,
			selected: 16,
			opened: 17,
			label: 0,
			loadChildren: 18,
			link: 19
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Treeview_item",
			options,
			id: create_fragment$1n.name
		});
	}

	get class() {
		throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get toggle() {
		throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set toggle(value) {
		throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get itemToggle() {
		throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set itemToggle(value) {
		throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectable() {
		throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectable(value) {
		throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selected() {
		throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get opened() {
		throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set opened(value) {
		throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get loadChildren() {
		throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set loadChildren(value) {
		throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get link() {
		throw new Error("<Treeview_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set link(value) {
		throw new Error("<Treeview_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/treeview.svelte generated by Svelte v3.31.0 */
const file$1n = "node_modules/framework7-svelte/components/treeview.svelte";

function create_fragment$1o(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$1n, 16, 0, 313);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 8) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$19($$self, $$props, $$invalidate) {
	const omit_props_names = ["class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Treeview", slots, ['default']);
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Mixins,
		Utils,
		restProps,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(2, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "treeview", Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, className, $$scope, slots];
}

class Treeview extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$19, create_fragment$1o, safe_not_equal, { class: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Treeview",
			options,
			id: create_fragment$1o.name
		});
	}

	get class() {
		throw new Error("<Treeview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Treeview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/view.svelte generated by Svelte v3.31.0 */
const file$1o = "node_modules/framework7-svelte/components/view.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[27] = list[i];
	return child_ctx;
}

// (141:2) {#each pages as page (page.id)}
function create_each_block$1(key_1, ctx) {
	let first;
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*page*/ ctx[27].props];
	var switch_value = /*page*/ ctx[27].component;

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_dev(target, first, anchor);

			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty & /*pages*/ 8)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*page*/ ctx[27].props)])
			: {};

			if (switch_value !== (switch_value = /*page*/ ctx[27].component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(first);
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(141:2) {#each pages as page (page.id)}",
		ctx
	});

	return block;
}

function create_fragment$1p(ctx) {
	let div;
	let t;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
	let each_value = /*pages*/ ctx[3];
	validate_each_argument(each_value);
	const get_key = ctx => /*page*/ ctx[27].id;
	validate_each_keys(ctx, each_value, get_each_context$1, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$1(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr_dev(div, "class", /*classes*/ ctx[4]);
			attr_dev(div, "style", /*style*/ ctx[1]);
			attr_dev(div, "id", /*id*/ ctx[0]);
			add_location(div, file$1o, 138, 0, 4153);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append_dev(div, t);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			/*div_binding*/ ctx[10](div);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 256) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
				}
			}

			if (dirty & /*pages*/ 8) {
				const each_value = /*pages*/ ctx[3];
				validate_each_argument(each_value);
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context$1, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$1, null, get_each_context$1);
				check_outros();
			}

			if (!current || dirty & /*classes*/ 16) {
				attr_dev(div, "class", /*classes*/ ctx[4]);
			}

			if (!current || dirty & /*style*/ 2) {
				attr_dev(div, "style", /*style*/ ctx[1]);
			}

			if (!current || dirty & /*id*/ 1) {
				attr_dev(div, "id", /*id*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*div_binding*/ ctx[10](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance_1$f($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("View", slots, ['default']);
	let { id = undefined } = $$props;
	let { style = undefined } = $$props;
	let { init = true } = $$props;
	let { class: className = undefined } = $$props;
	const dispatch = createEventDispatcher();
	const { main, tab, tabActive } = $$props;
	let el;
	let pages = [];
	let routerData;
	let f7View;

	function instance() {
		return f7View;
	}

	function onResize(view, width) {
		dispatch("viewResize", [width]);
		if (typeof $$props.onViewResize === "function") $$props.onViewResize(width);
	}

	function onSwipeBackMove(data) {
		dispatch("swipeBackMove", [data]);
		if (typeof $$props.onSwipeBackMove === "function") $$props.onSwipeBackMove(data);
	}

	function onSwipeBackBeforeChange(data) {
		dispatch("swipeBackBeforeChange", [data]);
		if (typeof $$props.onSwipeBackBeforeChange === "function") $$props.onSwipeBackBeforeChange(data);
	}

	function onSwipeBackAfterChange(data) {
		dispatch("swipeBackAfterChange", [data]);
		if (typeof $$props.onSwipeBackAfterChange === "function") $$props.onSwipeBackAfterChange(data);
	}

	function onSwipeBackBeforeReset(data) {
		dispatch("swipeBackBeforeReset", [data]);
		if (typeof $$props.onSwipeBackBeforeReset === "function") $$props.onSwipeBackBeforeReset(data);
	}

	function onSwipeBackAfterReset(data) {
		dispatch("swipeBackAfterReset", [data]);
		if (typeof $$props.onSwipeBackAfterReset === "function") $$props.onSwipeBackAfterReset(data);
	}

	function onTabShow(tabEl) {
		if (el !== tabEl) return;
		dispatch("tabShow");
		if (typeof $$props.onTabShow === "function") $$props.onTabShow(tabEl);
	}

	function onTabHide(tabEl) {
		if (el !== tabEl) return;
		dispatch("tabHide");
		if (typeof $$props.onTabHide === "function") $$props.onTabHide(tabEl);
	}

	function onViewInit(view) {
		f7View = view;
		routerData.instance = view;
		dispatch("viewInit", [view]);
		if (typeof $$props.onViewInit === "function") $$props.onViewInit(view);
	}

	onMount(() => {
		if (!init) return;

		f7.ready(() => {
			f7.instance.on("tabShow", onTabShow);
			f7.instance.on("tabHide", onTabHide);

			routerData = {
				el,
				instance: null,
				pages,
				setPages(p) {
					tick().then(() => {
						$$invalidate(3, pages = p);
					});
				}
			};

			f7.routers.views.push(routerData);

			routerData.instance = f7.instance.views.create(el, {
				...Utils.noUndefinedProps($$props),
				on: { init: onViewInit }
			});

			if (!f7View) f7View = routerData.instance;
			f7View.on("resize", onResize);
			f7View.on("swipebackMove", onSwipeBackMove);
			f7View.on("swipebackBeforeChange", onSwipeBackBeforeChange);
			f7View.on("swipebackAfterChange", onSwipeBackAfterChange);
			f7View.on("swipebackBeforeReset", onSwipeBackBeforeReset);
			f7View.on("swipebackAfterReset", onSwipeBackAfterReset);
		});
	});

	afterUpdate(() => {
		if (!routerData) return;
		f7.events.emit("viewRouterDidUpdate", routerData);
	});

	onDestroy(() => {
		if (!init) return;

		if (f7.instance) {
			f7.instance.off("tabShow", onTabShow);
			f7.instance.off("tabHide", onTabHide);
		}

		if (f7View) {
			f7View.off("resize", onResize);
			f7View.off("swipebackMove", onSwipeBackMove);
			f7View.off("swipebackBeforeChange", onSwipeBackBeforeChange);
			f7View.off("swipebackAfterChange", onSwipeBackAfterChange);
			f7View.off("swipebackBeforeReset", onSwipeBackBeforeReset);
			f7View.off("swipebackAfterReset", onSwipeBackAfterReset);

			if (f7View.destroy) {
				f7View.destroy();
			}
		}

		f7.routers.views.splice(f7.routers.views.indexOf(routerData), 1);
		f7View = null;
		routerData = null;
	});

	function div_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			el = $$value;
			$$invalidate(2, el);
		});
	}

	$$self.$$set = $$new_props => {
		$$invalidate(26, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
		if ("init" in $$new_props) $$invalidate(5, init = $$new_props.init);
		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		onDestroy,
		afterUpdate,
		createEventDispatcher,
		tick,
		f7,
		Mixins,
		Utils,
		id,
		style,
		init,
		className,
		dispatch,
		main,
		tab,
		tabActive,
		el,
		pages,
		routerData,
		f7View,
		instance,
		onResize,
		onSwipeBackMove,
		onSwipeBackBeforeChange,
		onSwipeBackAfterChange,
		onSwipeBackBeforeReset,
		onSwipeBackAfterReset,
		onTabShow,
		onTabHide,
		onViewInit,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(26, $$props = assign(assign({}, $$props), $$new_props));
		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
		if ("init" in $$props) $$invalidate(5, init = $$new_props.init);
		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
		if ("el" in $$props) $$invalidate(2, el = $$new_props.el);
		if ("pages" in $$props) $$invalidate(3, pages = $$new_props.pages);
		if ("routerData" in $$props) routerData = $$new_props.routerData;
		if ("f7View" in $$props) f7View = $$new_props.f7View;
		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(4, classes = Utils.classNames(
			className,
			"view",
			{
				"view-main": main,
				"tab-active": tabActive,
				tab
			},
			Mixins.colorClasses($$props)
		));
	};

	$$props = exclude_internal_props($$props);

	return [
		id,
		style,
		el,
		pages,
		classes,
		init,
		className,
		instance,
		$$scope,
		slots,
		div_binding
	];
}

class View extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance_1$f, create_fragment$1p, safe_not_equal, {
			id: 0,
			style: 1,
			init: 5,
			class: 6,
			instance: 7
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "View",
			options,
			id: create_fragment$1p.name
		});
	}

	get id() {
		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get init() {
		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set init(value) {
		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get instance() {
		return this.$$.ctx[7];
	}

	set instance(value) {
		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/framework7-svelte/components/views.svelte generated by Svelte v3.31.0 */
const file$1p = "node_modules/framework7-svelte/components/views.svelte";

function create_fragment$1q(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[5].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);
	let div_levels = [{ class: /*classes*/ ctx[0] }, restProps(/*$$restProps*/ ctx[1])];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			set_attributes(div, div_data);
			add_location(div, file$1p, 21, 0, 363);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 16) {
					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
				}
			}

			set_attributes(div, div_data = get_spread_update(div_levels, [
				(!current || dirty & /*classes*/ 1) && { class: /*classes*/ ctx[0] },
				dirty & /*$$restProps*/ 2 && restProps(/*$$restProps*/ ctx[1])
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1a($$self, $$props, $$invalidate) {
	const omit_props_names = ["tabs","class"];
	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Views", slots, ['default']);
	let { tabs = false } = $$props;
	let { class: className = undefined } = $$props;

	$$self.$$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
		if ("tabs" in $$new_props) $$invalidate(2, tabs = $$new_props.tabs);
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		Utils,
		restProps,
		Mixins,
		tabs,
		className,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("tabs" in $$props) $$invalidate(2, tabs = $$new_props.tabs);
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("classes" in $$props) $$invalidate(0, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		 $$invalidate(0, classes = Utils.classNames(className, "views", { tabs }, Mixins.colorClasses($$props)));
	};

	$$props = exclude_internal_props($$props);
	return [classes, $$restProps, tabs, className, $$scope, slots];
}

class Views extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1a, create_fragment$1q, safe_not_equal, { tabs: 2, class: 3 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Views",
			options,
			id: create_fragment$1q.name
		});
	}

	get tabs() {
		throw new Error("<Views>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tabs(value) {
		throw new Error("<Views>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get class() {
		throw new Error("<Views>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Views>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/**
 * Framework7 Svelte 5.7.14
 * Build full featured iOS & Android apps using Framework7 & Svelte
 * https://framework7.io/svelte/
 *
 * Copyright 2014-2020 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: November 9, 2020
 */

export default Plugin;
export { Accordion, Accordion_content as AccordionContent, Accordion_item as AccordionItem, Accordion_toggle as AccordionToggle, Actions, Actions_button as ActionsButton, Actions_group as ActionsGroup, Actions_label as ActionsLabel, App, Appbar, Badge, Block, Block_footer as BlockFooter, Block_header as BlockHeader, Block_title as BlockTitle, Button, Card, Card_content as CardContent, Card_footer as CardFooter, Card_header as CardHeader, Checkbox, Chip, Col, Fab, Fab_backdrop as FabBackdrop, Fab_button as FabButton, Fab_buttons as FabButtons, Gauge, Icon, Input, Link, List, List_button as ListButton, List_group as ListGroup, List_index as ListIndex, List_input as ListInput, List_item as ListItem, List_item_cell as ListItemCell, List_item_row as ListItemRow, Login_screen as LoginScreen, Login_screen_title as LoginScreenTitle, Menu, Menu_dropdown as MenuDropdown, Menu_dropdown_item as MenuDropdownItem, Menu_item as MenuItem, Message, Messagebar, Messagebar_attachment as MessagebarAttachment, Messagebar_attachments as MessagebarAttachments, Messagebar_sheet as MessagebarSheet, Messagebar_sheet_image as MessagebarSheetImage, Messagebar_sheet_item as MessagebarSheetItem, Messages, Messages_title as MessagesTitle, Nav_left as NavLeft, Nav_right as NavRight, Nav_title as NavTitle, Nav_title_large as NavTitleLarge, Navbar, Page, Page_content as PageContent, Panel, Photo_browser as PhotoBrowser, Popover, Popup, Preloader, Progressbar, Radio, Range, Routable_modals as RoutableModals, Row, Searchbar, Segmented, Sheet, Skeleton_block as SkeletonBlock, Skeleton_text as SkeletonText, Stepper, Subnavbar, Swipeout_actions as SwipeoutActions, Swipeout_button as SwipeoutButton, Swiper, Swiper_slide as SwiperSlide, Tab, Tabs, Text_editor as TextEditor, Toggle, Toolbar, Treeview, Treeview_item as TreeviewItem, View, Views, f7Instance as f7, f7ready, f7Theme as theme };
